--- linux-2.6.36.orig/arch/mips/bcm47xx/Makefile	2010-10-20 22:30:22.000000000 +0200
+++ linux-2.6.36/arch/mips/bcm47xx/Makefile	2010-12-22 16:39:15.000000000 +0100
@@ -3,4 +3,4 @@
 # under Linux.
 #
 
-obj-y := gpio.o irq.o nvram.o prom.o serial.o setup.o time.o wgt634u.o
+obj-y := gpio.o irq.o nvram.o prom.o serial.o setup.o time.o platform.o
--- /dev/null	Fri Jan  7 17:21:57 2011
+++ linux-2.6.36/arch/mips/bcm47xx/platform.c	Fri Jan  7 17:21:42 2011
@@ -0,0 +1,147 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2010, 2011 Waldemar Brodkorb <wbx@openadk.org>
+ * Copyright Â© 2007, 2011 Thorsten Glaser <tg@freewrt.org>
+ */
+
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/mtd/physmap.h>
+#include <linux/ssb/ssb.h>
+
+#include <asm/mach-bcm47xx/bcm47xx.h>
+#include <asm/mach-bcm47xx/nvram.h>
+
+#define NVRAM_FLASH_SIZE 0x10000
+#define CFGFS_FLASH_SIZE (64 * 1024)
+
+static struct mtd_partition bcm47xx_partitions[] = {
+#define SLOT_CFE 0
+	{
+		.name       = "cfe",
+		.offset     = 0,
+		.size       = 0x40000,		/* 256k */
+		.mask_flags = MTD_WRITEABLE	/* force read-only */
+	},
+#define SLOT_LINUX 1
+	{
+		.name   = "linux",
+		.offset = 0,
+		.size   = 0,
+	},
+#define SLOT_ROOTFS 2
+	{
+		.name   = "rootfs",
+		.offset = 0,
+		.size   = 0,
+	},
+#define SLOT_CFGFS 3
+	{
+		.name   = "cfgfs",
+		.offset = 0,
+		.size   = 0,
+	},
+#define SLOT_NVRAM 4
+	{
+		.name   = "nvram",
+		.offset = 0,
+		.size   = 0,
+	},
+};
+
+static struct physmap_flash_data bcm47xx_flash_data = {
+	.parts    = bcm47xx_partitions,
+	.nr_parts = ARRAY_SIZE(bcm47xx_partitions)
+};
+
+static struct resource bcm47xx_flash_resource = {
+	.flags = IORESOURCE_MEM,
+};
+
+static struct platform_device bcm47xx_flash = {
+	.name          = "physmap-flash",
+	.id            = 0,
+	.dev           = { .platform_data = &bcm47xx_flash_data, },
+	.resource      = &bcm47xx_flash_resource,
+	.num_resources = 1,
+};
+
+static struct platform_device *bcm47xx_devices[] __initdata = {
+	&bcm47xx_flash,
+};
+
+struct bcm47xx_trx_header {
+#define BCM47XX_TRX_MAGIC 0x30524448
+	u32 magic;
+	u32 len;
+	u32 crc32;
+	u32 flag_version;
+	u32 offsets[3];
+};
+
+#define UPTODOWN(slot, psize) do {			\
+	posn -= psize; left -= psize;			\
+	bcm47xx_partitions[slot].offset = posn;		\
+	bcm47xx_partitions[slot].size = psize;		\
+} while (/* CONSTCOND */ 0)
+
+static int __init bcm47xx_register_devices(void)
+{
+	u32 flash_size;
+	size_t left, posn;
+	struct ssb_mipscore *mcore = &ssb_bcm47xx.mipscore;
+	struct bcm47xx_trx_header *trx_hdr;
+
+	trx_hdr = (void *)KSEG1ADDR(mcore->flash_window + 0x40000);
+
+	/* devices might have 2, 4 or 8 MB flash size */
+#ifdef BCM47XX_OVERRIDE_FLASHSIZE
+	flash_size = BCM47XX_OVERRIDE_FLASHSIZE;
+	mcore->flash_window_size = flash_size;
+#define BCM47XX_OVERRODE_FLASHSIZE " (overridden)"
+#else
+	flash_size = mcore->flash_window_size;
+#define BCM47XX_OVERRODE_FLASHSIZE ""
+#endif
+	printk(KERN_INFO "FLASH SIZE%s: %x\n", BCM47XX_OVERRODE_FLASHSIZE,
+	    flash_size);
+
+	left = flash_size - 0x40000;
+	posn = flash_size;
+	UPTODOWN(SLOT_NVRAM, NVRAM_FLASH_SIZE);
+	UPTODOWN(SLOT_CFGFS, CFGFS_FLASH_SIZE);
+	bcm47xx_partitions[SLOT_LINUX].offset = 0x40000;
+	bcm47xx_partitions[SLOT_LINUX].size = left;
+
+	if (trx_hdr->magic == BCM47XX_TRX_MAGIC) {
+		bcm47xx_partitions[SLOT_ROOTFS].offset =
+		    bcm47xx_partitions[SLOT_LINUX].offset +
+		    trx_hdr->offsets[1];
+		bcm47xx_partitions[SLOT_ROOTFS].size =
+		    bcm47xx_partitions[SLOT_LINUX].size -
+		    trx_hdr->offsets[1];
+	} else
+		printk("bcm47xx/platform: no TRX header found\n");
+
+	printk(KERN_INFO "=== Flash map dump ===\n");
+	for (posn = 0; posn < bcm47xx_flash_data.nr_parts; ++posn)
+		printk(KERN_INFO " #%u %08X @%08X '%s'\n",
+		    (unsigned int)posn,
+		    (unsigned int)bcm47xx_partitions[posn].size,
+		    (unsigned int)bcm47xx_partitions[posn].offset,
+		    bcm47xx_partitions[posn].name);
+	printk(KERN_INFO "=== Hope this works, have a nice day\n");
+
+	bcm47xx_flash_data.width = mcore->flash_buswidth;
+	bcm47xx_flash_resource.start = mcore->flash_window;
+	bcm47xx_flash_resource.end = mcore->flash_window
+				   + mcore->flash_window_size
+				   - 1;
+	return platform_add_devices(bcm47xx_devices,
+			    ARRAY_SIZE(bcm47xx_devices));
+}
+
+device_initcall(bcm47xx_register_devices);
--- linux-2.6.36.orig/drivers/ssb/driver_mipscore.c	2010-10-20 22:30:22.000000000 +0200
+++ linux-2.6.36/drivers/ssb/driver_mipscore.c	2010-12-22 16:38:53.000000000 +0100
@@ -193,7 +193,7 @@
 	mcore->flash_buswidth = 2;
 	if (bus->chipco.dev) {
 		mcore->flash_window = 0x1c000000;
-		mcore->flash_window_size = 0x02000000;
+		mcore->flash_window_size = 0x00800000;
 		if ((ssb_read32(bus->chipco.dev, SSB_CHIPCO_FLASH_CFG)
 		               & SSB_CHIPCO_CFG_DS16) == 0)
 			mcore->flash_buswidth = 1;
