diff -Nur gcc-4.4.6.orig/gcc/builtins.c gcc-4.4.6/gcc/builtins.c
--- gcc-4.4.6.orig/gcc/builtins.c	2010-12-07 19:56:56.000000000 +0100
+++ gcc-4.4.6/gcc/builtins.c	2011-08-27 19:45:42.559232404 +0200
@@ -11108,7 +11108,7 @@
 
   do
     {
-      code = va_arg (ap, enum tree_code);
+      code = va_arg (ap, int);
       switch (code)
 	{
 	case 0:
diff -Nur gcc-4.4.6.orig/gcc/calls.c gcc-4.4.6/gcc/calls.c
--- gcc-4.4.6.orig/gcc/calls.c	2010-09-24 17:07:36.000000000 +0200
+++ gcc-4.4.6/gcc/calls.c	2011-08-27 19:45:42.589240794 +0200
@@ -3447,7 +3447,7 @@
   for (; count < nargs; count++)
     {
       rtx val = va_arg (p, rtx);
-      enum machine_mode mode = va_arg (p, enum machine_mode);
+      enum machine_mode mode = va_arg (p, int);
 
       /* We cannot convert the arg value to the mode the library wants here;
 	 must do it earlier where we know the signedness of the arg.  */
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/avr32.c gcc-4.4.6/gcc/config/avr32/avr32.c
--- gcc-4.4.6.orig/gcc/config/avr32/avr32.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/avr32.c	2011-08-27 19:45:59.051740454 +0200
@@ -0,0 +1,8087 @@
+/*
+   Target hooks and helper functions for AVR32.
+   Copyright 2003,2004,2005,2006,2007,2008,2009,2010 Atmel Corporation.
+
+   This file is part of GCC.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "tree.h"
+#include "obstack.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "real.h"
+#include "insn-config.h"
+#include "conditions.h"
+#include "output.h"
+#include "insn-attr.h"
+#include "flags.h"
+#include "reload.h"
+#include "function.h"
+#include "expr.h"
+#include "optabs.h"
+#include "toplev.h"
+#include "recog.h"
+#include "ggc.h"
+#include "except.h"
+#include "c-pragma.h"
+#include "integrate.h"
+#include "tm_p.h"
+#include "langhooks.h"
+#include "hooks.h"
+#include "df.h"
+
+#include "target.h"
+#include "target-def.h"
+
+#include <ctype.h>
+
+
+
+/* Global variables.  */
+typedef struct minipool_node Mnode;
+typedef struct minipool_fixup Mfix;
+
+/* Obstack for minipool constant handling.  */
+static struct obstack minipool_obstack;
+static char *minipool_startobj;
+static rtx minipool_vector_label;
+
+/* True if we are currently building a constant table.  */
+int making_const_table;
+
+tree fndecl_attribute_args = NULL_TREE;
+
+
+/* Function prototypes. */
+static unsigned long avr32_isr_value (tree);
+static unsigned long avr32_compute_func_type (void);
+static tree avr32_handle_isr_attribute (tree *, tree, tree, int, bool *);
+static tree avr32_handle_acall_attribute (tree *, tree, tree, int, bool *);
+static tree avr32_handle_fndecl_attribute (tree * node, tree name, tree args,
+					   int flags, bool * no_add_attrs);
+static void avr32_reorg (void);
+bool avr32_return_in_msb (tree type);
+bool avr32_vector_mode_supported (enum machine_mode mode);
+static void avr32_init_libfuncs (void);
+static void avr32_file_end (void);
+static void flashvault_decl_list_add (unsigned int vector_num, const char *name);
+
+
+
+static void
+avr32_add_gc_roots (void)
+{
+  gcc_obstack_init (&minipool_obstack);
+  minipool_startobj = (char *) obstack_alloc (&minipool_obstack, 0);
+}
+
+
+/* List of all known AVR32 parts  */
+static const struct part_type_s avr32_part_types[] = {
+  /* name, part_type, architecture type, macro */
+  {"none",            PART_TYPE_AVR32_NONE,            ARCH_TYPE_AVR32_AP,        "__AVR32__"},
+  {"ap7000",          PART_TYPE_AVR32_AP7000,          ARCH_TYPE_AVR32_AP,        "__AVR32_AP7000__"},
+  {"ap7001",          PART_TYPE_AVR32_AP7001,          ARCH_TYPE_AVR32_AP,        "__AVR32_AP7001__"},
+  {"ap7002",          PART_TYPE_AVR32_AP7002,          ARCH_TYPE_AVR32_AP,        "__AVR32_AP7002__"},
+  {"ap7200",          PART_TYPE_AVR32_AP7200,          ARCH_TYPE_AVR32_AP,        "__AVR32_AP7200__"},
+  {"uc3a0128",        PART_TYPE_AVR32_UC3A0128,        ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3A0128__"},
+  {"uc3a0256",        PART_TYPE_AVR32_UC3A0256,        ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3A0256__"},
+  {"uc3a0512",        PART_TYPE_AVR32_UC3A0512,        ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3A0512__"},
+  {"uc3a0512es",      PART_TYPE_AVR32_UC3A0512ES,      ARCH_TYPE_AVR32_UCR1,      "__AVR32_UC3A0512ES__"},
+  {"uc3a1128",        PART_TYPE_AVR32_UC3A1128,        ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3A1128__"},
+  {"uc3a1256",        PART_TYPE_AVR32_UC3A1256,        ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3A1256__"},
+  {"uc3a1512",        PART_TYPE_AVR32_UC3A1512,        ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3A1512__"},
+  {"uc3a1512es",      PART_TYPE_AVR32_UC3A1512ES,      ARCH_TYPE_AVR32_UCR1,      "__AVR32_UC3A1512ES__"},
+  {"uc3a3revd",       PART_TYPE_AVR32_UC3A3REVD,       ARCH_TYPE_AVR32_UCR2NOMUL, "__AVR32_UC3A3256S__"},
+  {"uc3a364",         PART_TYPE_AVR32_UC3A364,         ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3A364__"},
+  {"uc3a364s",        PART_TYPE_AVR32_UC3A364S,        ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3A364S__"},
+  {"uc3a3128",        PART_TYPE_AVR32_UC3A3128,        ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3A3128__"},
+  {"uc3a3128s",       PART_TYPE_AVR32_UC3A3128S,       ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3A3128S__"},
+  {"uc3a3256",        PART_TYPE_AVR32_UC3A3256,        ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3A3256__"},
+  {"uc3a3256s",       PART_TYPE_AVR32_UC3A3256S,       ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3A3256S__"},
+  {"uc3a464",         PART_TYPE_AVR32_UC3A464,         ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3A464__"},
+  {"uc3a464s",        PART_TYPE_AVR32_UC3A464S,        ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3A464S__"},
+  {"uc3a4128",        PART_TYPE_AVR32_UC3A4128,        ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3A4128__"},
+  {"uc3a4128s",       PART_TYPE_AVR32_UC3A4128S,       ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3A4128S__"},
+  {"uc3a4256",        PART_TYPE_AVR32_UC3A4256,        ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3A4256__"},
+  {"uc3a4256s",       PART_TYPE_AVR32_UC3A4256S,       ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3A4256S__"},
+  {"uc3b064",         PART_TYPE_AVR32_UC3B064,         ARCH_TYPE_AVR32_UCR1,      "__AVR32_UC3B064__"},
+  {"uc3b0128",        PART_TYPE_AVR32_UC3B0128,        ARCH_TYPE_AVR32_UCR1,      "__AVR32_UC3B0128__"},
+  {"uc3b0256",        PART_TYPE_AVR32_UC3B0256,        ARCH_TYPE_AVR32_UCR1,      "__AVR32_UC3B0256__"},
+  {"uc3b0256es",      PART_TYPE_AVR32_UC3B0256ES,      ARCH_TYPE_AVR32_UCR1,      "__AVR32_UC3B0256ES__"},
+  {"uc3b0512",        PART_TYPE_AVR32_UC3B0512,        ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3B0512__"},
+  {"uc3b0512revc",    PART_TYPE_AVR32_UC3B0512REVC,    ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3B0512REVC__"},
+  {"uc3b164",         PART_TYPE_AVR32_UC3B164,         ARCH_TYPE_AVR32_UCR1,      "__AVR32_UC3B164__"},
+  {"uc3b1128",        PART_TYPE_AVR32_UC3B1128,        ARCH_TYPE_AVR32_UCR1,      "__AVR32_UC3B1128__"},
+  {"uc3b1256",        PART_TYPE_AVR32_UC3B1256,        ARCH_TYPE_AVR32_UCR1,      "__AVR32_UC3B1256__"},
+  {"uc3b1256es",      PART_TYPE_AVR32_UC3B1256ES,      ARCH_TYPE_AVR32_UCR1,      "__AVR32_UC3B1256ES__"},
+  {"uc3b1512",        PART_TYPE_AVR32_UC3B1512,        ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3B1512__"},
+  {"uc3b1512revc",    PART_TYPE_AVR32_UC3B1512REVC,    ARCH_TYPE_AVR32_UCR2,      "__AVR32_UC3B1512REVC__"},
+  {"uc64d3",          PART_TYPE_AVR32_UC64D3,          ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC64D3__"},
+  {"uc128d3",         PART_TYPE_AVR32_UC128D3,         ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC128D3__"},
+  {"uc64d4",          PART_TYPE_AVR32_UC64D4,          ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC64D4__"},
+  {"uc128d4",         PART_TYPE_AVR32_UC128D4,         ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC128D4__"},
+  {"uc3c0512crevc",   PART_TYPE_AVR32_UC3C0512CREVC,   ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC3C0512CREVC__"},
+  {"uc3c1512crevc",   PART_TYPE_AVR32_UC3C1512CREVC,   ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC3C1512CREVC__"},
+  {"uc3c2512crevc",   PART_TYPE_AVR32_UC3C2512CREVC,   ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC3C2512CREVC__"},
+  {"uc3l0256",        PART_TYPE_AVR32_UC3L0256,        ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC3L0256__"},
+  {"uc3l0128",        PART_TYPE_AVR32_UC3L0128,        ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC3L0128__"},
+  {"uc3l064",         PART_TYPE_AVR32_UC3L064,         ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC3L064__"},
+  {"uc3l032",         PART_TYPE_AVR32_UC3L032,         ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC3L032__"},
+  {"uc3l016",         PART_TYPE_AVR32_UC3L016,         ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC3L016__"},
+  {"uc3l064revb",     PART_TYPE_AVR32_UC3L064REVB,     ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC3L064REVB__"},
+  {"uc64l3u",         PART_TYPE_AVR32_UC64L3U,         ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC64L3U__"},
+  {"uc128l3u",        PART_TYPE_AVR32_UC128L3U,        ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC128L3U__"},
+  {"uc256l3u",        PART_TYPE_AVR32_UC256L3U,        ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC256L3U__"},
+  {"uc64l4u",         PART_TYPE_AVR32_UC64L4U,         ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC64L4U__"},
+  {"uc128l4u",        PART_TYPE_AVR32_UC128L4U,        ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC128L4U__"},
+  {"uc256l4u",        PART_TYPE_AVR32_UC256L4U,        ARCH_TYPE_AVR32_UCR3,      "__AVR32_UC256L4U__"},
+  {"uc3c064c",        PART_TYPE_AVR32_UC3C064C,        ARCH_TYPE_AVR32_UCR3FP,    "__AVR32_UC3C064C__"},
+  {"uc3c0128c",       PART_TYPE_AVR32_UC3C0128C,       ARCH_TYPE_AVR32_UCR3FP,    "__AVR32_UC3C0128C__"},
+  {"uc3c0256c",       PART_TYPE_AVR32_UC3C0256C,       ARCH_TYPE_AVR32_UCR3FP,    "__AVR32_UC3C0256C__"},
+  {"uc3c0512c",       PART_TYPE_AVR32_UC3C0512C,       ARCH_TYPE_AVR32_UCR3FP,    "__AVR32_UC3C0512C__"},
+  {"uc3c164c",        PART_TYPE_AVR32_UC3C164C,        ARCH_TYPE_AVR32_UCR3FP,    "__AVR32_UC3C164C__"},
+  {"uc3c1128c",       PART_TYPE_AVR32_UC3C1128C,       ARCH_TYPE_AVR32_UCR3FP,    "__AVR32_UC3C1128C__"},
+  {"uc3c1256c",       PART_TYPE_AVR32_UC3C1256C,       ARCH_TYPE_AVR32_UCR3FP,    "__AVR32_UC3C1256C__"},
+  {"uc3c1512c",       PART_TYPE_AVR32_UC3C1512C,       ARCH_TYPE_AVR32_UCR3FP,    "__AVR32_UC3C1512C__"},
+  {"uc3c264c",        PART_TYPE_AVR32_UC3C264C,        ARCH_TYPE_AVR32_UCR3FP,    "__AVR32_UC3C264C__"},
+  {"uc3c2128c",       PART_TYPE_AVR32_UC3C2128C,       ARCH_TYPE_AVR32_UCR3FP,    "__AVR32_UC3C2128C__"},
+  {"uc3c2256c",       PART_TYPE_AVR32_UC3C2256C,       ARCH_TYPE_AVR32_UCR3FP,    "__AVR32_UC3C2256C__"},
+  {"uc3c2512c",       PART_TYPE_AVR32_UC3C2512C,       ARCH_TYPE_AVR32_UCR3FP,    "__AVR32_UC3C2512C__"},
+  {"mxt768e",         PART_TYPE_AVR32_MXT768E,         ARCH_TYPE_AVR32_UCR3,      "__AVR32_MXT768E__"},
+  {NULL, 0, 0, NULL}
+};
+
+/* List of all known AVR32 architectures  */
+static const struct arch_type_s avr32_arch_types[] = {
+  /* name, architecture type, microarchitecture type, feature flags, macro */
+  {"ap", ARCH_TYPE_AVR32_AP, UARCH_TYPE_AVR32B,
+   (FLAG_AVR32_HAS_DSP
+    | FLAG_AVR32_HAS_SIMD
+    | FLAG_AVR32_HAS_UNALIGNED_WORD
+    | FLAG_AVR32_HAS_BRANCH_PRED | FLAG_AVR32_HAS_RETURN_STACK
+    | FLAG_AVR32_HAS_CACHES),
+   "__AVR32_AP__"},
+  {"ucr1", ARCH_TYPE_AVR32_UCR1, UARCH_TYPE_AVR32A,
+   (FLAG_AVR32_HAS_DSP | FLAG_AVR32_HAS_RMW),
+   "__AVR32_UC__=1"},
+  {"ucr2", ARCH_TYPE_AVR32_UCR2, UARCH_TYPE_AVR32A,
+   (FLAG_AVR32_HAS_DSP | FLAG_AVR32_HAS_RMW
+    | FLAG_AVR32_HAS_V2_INSNS),
+   "__AVR32_UC__=2"},
+  {"ucr2nomul", ARCH_TYPE_AVR32_UCR2NOMUL, UARCH_TYPE_AVR32A,
+   (FLAG_AVR32_HAS_DSP | FLAG_AVR32_HAS_RMW
+    | FLAG_AVR32_HAS_V2_INSNS | FLAG_AVR32_HAS_NO_MUL_INSNS),
+   "__AVR32_UC__=2"},
+  {"ucr3", ARCH_TYPE_AVR32_UCR3, UARCH_TYPE_AVR32A,
+   (FLAG_AVR32_HAS_DSP | FLAG_AVR32_HAS_RMW
+    | FLAG_AVR32_HAS_V2_INSNS),
+   "__AVR32_UC__=3"},
+  {"ucr3fp", ARCH_TYPE_AVR32_UCR3FP, UARCH_TYPE_AVR32A,
+   (FLAG_AVR32_HAS_DSP | FLAG_AVR32_HAS_RMW | FLAG_AVR32_HAS_FPU
+    | FLAG_AVR32_HAS_V2_INSNS),
+   "__AVR32_UC__=3"},
+  {NULL, 0, 0, 0, NULL}
+};
+
+/* Default arch name */
+const char *avr32_arch_name = "none";
+const char *avr32_part_name = "none";
+
+const struct part_type_s *avr32_part;
+const struct arch_type_s *avr32_arch;
+
+
+/* FIXME: needs to use GC.  */
+struct flashvault_decl_list
+{
+  struct flashvault_decl_list *next;
+  unsigned int vector_num;
+  const char *name;
+};
+
+static struct flashvault_decl_list *flashvault_decl_list_head = NULL;
+
+
+/* Set default target_flags. */
+#undef TARGET_DEFAULT_TARGET_FLAGS
+#define TARGET_DEFAULT_TARGET_FLAGS \
+  (MASK_HAS_ASM_ADDR_PSEUDOS | MASK_MD_REORG_OPTIMIZATION | MASK_COND_EXEC_BEFORE_RELOAD)
+
+void
+avr32_optimization_options (int level, int size)
+{
+  if (AVR32_ALWAYS_PIC)
+    flag_pic = 1;
+
+  /* Enable section anchors if optimization is enabled. */
+  if (level > 0 || size)
+    flag_section_anchors = 2;
+}
+
+
+/* Override command line options */
+void
+avr32_override_options (void)
+{
+  const struct part_type_s *part;
+  const struct arch_type_s *arch, *part_arch;
+
+  /*Add backward compability*/
+  if (strcmp ("uc", avr32_arch_name)== 0)
+    {
+      fprintf (stderr, "Warning: Deprecated arch `%s' specified. "
+                       "Please use '-march=ucr1' instead. "
+                       "Using arch 'ucr1'\n",
+               avr32_arch_name);
+      avr32_arch_name="ucr1";
+    }
+
+  /* Check if arch type is set. */
+  for (arch = avr32_arch_types; arch->name; arch++)
+    {
+      if (strcmp (arch->name, avr32_arch_name) == 0)
+        break;
+    }
+  avr32_arch = arch;
+
+  if (!arch->name && strcmp("none", avr32_arch_name) != 0)
+    {
+      fprintf (stderr, "Unknown arch `%s' specified\n"
+                       "Known arch names:\n"
+                       "\tuc (deprecated)\n",
+               avr32_arch_name);
+      for (arch = avr32_arch_types; arch->name; arch++)
+        fprintf (stderr, "\t%s\n", arch->name);
+      avr32_arch = &avr32_arch_types[ARCH_TYPE_AVR32_AP];
+    }
+
+  /* Check if part type is set. */
+  for (part = avr32_part_types; part->name; part++)
+    if (strcmp (part->name, avr32_part_name) == 0)
+      break;
+
+  avr32_part = part;
+  if (!part->name)
+    {
+      fprintf (stderr, "Unknown part `%s' specified\nKnown part names:\n",
+               avr32_part_name);
+      for (part = avr32_part_types; part->name; part++)
+        {
+          if (strcmp("none", part->name) != 0)
+            fprintf (stderr, "\t%s\n", part->name);
+        }
+      /* Set default to NONE*/
+      avr32_part = &avr32_part_types[PART_TYPE_AVR32_NONE];
+    }
+
+  /* NB! option -march= overrides option -mpart
+   * if both are used at the same time */
+  if (!arch->name)
+    avr32_arch = &avr32_arch_types[avr32_part->arch_type];
+
+   /* When architecture implied by -mpart and one passed in -march are 
+    * conflicting, issue an error message */
+   part_arch = &avr32_arch_types[avr32_part->arch_type];
+   if (strcmp("none",avr32_part_name) && strcmp("none", avr32_arch_name) && strcmp(avr32_arch_name,part_arch->name))
+     error ("Conflicting architectures implied by -mpart and -march\n");
+
+  /* If optimization level is two or greater, then align start of loops to a
+     word boundary since this will allow folding the first insn of the loop.
+     Do this only for targets supporting branch prediction. */
+  if (optimize >= 2 && TARGET_BRANCH_PRED)
+    align_loops = 2;
+
+
+  /* Enable fast-float library if unsafe math optimizations
+     are used. */
+  if (flag_unsafe_math_optimizations)
+    target_flags |= MASK_FAST_FLOAT;
+
+  /* Check if we should set avr32_imm_in_const_pool
+     based on if caches are present or not. */
+  if ( avr32_imm_in_const_pool == -1 )
+    {
+      if ( TARGET_CACHES )
+        avr32_imm_in_const_pool = 1;
+      else
+        avr32_imm_in_const_pool = 0;
+    }
+
+  if (TARGET_NO_PIC)
+    flag_pic = 0;
+  avr32_add_gc_roots ();
+}
+
+
+/*
+If defined, a function that outputs the assembler code for entry to a
+function.  The prologue is responsible for setting up the stack frame,
+initializing the frame pointer register, saving registers that must be
+saved, and allocating size additional bytes of storage for the
+local variables.  size is an integer.  file is a stdio
+stream to which the assembler code should be output.
+
+The label for the beginning of the function need not be output by this
+macro.  That has already been done when the macro is run.
+
+To determine which registers to save, the macro can refer to the array
+regs_ever_live: element r is nonzero if hard register
+r is used anywhere within the function.  This implies the function
+prologue should save register r, provided it is not one of the
+call-used registers.  (TARGET_ASM_FUNCTION_EPILOGUE must likewise use
+regs_ever_live.)
+
+On machines that have ``register windows'', the function entry code does
+not save on the stack the registers that are in the windows, even if
+they are supposed to be preserved by function calls; instead it takes
+appropriate steps to ``push'' the register stack, if any non-call-used
+registers are used in the function.
+
+On machines where functions may or may not have frame-pointers, the
+function entry code must vary accordingly; it must set up the frame
+pointer if one is wanted, and not otherwise.  To determine whether a
+frame pointer is in wanted, the macro can refer to the variable
+frame_pointer_needed.  The variable's value will be 1 at run
+time in a function that needs a frame pointer.  (see Elimination).
+
+The function entry code is responsible for allocating any stack space
+required for the function.  This stack space consists of the regions
+listed below.  In most cases, these regions are allocated in the
+order listed, with the last listed region closest to the top of the
+stack (the lowest address if STACK_GROWS_DOWNWARD is defined, and
+the highest address if it is not defined).  You can use a different order
+for a machine if doing so is more convenient or required for
+compatibility reasons.  Except in cases where required by standard
+or by a debugger, there is no reason why the stack layout used by GCC
+need agree with that used by other compilers for a machine.
+*/
+
+#undef TARGET_ASM_FUNCTION_PROLOGUE
+#define TARGET_ASM_FUNCTION_PROLOGUE avr32_target_asm_function_prologue
+
+#undef TARGET_ASM_FILE_END
+#define TARGET_ASM_FILE_END avr32_file_end
+
+#undef TARGET_DEFAULT_SHORT_ENUMS
+#define TARGET_DEFAULT_SHORT_ENUMS hook_bool_void_false
+
+#undef TARGET_PROMOTE_FUNCTION_ARGS
+#define TARGET_PROMOTE_FUNCTION_ARGS hook_bool_tree_true
+
+#undef TARGET_PROMOTE_FUNCTION_RETURN
+#define TARGET_PROMOTE_FUNCTION_RETURN hook_bool_tree_true
+
+#undef TARGET_PROMOTE_PROTOTYPES
+#define TARGET_PROMOTE_PROTOTYPES hook_bool_tree_true
+
+#undef TARGET_MUST_PASS_IN_STACK
+#define TARGET_MUST_PASS_IN_STACK avr32_must_pass_in_stack
+
+#undef TARGET_PASS_BY_REFERENCE
+#define TARGET_PASS_BY_REFERENCE avr32_pass_by_reference
+
+#undef TARGET_STRICT_ARGUMENT_NAMING
+#define TARGET_STRICT_ARGUMENT_NAMING avr32_strict_argument_naming
+
+#undef TARGET_VECTOR_MODE_SUPPORTED_P
+#define TARGET_VECTOR_MODE_SUPPORTED_P avr32_vector_mode_supported
+
+#undef TARGET_RETURN_IN_MEMORY
+#define TARGET_RETURN_IN_MEMORY avr32_return_in_memory
+
+#undef TARGET_RETURN_IN_MSB
+#define TARGET_RETURN_IN_MSB avr32_return_in_msb
+
+#undef TARGET_ENCODE_SECTION_INFO
+#define TARGET_ENCODE_SECTION_INFO avr32_encode_section_info
+
+#undef TARGET_ARG_PARTIAL_BYTES
+#define TARGET_ARG_PARTIAL_BYTES avr32_arg_partial_bytes
+
+#undef TARGET_STRIP_NAME_ENCODING
+#define TARGET_STRIP_NAME_ENCODING avr32_strip_name_encoding
+
+#define streq(string1, string2) (strcmp (string1, string2) == 0)
+
+#undef  TARGET_NARROW_VOLATILE_BITFIELD
+#define TARGET_NARROW_VOLATILE_BITFIELD hook_bool_void_false
+
+#undef  TARGET_ATTRIBUTE_TABLE
+#define TARGET_ATTRIBUTE_TABLE avr32_attribute_table
+
+#undef  TARGET_COMP_TYPE_ATTRIBUTES
+#define TARGET_COMP_TYPE_ATTRIBUTES avr32_comp_type_attributes
+
+
+#undef  TARGET_RTX_COSTS
+#define TARGET_RTX_COSTS avr32_rtx_costs
+
+#undef  TARGET_CANNOT_FORCE_CONST_MEM
+#define  TARGET_CANNOT_FORCE_CONST_MEM avr32_cannot_force_const_mem
+
+#undef  TARGET_ASM_INTEGER
+#define TARGET_ASM_INTEGER avr32_assemble_integer
+
+#undef  TARGET_FUNCTION_VALUE
+#define TARGET_FUNCTION_VALUE avr32_function_value
+
+#undef  TARGET_MIN_ANCHOR_OFFSET
+#define TARGET_MIN_ANCHOR_OFFSET (0)
+
+#undef  TARGET_MAX_ANCHOR_OFFSET
+#define TARGET_MAX_ANCHOR_OFFSET ((1 << 15) - 1)
+#undef TARGET_SECONDARY_RELOAD
+#define TARGET_SECONDARY_RELOAD avr32_secondary_reload
+
+
+/*
+ * Defining the option, -mlist-devices to list the devices supported by gcc.
+ * This option should be used while printing target-help to list all the 
+ * supported devices.
+ */
+#undef TARGET_HELP
+#define TARGET_HELP avr32_target_help
+
+void avr32_target_help ()
+{
+  if (avr32_list_supported_parts)
+    {
+      const struct part_type_s *list;
+      fprintf (stdout, "List of parts supported by avr32-gcc:\n");
+      for (list = avr32_part_types; list->name; list++)
+        {
+          if (strcmp("none", list->name) != 0)
+            fprintf (stdout, "%-20s%s\n", list->name, list->macro);
+        }
+      fprintf (stdout, "\n\n");
+    }
+}
+
+enum reg_class
+avr32_secondary_reload (bool in_p, rtx x, enum reg_class class,
+                        enum machine_mode mode, secondary_reload_info *sri)
+{
+
+  if ( avr32_rmw_memory_operand (x, mode) )
+    {
+      if (!in_p)
+        sri->icode = CODE_FOR_reload_out_rmw_memory_operand;
+      else
+        sri->icode = CODE_FOR_reload_in_rmw_memory_operand;
+    }
+  return NO_REGS;
+
+}
+/*
+ * Switches to the appropriate section for output of constant pool
+ * entry x in mode. You can assume that x is some kind of constant in
+ * RTL. The argument mode is redundant except in the case of a
+ * const_int rtx. Select the section by calling readonly_data_ section
+ * or one of the alternatives for other sections. align is the
+ * constant alignment in bits.
+ *
+ * The default version of this function takes care of putting symbolic
+ * constants in flag_ pic mode in data_section and everything else in
+ * readonly_data_section.
+ */
+//#undef TARGET_ASM_SELECT_RTX_SECTION
+//#define TARGET_ASM_SELECT_RTX_SECTION avr32_select_rtx_section
+
+
+/*
+ * If non-null, this hook performs a target-specific pass over the
+ * instruction stream. The compiler will run it at all optimization
+ * levels, just before the point at which it normally does
+ * delayed-branch scheduling.
+ *
+ * The exact purpose of the hook varies from target to target. Some
+ * use it to do transformations that are necessary for correctness,
+ * such as laying out in-function constant pools or avoiding hardware
+ * hazards. Others use it as an opportunity to do some
+ * machine-dependent optimizations.
+ *
+ * You need not implement the hook if it has nothing to do. The
+ * default definition is null.
+ */
+#undef TARGET_MACHINE_DEPENDENT_REORG
+#define TARGET_MACHINE_DEPENDENT_REORG avr32_reorg
+
+/* Target hook for assembling integer objects.
+   Need to handle integer vectors */
+static bool
+avr32_assemble_integer (rtx x, unsigned int size, int aligned_p)
+{
+  if (avr32_vector_mode_supported (GET_MODE (x)))
+    {
+      int i, units;
+
+      if (GET_CODE (x) != CONST_VECTOR)
+	abort ();
+
+      units = CONST_VECTOR_NUNITS (x);
+
+      switch (GET_MODE (x))
+	{
+	case V2HImode:
+	  size = 2;
+	  break;
+	case V4QImode:
+	  size = 1;
+	  break;
+	default:
+	  abort ();
+	}
+
+      for (i = 0; i < units; i++)
+	{
+	  rtx elt;
+
+	  elt = CONST_VECTOR_ELT (x, i);
+	  assemble_integer (elt, size, i == 0 ? 32 : size * BITS_PER_UNIT, 1);
+	}
+
+      return true;
+    }
+
+  return default_assemble_integer (x, size, aligned_p);
+}
+
+
+/*
+ * This target hook describes the relative costs of RTL expressions.
+ *
+ * The cost may depend on the precise form of the expression, which is
+ * available for examination in x, and the rtx code of the expression
+ * in which it is contained, found in outer_code. code is the
+ * expression code--redundant, since it can be obtained with GET_CODE
+ * (x).
+ *
+ * In implementing this hook, you can use the construct COSTS_N_INSNS
+ * (n) to specify a cost equal to n fast instructions.
+ *
+ * On entry to the hook, *total contains a default estimate for the
+ * cost of the expression. The hook should modify this value as
+ * necessary. Traditionally, the default costs are COSTS_N_INSNS (5)
+ * for multiplications, COSTS_N_INSNS (7) for division and modulus
+ * operations, and COSTS_N_INSNS (1) for all other operations.
+ *
+ * When optimizing for code size, i.e. when optimize_size is non-zero,
+ * this target hook should be used to estimate the relative size cost
+ * of an expression, again relative to COSTS_N_INSNS.
+ *
+ * The hook returns true when all subexpressions of x have been
+ * processed, and false when rtx_cost should recurse.
+ */
+
+/* Worker routine for avr32_rtx_costs.  */
+static inline int
+avr32_rtx_costs_1 (rtx x, enum rtx_code code ATTRIBUTE_UNUSED,
+		   enum rtx_code outer ATTRIBUTE_UNUSED)
+{
+  enum machine_mode mode = GET_MODE (x);
+
+  switch (GET_CODE (x))
+    {
+    case MEM:
+      /* Using pre decrement / post increment memory operations on the
+         avr32_uc architecture means that two writebacks must be performed
+         and hence two cycles are needed. */
+      if (!optimize_size
+	  && GET_MODE_SIZE (mode) <= 2 * UNITS_PER_WORD
+	  && TARGET_ARCH_UC
+	  && (GET_CODE (XEXP (x, 0)) == PRE_DEC
+	      || GET_CODE (XEXP (x, 0)) == POST_INC))
+	return COSTS_N_INSNS (5);
+
+      /* Memory costs quite a lot for the first word, but subsequent words
+         load at the equivalent of a single insn each.  */
+      if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)
+	return COSTS_N_INSNS (3 + (GET_MODE_SIZE (mode) / UNITS_PER_WORD));
+
+      return COSTS_N_INSNS (4);
+    case SYMBOL_REF:
+    case CONST:
+      /* These are valid for the pseudo insns: lda.w and call which operates
+         on direct addresses. We assume that the cost of a lda.w is the same
+         as the cost of a ld.w insn. */
+      return (outer == SET) ? COSTS_N_INSNS (4) : COSTS_N_INSNS (1);
+    case DIV:
+    case MOD:
+    case UDIV:
+    case UMOD:
+      return optimize_size ? COSTS_N_INSNS (1) : COSTS_N_INSNS (16);
+
+    case ROTATE:
+    case ROTATERT:
+      if (mode == TImode)
+	return COSTS_N_INSNS (100);
+
+      if (mode == DImode)
+	return COSTS_N_INSNS (10);
+      return COSTS_N_INSNS (4);
+    case ASHIFT:
+    case LSHIFTRT:
+    case ASHIFTRT:
+    case NOT:
+      if (mode == TImode)
+	return COSTS_N_INSNS (10);
+
+      if (mode == DImode)
+	return COSTS_N_INSNS (4);
+      return COSTS_N_INSNS (1);
+    case PLUS:
+    case MINUS:
+    case NEG:
+    case COMPARE:
+    case ABS:
+      if (GET_MODE_CLASS (mode) == MODE_FLOAT)
+	return COSTS_N_INSNS (100);
+
+      if (mode == TImode)
+	return COSTS_N_INSNS (50);
+
+      if (mode == DImode)
+	return COSTS_N_INSNS (2);
+      return COSTS_N_INSNS (1);
+
+    case MULT:
+      {
+	if (GET_MODE_CLASS (mode) == MODE_FLOAT)
+	  return COSTS_N_INSNS (300);
+
+	if (mode == TImode)
+	  return COSTS_N_INSNS (16);
+
+	if (mode == DImode)
+	  return COSTS_N_INSNS (4);
+
+	if (mode == HImode)
+	  return COSTS_N_INSNS (2);
+
+	return COSTS_N_INSNS (3);
+      }
+    case IF_THEN_ELSE:
+      if (GET_CODE (XEXP (x, 1)) == PC || GET_CODE (XEXP (x, 2)) == PC)
+	return COSTS_N_INSNS (4);
+      return COSTS_N_INSNS (1);
+    case SIGN_EXTEND:
+    case ZERO_EXTEND:
+      /* Sign/Zero extensions of registers cost quite much since these
+         instrcutions only take one register operand which means that gcc
+         often must insert some move instrcutions */
+      if (mode == QImode || mode == HImode)
+	return (COSTS_N_INSNS (GET_CODE (XEXP (x, 0)) == MEM ? 0 : 1));
+      return COSTS_N_INSNS (4);
+    case UNSPEC:
+      /* divmod operations */
+      if (XINT (x, 1) == UNSPEC_UDIVMODSI4_INTERNAL
+	  || XINT (x, 1) == UNSPEC_DIVMODSI4_INTERNAL)
+	{
+	  return optimize_size ? COSTS_N_INSNS (1) : COSTS_N_INSNS (16);
+	}
+      /* Fallthrough */
+    default:
+      return COSTS_N_INSNS (1);
+    }
+}
+
+
+static bool
+avr32_rtx_costs (rtx x, int code, int outer_code, int *total)
+{
+  *total = avr32_rtx_costs_1 (x, code, outer_code);
+  return true;
+}
+
+
+bool
+avr32_cannot_force_const_mem (rtx x ATTRIBUTE_UNUSED)
+{
+  /* Do not want symbols in the constant pool when compiling pic or if using
+     address pseudo instructions. */
+  return ((flag_pic || TARGET_HAS_ASM_ADDR_PSEUDOS)
+	  && avr32_find_symbol (x) != NULL_RTX);
+}
+
+
+/* Table of machine attributes.  */
+const struct attribute_spec avr32_attribute_table[] = {
+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
+  /* Interrupt Service Routines have special prologue and epilogue
+     requirements.  */
+  {"isr", 0, 1, false, false, false, avr32_handle_isr_attribute},
+  {"interrupt", 0, 1, false, false, false, avr32_handle_isr_attribute},
+  {"acall", 0, 1, false, true, true, avr32_handle_acall_attribute},
+  {"naked", 0, 0, true, false, false, avr32_handle_fndecl_attribute},
+  {"rmw_addressable", 0, 0, true, false, false, NULL},
+  {"flashvault", 0, 1, true, false, false, avr32_handle_fndecl_attribute},
+  {"flashvault_impl", 0, 1, true, false, false, avr32_handle_fndecl_attribute},
+  {NULL, 0, 0, false, false, false, NULL}
+};
+
+
+typedef struct
+{
+  const char *const arg;
+  const unsigned long return_value;
+}
+isr_attribute_arg;
+
+
+static const isr_attribute_arg isr_attribute_args[] = {
+  {"FULL", AVR32_FT_ISR_FULL},
+  {"full", AVR32_FT_ISR_FULL},
+  {"HALF", AVR32_FT_ISR_HALF},
+  {"half", AVR32_FT_ISR_HALF},
+  {"NONE", AVR32_FT_ISR_NONE},
+  {"none", AVR32_FT_ISR_NONE},
+  {"UNDEF", AVR32_FT_ISR_NONE},
+  {"undef", AVR32_FT_ISR_NONE},
+  {"SWI", AVR32_FT_ISR_NONE},
+  {"swi", AVR32_FT_ISR_NONE},
+  {NULL, AVR32_FT_ISR_NONE}
+};
+
+
+/* Returns the (interrupt) function type of the current
+   function, or AVR32_FT_UNKNOWN if the type cannot be determined.  */
+static unsigned long
+avr32_isr_value (tree argument)
+{
+  const isr_attribute_arg *ptr;
+  const char *arg;
+
+  /* No argument - default to ISR_NONE.  */
+  if (argument == NULL_TREE)
+    return AVR32_FT_ISR_NONE;
+
+  /* Get the value of the argument.  */
+  if (TREE_VALUE (argument) == NULL_TREE
+      || TREE_CODE (TREE_VALUE (argument)) != STRING_CST)
+    return AVR32_FT_UNKNOWN;
+
+  arg = TREE_STRING_POINTER (TREE_VALUE (argument));
+
+  /* Check it against the list of known arguments.  */
+  for (ptr = isr_attribute_args; ptr->arg != NULL; ptr++)
+    if (streq (arg, ptr->arg))
+      return ptr->return_value;
+
+  /* An unrecognized interrupt type.  */
+  return AVR32_FT_UNKNOWN;
+}
+
+
+/*
+These hooks specify assembly directives for creating certain kinds
+of integer object.  The TARGET_ASM_BYTE_OP directive creates a
+byte-sized object, the TARGET_ASM_ALIGNED_HI_OP one creates an
+aligned two-byte object, and so on.  Any of the hooks may be
+NULL, indicating that no suitable directive is available.
+
+The compiler will print these strings at the start of a new line,
+followed immediately by the object's initial value.  In most cases,
+the string should contain a tab, a pseudo-op, and then another tab.
+*/
+#undef  TARGET_ASM_BYTE_OP
+#define TARGET_ASM_BYTE_OP "\t.byte\t"
+#undef  TARGET_ASM_ALIGNED_HI_OP
+#define TARGET_ASM_ALIGNED_HI_OP "\t.align 1\n\t.short\t"
+#undef  TARGET_ASM_ALIGNED_SI_OP
+#define TARGET_ASM_ALIGNED_SI_OP "\t.align 2\n\t.int\t"
+#undef  TARGET_ASM_ALIGNED_DI_OP
+#define TARGET_ASM_ALIGNED_DI_OP NULL
+#undef  TARGET_ASM_ALIGNED_TI_OP
+#define TARGET_ASM_ALIGNED_TI_OP NULL
+#undef  TARGET_ASM_UNALIGNED_HI_OP
+#define TARGET_ASM_UNALIGNED_HI_OP "\t.short\t"
+#undef  TARGET_ASM_UNALIGNED_SI_OP
+#define TARGET_ASM_UNALIGNED_SI_OP "\t.int\t"
+#undef  TARGET_ASM_UNALIGNED_DI_OP
+#define TARGET_ASM_UNALIGNED_DI_OP NULL
+#undef  TARGET_ASM_UNALIGNED_TI_OP
+#define TARGET_ASM_UNALIGNED_TI_OP NULL
+
+#undef TARGET_ASM_OUTPUT_MI_THUNK
+#define TARGET_ASM_OUTPUT_MI_THUNK avr32_output_mi_thunk
+
+#undef TARGET_ASM_CAN_OUTPUT_MI_THUNK
+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_const_tree_hwi_hwi_const_tree_true
+
+
+static void
+avr32_output_mi_thunk (FILE * file,
+    tree thunk ATTRIBUTE_UNUSED,
+    HOST_WIDE_INT delta,
+    HOST_WIDE_INT vcall_offset, tree function)
+  {
+    int mi_delta = delta;
+    int this_regno =
+      (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function) ?
+       INTERNAL_REGNUM (11) : INTERNAL_REGNUM (12));
+
+
+    if (!avr32_const_ok_for_constraint_p (mi_delta, 'I', "Is21")
+        || vcall_offset)
+      {
+        fputs ("\tpushm\tlr\n", file);
+      }
+
+
+    if (mi_delta != 0)
+      {
+        if (avr32_const_ok_for_constraint_p (mi_delta, 'I', "Is21"))
+          {
+            fprintf (file, "\tsub\t%s, %d\n", reg_names[this_regno], -mi_delta);
+          }
+        else
+          {
+            /* Immediate is larger than k21 we must make us a temp register by
+	     pushing a register to the stack. */
+            fprintf (file, "\tmov\tlr, lo(%d)\n", mi_delta);
+            fprintf (file, "\torh\tlr, hi(%d)\n", mi_delta);
+            fprintf (file, "\tadd\t%s, lr\n", reg_names[this_regno]);
+          }
+      }
+
+
+    if (vcall_offset != 0)
+      {
+        fprintf (file, "\tld.w\tlr, %s[0]\n", reg_names[this_regno]);
+        fprintf (file, "\tld.w\tlr, lr[%i]\n", (int) vcall_offset);
+        fprintf (file, "\tadd\t%s, lr\n", reg_names[this_regno]);
+      }
+
+
+    if (!avr32_const_ok_for_constraint_p (mi_delta, 'I', "Is21")
+        || vcall_offset)
+      {
+        fputs ("\tpopm\tlr\n", file);
+      }
+
+    /* Jump to the function. We assume that we can use an rjmp since the
+       function to jump to is local and probably not too far away from
+       the thunk. If this assumption proves to be wrong we could implement
+       this jump by calculating the offset between the jump source and destination
+       and put this in the constant pool and then perform an add to pc.
+       This would also be legitimate PIC code. But for now we hope that an rjmp
+       will be sufficient...
+    */
+    fputs ("\trjmp\t", file);
+    assemble_name (file, XSTR (XEXP (DECL_RTL (function), 0), 0));
+    fputc ('\n', file);
+  }
+
+
+/* Implements target hook vector_mode_supported.  */
+bool
+avr32_vector_mode_supported (enum machine_mode mode)
+{
+  if ((mode == V2HImode) || (mode == V4QImode))
+    return true;
+
+  return false;
+}
+
+
+#undef TARGET_INIT_LIBFUNCS
+#define TARGET_INIT_LIBFUNCS avr32_init_libfuncs
+
+#undef  TARGET_INIT_BUILTINS
+#define TARGET_INIT_BUILTINS avr32_init_builtins
+
+#undef  TARGET_EXPAND_BUILTIN
+#define TARGET_EXPAND_BUILTIN avr32_expand_builtin
+
+tree int_ftype_int, int_ftype_void, short_ftype_short, void_ftype_int_int,
+  void_ftype_ptr_int;
+tree void_ftype_int, void_ftype_ulong, void_ftype_void, int_ftype_ptr_int;
+tree short_ftype_short, int_ftype_int_short, int_ftype_short_short,
+  short_ftype_short_short;
+tree int_ftype_int_int, longlong_ftype_int_short, longlong_ftype_short_short;
+tree void_ftype_int_int_int_int_int, void_ftype_int_int_int;
+tree longlong_ftype_int_int, void_ftype_int_int_longlong;
+tree int_ftype_int_int_int, longlong_ftype_longlong_int_short;
+tree longlong_ftype_longlong_short_short, int_ftype_int_short_short;
+
+#define def_builtin(NAME, TYPE, CODE)					\
+  add_builtin_function ((NAME), (TYPE), (CODE),                          \
+                       BUILT_IN_MD, NULL, NULL_TREE)
+
+#define def_mbuiltin(MASK, NAME, TYPE, CODE)				\
+  do									\
+    {									\
+      if ((MASK))							\
+	add_builtin_function ((NAME), (TYPE), (CODE),                   \
+                              BUILT_IN_MD, NULL, NULL_TREE);            \
+    }									\
+  while (0)
+
+struct builtin_description
+{
+  const unsigned int mask;
+  const enum insn_code icode;
+  const char *const name;
+  const int code;
+  const enum rtx_code comparison;
+  const unsigned int flag;
+  const tree *ftype;
+};
+
+static const struct builtin_description bdesc_2arg[] = {
+
+#define DSP_BUILTIN(code, builtin, ftype) \
+  { 1, CODE_FOR_##code, "__builtin_" #code , \
+  AVR32_BUILTIN_##builtin, 0, 0, ftype }
+
+  DSP_BUILTIN (mulsathh_h,    MULSATHH_H,    &short_ftype_short_short),
+  DSP_BUILTIN (mulsathh_w,    MULSATHH_W,    &int_ftype_short_short),
+  DSP_BUILTIN (mulsatrndhh_h, MULSATRNDHH_H, &short_ftype_short_short),
+  DSP_BUILTIN (mulsatrndwh_w, MULSATRNDWH_W, &int_ftype_int_short),
+  DSP_BUILTIN (mulsatwh_w,    MULSATWH_W,    &int_ftype_int_short),
+  DSP_BUILTIN (satadd_h,      SATADD_H,      &short_ftype_short_short),
+  DSP_BUILTIN (satsub_h,      SATSUB_H,      &short_ftype_short_short),
+  DSP_BUILTIN (satadd_w,      SATADD_W,      &int_ftype_int_int),
+  DSP_BUILTIN (satsub_w,      SATSUB_W,      &int_ftype_int_int),
+  DSP_BUILTIN (mulwh_d,       MULWH_D,       &longlong_ftype_int_short),
+  DSP_BUILTIN (mulnwh_d,      MULNWH_D,      &longlong_ftype_int_short)
+};
+
+
+void
+avr32_init_builtins (void)
+{
+  unsigned int i;
+  const struct builtin_description *d;
+  tree endlink = void_list_node;
+  tree int_endlink = tree_cons (NULL_TREE, integer_type_node, endlink);
+  tree longlong_endlink =
+    tree_cons (NULL_TREE, long_long_integer_type_node, endlink);
+  tree short_endlink =
+    tree_cons (NULL_TREE, short_integer_type_node, endlink);
+  tree void_endlink = tree_cons (NULL_TREE, void_type_node, endlink);
+
+  /* int func (int) */
+  int_ftype_int = build_function_type (integer_type_node, int_endlink);
+
+  /* short func (short) */
+  short_ftype_short
+    = build_function_type (short_integer_type_node, short_endlink);
+
+  /* short func (short, short) */
+  short_ftype_short_short
+    = build_function_type (short_integer_type_node,
+			   tree_cons (NULL_TREE, short_integer_type_node,
+				      short_endlink));
+
+  /* long long func (long long, short, short) */
+  longlong_ftype_longlong_short_short
+    = build_function_type (long_long_integer_type_node,
+			   tree_cons (NULL_TREE, long_long_integer_type_node,
+				      tree_cons (NULL_TREE,
+						 short_integer_type_node,
+						 short_endlink)));
+
+  /* long long func (short, short) */
+  longlong_ftype_short_short
+    = build_function_type (long_long_integer_type_node,
+			   tree_cons (NULL_TREE, short_integer_type_node,
+				      short_endlink));
+
+  /* int func (int, int) */
+  int_ftype_int_int
+    = build_function_type (integer_type_node,
+			   tree_cons (NULL_TREE, integer_type_node,
+				      int_endlink));
+
+  /* long long func (int, int) */
+  longlong_ftype_int_int
+    = build_function_type (long_long_integer_type_node,
+			   tree_cons (NULL_TREE, integer_type_node,
+				      int_endlink));
+
+  /* long long int func (long long, int, short) */
+  longlong_ftype_longlong_int_short
+    = build_function_type (long_long_integer_type_node,
+			   tree_cons (NULL_TREE, long_long_integer_type_node,
+				      tree_cons (NULL_TREE, integer_type_node,
+						 short_endlink)));
+
+  /* long long int func (int, short) */
+  longlong_ftype_int_short
+    = build_function_type (long_long_integer_type_node,
+			   tree_cons (NULL_TREE, integer_type_node,
+				      short_endlink));
+
+  /* int func (int, short, short) */
+  int_ftype_int_short_short
+    = build_function_type (integer_type_node,
+			   tree_cons (NULL_TREE, integer_type_node,
+				      tree_cons (NULL_TREE,
+						 short_integer_type_node,
+						 short_endlink)));
+
+  /* int func (short, short) */
+  int_ftype_short_short
+    = build_function_type (integer_type_node,
+			   tree_cons (NULL_TREE, short_integer_type_node,
+				      short_endlink));
+
+  /* int func (int, short) */
+  int_ftype_int_short
+    = build_function_type (integer_type_node,
+			   tree_cons (NULL_TREE, integer_type_node,
+				      short_endlink));
+
+  /* void func (int, int) */
+  void_ftype_int_int
+    = build_function_type (void_type_node,
+			   tree_cons (NULL_TREE, integer_type_node,
+				      int_endlink));
+
+  /* void func (int, int, int) */
+  void_ftype_int_int_int
+    = build_function_type (void_type_node,
+			   tree_cons (NULL_TREE, integer_type_node,
+				      tree_cons (NULL_TREE, integer_type_node,
+						 int_endlink)));
+
+  /* void func (int, int, long long) */
+  void_ftype_int_int_longlong
+    = build_function_type (void_type_node,
+			   tree_cons (NULL_TREE, integer_type_node,
+				      tree_cons (NULL_TREE, integer_type_node,
+						 longlong_endlink)));
+
+  /* void func (int, int, int, int, int) */
+  void_ftype_int_int_int_int_int
+    = build_function_type (void_type_node,
+			   tree_cons (NULL_TREE, integer_type_node,
+				      tree_cons (NULL_TREE, integer_type_node,
+						 tree_cons (NULL_TREE,
+							    integer_type_node,
+							    tree_cons
+							    (NULL_TREE,
+							     integer_type_node,
+							     int_endlink)))));
+
+  /* void func (void *, int) */
+  void_ftype_ptr_int
+    = build_function_type (void_type_node,
+			   tree_cons (NULL_TREE, ptr_type_node, int_endlink));
+
+  /* void func (int) */
+  void_ftype_int = build_function_type (void_type_node, int_endlink);
+
+  /* void func (ulong) */
+  void_ftype_ulong = build_function_type_list (void_type_node,
+                           long_unsigned_type_node, NULL_TREE);
+
+  /* void func (void) */
+  void_ftype_void = build_function_type (void_type_node, void_endlink);
+
+  /* int func (void) */
+  int_ftype_void = build_function_type (integer_type_node, void_endlink);
+
+  /* int func (void *, int) */
+  int_ftype_ptr_int
+    = build_function_type (integer_type_node,
+			   tree_cons (NULL_TREE, ptr_type_node, int_endlink));
+
+  /* int func (int, int, int) */
+  int_ftype_int_int_int
+    = build_function_type (integer_type_node,
+			   tree_cons (NULL_TREE, integer_type_node,
+				      tree_cons (NULL_TREE, integer_type_node,
+						 int_endlink)));
+
+  /* Initialize avr32 builtins.  */
+  def_builtin ("__builtin_mfsr", int_ftype_int, AVR32_BUILTIN_MFSR);
+  def_builtin ("__builtin_mtsr", void_ftype_int_int, AVR32_BUILTIN_MTSR);
+  def_builtin ("__builtin_mfdr", int_ftype_int, AVR32_BUILTIN_MFDR);
+  def_builtin ("__builtin_mtdr", void_ftype_int_int, AVR32_BUILTIN_MTDR);
+  def_builtin ("__builtin_cache", void_ftype_ptr_int, AVR32_BUILTIN_CACHE);
+  def_builtin ("__builtin_sync", void_ftype_int, AVR32_BUILTIN_SYNC);
+  def_builtin ("__builtin_ssrf", void_ftype_int, AVR32_BUILTIN_SSRF);
+  def_builtin ("__builtin_csrf", void_ftype_int, AVR32_BUILTIN_CSRF);
+  def_builtin ("__builtin_tlbr", void_ftype_void, AVR32_BUILTIN_TLBR);
+  def_builtin ("__builtin_tlbs", void_ftype_void, AVR32_BUILTIN_TLBS);
+  def_builtin ("__builtin_tlbw", void_ftype_void, AVR32_BUILTIN_TLBW);
+  def_builtin ("__builtin_breakpoint", void_ftype_void,
+	       AVR32_BUILTIN_BREAKPOINT);
+  def_builtin ("__builtin_xchg", int_ftype_ptr_int, AVR32_BUILTIN_XCHG);
+  def_builtin ("__builtin_ldxi", int_ftype_ptr_int, AVR32_BUILTIN_LDXI);
+  def_builtin ("__builtin_bswap_16", short_ftype_short,
+	       AVR32_BUILTIN_BSWAP16);
+  def_builtin ("__builtin_bswap_32", int_ftype_int, AVR32_BUILTIN_BSWAP32);
+  def_builtin ("__builtin_cop", void_ftype_int_int_int_int_int,
+	       AVR32_BUILTIN_COP);
+  def_builtin ("__builtin_mvcr_w", int_ftype_int_int, AVR32_BUILTIN_MVCR_W);
+  def_builtin ("__builtin_mvrc_w", void_ftype_int_int_int,
+	       AVR32_BUILTIN_MVRC_W);
+  def_builtin ("__builtin_mvcr_d", longlong_ftype_int_int,
+	       AVR32_BUILTIN_MVCR_D);
+  def_builtin ("__builtin_mvrc_d", void_ftype_int_int_longlong,
+	       AVR32_BUILTIN_MVRC_D);
+  def_builtin ("__builtin_sats", int_ftype_int_int_int, AVR32_BUILTIN_SATS);
+  def_builtin ("__builtin_satu", int_ftype_int_int_int, AVR32_BUILTIN_SATU);
+  def_builtin ("__builtin_satrnds", int_ftype_int_int_int,
+	       AVR32_BUILTIN_SATRNDS);
+  def_builtin ("__builtin_satrndu", int_ftype_int_int_int,
+	       AVR32_BUILTIN_SATRNDU);
+  def_builtin ("__builtin_musfr", void_ftype_int, AVR32_BUILTIN_MUSFR);
+  def_builtin ("__builtin_mustr", int_ftype_void, AVR32_BUILTIN_MUSTR);
+  def_builtin ("__builtin_macsathh_w", int_ftype_int_short_short,
+	       AVR32_BUILTIN_MACSATHH_W);
+  def_builtin ("__builtin_macwh_d", longlong_ftype_longlong_int_short,
+	       AVR32_BUILTIN_MACWH_D);
+  def_builtin ("__builtin_machh_d", longlong_ftype_longlong_short_short,
+	       AVR32_BUILTIN_MACHH_D);
+  def_builtin ("__builtin_mems", void_ftype_ptr_int, AVR32_BUILTIN_MEMS);
+  def_builtin ("__builtin_memt", void_ftype_ptr_int, AVR32_BUILTIN_MEMT);
+  def_builtin ("__builtin_memc", void_ftype_ptr_int, AVR32_BUILTIN_MEMC);
+  def_builtin ("__builtin_sleep", void_ftype_int, AVR32_BUILTIN_SLEEP);
+  def_builtin ("__builtin_avr32_delay_cycles", void_ftype_int, AVR32_BUILTIN_DELAY_CYCLES);
+
+  /* Add all builtins that are more or less simple operations on two
+     operands.  */
+  for (i = 0, d = bdesc_2arg; i < ARRAY_SIZE (bdesc_2arg); i++, d++)
+    {
+      /* Use one of the operands; the target can have a different mode for
+         mask-generating compares.  */
+
+      if (d->name == 0)
+	continue;
+
+      def_mbuiltin (d->mask, d->name, *(d->ftype), d->code);
+    }
+}
+
+
+/* Subroutine of avr32_expand_builtin to take care of binop insns. */
+static rtx
+avr32_expand_binop_builtin (enum insn_code icode, tree exp, rtx target)
+{
+  rtx pat;
+  tree arg0 = CALL_EXPR_ARG (exp,0);
+  tree arg1 = CALL_EXPR_ARG (exp,1);
+  rtx op0 = expand_normal (arg0);
+  rtx op1 = expand_normal (arg1);
+  enum machine_mode tmode = insn_data[icode].operand[0].mode;
+  enum machine_mode mode0 = insn_data[icode].operand[1].mode;
+  enum machine_mode mode1 = insn_data[icode].operand[2].mode;
+
+  if (!target
+      || GET_MODE (target) != tmode
+      || !(*insn_data[icode].operand[0].predicate) (target, tmode))
+    target = gen_reg_rtx (tmode);
+
+  /* In case the insn wants input operands in modes different from the
+     result, abort.  */
+  if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))
+    {
+      /* If op0 is already a reg we must cast it to the correct mode. */
+      if (REG_P (op0))
+	op0 = convert_to_mode (mode0, op0, 1);
+      else
+	op0 = copy_to_mode_reg (mode0, op0);
+    }
+  if (!(*insn_data[icode].operand[2].predicate) (op1, mode1))
+    {
+      /* If op1 is already a reg we must cast it to the correct mode. */
+      if (REG_P (op1))
+	op1 = convert_to_mode (mode1, op1, 1);
+      else
+	op1 = copy_to_mode_reg (mode1, op1);
+    }
+  pat = GEN_FCN (icode) (target, op0, op1);
+  if (!pat)
+    return 0;
+  emit_insn (pat);
+  return target;
+}
+
+
+/* Expand an expression EXP that calls a built-in function,
+   with result going to TARGET if that's convenient
+   (and in mode MODE if that's convenient).
+   SUBTARGET may be used as the target for computing one of EXP's operands.
+   IGNORE is nonzero if the value is to be ignored.  */
+rtx
+avr32_expand_builtin (tree exp,
+		      rtx target,
+		      rtx subtarget ATTRIBUTE_UNUSED,
+		      enum machine_mode mode ATTRIBUTE_UNUSED,
+		      int ignore ATTRIBUTE_UNUSED)
+{
+  const struct builtin_description *d;
+  unsigned int i;
+  enum insn_code icode = 0;
+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);
+  tree arg0, arg1, arg2;
+  rtx op0, op1, op2, pat;
+  enum machine_mode tmode, mode0, mode1;
+  enum machine_mode arg0_mode;
+  int fcode = DECL_FUNCTION_CODE (fndecl);
+
+  switch (fcode)
+    {
+    default:
+      break;
+
+    case AVR32_BUILTIN_SATS:
+    case AVR32_BUILTIN_SATU:
+    case AVR32_BUILTIN_SATRNDS:
+    case AVR32_BUILTIN_SATRNDU:
+      {
+	const char *fname;
+	switch (fcode)
+	  {
+	  default:
+	  case AVR32_BUILTIN_SATS:
+	    icode = CODE_FOR_sats;
+	    fname = "sats";
+	    break;
+	  case AVR32_BUILTIN_SATU:
+	    icode = CODE_FOR_satu;
+	    fname = "satu";
+	    break;
+	  case AVR32_BUILTIN_SATRNDS:
+	    icode = CODE_FOR_satrnds;
+	    fname = "satrnds";
+	    break;
+	  case AVR32_BUILTIN_SATRNDU:
+	    icode = CODE_FOR_satrndu;
+	    fname = "satrndu";
+	    break;
+	  }
+
+	arg0 = CALL_EXPR_ARG (exp,0);
+	arg1 = CALL_EXPR_ARG (exp,1);
+	arg2 = CALL_EXPR_ARG (exp,2);
+	op0 = expand_normal (arg0);
+	op1 = expand_normal (arg1);
+	op2 = expand_normal (arg2);
+
+	tmode = insn_data[icode].operand[0].mode;
+
+
+	if (target == 0
+	    || GET_MODE (target) != tmode
+	    || !(*insn_data[icode].operand[0].predicate) (target, tmode))
+	  target = gen_reg_rtx (tmode);
+
+
+	if (!(*insn_data[icode].operand[0].predicate) (op0, GET_MODE (op0)))
+	  {
+	    op0 = copy_to_mode_reg (insn_data[icode].operand[0].mode, op0);
+	  }
+
+	if (!(*insn_data[icode].operand[1].predicate) (op1, SImode))
+	  {
+	    error ("Parameter 2 to __builtin_%s should be a constant number.",
+		   fname);
+	    return NULL_RTX;
+	  }
+
+	if (!(*insn_data[icode].operand[1].predicate) (op2, SImode))
+	  {
+	    error ("Parameter 3 to __builtin_%s should be a constant number.",
+		   fname);
+	    return NULL_RTX;
+	  }
+
+	emit_move_insn (target, op0);
+	pat = GEN_FCN (icode) (target, op1, op2);
+	if (!pat)
+	  return 0;
+	emit_insn (pat);
+
+	return target;
+      }
+    case AVR32_BUILTIN_MUSTR:
+      icode = CODE_FOR_mustr;
+      tmode = insn_data[icode].operand[0].mode;
+
+      if (target == 0
+	  || GET_MODE (target) != tmode
+	  || !(*insn_data[icode].operand[0].predicate) (target, tmode))
+	target = gen_reg_rtx (tmode);
+      pat = GEN_FCN (icode) (target);
+      if (!pat)
+	return 0;
+      emit_insn (pat);
+      return target;
+
+    case AVR32_BUILTIN_MFSR:
+      icode = CODE_FOR_mfsr;
+      arg0 = CALL_EXPR_ARG (exp,0);
+      op0 = expand_normal (arg0);
+      tmode = insn_data[icode].operand[0].mode;
+      mode0 = insn_data[icode].operand[1].mode;
+
+      if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))
+	{
+	  error ("Parameter 1 to __builtin_mfsr must be a constant number");
+	}
+
+      if (target == 0
+	  || GET_MODE (target) != tmode
+	  || !(*insn_data[icode].operand[0].predicate) (target, tmode))
+	target = gen_reg_rtx (tmode);
+      pat = GEN_FCN (icode) (target, op0);
+      if (!pat)
+	return 0;
+      emit_insn (pat);
+      return target;
+    case AVR32_BUILTIN_MTSR:
+      icode = CODE_FOR_mtsr;
+      arg0 = CALL_EXPR_ARG (exp,0);
+      arg1 = CALL_EXPR_ARG (exp,1);
+      op0 = expand_normal (arg0);
+      op1 = expand_normal (arg1);
+      mode0 = insn_data[icode].operand[0].mode;
+      mode1 = insn_data[icode].operand[1].mode;
+
+      if (!(*insn_data[icode].operand[0].predicate) (op0, mode0))
+	{
+	  error ("Parameter 1 to __builtin_mtsr must be a constant number");
+	  return gen_reg_rtx (mode0);
+	}
+      if (!(*insn_data[icode].operand[1].predicate) (op1, mode1))
+	op1 = copy_to_mode_reg (mode1, op1);
+      pat = GEN_FCN (icode) (op0, op1);
+      if (!pat)
+	return 0;
+      emit_insn (pat);
+      return NULL_RTX;
+    case AVR32_BUILTIN_MFDR:
+      icode = CODE_FOR_mfdr;
+      arg0 = CALL_EXPR_ARG (exp,0);
+      op0 = expand_normal (arg0);
+      tmode = insn_data[icode].operand[0].mode;
+      mode0 = insn_data[icode].operand[1].mode;
+
+      if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))
+	{
+	  error ("Parameter 1 to __builtin_mfdr must be a constant number");
+	}
+
+      if (target == 0
+	  || GET_MODE (target) != tmode
+	  || !(*insn_data[icode].operand[0].predicate) (target, tmode))
+	target = gen_reg_rtx (tmode);
+      pat = GEN_FCN (icode) (target, op0);
+      if (!pat)
+	return 0;
+      emit_insn (pat);
+      return target;
+    case AVR32_BUILTIN_MTDR:
+      icode = CODE_FOR_mtdr;
+      arg0 = CALL_EXPR_ARG (exp,0);
+      arg1 = CALL_EXPR_ARG (exp,1);
+      op0 = expand_normal (arg0);
+      op1 = expand_normal (arg1);
+      mode0 = insn_data[icode].operand[0].mode;
+      mode1 = insn_data[icode].operand[1].mode;
+
+      if (!(*insn_data[icode].operand[0].predicate) (op0, mode0))
+	{
+	  error ("Parameter 1 to __builtin_mtdr must be a constant number");
+	  return gen_reg_rtx (mode0);
+	}
+      if (!(*insn_data[icode].operand[1].predicate) (op1, mode1))
+	op1 = copy_to_mode_reg (mode1, op1);
+      pat = GEN_FCN (icode) (op0, op1);
+      if (!pat)
+	return 0;
+      emit_insn (pat);
+      return NULL_RTX;
+    case AVR32_BUILTIN_CACHE:
+      icode = CODE_FOR_cache;
+      arg0 = CALL_EXPR_ARG (exp,0);
+      arg1 = CALL_EXPR_ARG (exp,1);
+      op0 = expand_normal (arg0);
+      op1 = expand_normal (arg1);
+      mode0 = insn_data[icode].operand[0].mode;
+      mode1 = insn_data[icode].operand[1].mode;
+
+      if (!(*insn_data[icode].operand[1].predicate) (op1, mode1))
+	{
+	  error ("Parameter 2 to __builtin_cache must be a constant number");
+	  return gen_reg_rtx (mode1);
+	}
+
+      if (!(*insn_data[icode].operand[0].predicate) (op0, mode0))
+	op0 = copy_to_mode_reg (mode0, op0);
+
+      pat = GEN_FCN (icode) (op0, op1);
+      if (!pat)
+	return 0;
+      emit_insn (pat);
+      return NULL_RTX;
+    case AVR32_BUILTIN_SYNC:
+    case AVR32_BUILTIN_MUSFR:
+    case AVR32_BUILTIN_SSRF:
+    case AVR32_BUILTIN_CSRF:
+      {
+	const char *fname;
+	switch (fcode)
+	  {
+	  default:
+	  case AVR32_BUILTIN_SYNC:
+	    icode = CODE_FOR_sync;
+	    fname = "sync";
+	    break;
+	  case AVR32_BUILTIN_MUSFR:
+	    icode = CODE_FOR_musfr;
+	    fname = "musfr";
+	    break;
+	  case AVR32_BUILTIN_SSRF:
+	    icode = CODE_FOR_ssrf;
+	    fname = "ssrf";
+	    break;
+	  case AVR32_BUILTIN_CSRF:
+	    icode = CODE_FOR_csrf;
+	    fname = "csrf";
+	    break;
+	  }
+
+	arg0 = CALL_EXPR_ARG (exp,0);
+	op0 = expand_normal (arg0);
+	mode0 = insn_data[icode].operand[0].mode;
+
+	if (!(*insn_data[icode].operand[0].predicate) (op0, mode0))
+	  {
+	    if (icode == CODE_FOR_musfr)
+	      op0 = copy_to_mode_reg (mode0, op0);
+	    else
+	      {
+		error ("Parameter to __builtin_%s is illegal.", fname);
+		return gen_reg_rtx (mode0);
+	      }
+	  }
+	pat = GEN_FCN (icode) (op0);
+	if (!pat)
+	  return 0;
+	emit_insn (pat);
+	return NULL_RTX;
+      }
+    case AVR32_BUILTIN_TLBR:
+      icode = CODE_FOR_tlbr;
+      pat = GEN_FCN (icode) (NULL_RTX);
+      if (!pat)
+	return 0;
+      emit_insn (pat);
+      return NULL_RTX;
+    case AVR32_BUILTIN_TLBS:
+      icode = CODE_FOR_tlbs;
+      pat = GEN_FCN (icode) (NULL_RTX);
+      if (!pat)
+	return 0;
+      emit_insn (pat);
+      return NULL_RTX;
+    case AVR32_BUILTIN_TLBW:
+      icode = CODE_FOR_tlbw;
+      pat = GEN_FCN (icode) (NULL_RTX);
+      if (!pat)
+	return 0;
+      emit_insn (pat);
+      return NULL_RTX;
+    case AVR32_BUILTIN_BREAKPOINT:
+      icode = CODE_FOR_breakpoint;
+      pat = GEN_FCN (icode) (NULL_RTX);
+      if (!pat)
+	return 0;
+      emit_insn (pat);
+      return NULL_RTX;
+    case AVR32_BUILTIN_XCHG:
+      icode = CODE_FOR_sync_lock_test_and_setsi;
+      arg0 = CALL_EXPR_ARG (exp,0);
+      arg1 = CALL_EXPR_ARG (exp,1);
+      op0 = expand_normal (arg0);
+      op1 = expand_normal (arg1);
+      tmode = insn_data[icode].operand[0].mode;
+      mode0 = insn_data[icode].operand[1].mode;
+      mode1 = insn_data[icode].operand[2].mode;
+
+      if (!(*insn_data[icode].operand[2].predicate) (op1, mode1))
+	{
+	  op1 = copy_to_mode_reg (mode1, op1);
+	}
+
+      op0 = force_reg (GET_MODE (op0), op0);
+      op0 = gen_rtx_MEM (GET_MODE (op0), op0);
+      if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))
+	{
+	  error
+	    ("Parameter 1 to __builtin_xchg must be a pointer to an integer.");
+	}
+
+      if (target == 0
+	  || GET_MODE (target) != tmode
+	  || !(*insn_data[icode].operand[0].predicate) (target, tmode))
+	target = gen_reg_rtx (tmode);
+      pat = GEN_FCN (icode) (target, op0, op1);
+      if (!pat)
+	return 0;
+      emit_insn (pat);
+      return target;
+    case AVR32_BUILTIN_LDXI:
+      icode = CODE_FOR_ldxi;
+      arg0 = CALL_EXPR_ARG (exp,0);
+      arg1 = CALL_EXPR_ARG (exp,1);
+      arg2 = CALL_EXPR_ARG (exp,2);
+      op0 = expand_normal (arg0);
+      op1 = expand_normal (arg1);
+      op2 = expand_normal (arg2);
+      tmode = insn_data[icode].operand[0].mode;
+      mode0 = insn_data[icode].operand[1].mode;
+      mode1 = insn_data[icode].operand[2].mode;
+
+      if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))
+	{
+	  op0 = copy_to_mode_reg (mode0, op0);
+	}
+
+      if (!(*insn_data[icode].operand[2].predicate) (op1, mode1))
+	{
+	  op1 = copy_to_mode_reg (mode1, op1);
+	}
+
+      if (!(*insn_data[icode].operand[3].predicate) (op2, SImode))
+	{
+	  error
+	    ("Parameter 3 to __builtin_ldxi must be a valid extract shift operand: (0|8|16|24)");
+	  return gen_reg_rtx (mode0);
+	}
+
+      if (target == 0
+	  || GET_MODE (target) != tmode
+	  || !(*insn_data[icode].operand[0].predicate) (target, tmode))
+	target = gen_reg_rtx (tmode);
+      pat = GEN_FCN (icode) (target, op0, op1, op2);
+      if (!pat)
+	return 0;
+      emit_insn (pat);
+      return target;
+    case AVR32_BUILTIN_BSWAP16:
+      {
+	icode = CODE_FOR_bswap_16;
+	arg0 = CALL_EXPR_ARG (exp,0);
+	arg0_mode = TYPE_MODE (TREE_TYPE (arg0));
+	mode0 = insn_data[icode].operand[1].mode;
+	if (arg0_mode != mode0)
+	  arg0 = build1 (NOP_EXPR,
+			 (*lang_hooks.types.type_for_mode) (mode0, 0), arg0);
+
+	op0 = expand_expr (arg0, NULL_RTX, HImode, 0);
+	tmode = insn_data[icode].operand[0].mode;
+
+
+	if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))
+	  {
+            if ( CONST_INT_P (op0) )
+              {
+                HOST_WIDE_INT val = ( ((INTVAL (op0)&0x00ff) << 8) |
+                                      ((INTVAL (op0)&0xff00) >> 8) );
+                /* Sign extend 16-bit value to host wide int */
+                val <<= (HOST_BITS_PER_WIDE_INT - 16);
+                val >>= (HOST_BITS_PER_WIDE_INT - 16);
+                op0 = GEN_INT(val);
+                if (target == 0
+                    || GET_MODE (target) != tmode
+                    || !(*insn_data[icode].operand[0].predicate) (target, tmode))
+                  target = gen_reg_rtx (tmode);
+                emit_move_insn(target, op0);
+                return target;
+              }
+            else
+              op0 = copy_to_mode_reg (mode0, op0);
+	  }
+
+	if (target == 0
+	    || GET_MODE (target) != tmode
+	    || !(*insn_data[icode].operand[0].predicate) (target, tmode))
+	  {
+	    target = gen_reg_rtx (tmode);
+	  }
+
+
+	pat = GEN_FCN (icode) (target, op0);
+	if (!pat)
+	  return 0;
+	emit_insn (pat);
+
+	return target;
+      }
+    case AVR32_BUILTIN_BSWAP32:
+      {
+	icode = CODE_FOR_bswap_32;
+	arg0 = CALL_EXPR_ARG (exp,0);
+	op0 = expand_normal (arg0);
+	tmode = insn_data[icode].operand[0].mode;
+	mode0 = insn_data[icode].operand[1].mode;
+
+	if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))
+	  {
+            if ( CONST_INT_P (op0) )
+              {
+                HOST_WIDE_INT val = ( ((INTVAL (op0)&0x000000ff) << 24) |
+                                      ((INTVAL (op0)&0x0000ff00) << 8) |
+                                      ((INTVAL (op0)&0x00ff0000) >> 8) |
+                                      ((INTVAL (op0)&0xff000000) >> 24) );
+                /* Sign extend 32-bit value to host wide int */
+                val <<= (HOST_BITS_PER_WIDE_INT - 32);
+                val >>= (HOST_BITS_PER_WIDE_INT - 32);
+                op0 = GEN_INT(val);
+                if (target == 0
+                    || GET_MODE (target) != tmode
+                    || !(*insn_data[icode].operand[0].predicate) (target, tmode))
+                  target = gen_reg_rtx (tmode);
+                emit_move_insn(target, op0);
+                return target;
+              }
+            else
+              op0 = copy_to_mode_reg (mode0, op0);
+	  }
+
+	if (target == 0
+	    || GET_MODE (target) != tmode
+	    || !(*insn_data[icode].operand[0].predicate) (target, tmode))
+	  target = gen_reg_rtx (tmode);
+
+
+	pat = GEN_FCN (icode) (target, op0);
+	if (!pat)
+	  return 0;
+	emit_insn (pat);
+
+	return target;
+      }
+    case AVR32_BUILTIN_MVCR_W:
+    case AVR32_BUILTIN_MVCR_D:
+      {
+	arg0 = CALL_EXPR_ARG (exp,0);
+	arg1 = CALL_EXPR_ARG (exp,1);
+	op0 = expand_normal (arg0);
+	op1 = expand_normal (arg1);
+
+	if (fcode == AVR32_BUILTIN_MVCR_W)
+	  icode = CODE_FOR_mvcrsi;
+	else
+	  icode = CODE_FOR_mvcrdi;
+
+	tmode = insn_data[icode].operand[0].mode;
+
+	if (target == 0
+	    || GET_MODE (target) != tmode
+	    || !(*insn_data[icode].operand[0].predicate) (target, tmode))
+	  target = gen_reg_rtx (tmode);
+
+	if (!(*insn_data[icode].operand[1].predicate) (op0, SImode))
+	  {
+	    error
+	      ("Parameter 1 to __builtin_cop is not a valid coprocessor number.");
+	    error ("Number should be between 0 and 7.");
+	    return NULL_RTX;
+	  }
+
+	if (!(*insn_data[icode].operand[2].predicate) (op1, SImode))
+	  {
+	    error
+	      ("Parameter 2 to __builtin_cop is not a valid coprocessor register number.");
+	    error ("Number should be between 0 and 15.");
+	    return NULL_RTX;
+	  }
+
+	pat = GEN_FCN (icode) (target, op0, op1);
+	if (!pat)
+	  return 0;
+	emit_insn (pat);
+
+	return target;
+      }
+    case AVR32_BUILTIN_MACSATHH_W:
+    case AVR32_BUILTIN_MACWH_D:
+    case AVR32_BUILTIN_MACHH_D:
+      {
+	arg0 = CALL_EXPR_ARG (exp,0);
+	arg1 = CALL_EXPR_ARG (exp,1);
+	arg2 = CALL_EXPR_ARG (exp,2);
+	op0 = expand_normal (arg0);
+	op1 = expand_normal (arg1);
+	op2 = expand_normal (arg2);
+
+	icode = ((fcode == AVR32_BUILTIN_MACSATHH_W) ? CODE_FOR_macsathh_w :
+		 (fcode == AVR32_BUILTIN_MACWH_D) ? CODE_FOR_macwh_d :
+		 CODE_FOR_machh_d);
+
+	tmode = insn_data[icode].operand[0].mode;
+	mode0 = insn_data[icode].operand[1].mode;
+	mode1 = insn_data[icode].operand[2].mode;
+
+
+	if (!target
+	    || GET_MODE (target) != tmode
+	    || !(*insn_data[icode].operand[0].predicate) (target, tmode))
+	  target = gen_reg_rtx (tmode);
+
+	if (!(*insn_data[icode].operand[0].predicate) (op0, tmode))
+	  {
+	    /* If op0 is already a reg we must cast it to the correct mode. */
+	    if (REG_P (op0))
+	      op0 = convert_to_mode (tmode, op0, 1);
+	    else
+	      op0 = copy_to_mode_reg (tmode, op0);
+	  }
+
+	if (!(*insn_data[icode].operand[1].predicate) (op1, mode0))
+	  {
+	    /* If op1 is already a reg we must cast it to the correct mode. */
+	    if (REG_P (op1))
+	      op1 = convert_to_mode (mode0, op1, 1);
+	    else
+	      op1 = copy_to_mode_reg (mode0, op1);
+	  }
+
+	if (!(*insn_data[icode].operand[2].predicate) (op2, mode1))
+	  {
+	    /* If op1 is already a reg we must cast it to the correct mode. */
+	    if (REG_P (op2))
+	      op2 = convert_to_mode (mode1, op2, 1);
+	    else
+	      op2 = copy_to_mode_reg (mode1, op2);
+	  }
+
+	emit_move_insn (target, op0);
+
+	pat = GEN_FCN (icode) (target, op1, op2);
+	if (!pat)
+	  return 0;
+	emit_insn (pat);
+	return target;
+      }
+    case AVR32_BUILTIN_MVRC_W:
+    case AVR32_BUILTIN_MVRC_D:
+      {
+	arg0 = CALL_EXPR_ARG (exp,0);
+	arg1 = CALL_EXPR_ARG (exp,1);
+	arg2 = CALL_EXPR_ARG (exp,2);
+	op0 = expand_normal (arg0);
+	op1 = expand_normal (arg1);
+	op2 = expand_normal (arg2);
+
+	if (fcode == AVR32_BUILTIN_MVRC_W)
+	  icode = CODE_FOR_mvrcsi;
+	else
+	  icode = CODE_FOR_mvrcdi;
+
+	if (!(*insn_data[icode].operand[0].predicate) (op0, SImode))
+	  {
+	    error ("Parameter 1 is not a valid coprocessor number.");
+	    error ("Number should be between 0 and 7.");
+	    return NULL_RTX;
+	  }
+
+	if (!(*insn_data[icode].operand[1].predicate) (op1, SImode))
+	  {
+	    error ("Parameter 2 is not a valid coprocessor register number.");
+	    error ("Number should be between 0 and 15.");
+	    return NULL_RTX;
+	  }
+
+	if (GET_CODE (op2) == CONST_INT
+	    || GET_CODE (op2) == CONST
+	    || GET_CODE (op2) == SYMBOL_REF || GET_CODE (op2) == LABEL_REF)
+	  {
+	    op2 = force_const_mem (insn_data[icode].operand[2].mode, op2);
+	  }
+
+	if (!(*insn_data[icode].operand[2].predicate) (op2, GET_MODE (op2)))
+	  op2 = copy_to_mode_reg (insn_data[icode].operand[2].mode, op2);
+
+
+	pat = GEN_FCN (icode) (op0, op1, op2);
+	if (!pat)
+	  return 0;
+	emit_insn (pat);
+
+	return NULL_RTX;
+      }
+    case AVR32_BUILTIN_COP:
+      {
+	rtx op3, op4;
+	tree arg3, arg4;
+	icode = CODE_FOR_cop;
+	arg0 = CALL_EXPR_ARG (exp,0);
+	arg1 = CALL_EXPR_ARG (exp,1);
+	arg2 = CALL_EXPR_ARG (exp,2);
+	arg3 = CALL_EXPR_ARG (exp,3);
+	arg4 = CALL_EXPR_ARG (exp,4);
+	op0 = expand_normal (arg0);
+	op1 = expand_normal (arg1);
+	op2 = expand_normal (arg2);
+	op3 = expand_normal (arg3);
+	op4 = expand_normal (arg4);
+
+	if (!(*insn_data[icode].operand[0].predicate) (op0, SImode))
+	  {
+	    error
+	      ("Parameter 1 to __builtin_cop is not a valid coprocessor number.");
+	    error ("Number should be between 0 and 7.");
+	    return NULL_RTX;
+	  }
+
+	if (!(*insn_data[icode].operand[1].predicate) (op1, SImode))
+	  {
+	    error
+	      ("Parameter 2 to __builtin_cop is not a valid coprocessor register number.");
+	    error ("Number should be between 0 and 15.");
+	    return NULL_RTX;
+	  }
+
+	if (!(*insn_data[icode].operand[2].predicate) (op2, SImode))
+	  {
+	    error
+	      ("Parameter 3 to __builtin_cop is not a valid coprocessor register number.");
+	    error ("Number should be between 0 and 15.");
+	    return NULL_RTX;
+	  }
+
+	if (!(*insn_data[icode].operand[3].predicate) (op3, SImode))
+	  {
+	    error
+	      ("Parameter 4 to __builtin_cop is not a valid coprocessor register number.");
+	    error ("Number should be between 0 and 15.");
+	    return NULL_RTX;
+	  }
+
+	if (!(*insn_data[icode].operand[4].predicate) (op4, SImode))
+	  {
+	    error
+	      ("Parameter 5 to __builtin_cop is not a valid coprocessor operation.");
+	    error ("Number should be between 0 and 127.");
+	    return NULL_RTX;
+	  }
+
+	pat = GEN_FCN (icode) (op0, op1, op2, op3, op4);
+	if (!pat)
+	  return 0;
+	emit_insn (pat);
+
+	return target;
+      }
+
+     case AVR32_BUILTIN_MEMS:
+     case AVR32_BUILTIN_MEMC:
+     case AVR32_BUILTIN_MEMT:
+       {
+         if (!TARGET_RMW)
+           error ("Trying to use __builtin_mem(s/c/t) when target does not support RMW insns.");
+         
+         switch (fcode) {
+         case AVR32_BUILTIN_MEMS:
+           icode = CODE_FOR_iorsi3;
+           break;
+         case AVR32_BUILTIN_MEMC:
+           icode = CODE_FOR_andsi3;
+           break;
+         case AVR32_BUILTIN_MEMT:
+           icode = CODE_FOR_xorsi3;
+           break;
+         }
+			arg0 = CALL_EXPR_ARG (exp,0);
+			arg1 = CALL_EXPR_ARG (exp,1);
+         op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);
+         if ( GET_CODE (op0) == SYMBOL_REF )
+           // This symbol must be RMW addressable
+           SYMBOL_REF_FLAGS (op0) |= (1 << SYMBOL_FLAG_RMW_ADDR_SHIFT);
+         op0 = gen_rtx_MEM(SImode, op0);
+         op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);
+         mode0 = insn_data[icode].operand[1].mode;
+         
+         
+         if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))
+           {
+             error ("Parameter 1 to __builtin_mem(s/c/t) must be a Ks15<<2 address or a rmw addressable symbol.");
+           }
+         
+         if ( !CONST_INT_P (op1)
+              || INTVAL (op1) > 31
+              || INTVAL (op1) < 0 )
+           error ("Parameter 2 to __builtin_mem(s/c/t) must be a constant between 0 and 31.");
+ 
+         if ( fcode == AVR32_BUILTIN_MEMC )
+           op1 = GEN_INT((~(1 << INTVAL(op1)))&0xffffffff);
+         else
+           op1 = GEN_INT((1 << INTVAL(op1))&0xffffffff);
+         pat = GEN_FCN (icode) (op0, op0, op1);
+         if (!pat)
+           return 0;
+         emit_insn (pat);
+         return op0;
+       }
+       
+     case AVR32_BUILTIN_SLEEP:
+       {
+ 	arg0 = CALL_EXPR_ARG (exp, 0);
+ 	op0  = expand_normal (arg0);
+ 	int intval = INTVAL(op0);
+ 
+ 	/* Check if the argument if integer and if the value of integer
+ 	   is greater than 0. */ 
+ 	 
+ 	if (!CONSTANT_P (op0))
+         error ("Parameter 1 to __builtin_sleep() is not a valid integer.");
+ 	if (intval < 0 )
+ 	     error ("Parameter 1 to __builtin_sleep() should be an integer greater than 0.");
+ 
+         int strncmpval = strncmp (avr32_part_name,"uc3l", 4);
+  
+ 	/* Check if op0 is less than 7 for uc3l* and less than 6 for other
+ 	   devices. By this check we are avoiding if operand is less than  
+ 	   256. For more devices, add more such checks. */
+ 	 
+ 	if ( strncmpval == 0 && intval >= 7)  
+        error ("Parameter 1 to __builtin_sleep() should be less than or equal to 7.");
+ 	else if ( strncmp != 0 && intval >= 6)
+ 	    error ("Parameter 1 to __builtin_sleep() should be less than or equal to 6.");
+ 
+ 	emit_insn (gen_sleep(op0));
+ 	return target;
+ 
+       }	
+     case AVR32_BUILTIN_DELAY_CYCLES: 
+       {
+       arg0 = CALL_EXPR_ARG (exp, 0);
+       op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);
+ 
+       if (TARGET_ARCH_AP)
+         error (" __builtin_avr32_delay_cycles() not supported for \'%s\' architecture.", avr32_arch_name);
+       if (!CONSTANT_P (op0))
+        error ("Parameter 1 to __builtin_avr32_delay_cycles() should be an integer.");
+       emit_insn (gen_delay_cycles (op0));
+       return 0;
+ 
+       }       
+
+    }
+
+  for (i = 0, d = bdesc_2arg; i < ARRAY_SIZE (bdesc_2arg); i++, d++)
+    if (d->code == fcode)
+      return avr32_expand_binop_builtin (d->icode, exp, target);
+
+
+  /* @@@ Should really do something sensible here.  */
+  return NULL_RTX;
+}
+
+
+/* Handle an "interrupt" or "isr" attribute;
+   arguments as in struct attribute_spec.handler.  */
+static tree
+avr32_handle_isr_attribute (tree * node, tree name, tree args,
+			    int flags, bool * no_add_attrs)
+{
+  if (DECL_P (*node))
+    {
+      if (TREE_CODE (*node) != FUNCTION_DECL)
+	{
+	  warning (OPT_Wattributes,"`%s' attribute only applies to functions",
+		   IDENTIFIER_POINTER (name));
+	  *no_add_attrs = true;
+	}
+      /* FIXME: the argument if any is checked for type attributes; should it
+         be checked for decl ones? */
+    }
+  else
+    {
+      if (TREE_CODE (*node) == FUNCTION_TYPE
+	  || TREE_CODE (*node) == METHOD_TYPE)
+	{
+	  if (avr32_isr_value (args) == AVR32_FT_UNKNOWN)
+	    {
+	      warning (OPT_Wattributes,"`%s' attribute ignored", IDENTIFIER_POINTER (name));
+	      *no_add_attrs = true;
+	    }
+	}
+      else if (TREE_CODE (*node) == POINTER_TYPE
+	       && (TREE_CODE (TREE_TYPE (*node)) == FUNCTION_TYPE
+		   || TREE_CODE (TREE_TYPE (*node)) == METHOD_TYPE)
+	       && avr32_isr_value (args) != AVR32_FT_UNKNOWN)
+	{
+	  *node = build_variant_type_copy (*node);
+	  TREE_TYPE (*node) = build_type_attribute_variant
+	    (TREE_TYPE (*node),
+	     tree_cons (name, args, TYPE_ATTRIBUTES (TREE_TYPE (*node))));
+	  *no_add_attrs = true;
+	}
+      else
+	{
+	  /* Possibly pass this attribute on from the type to a decl.  */
+	  if (flags & ((int) ATTR_FLAG_DECL_NEXT
+		       | (int) ATTR_FLAG_FUNCTION_NEXT
+		       | (int) ATTR_FLAG_ARRAY_NEXT))
+	    {
+	      *no_add_attrs = true;
+	      return tree_cons (name, args, NULL_TREE);
+	    }
+	  else
+	    {
+	      warning (OPT_Wattributes,"`%s' attribute ignored", IDENTIFIER_POINTER (name));
+	    }
+	}
+    }
+
+  return NULL_TREE;
+}
+
+
+/* Handle an attribute requiring a FUNCTION_DECL;
+   arguments as in struct attribute_spec.handler.  */
+static tree
+avr32_handle_fndecl_attribute (tree * node, tree name,
+			       tree args,
+			       int flags ATTRIBUTE_UNUSED,
+			       bool * no_add_attrs)
+{
+  if (TREE_CODE (*node) != FUNCTION_DECL)
+    {
+      warning (OPT_Wattributes,"%qs attribute only applies to functions",
+	       IDENTIFIER_POINTER (name));
+      *no_add_attrs = true;
+      return NULL_TREE;
+    }
+
+  fndecl_attribute_args = args;
+  if (args == NULL_TREE)
+	  return NULL_TREE;
+
+  tree value = TREE_VALUE (args);
+  if (TREE_CODE (value) != INTEGER_CST)
+    {
+      warning (OPT_Wattributes,
+	       "argument of %qs attribute is not an integer constant",
+	       IDENTIFIER_POINTER (name));
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
+
+/* Handle an acall attribute;
+   arguments as in struct attribute_spec.handler.  */
+
+static tree
+avr32_handle_acall_attribute (tree * node, tree name,
+			      tree args ATTRIBUTE_UNUSED,
+			      int flags ATTRIBUTE_UNUSED, bool * no_add_attrs)
+{
+  if (TREE_CODE (*node) == FUNCTION_TYPE || TREE_CODE (*node) == METHOD_TYPE)
+    {
+      warning (OPT_Wattributes,"`%s' attribute not yet supported...",
+	       IDENTIFIER_POINTER (name));
+      *no_add_attrs = true;
+      return NULL_TREE;
+    }
+
+  warning (OPT_Wattributes,"`%s' attribute only applies to functions",
+	   IDENTIFIER_POINTER (name));
+  *no_add_attrs = true;
+  return NULL_TREE;
+}
+
+
+bool
+avr32_flashvault_call(tree decl)
+{
+  tree attributes;
+  tree fv_attribute;
+  tree vector_tree;
+  unsigned int vector;
+
+  if (decl && TREE_CODE (decl) == FUNCTION_DECL) 
+    {
+      attributes = DECL_ATTRIBUTES(decl);
+      fv_attribute = lookup_attribute ("flashvault", attributes);
+      if (fv_attribute != NULL_TREE)
+        {
+          /* Get attribute parameter, for the function vector number. */
+          /* 
+          There is probably an easier, standard way to retrieve the
+          attribute parameter which needs to be done here.
+          */
+          vector_tree = TREE_VALUE(fv_attribute);
+          if (vector_tree != NULL_TREE)
+            {
+              vector = (unsigned int)TREE_INT_CST_LOW(TREE_VALUE(vector_tree));
+              fprintf (asm_out_file,
+                       "\tmov\tr8, lo(%i)\t# Load vector number for sscall.\n",
+                       vector);
+            }
+
+          fprintf (asm_out_file,
+                   "\tsscall\t# Secure system call.\n");
+
+          return true;
+        }
+    }
+  
+  return false;
+}
+
+
+static bool has_attribute_p (tree decl, const char *name)
+{
+  if (decl && TREE_CODE (decl) == FUNCTION_DECL) 
+    {
+      return (lookup_attribute (name, DECL_ATTRIBUTES(decl)) != NULL_TREE);
+    }
+  return NULL_TREE;    
+}
+
+
+/* Return 0 if the attributes for two types are incompatible, 1 if they
+   are compatible, and 2 if they are nearly compatible (which causes a
+   warning to be generated).  */
+static int
+avr32_comp_type_attributes (tree type1, tree type2)
+{
+  bool acall1, acall2, isr1, isr2, naked1, naked2, fv1, fv2, fvimpl1, fvimpl2;
+
+  /* Check for mismatch of non-default calling convention.  */
+  if (TREE_CODE (type1) != FUNCTION_TYPE)
+    return 1;
+
+  /* Check for mismatched call attributes.  */
+  acall1 = lookup_attribute ("acall", TYPE_ATTRIBUTES (type1)) != NULL;
+  acall2 = lookup_attribute ("acall", TYPE_ATTRIBUTES (type2)) != NULL;
+  naked1 = lookup_attribute ("naked", TYPE_ATTRIBUTES (type1)) != NULL;
+  naked2 = lookup_attribute ("naked", TYPE_ATTRIBUTES (type2)) != NULL;
+  fv1 = lookup_attribute ("flashvault", TYPE_ATTRIBUTES (type1)) != NULL;
+  fv2 = lookup_attribute ("flashvault", TYPE_ATTRIBUTES (type2)) != NULL;
+  fvimpl1 = lookup_attribute ("flashvault_impl", TYPE_ATTRIBUTES (type1)) != NULL;
+  fvimpl2 = lookup_attribute ("flashvault_impl", TYPE_ATTRIBUTES (type2)) != NULL;
+  isr1 = lookup_attribute ("isr", TYPE_ATTRIBUTES (type1)) != NULL;
+  if (!isr1)
+    isr1 = lookup_attribute ("interrupt", TYPE_ATTRIBUTES (type1)) != NULL;
+
+  isr2 = lookup_attribute ("isr", TYPE_ATTRIBUTES (type2)) != NULL;
+  if (!isr2)
+    isr2 = lookup_attribute ("interrupt", TYPE_ATTRIBUTES (type2)) != NULL;
+
+  if ((acall1 && isr2)
+      || (acall2 && isr1)
+      || (naked1 && isr2)
+      || (naked2 && isr1)
+      || (fv1 && isr2)
+      || (fv2 && isr1)
+      || (fvimpl1 && isr2)
+      || (fvimpl2 && isr1)
+      || (fv1 && fvimpl2)
+      || (fv2 && fvimpl1)
+      )
+    return 0;
+
+  return 1;
+}
+
+
+/* Computes the type of the current function.  */
+static unsigned long
+avr32_compute_func_type (void)
+{
+  unsigned long type = AVR32_FT_UNKNOWN;
+  tree a;
+  tree attr;
+
+  if (TREE_CODE (current_function_decl) != FUNCTION_DECL)
+    abort ();
+
+  /* Decide if the current function is volatile.  Such functions never
+     return, and many memory cycles can be saved by not storing register
+     values that will never be needed again.  This optimization was added to
+     speed up context switching in a kernel application.  */
+  if (optimize > 0
+      && TREE_NOTHROW (current_function_decl)
+      && TREE_THIS_VOLATILE (current_function_decl))
+    type |= AVR32_FT_VOLATILE;
+
+  if (cfun->static_chain_decl != NULL)
+    type |= AVR32_FT_NESTED;
+
+  attr = DECL_ATTRIBUTES (current_function_decl);
+
+  a = lookup_attribute ("isr", attr);
+  if (a == NULL_TREE)
+    a = lookup_attribute ("interrupt", attr);
+
+  if (a == NULL_TREE)
+    type |= AVR32_FT_NORMAL;
+  else
+    type |= avr32_isr_value (TREE_VALUE (a));
+
+
+  a = lookup_attribute ("acall", attr);
+  if (a != NULL_TREE)
+    type |= AVR32_FT_ACALL;
+
+  a = lookup_attribute ("naked", attr);
+  if (a != NULL_TREE)
+    type |= AVR32_FT_NAKED;
+
+  a = lookup_attribute ("flashvault", attr);
+  if (a != NULL_TREE)
+    type |= AVR32_FT_FLASHVAULT;
+
+  a = lookup_attribute ("flashvault_impl", attr);
+  if (a != NULL_TREE)
+    type |= AVR32_FT_FLASHVAULT_IMPL;
+
+  return type;
+}
+
+
+/* Returns the type of the current function.  */
+static unsigned long
+avr32_current_func_type (void)
+{
+  if (AVR32_FUNC_TYPE (cfun->machine->func_type) == AVR32_FT_UNKNOWN)
+    cfun->machine->func_type = avr32_compute_func_type ();
+
+  return cfun->machine->func_type;
+}
+
+
+/*
+This target hook should return true if we should not pass type solely
+in registers. The file expr.h defines a definition that is usually appropriate,
+refer to expr.h for additional documentation.
+*/
+bool
+avr32_must_pass_in_stack (enum machine_mode mode ATTRIBUTE_UNUSED, tree type)
+{
+  if (type && AGGREGATE_TYPE_P (type)
+      /* If the alignment is less than the size then pass in the struct on
+         the stack. */
+      && ((unsigned int) TYPE_ALIGN_UNIT (type) <
+	  (unsigned int) int_size_in_bytes (type))
+      /* If we support unaligned word accesses then structs of size 4 and 8
+         can have any alignment and still be passed in registers. */
+      && !(TARGET_UNALIGNED_WORD
+	   && (int_size_in_bytes (type) == 4
+	       || int_size_in_bytes (type) == 8))
+      /* Double word structs need only a word alignment. */
+      && !(int_size_in_bytes (type) == 8 && TYPE_ALIGN_UNIT (type) >= 4))
+    return true;
+
+  if (type && AGGREGATE_TYPE_P (type)
+      /* Structs of size 3,5,6,7 are always passed in registers. */
+      && (int_size_in_bytes (type) == 3
+	  || int_size_in_bytes (type) == 5
+	  || int_size_in_bytes (type) == 6 || int_size_in_bytes (type) == 7))
+    return true;
+
+
+  return (type && TREE_ADDRESSABLE (type));
+}
+
+
+bool
+avr32_strict_argument_naming (CUMULATIVE_ARGS * ca ATTRIBUTE_UNUSED)
+{
+  return true;
+}
+
+
+/*
+   This target hook should return true if an argument at the position indicated
+   by cum should be passed by reference. This predicate is queried after target
+   independent reasons for being passed by reference, such as TREE_ADDRESSABLE (type).
+
+   If the hook returns true, a copy of that argument is made in memory and a
+   pointer to the argument is passed instead of the argument itself. The pointer
+   is passed in whatever way is appropriate for passing a pointer to that type.
+*/
+bool
+avr32_pass_by_reference (CUMULATIVE_ARGS * cum ATTRIBUTE_UNUSED,
+			 enum machine_mode mode ATTRIBUTE_UNUSED,
+			 tree type, bool named ATTRIBUTE_UNUSED)
+{
+  return (type && (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST));
+}
+
+
+static int
+avr32_arg_partial_bytes (CUMULATIVE_ARGS * pcum ATTRIBUTE_UNUSED,
+			 enum machine_mode mode ATTRIBUTE_UNUSED,
+			 tree type ATTRIBUTE_UNUSED,
+			 bool named ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+/*
+  Table used to convert from register number in the assembler instructions and
+  the register numbers used in gcc.
+*/
+const int avr32_function_arg_reglist[] = {
+  INTERNAL_REGNUM (12),
+  INTERNAL_REGNUM (11),
+  INTERNAL_REGNUM (10),
+  INTERNAL_REGNUM (9),
+  INTERNAL_REGNUM (8)
+};
+
+
+rtx avr32_compare_op0 = NULL_RTX;
+rtx avr32_compare_op1 = NULL_RTX;
+rtx avr32_compare_operator = NULL_RTX;
+rtx avr32_acc_cache = NULL_RTX;
+/* type of branch to use */
+enum avr32_cmp_type avr32_branch_type;
+
+
+/*
+  Returns nonzero if it is allowed to store a value of mode mode in hard
+  register number regno.
+*/
+int
+avr32_hard_regno_mode_ok (int regnr, enum machine_mode mode)
+{
+  switch (mode)
+    {
+      case DImode:		/* long long */
+      case DFmode:		/* double */
+      case SCmode:		/* __complex__ float */
+      case CSImode:		/* __complex__ int */
+        if (regnr < 4)
+	  {		/* long long int not supported in r12, sp, lr or pc. */
+	    return 0;
+	  }
+        else
+	  {
+	    /* long long int has to be referred in even registers. */
+            if (regnr % 2)
+	      return 0;
+	    else
+	      return 1;
+	  }
+      case CDImode:		/* __complex__ long long */
+      case DCmode:		/* __complex__ double */
+      case TImode:		/* 16 bytes */
+        if (regnr < 7)
+	  return 0;
+        else if (regnr % 2)
+	  return 0;
+        else
+	  return 1;
+      default:
+        return 1;
+    }
+}
+
+
+int
+avr32_rnd_operands (rtx add, rtx shift)
+{
+  if (GET_CODE (shift) == CONST_INT &&
+      GET_CODE (add) == CONST_INT && INTVAL (shift) > 0)
+    {
+      if ((1 << (INTVAL (shift) - 1)) == INTVAL (add))
+	return TRUE;
+    }
+
+  return FALSE;
+}
+
+
+int
+avr32_const_ok_for_constraint_p (HOST_WIDE_INT value, char c, const char *str)
+{
+  switch (c)
+    {
+    case 'K':
+    case 'I':
+      {
+	HOST_WIDE_INT min_value = 0, max_value = 0;
+	char size_str[3];
+	int const_size;
+
+	size_str[0] = str[2];
+	size_str[1] = str[3];
+	size_str[2] = '\0';
+	const_size = atoi (size_str);
+
+	if (TOUPPER (str[1]) == 'U')
+	  {
+	    min_value = 0;
+	    max_value = (1 << const_size) - 1;
+	  }
+	else if (TOUPPER (str[1]) == 'S')
+	  {
+	    min_value = -(1 << (const_size - 1));
+	    max_value = (1 << (const_size - 1)) - 1;
+	  }
+
+	if (c == 'I')
+	  {
+	    value = -value;
+	  }
+
+	if (value >= min_value && value <= max_value)
+	  {
+	    return 1;
+	  }
+	break;
+      }
+    case 'M':
+      return avr32_mask_upper_bits_operand (GEN_INT (value), VOIDmode);
+    case 'J':
+      return avr32_hi16_immediate_operand (GEN_INT (value), VOIDmode);
+    case 'O':
+      return one_bit_set_operand (GEN_INT (value), VOIDmode);
+    case 'N':
+      return one_bit_cleared_operand (GEN_INT (value), VOIDmode);
+    case 'L':
+      /* The lower 16-bits are set. */
+      return ((value & 0xffff) == 0xffff) ;
+    }
+
+  return 0;
+}
+
+
+/* Compute mask of registers which needs saving upon function entry. */
+static unsigned long
+avr32_compute_save_reg_mask (int push)
+{
+  unsigned long func_type;
+  unsigned int save_reg_mask = 0;
+  unsigned int reg;
+
+  func_type = avr32_current_func_type ();
+
+  if (IS_INTERRUPT (func_type))
+    {
+      unsigned int max_reg = 12;
+
+      /* Get the banking scheme for the interrupt */
+      switch (func_type)
+	{
+	case AVR32_FT_ISR_FULL:
+	  max_reg = 0;
+	  break;
+	case AVR32_FT_ISR_HALF:
+	  max_reg = 7;
+	  break;
+	case AVR32_FT_ISR_NONE:
+	  max_reg = 12;
+	  break;
+	}
+
+      /* Interrupt functions must not corrupt any registers, even call
+         clobbered ones.  If this is a leaf function we can just examine the
+         registers used by the RTL, but otherwise we have to assume that
+         whatever function is called might clobber anything, and so we have
+         to save all the call-clobbered registers as well.  */
+
+      /* Need not push the registers r8-r12 for AVR32A architectures, as this
+         is automatially done in hardware. We also do not have any shadow
+         registers. */
+      if (TARGET_UARCH_AVR32A)
+	{
+	  max_reg = 7;
+	  func_type = AVR32_FT_ISR_NONE;
+	}
+
+      /* All registers which are used and are not shadowed must be saved. */
+      for (reg = 0; reg <= max_reg; reg++)
+	if (df_regs_ever_live_p (INTERNAL_REGNUM (reg))
+	    || (!current_function_is_leaf
+		&& call_used_regs[INTERNAL_REGNUM (reg)]))
+	  save_reg_mask |= (1 << reg);
+
+      /* Check LR */
+      if ((df_regs_ever_live_p (LR_REGNUM)
+	   || !current_function_is_leaf || frame_pointer_needed)
+	  /* Only non-shadowed register models */
+	  && (func_type == AVR32_FT_ISR_NONE))
+	save_reg_mask |= (1 << ASM_REGNUM (LR_REGNUM));
+
+      /* Make sure that the GOT register is pushed. */
+      if (max_reg >= ASM_REGNUM (PIC_OFFSET_TABLE_REGNUM)
+	  && crtl->uses_pic_offset_table)
+	save_reg_mask |= (1 << ASM_REGNUM (PIC_OFFSET_TABLE_REGNUM));
+
+    }
+  else
+    {
+      int use_pushm = optimize_size;
+
+      /* In the normal case we only need to save those registers which are
+         call saved and which are used by this function.  */
+      for (reg = 0; reg <= 7; reg++)
+	if (df_regs_ever_live_p (INTERNAL_REGNUM (reg))
+	    && !call_used_regs[INTERNAL_REGNUM (reg)])
+	  save_reg_mask |= (1 << reg);
+
+      /* Make sure that the GOT register is pushed. */
+      if (crtl->uses_pic_offset_table)
+	save_reg_mask |= (1 << ASM_REGNUM (PIC_OFFSET_TABLE_REGNUM));
+
+
+      /* If we optimize for size and do not have anonymous arguments: use
+         pushm/popm always. */
+      if (use_pushm)
+	{
+	  if ((save_reg_mask & (1 << 0))
+	      || (save_reg_mask & (1 << 1))
+	      || (save_reg_mask & (1 << 2)) || (save_reg_mask & (1 << 3)))
+	    save_reg_mask |= 0xf;
+
+	  if ((save_reg_mask & (1 << 4))
+	      || (save_reg_mask & (1 << 5))
+	      || (save_reg_mask & (1 << 6)) || (save_reg_mask & (1 << 7)))
+	    save_reg_mask |= 0xf0;
+
+	  if ((save_reg_mask & (1 << 8)) || (save_reg_mask & (1 << 9)))
+	    save_reg_mask |= 0x300;
+	}
+
+
+        /* Check LR */
+        if ((df_regs_ever_live_p (LR_REGNUM)
+        || !current_function_is_leaf
+        || (optimize_size
+        && save_reg_mask
+        && !crtl->calls_eh_return)
+          || frame_pointer_needed)
+          && !IS_FLASHVAULT (func_type))
+	{
+	  if (push
+	      /* Never pop LR into PC for functions which
+	         calls __builtin_eh_return, since we need to
+	         fix the SP after the restoring of the registers
+	         and before returning. */
+	      || crtl->calls_eh_return)
+	    {
+	      /* Push/Pop LR */
+	      save_reg_mask |= (1 << ASM_REGNUM (LR_REGNUM));
+	    }
+	  else
+	    {
+	      /* Pop PC */
+	      save_reg_mask |= (1 << ASM_REGNUM (PC_REGNUM));
+	    }
+	}
+    }
+
+
+  /* Save registers so the exception handler can modify them.  */
+  if (crtl->calls_eh_return)
+    {
+      unsigned int i;
+
+      for (i = 0;; i++)
+	{
+	  reg = EH_RETURN_DATA_REGNO (i);
+	  if (reg == INVALID_REGNUM)
+	    break;
+	  save_reg_mask |= 1 << ASM_REGNUM (reg);
+	}
+    }
+
+  return save_reg_mask;
+}
+
+
+/* Compute total size in bytes of all saved registers. */
+static int
+avr32_get_reg_mask_size (int reg_mask)
+{
+  int reg, size;
+  size = 0;
+
+  for (reg = 0; reg <= 15; reg++)
+    if (reg_mask & (1 << reg))
+      size += 4;
+
+  return size;
+}
+
+
+/* Get a register from one of the registers which are saved onto the stack
+  upon function entry. */
+static int
+avr32_get_saved_reg (int save_reg_mask)
+{
+  unsigned int reg;
+
+  /* Find the first register which is saved in the saved_reg_mask */
+  for (reg = 0; reg <= 15; reg++)
+    if (save_reg_mask & (1 << reg))
+      return reg;
+
+  return -1;
+}
+
+
+/* Return 1 if it is possible to return using a single instruction. */
+int
+avr32_use_return_insn (int iscond)
+{
+  unsigned int func_type = avr32_current_func_type ();
+  unsigned long saved_int_regs;
+
+  /* Never use a return instruction before reload has run. */
+  if (!reload_completed)
+    return 0;
+
+  /* Must adjust the stack for vararg functions. */
+  if (crtl->args.info.uses_anonymous_args)
+    return 0;
+
+  /* If there a stack adjstment.  */
+  if (get_frame_size ())
+    return 0;
+
+  saved_int_regs = avr32_compute_save_reg_mask (TRUE);
+
+  /* Conditional returns can not be performed in one instruction if we need
+     to restore registers from the stack */
+  if (iscond && saved_int_regs)
+    return 0;
+
+  /* Conditional return can not be used for interrupt handlers. */
+  if (iscond && IS_INTERRUPT (func_type))
+    return 0;
+
+  /* For interrupt handlers which needs to pop registers */
+  if (saved_int_regs && IS_INTERRUPT (func_type))
+    return 0;
+
+
+  /* If there are saved registers but the LR isn't saved, then we need two
+     instructions for the return.  */
+  if (saved_int_regs && !(saved_int_regs & (1 << ASM_REGNUM (LR_REGNUM))))
+    return 0;
+
+
+  return 1;
+}
+
+
+/* Generate some function prologue info in the assembly file. */
+void
+avr32_target_asm_function_prologue (FILE * f, HOST_WIDE_INT frame_size)
+{
+  unsigned long func_type = avr32_current_func_type ();
+
+  if (IS_NAKED (func_type))
+    fprintf (f,
+      "\t# Function is naked: Prologue and epilogue provided by programmer\n");
+
+  if (IS_FLASHVAULT (func_type))
+  {
+    fprintf(f, 
+      "\t.ident \"flashvault\"\n\t# Function is defined with flashvault attribute.\n");
+  }
+
+  if (IS_FLASHVAULT_IMPL (func_type))
+  {
+    fprintf(f, 
+      "\t.ident \"flashvault\"\n\t# Function is defined with flashvault_impl attribute.\n");
+
+    /* Save information on flashvault function declaration. */
+    tree fv_attribute = lookup_attribute ("flashvault_impl", DECL_ATTRIBUTES(current_function_decl));
+    if (fv_attribute != NULL_TREE)
+      {
+        tree vector_tree = TREE_VALUE(fv_attribute);
+        if (vector_tree != NULL_TREE)
+          {
+            unsigned int vector_num;
+            const char * name;
+
+            vector_num = (unsigned int) TREE_INT_CST_LOW (TREE_VALUE (vector_tree));
+
+            name = XSTR  (XEXP (DECL_RTL (current_function_decl), 0), 0);
+
+            flashvault_decl_list_add (vector_num, name);
+          }
+      }
+  }
+
+  if (IS_INTERRUPT (func_type))
+    {
+      switch (func_type)
+        {
+          case AVR32_FT_ISR_FULL:
+            fprintf (f,
+                     "\t# Interrupt Function: Fully shadowed register file\n");
+            break;
+          case AVR32_FT_ISR_HALF:
+            fprintf (f,
+                     "\t# Interrupt Function: Half shadowed register file\n");
+            break;
+          default:
+          case AVR32_FT_ISR_NONE:
+            fprintf (f, "\t# Interrupt Function: No shadowed register file\n");
+            break;
+        }
+    }
+
+
+  fprintf (f, "\t# args = %i, frame = %li, pretend = %i\n",
+           crtl->args.size, frame_size,
+           crtl->args.pretend_args_size);
+
+  fprintf (f, "\t# frame_needed = %i, leaf_function = %i\n",
+           frame_pointer_needed, current_function_is_leaf);
+
+  fprintf (f, "\t# uses_anonymous_args = %i\n",
+           crtl->args.info.uses_anonymous_args);
+
+  if (crtl->calls_eh_return)
+    fprintf (f, "\t# Calls __builtin_eh_return.\n");
+
+}
+
+
+/* Generate and emit an insn that we will recognize as a pushm or stm.
+   Unfortunately, since this insn does not reflect very well the actual
+   semantics of the operation, we need to annotate the insn for the benefit
+   of DWARF2 frame unwind information.  */
+
+int avr32_convert_to_reglist16 (int reglist8_vect);
+
+static rtx
+emit_multi_reg_push (int reglist, int usePUSHM)
+{
+  rtx insn;
+  rtx dwarf;
+  rtx tmp;
+  rtx reg;
+  int i;
+  int nr_regs;
+  int index = 0;
+
+  if (usePUSHM)
+    {
+      insn = emit_insn (gen_pushm (gen_rtx_CONST_INT (SImode, reglist)));
+      reglist = avr32_convert_to_reglist16 (reglist);
+    }
+  else
+    {
+      insn = emit_insn (gen_stm (stack_pointer_rtx,
+				 gen_rtx_CONST_INT (SImode, reglist),
+				 gen_rtx_CONST_INT (SImode, 1)));
+    }
+
+  nr_regs = avr32_get_reg_mask_size (reglist) / 4;
+  dwarf = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (nr_regs + 1));
+
+  for (i = 15; i >= 0; i--)
+    {
+      if (reglist & (1 << i))
+	{
+	  reg = gen_rtx_REG (SImode, INTERNAL_REGNUM (i));
+	  tmp = gen_rtx_SET (VOIDmode,
+			     gen_rtx_MEM (SImode,
+					  plus_constant (stack_pointer_rtx,
+							 4 * index)), reg);
+	  RTX_FRAME_RELATED_P (tmp) = 1;
+	  XVECEXP (dwarf, 0, 1 + index++) = tmp;
+	}
+    }
+
+  tmp = gen_rtx_SET (SImode,
+		     stack_pointer_rtx,
+		     gen_rtx_PLUS (SImode,
+				   stack_pointer_rtx,
+				   GEN_INT (-4 * nr_regs)));
+  RTX_FRAME_RELATED_P (tmp) = 1;
+  XVECEXP (dwarf, 0, 0) = tmp;
+  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,
+					REG_NOTES (insn));
+  return insn;
+}
+
+rtx
+avr32_gen_load_multiple (rtx * regs, int count, rtx from,
+			 int write_back, int in_struct_p, int scalar_p)
+{
+
+  rtx result;
+  int i = 0, j;
+
+  result =
+    gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count + (write_back ? 1 : 0)));
+
+  if (write_back)
+    {
+      XVECEXP (result, 0, 0)
+	= gen_rtx_SET (GET_MODE (from), from,
+		       plus_constant (from, count * 4));
+      i = 1;
+      count++;
+    }
+
+
+  for (j = 0; i < count; i++, j++)
+    {
+      rtx unspec;
+      rtx mem = gen_rtx_MEM (SImode, plus_constant (from, j * 4));
+      MEM_IN_STRUCT_P (mem) = in_struct_p;
+      MEM_SCALAR_P (mem) = scalar_p;
+      unspec = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, mem), UNSPEC_LDM);
+      XVECEXP (result, 0, i) = gen_rtx_SET (VOIDmode, regs[j], unspec);
+    }
+
+  return result;
+}
+
+
+rtx
+avr32_gen_store_multiple (rtx * regs, int count, rtx to,
+			  int in_struct_p, int scalar_p)
+{
+  rtx result;
+  int i = 0, j;
+
+  result = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));
+
+  for (j = 0; i < count; i++, j++)
+    {
+      rtx mem = gen_rtx_MEM (SImode, plus_constant (to, j * 4));
+      MEM_IN_STRUCT_P (mem) = in_struct_p;
+      MEM_SCALAR_P (mem) = scalar_p;
+      XVECEXP (result, 0, i)
+	= gen_rtx_SET (VOIDmode, mem,
+		       gen_rtx_UNSPEC (VOIDmode,
+				       gen_rtvec (1, regs[j]),
+				       UNSPEC_STORE_MULTIPLE));
+    }
+
+  return result;
+}
+
+
+/* Move a block of memory if it is word aligned or we support unaligned
+   word memory accesses. The size must be maximum 64 bytes. */
+int
+avr32_gen_movmemsi (rtx * operands)
+{
+  HOST_WIDE_INT bytes_to_go;
+  rtx src, dst;
+  rtx st_src, st_dst;
+  int src_offset = 0, dst_offset = 0;
+  int block_size;
+  int dst_in_struct_p, src_in_struct_p;
+  int dst_scalar_p, src_scalar_p;
+  int unaligned;
+
+  if (GET_CODE (operands[2]) != CONST_INT
+      || GET_CODE (operands[3]) != CONST_INT
+      || INTVAL (operands[2]) > 64
+      || ((INTVAL (operands[3]) & 3) && !TARGET_UNALIGNED_WORD))
+    return 0;
+
+  unaligned = (INTVAL (operands[3]) & 3) != 0;
+
+  block_size = 4;
+
+  st_dst = XEXP (operands[0], 0);
+  st_src = XEXP (operands[1], 0);
+
+  dst_in_struct_p = MEM_IN_STRUCT_P (operands[0]);
+  dst_scalar_p = MEM_SCALAR_P (operands[0]);
+  src_in_struct_p = MEM_IN_STRUCT_P (operands[1]);
+  src_scalar_p = MEM_SCALAR_P (operands[1]);
+
+  dst = copy_to_mode_reg (SImode, st_dst);
+  src = copy_to_mode_reg (SImode, st_src);
+
+  bytes_to_go = INTVAL (operands[2]);
+
+  while (bytes_to_go)
+    {
+      enum machine_mode move_mode;
+      /* (Seems to be a problem with reloads for the movti pattern so this is
+         disabled until that problem is resolved)
+         UPDATE: Problem seems to be solved now.... */
+      if (bytes_to_go >= GET_MODE_SIZE (TImode) && !unaligned
+	  /* Do not emit ldm/stm for UC3 as ld.d/st.d is more optimal. */
+	  && !TARGET_ARCH_UC)
+	move_mode = TImode;
+      else if ((bytes_to_go >= GET_MODE_SIZE (DImode)) && !unaligned)
+	move_mode = DImode;
+      else if (bytes_to_go >= GET_MODE_SIZE (SImode))
+	move_mode = SImode;
+      else
+	move_mode = QImode;
+
+      {
+        rtx src_mem;
+	rtx dst_mem = gen_rtx_MEM (move_mode,
+				   gen_rtx_PLUS (SImode, dst,
+						 GEN_INT (dst_offset)));
+        dst_offset += GET_MODE_SIZE (move_mode);
+        if ( 0 /* This causes an error in GCC. Think there is
+                  something wrong in the gcse pass which causes REQ_EQUIV notes
+                  to be wrong so disabling it for now. */
+             && move_mode == TImode
+             && INTVAL (operands[2]) > GET_MODE_SIZE (TImode) )
+          {
+            src_mem = gen_rtx_MEM (move_mode,
+				   gen_rtx_POST_INC (SImode, src));
+          }
+        else
+          {
+            src_mem = gen_rtx_MEM (move_mode,
+				   gen_rtx_PLUS (SImode, src,
+						 GEN_INT (src_offset)));
+            src_offset += GET_MODE_SIZE (move_mode);
+          }
+
+	bytes_to_go -= GET_MODE_SIZE (move_mode);
+
+	MEM_IN_STRUCT_P (dst_mem) = dst_in_struct_p;
+	MEM_SCALAR_P (dst_mem) = dst_scalar_p;
+
+	MEM_IN_STRUCT_P (src_mem) = src_in_struct_p;
+	MEM_SCALAR_P (src_mem) = src_scalar_p;
+	emit_move_insn (dst_mem, src_mem);
+
+      }
+    }
+
+  return 1;
+}
+
+
+/* Expand the prologue instruction. */
+void
+avr32_expand_prologue (void)
+{
+  rtx insn, dwarf;
+  unsigned long saved_reg_mask;
+  int reglist8 = 0;
+
+  /* Naked functions do not have a prologue. */
+  if (IS_NAKED (avr32_current_func_type ()))
+    return;
+
+  saved_reg_mask = avr32_compute_save_reg_mask (TRUE);
+
+  if (saved_reg_mask)
+    {
+      /* Must push used registers. */
+
+      /* Should we use POPM or LDM? */
+      int usePUSHM = TRUE;
+      reglist8 = 0;
+      if (((saved_reg_mask & (1 << 0)) ||
+	   (saved_reg_mask & (1 << 1)) ||
+	   (saved_reg_mask & (1 << 2)) || (saved_reg_mask & (1 << 3))))
+	{
+	  /* One of R0-R3 should at least be pushed. */
+	  if (((saved_reg_mask & (1 << 0)) &&
+	       (saved_reg_mask & (1 << 1)) &&
+	       (saved_reg_mask & (1 << 2)) && (saved_reg_mask & (1 << 3))))
+	    {
+	      /* All should be pushed. */
+	      reglist8 |= 0x01;
+	    }
+	  else
+	    {
+	      usePUSHM = FALSE;
+	    }
+	}
+
+      if (((saved_reg_mask & (1 << 4)) ||
+	   (saved_reg_mask & (1 << 5)) ||
+	   (saved_reg_mask & (1 << 6)) || (saved_reg_mask & (1 << 7))))
+	{
+	  /* One of R4-R7 should at least be pushed */
+	  if (((saved_reg_mask & (1 << 4)) &&
+	       (saved_reg_mask & (1 << 5)) &&
+	       (saved_reg_mask & (1 << 6)) && (saved_reg_mask & (1 << 7))))
+	    {
+	      if (usePUSHM)
+		/* All should be pushed */
+		reglist8 |= 0x02;
+	    }
+	  else
+	    {
+	      usePUSHM = FALSE;
+	    }
+	}
+
+      if (((saved_reg_mask & (1 << 8)) || (saved_reg_mask & (1 << 9))))
+	{
+	  /* One of R8-R9 should at least be pushed. */
+	  if (((saved_reg_mask & (1 << 8)) && (saved_reg_mask & (1 << 9))))
+	    {
+	      if (usePUSHM)
+		/* All should be pushed. */
+		reglist8 |= 0x04;
+	    }
+	  else
+	    {
+	      usePUSHM = FALSE;
+	    }
+	}
+
+      if (saved_reg_mask & (1 << 10))
+	reglist8 |= 0x08;
+
+      if (saved_reg_mask & (1 << 11))
+	reglist8 |= 0x10;
+
+      if (saved_reg_mask & (1 << 12))
+	reglist8 |= 0x20;
+
+      if ((saved_reg_mask & (1 << ASM_REGNUM (LR_REGNUM)))
+           && !IS_FLASHVAULT (avr32_current_func_type ()))
+	{
+	  /* Push LR */
+	  reglist8 |= 0x40;
+	}
+
+      if (usePUSHM)
+	{
+	  insn = emit_multi_reg_push (reglist8, TRUE);
+	}
+      else
+	{
+	  insn = emit_multi_reg_push (saved_reg_mask, FALSE);
+	}
+      RTX_FRAME_RELATED_P (insn) = 1;
+
+      /* Prevent this instruction from being scheduled after any other
+         instructions.  */
+      emit_insn (gen_blockage ());
+    }
+
+  /* Set frame pointer */
+  if (frame_pointer_needed)
+    {
+      insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);
+      RTX_FRAME_RELATED_P (insn) = 1;
+    }
+
+  if (get_frame_size () > 0)
+    {
+      if (avr32_const_ok_for_constraint_p (get_frame_size (), 'K', "Ks21"))
+	{
+	  insn = emit_insn (gen_rtx_SET (SImode,
+					 stack_pointer_rtx,
+					 gen_rtx_PLUS (SImode,
+						       stack_pointer_rtx,
+						       gen_rtx_CONST_INT
+						       (SImode,
+							-get_frame_size
+							()))));
+	  RTX_FRAME_RELATED_P (insn) = 1;
+	}
+      else
+	{
+	  /* Immediate is larger than k21 We must either check if we can use
+	     one of the pushed reegisters as temporary storage or we must
+	     make us a temp register by pushing a register to the stack. */
+	  rtx temp_reg, const_pool_entry, insn;
+	  if (saved_reg_mask)
+	    {
+	      temp_reg =
+		gen_rtx_REG (SImode,
+			     INTERNAL_REGNUM (avr32_get_saved_reg
+					      (saved_reg_mask)));
+	    }
+	  else
+	    {
+	      temp_reg = gen_rtx_REG (SImode, INTERNAL_REGNUM (7));
+	      emit_move_insn (gen_rtx_MEM
+			      (SImode,
+			       gen_rtx_PRE_DEC (SImode, stack_pointer_rtx)),
+			      temp_reg);
+	    }
+
+	  const_pool_entry =
+	    force_const_mem (SImode,
+			     gen_rtx_CONST_INT (SImode, get_frame_size ()));
+	  emit_move_insn (temp_reg, const_pool_entry);
+
+	  insn = emit_insn (gen_rtx_SET (SImode,
+					 stack_pointer_rtx,
+					 gen_rtx_MINUS (SImode,
+							stack_pointer_rtx,
+							temp_reg)));
+
+	  dwarf = gen_rtx_SET (VOIDmode, stack_pointer_rtx,
+			       gen_rtx_PLUS (SImode, stack_pointer_rtx,
+					     GEN_INT (-get_frame_size ())));
+	  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,
+						dwarf, REG_NOTES (insn));
+	  RTX_FRAME_RELATED_P (insn) = 1;
+
+	  if (!saved_reg_mask)
+	    {
+	      insn =
+		emit_move_insn (temp_reg,
+				gen_rtx_MEM (SImode,
+					     gen_rtx_POST_INC (SImode,
+							       gen_rtx_REG
+							       (SImode,
+								13))));
+	    }
+
+	  /* Mark the temp register as dead */
+	  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD, temp_reg,
+						REG_NOTES (insn));
+
+
+	}
+
+      /* Prevent the the stack adjustment to be scheduled after any
+         instructions using the frame pointer.  */
+      emit_insn (gen_blockage ());
+    }
+
+  /* Load GOT */
+  if (flag_pic)
+    {
+      avr32_load_pic_register ();
+
+      /* gcc does not know that load or call instructions might use the pic
+         register so it might schedule these instructions before the loading
+         of the pic register. To avoid this emit a barrier for now. TODO!
+         Find out a better way to let gcc know which instructions might use
+         the pic register. */
+      emit_insn (gen_blockage ());
+    }
+  return;
+}
+
+
+void
+avr32_set_return_address (rtx source, rtx scratch)
+{
+  rtx addr;
+  unsigned long saved_regs;
+
+  saved_regs = avr32_compute_save_reg_mask (TRUE);
+
+  if (!(saved_regs & (1 << ASM_REGNUM (LR_REGNUM))))
+    emit_move_insn (gen_rtx_REG (Pmode, LR_REGNUM), source);
+  else
+    {
+      if (frame_pointer_needed)
+	addr = gen_rtx_REG (Pmode, FRAME_POINTER_REGNUM);
+      else
+	if (avr32_const_ok_for_constraint_p (get_frame_size (), 'K', "Ks16"))
+	{
+	  addr = plus_constant (stack_pointer_rtx, get_frame_size ());
+	}
+      else
+	{
+	  emit_insn (gen_movsi (scratch, GEN_INT (get_frame_size ())));
+	  addr = scratch;
+	}
+      emit_move_insn (gen_rtx_MEM (Pmode, addr), source);
+    }
+}
+
+
+/* Return the length of INSN.  LENGTH is the initial length computed by
+   attributes in the machine-description file.  */
+int
+avr32_adjust_insn_length (rtx insn ATTRIBUTE_UNUSED,
+			  int length ATTRIBUTE_UNUSED)
+{
+  return length;
+}
+
+
+void
+avr32_output_return_instruction (int single_ret_inst ATTRIBUTE_UNUSED,
+				 int iscond ATTRIBUTE_UNUSED,
+				 rtx cond ATTRIBUTE_UNUSED, rtx r12_imm)
+{
+
+  unsigned long saved_reg_mask;
+  int insert_ret = TRUE;
+  int reglist8 = 0;
+  int stack_adjustment = get_frame_size ();
+  unsigned int func_type = avr32_current_func_type ();
+  FILE *f = asm_out_file;
+
+  /* Naked functions does not have an epilogue */
+  if (IS_NAKED (func_type))
+    return;
+
+  saved_reg_mask = avr32_compute_save_reg_mask (FALSE);
+
+  /* Reset frame pointer */
+  if (stack_adjustment > 0)
+    {
+      if (avr32_const_ok_for_constraint_p (stack_adjustment, 'I', "Is21"))
+	{
+	  fprintf (f, "\tsub\tsp, %i # Reset Frame Pointer\n",
+		   -stack_adjustment);
+	}
+      else
+	{
+	  /* TODO! Is it safe to use r8 as scratch?? */
+	  fprintf (f, "\tmov\tr8, lo(%i) # Reset Frame Pointer\n",
+		   -stack_adjustment);
+	  fprintf (f, "\torh\tr8, hi(%i) # Reset Frame Pointer\n",
+		   -stack_adjustment);
+	  fprintf (f, "\tadd\tsp, r8  # Reset Frame Pointer\n");
+	}
+    }
+
+  if (saved_reg_mask)
+    {
+      /* Must pop used registers */
+
+      /* Should we use POPM or LDM? */
+      int usePOPM = TRUE;
+      if (((saved_reg_mask & (1 << 0)) ||
+	   (saved_reg_mask & (1 << 1)) ||
+	   (saved_reg_mask & (1 << 2)) || (saved_reg_mask & (1 << 3))))
+	{
+	  /* One of R0-R3 should at least be popped */
+	  if (((saved_reg_mask & (1 << 0)) &&
+	       (saved_reg_mask & (1 << 1)) &&
+	       (saved_reg_mask & (1 << 2)) && (saved_reg_mask & (1 << 3))))
+	    {
+	      /* All should be popped */
+	      reglist8 |= 0x01;
+	    }
+	  else
+	    {
+	      usePOPM = FALSE;
+	    }
+	}
+
+      if (((saved_reg_mask & (1 << 4)) ||
+	   (saved_reg_mask & (1 << 5)) ||
+	   (saved_reg_mask & (1 << 6)) || (saved_reg_mask & (1 << 7))))
+	{
+	  /* One of R0-R3 should at least be popped */
+	  if (((saved_reg_mask & (1 << 4)) &&
+	       (saved_reg_mask & (1 << 5)) &&
+	       (saved_reg_mask & (1 << 6)) && (saved_reg_mask & (1 << 7))))
+	    {
+	      if (usePOPM)
+		/* All should be popped */
+		reglist8 |= 0x02;
+	    }
+	  else
+	    {
+	      usePOPM = FALSE;
+	    }
+	}
+
+      if (((saved_reg_mask & (1 << 8)) || (saved_reg_mask & (1 << 9))))
+	{
+	  /* One of R8-R9 should at least be pushed */
+	  if (((saved_reg_mask & (1 << 8)) && (saved_reg_mask & (1 << 9))))
+	    {
+	      if (usePOPM)
+		/* All should be pushed */
+		reglist8 |= 0x04;
+	    }
+	  else
+	    {
+	      usePOPM = FALSE;
+	    }
+	}
+
+      if (saved_reg_mask & (1 << 10))
+	reglist8 |= 0x08;
+
+      if (saved_reg_mask & (1 << 11))
+	reglist8 |= 0x10;
+
+      if (saved_reg_mask & (1 << 12))
+	reglist8 |= 0x20;
+
+      if (saved_reg_mask & (1 << ASM_REGNUM (LR_REGNUM)))
+	/* Pop LR */
+	reglist8 |= 0x40;
+
+      if ((saved_reg_mask & (1 << ASM_REGNUM (PC_REGNUM))) 
+           && !IS_FLASHVAULT_IMPL (func_type))
+	/* Pop LR into PC. */
+	reglist8 |= 0x80;
+
+      if (usePOPM)
+	{
+	  char reglist[64];	/* 64 bytes should be enough... */
+	  avr32_make_reglist8 (reglist8, (char *) reglist);
+
+	  if (reglist8 & 0x80)
+	    /* This instruction is also a return */
+	    insert_ret = FALSE;
+
+	  if (r12_imm && !insert_ret)
+	    fprintf (f, "\tpopm\t%s, r12=%li\n", reglist, INTVAL (r12_imm));
+	  else
+	    fprintf (f, "\tpopm\t%s\n", reglist);
+
+	}
+      else
+	{
+	  char reglist[64];	/* 64 bytes should be enough... */
+	  avr32_make_reglist16 (saved_reg_mask, (char *) reglist);
+	  if (saved_reg_mask & (1 << ASM_REGNUM (PC_REGNUM)))
+	    /* This instruction is also a return */
+	    insert_ret = FALSE;
+
+	  if (r12_imm && !insert_ret)
+	    fprintf (f, "\tldm\tsp++, %s, r12=%li\n", reglist,
+		     INTVAL (r12_imm));
+	  else
+	    fprintf (f, "\tldm\tsp++, %s\n", reglist);
+
+	}
+
+    }
+
+  /* Stack adjustment for exception handler.  */
+  if (crtl->calls_eh_return)
+    fprintf (f, "\tadd\tsp, r%d\n", ASM_REGNUM (EH_RETURN_STACKADJ_REGNO));
+
+
+  if (IS_INTERRUPT (func_type))
+    {
+      fprintf (f, "\trete\n");
+    }
+  else if (IS_FLASHVAULT (func_type))
+    {
+      /* Normal return from Secure System call, increment SS_RAR before
+      returning. Use R8 as scratch. */
+      fprintf (f,
+               "\t# Normal return from sscall.\n"
+               "\t# Increment SS_RAR before returning.\n"
+               "\t# Use R8 as scratch.\n"
+               "\tmfsr\tr8,  440\n"
+               "\tsub\tr8,  -2\n"
+               "\tmtsr\t440, r8\n"
+               "\tretss\n");
+    }
+  else if (insert_ret)
+    {
+      if (r12_imm)
+	fprintf (f, "\tretal\t%li\n", INTVAL (r12_imm));
+      else
+	fprintf (f, "\tretal\tr12\n");
+    }
+}
+
+void
+avr32_make_reglist16 (int reglist16_vect, char *reglist16_string)
+{
+  int i;
+  bool first_reg = true;
+  /* Make sure reglist16_string is empty. */
+  reglist16_string[0] = '\0';
+
+  for (i = 0; i < 16; ++i)
+    {
+      if (reglist16_vect & (1 << i))
+	{
+          first_reg == true ?  first_reg = false : strcat(reglist16_string,", ");
+	  strcat (reglist16_string, reg_names[INTERNAL_REGNUM (i)]);
+	}
+    }
+}
+
+int
+avr32_convert_to_reglist16 (int reglist8_vect)
+{
+  int reglist16_vect = 0;
+  if (reglist8_vect & 0x1)
+    reglist16_vect |= 0xF;
+  if (reglist8_vect & 0x2)
+    reglist16_vect |= 0xF0;
+  if (reglist8_vect & 0x4)
+    reglist16_vect |= 0x300;
+  if (reglist8_vect & 0x8)
+    reglist16_vect |= 0x400;
+  if (reglist8_vect & 0x10)
+    reglist16_vect |= 0x800;
+  if (reglist8_vect & 0x20)
+    reglist16_vect |= 0x1000;
+  if (reglist8_vect & 0x40)
+    reglist16_vect |= 0x4000;
+  if (reglist8_vect & 0x80)
+    reglist16_vect |= 0x8000;
+
+  return reglist16_vect;
+}
+
+void
+avr32_make_reglist8 (int reglist8_vect, char *reglist8_string)
+{
+  /* Make sure reglist8_string is empty. */
+  reglist8_string[0] = '\0';
+
+  if (reglist8_vect & 0x1)
+    strcpy (reglist8_string, "r0-r3");
+  if (reglist8_vect & 0x2)
+    strlen (reglist8_string) ? strcat (reglist8_string, ", r4-r7") :
+      strcpy (reglist8_string, "r4-r7");
+  if (reglist8_vect & 0x4)
+    strlen (reglist8_string) ? strcat (reglist8_string, ", r8-r9") :
+      strcpy (reglist8_string, "r8-r9");
+  if (reglist8_vect & 0x8)
+    strlen (reglist8_string) ? strcat (reglist8_string, ", r10") :
+      strcpy (reglist8_string, "r10");
+  if (reglist8_vect & 0x10)
+    strlen (reglist8_string) ? strcat (reglist8_string, ", r11") :
+      strcpy (reglist8_string, "r11");
+  if (reglist8_vect & 0x20)
+    strlen (reglist8_string) ? strcat (reglist8_string, ", r12") :
+      strcpy (reglist8_string, "r12");
+  if (reglist8_vect & 0x40)
+    strlen (reglist8_string) ? strcat (reglist8_string, ", lr") :
+      strcpy (reglist8_string, "lr");
+  if (reglist8_vect & 0x80)
+    strlen (reglist8_string) ? strcat (reglist8_string, ", pc") :
+      strcpy (reglist8_string, "pc");
+}
+
+
+int
+avr32_eh_return_data_regno (int n)
+{
+  if (n >= 0 && n <= 3)
+    return 8 + n;
+  else
+    return INVALID_REGNUM;
+}
+
+
+/* Compute the distance from register FROM to register TO.
+   These can be the arg pointer, the frame pointer or
+   the stack pointer.
+   Typical stack layout looks like this:
+
+       old stack pointer -> |    |
+			     ----
+			    |    | \
+			    |    |   saved arguments for
+			    |    |   vararg functions
+ arg_pointer	->	    |    | /
+			      --
+			    |    | \
+			    |    |   call saved
+			    |    |   registers
+			    |    | /
+  frame ptr	 ->	--
+			    |    | \
+			    |    |   local
+			    |    |   variables
+  stack ptr -->	     |    | /
+			      --
+			    |    | \
+			    |    |   outgoing
+			    |    |   arguments
+			    |    | /
+			      --
+
+  For a given funciton some or all of these stack compomnents
+  may not be needed, giving rise to the possibility of
+  eliminating some of the registers.
+
+  The values returned by this function must reflect the behaviour
+  of avr32_expand_prologue() and avr32_compute_save_reg_mask().
+
+  The sign of the number returned reflects the direction of stack
+  growth, so the values are positive for all eliminations except
+  from the soft frame pointer to the hard frame pointer.  */
+int
+avr32_initial_elimination_offset (int from, int to)
+{
+  int i;
+  int call_saved_regs = 0;
+  unsigned long saved_reg_mask;
+  unsigned int local_vars = get_frame_size ();
+
+  saved_reg_mask = avr32_compute_save_reg_mask (TRUE);
+
+  for (i = 0; i < 16; ++i)
+    {
+      if (saved_reg_mask & (1 << i))
+	call_saved_regs += 4;
+    }
+
+  switch (from)
+    {
+    case ARG_POINTER_REGNUM:
+      switch (to)
+	{
+	case STACK_POINTER_REGNUM:
+	  return call_saved_regs + local_vars;
+	case FRAME_POINTER_REGNUM:
+	  return call_saved_regs;
+	default:
+	  abort ();
+	}
+    case FRAME_POINTER_REGNUM:
+      switch (to)
+	{
+	case STACK_POINTER_REGNUM:
+	  return local_vars;
+	default:
+	  abort ();
+	}
+    default:
+      abort ();
+    }
+}
+
+
+/*
+  Returns a rtx used when passing the next argument to a function.
+  avr32_init_cumulative_args() and avr32_function_arg_advance() sets which
+  register to use.
+*/
+rtx
+avr32_function_arg (CUMULATIVE_ARGS * cum, enum machine_mode mode,
+		    tree type, int named)
+{
+  int index = -1;
+  //unsigned long func_type = avr32_current_func_type ();
+  //int last_reg_index = (IS_FLASHVAULT(func_type) || IS_FLASHVAULT_IMPL(func_type) || cum->flashvault_func ? LAST_CUM_REG_INDEX - 1 : LAST_CUM_REG_INDEX);
+  int last_reg_index = (cum->flashvault_func ? LAST_CUM_REG_INDEX - 1 : LAST_CUM_REG_INDEX);
+
+  HOST_WIDE_INT arg_size, arg_rsize;
+  if (type)
+    {
+      arg_size = int_size_in_bytes (type);
+    }
+  else
+    {
+      arg_size = GET_MODE_SIZE (mode);
+    }
+  arg_rsize = PUSH_ROUNDING (arg_size);
+
+  /*
+     The last time this macro is called, it is called with mode == VOIDmode,
+     and its result is passed to the call or call_value pattern as operands 2
+     and 3 respectively. */
+  if (mode == VOIDmode)
+    {
+      return gen_rtx_CONST_INT (SImode, 22);	/* ToDo: fixme. */
+    }
+
+  if ((*targetm.calls.must_pass_in_stack) (mode, type) || !named)
+    {
+      return NULL_RTX;
+    }
+
+  if (arg_rsize == 8)
+    {
+      /* use r11:r10 or r9:r8. */
+      if (!(GET_USED_INDEX (cum, 1) || GET_USED_INDEX (cum, 2)))
+	index = 1;
+      else if ((last_reg_index == 4) && 
+               !(GET_USED_INDEX (cum, 3) || GET_USED_INDEX (cum, 4)))
+	index = 3;
+      else
+	index = -1;
+    }
+  else if (arg_rsize == 4)
+    {				/* Use first available register */
+      index = 0;
+      while (index <= last_reg_index && GET_USED_INDEX (cum, index))
+	index++;
+      if (index > last_reg_index)
+	index = -1;
+    }
+
+  SET_REG_INDEX (cum, index);
+
+  if (GET_REG_INDEX (cum) >= 0)
+    return gen_rtx_REG (mode, avr32_function_arg_reglist[GET_REG_INDEX (cum)]);
+
+  return NULL_RTX;
+}
+
+
+/* Set the register used for passing the first argument to a function. */
+void
+avr32_init_cumulative_args (CUMULATIVE_ARGS * cum,
+                            tree fntype ATTRIBUTE_UNUSED,
+                            rtx libname ATTRIBUTE_UNUSED,
+                            tree fndecl)
+{
+  /* Set all registers as unused. */
+  SET_INDEXES_UNUSED (cum);
+
+  /* Reset uses_anonymous_args */
+  cum->uses_anonymous_args = 0;
+
+  /* Reset size of stack pushed arguments */
+  cum->stack_pushed_args_size = 0;
+  
+  cum->flashvault_func = (fndecl && (has_attribute_p (fndecl,"flashvault") || has_attribute_p (fndecl,"flashvault_impl")));
+}
+
+
+/*
+  Set register used for passing the next argument to a function. Only the
+  Scratch Registers are used.
+
+		number  name
+		   15   r15  PC
+		   14   r14  LR
+		   13   r13 _SP_________
+     FIRST_CUM_REG 12   r12 _||_
+		   10   r11  ||
+		   11   r10 _||_  Scratch Registers
+		    8   r9   ||
+  LAST_SCRATCH_REG  9   r8  _\/_________
+		    6   r7   /\
+		    7   r6   ||
+		    4   r5   ||
+		    5   r4   ||
+		    2   r3   ||
+		    3   r2   ||
+		    0   r1   ||
+		    1   r0  _||_________
+
+*/
+void
+avr32_function_arg_advance (CUMULATIVE_ARGS * cum, enum machine_mode mode,
+			    tree type, int named ATTRIBUTE_UNUSED)
+{
+  HOST_WIDE_INT arg_size, arg_rsize;
+
+  if (type)
+    {
+      arg_size = int_size_in_bytes (type);
+    }
+  else
+    {
+      arg_size = GET_MODE_SIZE (mode);
+    }
+  arg_rsize = PUSH_ROUNDING (arg_size);
+
+  /* If the argument had to be passed in stack, no register is used. */
+  if ((*targetm.calls.must_pass_in_stack) (mode, type))
+    {
+      cum->stack_pushed_args_size += PUSH_ROUNDING (int_size_in_bytes (type));
+      return;
+    }
+
+  /* Mark the used registers as "used". */
+  if (GET_REG_INDEX (cum) >= 0)
+    {
+      SET_USED_INDEX (cum, GET_REG_INDEX (cum));
+      if (arg_rsize == 8)
+	{
+	  SET_USED_INDEX (cum, (GET_REG_INDEX (cum) + 1));
+	}
+    }
+  else
+    {
+      /* Had to use stack */
+      cum->stack_pushed_args_size += arg_rsize;
+    }
+}
+
+
+/*
+  Defines witch direction to go to find the next register to use if the
+  argument is larger then one register or for arguments shorter than an
+  int which is not promoted, such as the last part of structures with
+  size not a multiple of 4. */
+enum direction
+avr32_function_arg_padding (enum machine_mode mode ATTRIBUTE_UNUSED,
+			    tree type)
+{
+  /* Pad upward for all aggregates except byte and halfword sized aggregates
+     which can be passed in registers. */
+  if (type
+      && AGGREGATE_TYPE_P (type)
+      && (int_size_in_bytes (type) != 1)
+      && !((int_size_in_bytes (type) == 2)
+	   && TYPE_ALIGN_UNIT (type) >= 2)
+      && (int_size_in_bytes (type) & 0x3))
+    {
+      return upward;
+    }
+
+  return downward;
+}
+
+
+/* Return a rtx used for the return value from a function call. */
+rtx
+avr32_function_value (tree type, tree func, bool outgoing ATTRIBUTE_UNUSED)
+{
+  if (avr32_return_in_memory (type, func))
+    return NULL_RTX;
+
+  if (int_size_in_bytes (type) <= 4)
+    {
+      enum machine_mode mode = TYPE_MODE (type);
+      int unsignedp = 0;
+      PROMOTE_FUNCTION_MODE (mode, unsignedp, type);
+      return gen_rtx_REG (mode, RET_REGISTER);
+    }
+  else if (int_size_in_bytes (type) <= 8)
+    return gen_rtx_REG (TYPE_MODE (type), INTERNAL_REGNUM (11));
+
+  return NULL_RTX;
+}
+
+
+/* Return a rtx used for the return value from a library function call. */
+rtx
+avr32_libcall_value (enum machine_mode mode)
+{
+
+  if (GET_MODE_SIZE (mode) <= 4)
+    return gen_rtx_REG (mode, RET_REGISTER);
+  else if (GET_MODE_SIZE (mode) <= 8)
+    return gen_rtx_REG (mode, INTERNAL_REGNUM (11));
+  else
+    return NULL_RTX;
+}
+
+
+/* Return TRUE if X references a SYMBOL_REF.  */
+int
+symbol_mentioned_p (rtx x)
+{
+  const char *fmt;
+  int i;
+
+  if (GET_CODE (x) == SYMBOL_REF)
+    return 1;
+
+  fmt = GET_RTX_FORMAT (GET_CODE (x));
+
+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)
+    {
+      if (fmt[i] == 'E')
+	{
+	  int j;
+
+	  for (j = XVECLEN (x, i) - 1; j >= 0; j--)
+	    if (symbol_mentioned_p (XVECEXP (x, i, j)))
+	      return 1;
+	}
+      else if (fmt[i] == 'e' && symbol_mentioned_p (XEXP (x, i)))
+	return 1;
+    }
+
+  return 0;
+}
+
+
+/* Return TRUE if X references a LABEL_REF.  */
+int
+label_mentioned_p (rtx x)
+{
+  const char *fmt;
+  int i;
+
+  if (GET_CODE (x) == LABEL_REF)
+    return 1;
+
+  fmt = GET_RTX_FORMAT (GET_CODE (x));
+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)
+    {
+      if (fmt[i] == 'E')
+	{
+	  int j;
+
+	  for (j = XVECLEN (x, i) - 1; j >= 0; j--)
+	    if (label_mentioned_p (XVECEXP (x, i, j)))
+	      return 1;
+	}
+      else if (fmt[i] == 'e' && label_mentioned_p (XEXP (x, i)))
+	return 1;
+    }
+
+  return 0;
+}
+
+
+/* Return TRUE if X contains a MEM expression.  */
+int
+mem_mentioned_p (rtx x)
+{
+  const char *fmt;
+  int i;
+
+  if (MEM_P (x))
+    return 1;
+
+  fmt = GET_RTX_FORMAT (GET_CODE (x));
+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)
+    {
+      if (fmt[i] == 'E')
+	{
+	  int j;
+
+	  for (j = XVECLEN (x, i) - 1; j >= 0; j--)
+	    if (mem_mentioned_p (XVECEXP (x, i, j)))
+	      return 1;
+	}
+      else if (fmt[i] == 'e' && mem_mentioned_p (XEXP (x, i)))
+	return 1;
+    }
+
+  return 0;
+}
+
+
+int
+avr32_legitimate_pic_operand_p (rtx x)
+{
+
+  /* We can't have const, this must be broken down to a symbol. */
+  if (GET_CODE (x) == CONST)
+    return FALSE;
+
+  /* Can't access symbols or labels via the constant pool either */
+  if ((GET_CODE (x) == SYMBOL_REF
+       && CONSTANT_POOL_ADDRESS_P (x)
+       && (symbol_mentioned_p (get_pool_constant (x))
+	   || label_mentioned_p (get_pool_constant (x)))))
+    return FALSE;
+
+  return TRUE;
+}
+
+
+rtx
+legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,
+			rtx reg)
+{
+
+  if (GET_CODE (orig) == SYMBOL_REF || GET_CODE (orig) == LABEL_REF)
+    {
+      int subregs = 0;
+
+      if (reg == 0)
+	{
+	  if (!can_create_pseudo_p ())
+	    abort ();
+	  else
+	    reg = gen_reg_rtx (Pmode);
+
+	  subregs = 1;
+	}
+
+      emit_move_insn (reg, orig);
+
+      /* Only set current function as using pic offset table if flag_pic is
+         set. This is because this function is also used if
+         TARGET_HAS_ASM_ADDR_PSEUDOS is set. */
+      if (flag_pic)
+	crtl->uses_pic_offset_table = 1;
+
+      /* Put a REG_EQUAL note on this insn, so that it can be optimized by
+         loop.  */
+      return reg;
+    }
+  else if (GET_CODE (orig) == CONST)
+    {
+      rtx base, offset;
+
+      if (flag_pic
+	  && GET_CODE (XEXP (orig, 0)) == PLUS
+	  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)
+	return orig;
+
+      if (reg == 0)
+	{
+	  if (!can_create_pseudo_p ())
+	    abort ();
+	  else
+	    reg = gen_reg_rtx (Pmode);
+	}
+
+      if (GET_CODE (XEXP (orig, 0)) == PLUS)
+	{
+	  base =
+	    legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);
+	  offset =
+	    legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,
+				    base == reg ? 0 : reg);
+	}
+      else
+	abort ();
+
+      if (GET_CODE (offset) == CONST_INT)
+	{
+	  /* The base register doesn't really matter, we only want to test
+	     the index for the appropriate mode.  */
+	  if (!avr32_const_ok_for_constraint_p (INTVAL (offset), 'I', "Is21"))
+	    {
+	      if (can_create_pseudo_p ())
+		offset = force_reg (Pmode, offset);
+	      else
+		abort ();
+	    }
+
+	  if (GET_CODE (offset) == CONST_INT)
+	    return plus_constant (base, INTVAL (offset));
+	}
+
+      return gen_rtx_PLUS (Pmode, base, offset);
+    }
+
+  return orig;
+}
+
+
+/* Generate code to load the PIC register.  */
+void
+avr32_load_pic_register (void)
+{
+  rtx l1, pic_tmp;
+  rtx global_offset_table;
+
+  if ((crtl->uses_pic_offset_table == 0) || TARGET_NO_INIT_GOT)
+    return;
+
+  if (!flag_pic)
+    abort ();
+
+  l1 = gen_label_rtx ();
+
+  global_offset_table = gen_rtx_SYMBOL_REF (Pmode, "_GLOBAL_OFFSET_TABLE_");
+  pic_tmp =
+    gen_rtx_CONST (Pmode,
+		   gen_rtx_MINUS (SImode, gen_rtx_LABEL_REF (Pmode, l1),
+				  global_offset_table));
+  emit_insn (gen_pic_load_addr
+	     (pic_offset_table_rtx, force_const_mem (SImode, pic_tmp)));
+  emit_insn (gen_pic_compute_got_from_pc (pic_offset_table_rtx, l1));
+
+  /* Need to emit this whether or not we obey regdecls, since setjmp/longjmp
+     can cause life info to screw up.  */
+  emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));
+}
+
+
+/* This hook should return true if values of type type are returned at the most
+   significant end of a register (in other words, if they are padded at the
+   least significant end). You can assume that type is returned in a register;
+   the caller is required to check this.  Note that the register provided by
+   FUNCTION_VALUE must be able to hold the complete return value. For example,
+   if a 1-, 2- or 3-byte structure is returned at the most significant end of a
+   4-byte register, FUNCTION_VALUE should provide an SImode rtx. */
+bool
+avr32_return_in_msb (tree type ATTRIBUTE_UNUSED)
+{
+  /* if ( AGGREGATE_TYPE_P (type) ) if ((int_size_in_bytes(type) == 1) ||
+     ((int_size_in_bytes(type) == 2) && TYPE_ALIGN_UNIT(type) >= 2)) return
+     false; else return true; */
+
+  return false;
+}
+
+
+/*
+  Returns one if a certain function value is going to be returned in memory
+  and zero if it is going to be returned in a register.
+
+  BLKmode and all other modes that is larger than 64 bits are returned in
+  memory.
+*/
+bool
+avr32_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)
+{
+  if (TYPE_MODE (type) == VOIDmode)
+    return false;
+
+  if (int_size_in_bytes (type) > (2 * UNITS_PER_WORD)
+      || int_size_in_bytes (type) == -1)
+    {
+      return true;
+    }
+
+  /* If we have an aggregate then use the same mechanism as when checking if
+     it should be passed on the stack. */
+  if (type
+      && AGGREGATE_TYPE_P (type)
+      && (*targetm.calls.must_pass_in_stack) (TYPE_MODE (type), type))
+    return true;
+
+  return false;
+}
+
+
+/* Output the constant part of the trampoline.
+   lddpc    r0, pc[0x8:e] ; load static chain register
+   lddpc    pc, pc[0x8:e] ; jump to subrutine
+   .long    0		 ; Address to static chain,
+			 ; filled in by avr32_initialize_trampoline()
+   .long    0		 ; Address to subrutine,
+			 ; filled in by avr32_initialize_trampoline()
+*/
+void
+avr32_trampoline_template (FILE * file)
+{
+  fprintf (file, "\tlddpc    r0, pc[8]\n");
+  fprintf (file, "\tlddpc    pc, pc[8]\n");
+  /* make room for the address of the static chain. */
+  fprintf (file, "\t.long\t0\n");
+  /* make room for the address to the subrutine. */
+  fprintf (file, "\t.long\t0\n");
+}
+
+
+/* Initialize the variable parts of a trampoline. */
+void
+avr32_initialize_trampoline (rtx addr, rtx fnaddr, rtx static_chain)
+{
+  /* Store the address to the static chain. */
+  emit_move_insn (gen_rtx_MEM
+		  (SImode, plus_constant (addr, TRAMPOLINE_SIZE - 4)),
+		  static_chain);
+
+  /* Store the address to the function. */
+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, TRAMPOLINE_SIZE)),
+		  fnaddr);
+
+  emit_insn (gen_cache (gen_rtx_REG (SImode, 13),
+			gen_rtx_CONST_INT (SImode,
+					   AVR32_CACHE_INVALIDATE_ICACHE)));
+}
+
+
+/* Return nonzero if X is valid as an addressing register.  */
+int
+avr32_address_register_rtx_p (rtx x, int strict_p)
+{
+  int regno;
+
+  if (!register_operand(x, GET_MODE(x)))
+    return 0;
+
+  /* If strict we require the register to be a hard register. */
+  if (strict_p
+      && !REG_P(x))
+    return 0;
+
+  regno = REGNO (x);
+
+  if (strict_p)
+    return REGNO_OK_FOR_BASE_P (regno);
+
+  return (regno <= LAST_REGNUM || regno >= FIRST_PSEUDO_REGISTER);
+}
+
+
+/* Return nonzero if INDEX is valid for an address index operand.  */
+int
+avr32_legitimate_index_p (enum machine_mode mode, rtx index, int strict_p)
+{
+  enum rtx_code code = GET_CODE (index);
+
+  if (GET_MODE_SIZE (mode) > 8)
+    return 0;
+
+  /* Standard coprocessor addressing modes.  */
+  if (code == CONST_INT)
+    {
+	return CONST_OK_FOR_CONSTRAINT_P (INTVAL (index), 'K', "Ks16");
+    }
+
+  if (avr32_address_register_rtx_p (index, strict_p))
+    return 1;
+
+  if (code == MULT)
+    {
+      rtx xiop0 = XEXP (index, 0);
+      rtx xiop1 = XEXP (index, 1);
+      return ((avr32_address_register_rtx_p (xiop0, strict_p)
+	       && power_of_two_operand (xiop1, SImode)
+	       && (INTVAL (xiop1) <= 8))
+	      || (avr32_address_register_rtx_p (xiop1, strict_p)
+		  && power_of_two_operand (xiop0, SImode)
+		  && (INTVAL (xiop0) <= 8)));
+    }
+  else if (code == ASHIFT)
+    {
+      rtx op = XEXP (index, 1);
+
+      return (avr32_address_register_rtx_p (XEXP (index, 0), strict_p)
+	      && GET_CODE (op) == CONST_INT
+	      && INTVAL (op) > 0 && INTVAL (op) <= 3);
+    }
+
+  return 0;
+}
+
+
+/*
+  Used in the GO_IF_LEGITIMATE_ADDRESS macro. Returns a nonzero value if
+  the RTX x is a legitimate memory address.
+
+  Returns NO_REGS if the address is not legatime, GENERAL_REGS or ALL_REGS
+  if it is.
+*/
+
+
+/* Forward declaration */
+int is_minipool_label (rtx label);
+
+int
+avr32_legitimate_address (enum machine_mode mode, rtx x, int strict)
+{
+
+  switch (GET_CODE (x))
+    {
+    case REG:
+      return avr32_address_register_rtx_p (x, strict);
+    case CONST_INT:
+      return ((mode==SImode) && TARGET_RMW_ADDRESSABLE_DATA
+              && CONST_OK_FOR_CONSTRAINT_P(INTVAL(x), 'K', "Ks17"));
+    case CONST:
+      {
+	rtx label = avr32_find_symbol (x);
+	if (label
+	    &&
+	    (/*
+               If we enable (const (plus (symbol_ref ...))) type constant
+               pool entries we must add support for it in the predicates and
+               in the minipool generation in avr32_reorg().
+               (CONSTANT_POOL_ADDRESS_P (label)
+               && !(flag_pic
+               && (symbol_mentioned_p (get_pool_constant (label))
+               || label_mentioned_p (get_pool_constant (label)))))
+               ||*/
+             ((GET_CODE (label) == LABEL_REF)
+              && GET_CODE (XEXP (label, 0)) == CODE_LABEL
+    		  && is_minipool_label (XEXP (label, 0)))
+              /*|| ((GET_CODE (label) == SYMBOL_REF) 
+                  && mode == SImode
+                  && SYMBOL_REF_RMW_ADDR(label))*/))
+	  {
+	    return TRUE;
+	  }
+      }
+      break;
+    case LABEL_REF:
+      if (GET_CODE (XEXP (x, 0)) == CODE_LABEL
+	  && is_minipool_label (XEXP (x, 0)))
+	{
+	  return TRUE;
+	}
+      break;
+    case SYMBOL_REF:
+      {
+	if (CONSTANT_POOL_ADDRESS_P (x)
+	    && !(flag_pic
+		 && (symbol_mentioned_p (get_pool_constant (x))
+		     || label_mentioned_p (get_pool_constant (x)))))
+	  return TRUE;
+	else if (SYMBOL_REF_RCALL_FUNCTION_P (x)
+                 || (mode == SImode
+                     && SYMBOL_REF_RMW_ADDR (x)))
+	  return TRUE;
+	break;
+      }
+    case PRE_DEC:		/* (pre_dec (...)) */
+    case POST_INC:		/* (post_inc (...)) */
+      return avr32_address_register_rtx_p (XEXP (x, 0), strict);
+    case PLUS:			/* (plus (...) (...)) */
+      {
+	rtx xop0 = XEXP (x, 0);
+	rtx xop1 = XEXP (x, 1);
+
+	return ((avr32_address_register_rtx_p (xop0, strict)
+		 && avr32_legitimate_index_p (mode, xop1, strict))
+		|| (avr32_address_register_rtx_p (xop1, strict)
+		    && avr32_legitimate_index_p (mode, xop0, strict)));
+      }
+    default:
+      break;
+    }
+
+  return FALSE;
+}
+
+
+int
+avr32_const_ok_for_move (HOST_WIDE_INT c)
+{
+  if ( TARGET_V2_INSNS )
+    return ( avr32_const_ok_for_constraint_p (c, 'K', "Ks21")
+             /* movh instruction */
+             || avr32_hi16_immediate_operand (GEN_INT(c), VOIDmode) );
+  else
+    return avr32_const_ok_for_constraint_p (c, 'K', "Ks21");
+}
+
+
+int
+avr32_const_double_immediate (rtx value)
+{
+  HOST_WIDE_INT hi, lo;
+
+  if (GET_CODE (value) != CONST_DOUBLE)
+    return FALSE;
+
+  if (SCALAR_FLOAT_MODE_P (GET_MODE (value)))
+    {
+      HOST_WIDE_INT target_float[2];
+      hi = lo = 0;
+      real_to_target (target_float, CONST_DOUBLE_REAL_VALUE (value),
+		      GET_MODE (value));
+      lo = target_float[0];
+      hi = target_float[1];
+    }
+  else
+    {
+      hi = CONST_DOUBLE_HIGH (value);
+      lo = CONST_DOUBLE_LOW (value);
+    }
+
+  if (avr32_const_ok_for_constraint_p (lo, 'K', "Ks21")
+      && (GET_MODE (value) == SFmode
+	  || avr32_const_ok_for_constraint_p (hi, 'K', "Ks21")))
+    {
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+
+int
+avr32_legitimate_constant_p (rtx x)
+{
+  switch (GET_CODE (x))
+    {
+    case CONST_INT:
+      /* Check if we should put large immediate into constant pool
+       or load them directly with mov/orh.*/
+      if (!avr32_imm_in_const_pool)
+	return 1;
+
+      return avr32_const_ok_for_move (INTVAL (x));
+    case CONST_DOUBLE:
+      /* Check if we should put large immediate into constant pool
+         or load them directly with mov/orh.*/
+      if (!avr32_imm_in_const_pool)
+	return 1;
+
+      if (GET_MODE (x) == SFmode
+	  || GET_MODE (x) == DFmode || GET_MODE (x) == DImode)
+	return avr32_const_double_immediate (x);
+      else
+	return 0;
+    case LABEL_REF:
+    case SYMBOL_REF:
+      return avr32_find_symbol (x) && (flag_pic || TARGET_HAS_ASM_ADDR_PSEUDOS);
+    case CONST:
+    case HIGH:
+    case CONST_VECTOR:
+      return 0;
+    default:
+      printf ("%s():\n", __FUNCTION__);
+      debug_rtx (x);
+      return 1;
+    }
+}
+
+
+/* Strip any special encoding from labels */
+const char *
+avr32_strip_name_encoding (const char *name)
+{
+  const char *stripped = name;
+
+  while (1)
+    {
+      switch (stripped[0])
+	{
+	case '#':
+	  stripped = strchr (name + 1, '#') + 1;
+	  break;
+	case '*':
+	  stripped = &stripped[1];
+	  break;
+	default:
+	  return stripped;
+	}
+    }
+}
+
+
+
+/* Do anything needed before RTL is emitted for each function.  */
+static struct machine_function *
+avr32_init_machine_status (void)
+{
+  struct machine_function *machine;
+  machine =
+    (machine_function *) ggc_alloc_cleared (sizeof (machine_function));
+
+#if AVR32_FT_UNKNOWN != 0
+  machine->func_type = AVR32_FT_UNKNOWN;
+#endif
+
+  machine->minipool_label_head = 0;
+  machine->minipool_label_tail = 0;
+  machine->ifcvt_after_reload = 0;
+  return machine;
+}
+
+
+void
+avr32_init_expanders (void)
+{
+  /* Arrange to initialize and mark the machine per-function status.  */
+  init_machine_status = avr32_init_machine_status;
+}
+
+
+/* Return an RTX indicating where the return address to the
+   calling function can be found.  */
+rtx
+avr32_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)
+{
+  if (count != 0)
+    return NULL_RTX;
+
+  return get_hard_reg_initial_val (Pmode, LR_REGNUM);
+}
+
+
+void
+avr32_encode_section_info (tree decl, rtx rtl, int first)
+{
+   default_encode_section_info(decl, rtl, first);
+
+   if ( TREE_CODE (decl) == VAR_DECL
+        && (GET_CODE (XEXP (rtl, 0)) == SYMBOL_REF)
+        && (lookup_attribute ("rmw_addressable", DECL_ATTRIBUTES (decl))
+            || TARGET_RMW_ADDRESSABLE_DATA) ){
+     if ( !TARGET_RMW || flag_pic )
+       return;
+     //  {
+     //    warning ("Using RMW addressable data with an arch that does not support RMW instructions.");
+     //    return;
+     //  } 
+     //
+     //if ( flag_pic )
+     //  {
+     //    warning ("Using RMW addressable data with together with -fpic switch. Can not use RMW instruction when compiling with -fpic.");
+     //    return;
+     //  } 
+     SYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= (1 << SYMBOL_FLAG_RMW_ADDR_SHIFT);
+  }
+}
+
+
+void
+avr32_asm_output_label (FILE * stream, const char *name)
+{
+  name = avr32_strip_name_encoding (name);
+
+  /* Print the label. */
+  assemble_name (stream, name);
+  fprintf (stream, ":\n");
+}
+
+
+void
+avr32_asm_weaken_label (FILE * stream, const char *name)
+{
+  fprintf (stream, "\t.weak ");
+  assemble_name (stream, name);
+  fprintf (stream, "\n");
+}
+
+
+/*
+  Checks if a labelref is equal to a reserved word in the assembler. If it is,
+  insert a '_' before the label name.
+*/
+void
+avr32_asm_output_labelref (FILE * stream, const char *name)
+{
+  int verbatim = FALSE;
+  const char *stripped = name;
+  int strip_finished = FALSE;
+
+  while (!strip_finished)
+    {
+      switch (stripped[0])
+	{
+	case '#':
+	  stripped = strchr (name + 1, '#') + 1;
+	  break;
+	case '*':
+	  stripped = &stripped[1];
+	  verbatim = TRUE;
+	  break;
+	default:
+	  strip_finished = TRUE;
+	  break;
+	}
+    }
+
+  if (verbatim)
+    fputs (stripped, stream);
+  else
+    asm_fprintf (stream, "%U%s", stripped);
+}
+
+
+/*
+   Check if the comparison in compare_exp is redundant
+   for the condition given in next_cond given that the
+   needed flags are already set by an earlier instruction.
+   Uses cc_prev_status to check this.
+
+   Returns NULL_RTX if the compare is not redundant
+   or the new condition to use in the conditional
+   instruction if the compare is redundant.
+*/
+static rtx
+is_compare_redundant (rtx compare_exp, rtx next_cond)
+{
+  int z_flag_valid = FALSE;
+  int n_flag_valid = FALSE;
+  rtx new_cond;
+
+  if (GET_CODE (compare_exp) != COMPARE
+      && GET_CODE (compare_exp) != AND)
+    return NULL_RTX;
+
+
+  if (rtx_equal_p (cc_prev_status.mdep.value, compare_exp))
+    {
+      /* cc0 already contains the correct comparison -> delete cmp insn */
+      return next_cond;
+    }
+
+  if (GET_MODE (compare_exp) != SImode)
+    return NULL_RTX;
+
+  switch (cc_prev_status.mdep.flags)
+    {
+    case CC_SET_VNCZ:
+    case CC_SET_NCZ:
+      n_flag_valid = TRUE;
+    case CC_SET_CZ:
+    case CC_SET_Z:
+      z_flag_valid = TRUE;
+    }
+
+  if (cc_prev_status.mdep.value
+      && GET_CODE (compare_exp) == COMPARE
+      && REG_P (XEXP (compare_exp, 0))
+      && REGNO (XEXP (compare_exp, 0)) == REGNO (cc_prev_status.mdep.value)
+      && GET_CODE (XEXP (compare_exp, 1)) == CONST_INT
+      && next_cond != NULL_RTX)
+    {
+      if (INTVAL (XEXP (compare_exp, 1)) == 0
+	  && z_flag_valid
+	  && (GET_CODE (next_cond) == EQ || GET_CODE (next_cond) == NE))
+	/* We can skip comparison Z flag is already reflecting ops[0] */
+	return next_cond;
+      else if (n_flag_valid
+	       && ((INTVAL (XEXP (compare_exp, 1)) == 0
+		    && (GET_CODE (next_cond) == GE
+			|| GET_CODE (next_cond) == LT))
+		   || (INTVAL (XEXP (compare_exp, 1)) == -1
+		       && (GET_CODE (next_cond) == GT
+			   || GET_CODE (next_cond) == LE))))
+	{
+	  /* We can skip comparison N flag is already reflecting ops[0],
+	     which means that we can use the mi/pl conditions to check if
+	     ops[0] is GE or LT 0. */
+	  if ((GET_CODE (next_cond) == GE) || (GET_CODE (next_cond) == GT))
+	    new_cond =
+	      gen_rtx_UNSPEC (GET_MODE (next_cond), gen_rtvec (2, cc0_rtx, const0_rtx),
+			      UNSPEC_COND_PL);
+	  else
+	    new_cond =
+	      gen_rtx_UNSPEC (GET_MODE (next_cond), gen_rtvec (2, cc0_rtx, const0_rtx),
+			      UNSPEC_COND_MI);
+	  return new_cond;
+	}
+    }
+  return NULL_RTX;
+}
+
+
+/* Updates cc_status.  */
+void
+avr32_notice_update_cc (rtx exp, rtx insn)
+{
+  enum attr_cc attr_cc = get_attr_cc (insn);
+
+  if ( attr_cc == CC_SET_Z_IF_NOT_V2 )
+    {
+      if (TARGET_V2_INSNS)
+        attr_cc = CC_NONE;
+      else
+        attr_cc = CC_SET_Z;
+    }
+
+  switch (attr_cc)
+    {
+    case CC_CALL_SET:
+      CC_STATUS_INIT;
+      /* Check if the function call returns a value in r12 */
+      if (REG_P (recog_data.operand[0])
+	  && REGNO (recog_data.operand[0]) == RETVAL_REGNUM)
+	{
+	  cc_status.flags = 0;
+	  cc_status.mdep.value =
+	    gen_rtx_COMPARE (SImode, recog_data.operand[0], const0_rtx);
+	  cc_status.mdep.flags = CC_SET_VNCZ;
+          cc_status.mdep.cond_exec_cmp_clobbered = 0;
+
+	}
+      break;
+    case CC_COMPARE:
+      {
+        /* Check that compare will not be optimized away if so nothing should
+           be done */
+        rtx compare_exp = SET_SRC (exp);
+        /* Check if we have a tst expression. If so convert it to a
+           compare with 0. */
+        if ( REG_P (SET_SRC (exp)) )
+          compare_exp = gen_rtx_COMPARE (GET_MODE (SET_SRC (exp)),
+                                         SET_SRC (exp),
+                                         const0_rtx);
+
+        if (!next_insn_emits_cmp (insn)
+            && (is_compare_redundant (compare_exp, get_next_insn_cond (insn)) == NULL_RTX))
+          {
+
+            /* Reset the nonstandard flag */
+            CC_STATUS_INIT;
+            cc_status.flags = 0;
+            cc_status.mdep.value = compare_exp;
+            cc_status.mdep.flags = CC_SET_VNCZ;
+            cc_status.mdep.cond_exec_cmp_clobbered = 0;
+         }
+      }
+      break;
+    case CC_CMP_COND_INSN:
+      {
+	/* Conditional insn that emit the compare itself. */
+        rtx cmp;
+        rtx cmp_op0, cmp_op1;
+        rtx cond;
+        rtx dest;
+        rtx next_insn = next_nonnote_insn (insn);
+
+        if ( GET_CODE (exp) == COND_EXEC )
+          {
+            cmp_op0 = XEXP (COND_EXEC_TEST (exp), 0);
+            cmp_op1 = XEXP (COND_EXEC_TEST (exp), 1);
+            cond = COND_EXEC_TEST (exp);
+            dest = SET_DEST (COND_EXEC_CODE (exp));
+          }
+        else
+          {
+            /* If then else conditional. compare operands are in operands
+               4 and 5. */
+            cmp_op0 = recog_data.operand[4];
+            cmp_op1 = recog_data.operand[5];
+            cond = recog_data.operand[1];
+            dest = SET_DEST (exp);
+          }
+
+        if ( GET_CODE (cmp_op0) == AND )
+          cmp = cmp_op0;
+        else
+          cmp = gen_rtx_COMPARE (GET_MODE (cmp_op0),
+                                 cmp_op0,
+                                 cmp_op1);
+
+        /* Check if the conditional insns updates a register present
+           in the comparison, if so then we must reset the cc_status. */
+        if (REG_P (dest)
+            && (reg_mentioned_p (dest, cmp_op0)
+                || reg_mentioned_p (dest, cmp_op1))
+            && GET_CODE (exp) != COND_EXEC )
+          {
+            CC_STATUS_INIT;
+          }
+	else if (is_compare_redundant (cmp, cond) == NULL_RTX)
+	  {
+	    /* Reset the nonstandard flag */
+	    CC_STATUS_INIT;
+            if ( GET_CODE (cmp_op0) == AND )
+              {
+                cc_status.flags = CC_INVERTED;
+                cc_status.mdep.flags = CC_SET_Z;
+              }
+            else
+              {
+                cc_status.flags = 0;
+                cc_status.mdep.flags = CC_SET_VNCZ;
+              }
+	    cc_status.mdep.value = cmp;
+            cc_status.mdep.cond_exec_cmp_clobbered = 0;
+	  }
+
+
+        /* Check if we have a COND_EXEC insn which updates one
+           of the registers in the compare status. */
+        if (REG_P (dest)
+            && (reg_mentioned_p (dest, cmp_op0)
+                || reg_mentioned_p (dest, cmp_op1))
+            && GET_CODE (exp) == COND_EXEC )
+          cc_status.mdep.cond_exec_cmp_clobbered = 1;
+
+        if ( cc_status.mdep.cond_exec_cmp_clobbered
+             && GET_CODE (exp) == COND_EXEC
+             && next_insn != NULL
+             && INSN_P (next_insn)
+             && !(GET_CODE (PATTERN (next_insn)) == COND_EXEC
+                  && rtx_equal_p (XEXP (COND_EXEC_TEST (PATTERN (next_insn)), 0), cmp_op0)
+                  && rtx_equal_p (XEXP (COND_EXEC_TEST (PATTERN (next_insn)), 1), cmp_op1)
+                  && (GET_CODE (COND_EXEC_TEST (PATTERN (next_insn))) == GET_CODE (cond)
+                      || GET_CODE (COND_EXEC_TEST (PATTERN (next_insn))) == reverse_condition (GET_CODE (cond)))) )
+          {
+            /* We have a sequence of conditional insns where the compare status has been clobbered
+               since the compare no longer reflects the content of the values to compare. */
+            CC_STATUS_INIT;
+            cc_status.mdep.cond_exec_cmp_clobbered = 1;
+          }
+
+      }
+      break;
+    case CC_BLD:
+      /* Bit load is kind of like an inverted testsi, because the Z flag is
+         inverted */
+      CC_STATUS_INIT;
+      cc_status.flags = CC_INVERTED;
+      cc_status.mdep.value = SET_SRC (exp);
+      cc_status.mdep.flags = CC_SET_Z;
+      cc_status.mdep.cond_exec_cmp_clobbered = 0;
+      break;
+    case CC_NONE:
+      /* Insn does not affect CC at all. Check if the instruction updates
+         some of the register currently reflected in cc0 */
+
+      if ((GET_CODE (exp) == SET)
+	  && (cc_status.value1 || cc_status.value2 || cc_status.mdep.value)
+	  && (reg_mentioned_p (SET_DEST (exp), cc_status.value1)
+	      || reg_mentioned_p (SET_DEST (exp), cc_status.value2)
+	      || reg_mentioned_p (SET_DEST (exp), cc_status.mdep.value)))
+	{
+	  CC_STATUS_INIT;
+	}
+
+      /* If this is a parallel we must step through each of the parallel
+         expressions */
+      if (GET_CODE (exp) == PARALLEL)
+	{
+	  int i;
+	  for (i = 0; i < XVECLEN (exp, 0); ++i)
+	    {
+	      rtx vec_exp = XVECEXP (exp, 0, i);
+	      if ((GET_CODE (vec_exp) == SET)
+		  && (cc_status.value1 || cc_status.value2
+		      || cc_status.mdep.value)
+		  && (reg_mentioned_p (SET_DEST (vec_exp), cc_status.value1)
+		      || reg_mentioned_p (SET_DEST (vec_exp),
+					  cc_status.value2)
+		      || reg_mentioned_p (SET_DEST (vec_exp),
+					  cc_status.mdep.value)))
+		{
+		  CC_STATUS_INIT;
+		}
+	    }
+	}
+
+      /* Check if we have memory opartions with post_inc or pre_dec on the
+         register currently reflected in cc0 */
+      if (GET_CODE (exp) == SET
+	  && GET_CODE (SET_SRC (exp)) == MEM
+	  && (GET_CODE (XEXP (SET_SRC (exp), 0)) == POST_INC
+	      || GET_CODE (XEXP (SET_SRC (exp), 0)) == PRE_DEC)
+	  &&
+	  (reg_mentioned_p
+	   (XEXP (XEXP (SET_SRC (exp), 0), 0), cc_status.value1)
+	   || reg_mentioned_p (XEXP (XEXP (SET_SRC (exp), 0), 0),
+			       cc_status.value2)
+	   || reg_mentioned_p (XEXP (XEXP (SET_SRC (exp), 0), 0),
+			       cc_status.mdep.value)))
+	CC_STATUS_INIT;
+
+      if (GET_CODE (exp) == SET
+	  && GET_CODE (SET_DEST (exp)) == MEM
+	  && (GET_CODE (XEXP (SET_DEST (exp), 0)) == POST_INC
+	      || GET_CODE (XEXP (SET_DEST (exp), 0)) == PRE_DEC)
+	  &&
+	  (reg_mentioned_p
+	   (XEXP (XEXP (SET_DEST (exp), 0), 0), cc_status.value1)
+	   || reg_mentioned_p (XEXP (XEXP (SET_DEST (exp), 0), 0),
+			       cc_status.value2)
+	   || reg_mentioned_p (XEXP (XEXP (SET_DEST (exp), 0), 0),
+			       cc_status.mdep.value)))
+	CC_STATUS_INIT;
+      break;
+
+    case CC_SET_VNCZ:
+      CC_STATUS_INIT;
+      cc_status.mdep.value = recog_data.operand[0];
+      cc_status.mdep.flags = CC_SET_VNCZ;
+      cc_status.mdep.cond_exec_cmp_clobbered = 0;
+      break;
+
+    case CC_SET_NCZ:
+      CC_STATUS_INIT;
+      cc_status.mdep.value = recog_data.operand[0];
+      cc_status.mdep.flags = CC_SET_NCZ;
+      cc_status.mdep.cond_exec_cmp_clobbered = 0;
+      break;
+
+    case CC_SET_CZ:
+      CC_STATUS_INIT;
+      cc_status.mdep.value = recog_data.operand[0];
+      cc_status.mdep.flags = CC_SET_CZ;
+      cc_status.mdep.cond_exec_cmp_clobbered = 0;
+      break;
+
+    case CC_SET_Z:
+      CC_STATUS_INIT;
+      cc_status.mdep.value = recog_data.operand[0];
+      cc_status.mdep.flags = CC_SET_Z;
+      cc_status.mdep.cond_exec_cmp_clobbered = 0;
+      break;
+
+    case CC_CLOBBER:
+      CC_STATUS_INIT;
+      break;
+
+    default:
+      CC_STATUS_INIT;
+    }
+}
+
+
+/*
+  Outputs to stdio stream stream the assembler syntax for an instruction
+  operand x. x is an RTL expression.
+*/
+void
+avr32_print_operand (FILE * stream, rtx x, int code)
+{
+  int error = 0;
+
+  if ( code == '?' )
+    {
+      /* Predicable instruction, print condition code */
+
+      /* If the insn should not be conditional then do nothing. */
+      if ( current_insn_predicate == NULL_RTX )
+        return;
+
+      /* Set x to the predicate to force printing
+         the condition later on. */
+      x = current_insn_predicate;
+
+      /* Reverse condition if useing bld insn. */
+      if ( GET_CODE (XEXP(current_insn_predicate,0)) == AND )
+        x = reversed_condition (current_insn_predicate);
+    }
+  else if ( code == '!' )
+    {
+      /* Output compare for conditional insn if needed. */
+      rtx new_cond;
+      gcc_assert ( current_insn_predicate != NULL_RTX );
+      new_cond = avr32_output_cmp(current_insn_predicate,
+                                  GET_MODE(XEXP(current_insn_predicate,0)),
+                                  XEXP(current_insn_predicate,0),
+                                  XEXP(current_insn_predicate,1));
+
+      /* Check if the new condition is a special avr32 condition
+         specified using UNSPECs. If so we must handle it differently. */
+      if ( GET_CODE (new_cond) == UNSPEC )
+        {
+          current_insn_predicate =
+            gen_rtx_UNSPEC (CCmode,
+                            gen_rtvec (2,
+                                       XEXP(current_insn_predicate,0),
+                                       XEXP(current_insn_predicate,1)),
+                            XINT (new_cond, 1));
+        }
+      else
+        {
+          PUT_CODE(current_insn_predicate, GET_CODE(new_cond));
+        }
+      return;
+    }
+
+  switch (GET_CODE (x))
+    {
+    case UNSPEC:
+      switch (XINT (x, 1))
+	{
+	case UNSPEC_COND_PL:
+	  if (code == 'i')
+	    fputs ("mi", stream);
+	  else
+	    fputs ("pl", stream);
+	  break;
+	case UNSPEC_COND_MI:
+	  if (code == 'i')
+	    fputs ("pl", stream);
+	  else
+	    fputs ("mi", stream);
+	  break;
+	default:
+	  error = 1;
+	}
+      break;
+    case EQ:
+      if (code == 'i')
+	fputs ("ne", stream);
+      else
+	fputs ("eq", stream);
+      break;
+    case NE:
+      if (code == 'i')
+	fputs ("eq", stream);
+      else
+	fputs ("ne", stream);
+      break;
+    case GT:
+      if (code == 'i')
+	fputs ("le", stream);
+      else
+	fputs ("gt", stream);
+      break;
+    case GTU:
+      if (code == 'i')
+	fputs ("ls", stream);
+      else
+	fputs ("hi", stream);
+      break;
+    case LT:
+      if (code == 'i')
+	fputs ("ge", stream);
+      else
+	fputs ("lt", stream);
+      break;
+    case LTU:
+      if (code == 'i')
+	fputs ("hs", stream);
+      else
+	fputs ("lo", stream);
+      break;
+    case GE:
+      if (code == 'i')
+	fputs ("lt", stream);
+      else
+	fputs ("ge", stream);
+      break;
+    case GEU:
+      if (code == 'i')
+	fputs ("lo", stream);
+      else
+	fputs ("hs", stream);
+      break;
+    case LE:
+      if (code == 'i')
+	fputs ("gt", stream);
+      else
+	fputs ("le", stream);
+      break;
+    case LEU:
+      if (code == 'i')
+	fputs ("hi", stream);
+      else
+	fputs ("ls", stream);
+      break;
+    case CONST_INT:
+      {
+        HOST_WIDE_INT value = INTVAL (x);
+
+        switch (code)
+          {
+          case 'm':
+            if ( HOST_BITS_PER_WIDE_INT > BITS_PER_WORD )
+              {
+                /* A const_int can be used to represent DImode constants. */
+                value >>= BITS_PER_WORD;
+              }
+            /* We might get a const_int immediate for setting a DI register,
+               we then must then return the correct sign extended DI. The most
+               significant word is just a sign extension. */
+            else if (value < 0)
+              value = -1;
+            else
+              value = 0;
+            break;
+          case 'i':
+            value++;
+            break;
+          case 'p':
+            {
+              /* Set to bit position of first bit set in immediate */
+              int i, bitpos = 32;
+              for (i = 0; i < 32; i++)
+                if (value & (1 << i))
+                  {
+                    bitpos = i;
+                    break;
+                  }
+              value = bitpos;
+            }
+            break;
+          case 'z':
+            {
+              /* Set to bit position of first bit cleared in immediate */
+              int i, bitpos = 32;
+              for (i = 0; i < 32; i++)
+                if (!(value & (1 << i)))
+                  {
+                    bitpos = i;
+                    break;
+                  }
+              value = bitpos;
+            }
+            break;
+          case 'r':
+            {
+              /* Reglist 8 */
+              char op[50];
+              op[0] = '\0';
+
+              if (value & 0x01)
+                strcpy (op, "r0-r3");
+              if (value & 0x02)
+                strlen (op) ? strcat (op, ", r4-r7") : strcpy (op,"r4-r7");
+              if (value & 0x04)
+                strlen (op) ? strcat (op, ", r8-r9") : strcpy (op,"r8-r9");
+              if (value & 0x08)
+                strlen (op) ? strcat (op, ", r10") : strcpy (op,"r10");
+              if (value & 0x10)
+                strlen (op) ? strcat (op, ", r11") : strcpy (op,"r11");
+              if (value & 0x20)
+                strlen (op) ? strcat (op, ", r12") : strcpy (op,"r12");
+              if (value & 0x40)
+                strlen (op) ? strcat (op, ", lr") : strcpy (op, "lr");
+              if (value & 0x80)
+                strlen (op) ? strcat (op, ", pc") : strcpy (op, "pc");
+
+              fputs (op, stream);
+              return;
+            }
+          case 's':
+            {
+              /* Reglist 16 */
+              char reglist16_string[100];
+              int i;
+	      bool first_reg = true;
+              reglist16_string[0] = '\0';
+
+	      for (i = 0; i < 16; ++i)
+		{
+		  if (value & (1 << i))
+		    {
+			first_reg == true ?  first_reg = false : strcat(reglist16_string,", ");
+			strcat(reglist16_string,reg_names[INTERNAL_REGNUM(i)]);		      
+		    }
+		}
+	      fputs (reglist16_string, stream);
+	      return;
+	    }
+	  case 'h':
+	    /* Print halfword part of word */
+	    fputs (value ? "b" : "t", stream);
+	    return;
+	  }
+
+	/* Print Value */
+	fprintf (stream, "%d", value);
+	break;
+      }
+    case CONST_DOUBLE:
+      {
+	HOST_WIDE_INT hi, lo;
+	if (SCALAR_FLOAT_MODE_P (GET_MODE (x)))
+	  {
+	    HOST_WIDE_INT target_float[2];
+	    hi = lo = 0;
+	    real_to_target (target_float, CONST_DOUBLE_REAL_VALUE (x),
+			    GET_MODE (x));
+	    /* For doubles the most significant part starts at index 0. */
+	    if (GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD)
+	      {
+		hi = target_float[0];
+		lo = target_float[1];
+	      }
+	    else
+	      {
+		lo = target_float[0];
+	      }
+	  }
+	else
+	  {
+	    hi = CONST_DOUBLE_HIGH (x);
+	    lo = CONST_DOUBLE_LOW (x);
+	  }
+
+	if (code == 'm')
+	  fprintf (stream, "%ld", hi);
+	else
+	  fprintf (stream, "%ld", lo);
+
+	break;
+      }
+    case CONST:
+      output_addr_const (stream, XEXP (XEXP (x, 0), 0));
+      fprintf (stream, "+%ld", INTVAL (XEXP (XEXP (x, 0), 1)));
+      break;
+    case REG:
+      /* Swap register name if the register is DImode or DFmode. */
+      if (GET_MODE (x) == DImode || GET_MODE (x) == DFmode)
+	{
+	  /* Double register must have an even numbered address */
+	  gcc_assert (!(REGNO (x) % 2));
+	  if (code == 'm')
+	    fputs (reg_names[true_regnum (x)], stream);
+	  else
+	    fputs (reg_names[true_regnum (x) + 1], stream);
+	}
+      else if (GET_MODE (x) == TImode)
+	{
+	  switch (code)
+	    {
+	    case 'T':
+	      fputs (reg_names[true_regnum (x)], stream);
+	      break;
+	    case 'U':
+	      fputs (reg_names[true_regnum (x) + 1], stream);
+	      break;
+	    case 'L':
+	      fputs (reg_names[true_regnum (x) + 2], stream);
+	      break;
+	    case 'B':
+	      fputs (reg_names[true_regnum (x) + 3], stream);
+	      break;
+	    default:
+	      fprintf (stream, "%s, %s, %s, %s",
+		       reg_names[true_regnum (x) + 3],
+		       reg_names[true_regnum (x) + 2],
+		       reg_names[true_regnum (x) + 1],
+		       reg_names[true_regnum (x)]);
+	      break;
+	    }
+	}
+      else
+	{
+	  fputs (reg_names[true_regnum (x)], stream);
+	}
+      break;
+    case CODE_LABEL:
+    case LABEL_REF:
+    case SYMBOL_REF:
+      output_addr_const (stream, x);
+      break;
+    case MEM:
+      switch (GET_CODE (XEXP (x, 0)))
+	{
+	case LABEL_REF:
+	case SYMBOL_REF:
+	  output_addr_const (stream, XEXP (x, 0));
+	  break;
+	case MEM:
+	  switch (GET_CODE (XEXP (XEXP (x, 0), 0)))
+	    {
+	    case SYMBOL_REF:
+	      output_addr_const (stream, XEXP (XEXP (x, 0), 0));
+	      break;
+	    default:
+	      error = 1;
+	      break;
+	    }
+	  break;
+	case REG:
+	  avr32_print_operand (stream, XEXP (x, 0), 0);
+	  if (code != 'p')
+	    fputs ("[0]", stream);
+	  break;
+	case PRE_DEC:
+	  fputs ("--", stream);
+	  avr32_print_operand (stream, XEXP (XEXP (x, 0), 0), 0);
+	  break;
+	case POST_INC:
+	  avr32_print_operand (stream, XEXP (XEXP (x, 0), 0), 0);
+	  fputs ("++", stream);
+	  break;
+	case PLUS:
+	  {
+	    rtx op0 = XEXP (XEXP (x, 0), 0);
+	    rtx op1 = XEXP (XEXP (x, 0), 1);
+	    rtx base = NULL_RTX, offset = NULL_RTX;
+
+	    if (avr32_address_register_rtx_p (op0, 1))
+	      {
+		base = op0;
+		offset = op1;
+	      }
+	    else if (avr32_address_register_rtx_p (op1, 1))
+	      {
+		/* Operands are switched. */
+		base = op1;
+		offset = op0;
+	      }
+
+	    gcc_assert (base && offset
+			&& avr32_address_register_rtx_p (base, 1)
+			&& avr32_legitimate_index_p (GET_MODE (x), offset,
+						     1));
+
+	    avr32_print_operand (stream, base, 0);
+	    fputs ("[", stream);
+	    avr32_print_operand (stream, offset, 0);
+	    fputs ("]", stream);
+	    break;
+	  }
+	case CONST:
+	  output_addr_const (stream, XEXP (XEXP (XEXP (x, 0), 0), 0));
+	  fprintf (stream, " + %ld",
+		   INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1)));
+	  break;
+        case CONST_INT:
+	  avr32_print_operand (stream, XEXP (x, 0), 0);
+          break;
+	default:
+	  error = 1;
+	}
+      break;
+    case MULT:
+      {
+	int value = INTVAL (XEXP (x, 1));
+
+	/* Convert immediate in multiplication into a shift immediate */
+	switch (value)
+	  {
+	  case 2:
+	    value = 1;
+	    break;
+	  case 4:
+	    value = 2;
+	    break;
+	  case 8:
+	    value = 3;
+	    break;
+	  default:
+	    value = 0;
+	  }
+	fprintf (stream, "%s << %i", reg_names[true_regnum (XEXP (x, 0))],
+		 value);
+	break;
+      }
+    case ASHIFT:
+      if (GET_CODE (XEXP (x, 1)) == CONST_INT)
+	fprintf (stream, "%s << %i", reg_names[true_regnum (XEXP (x, 0))],
+		 (int) INTVAL (XEXP (x, 1)));
+      else if (REG_P (XEXP (x, 1)))
+	fprintf (stream, "%s << %s", reg_names[true_regnum (XEXP (x, 0))],
+		 reg_names[true_regnum (XEXP (x, 1))]);
+      else
+	{
+	  error = 1;
+	}
+      break;
+    case LSHIFTRT:
+      if (GET_CODE (XEXP (x, 1)) == CONST_INT)
+	fprintf (stream, "%s >> %i", reg_names[true_regnum (XEXP (x, 0))],
+		 (int) INTVAL (XEXP (x, 1)));
+      else if (REG_P (XEXP (x, 1)))
+	fprintf (stream, "%s >> %s", reg_names[true_regnum (XEXP (x, 0))],
+		 reg_names[true_regnum (XEXP (x, 1))]);
+      else
+	{
+	  error = 1;
+	}
+      fprintf (stream, ">>");
+      break;
+    case PARALLEL:
+      {
+	/* Load store multiple */
+	int i;
+	int count = XVECLEN (x, 0);
+	int reglist16 = 0;
+	char reglist16_string[100];
+
+	for (i = 0; i < count; ++i)
+	  {
+	    rtx vec_elm = XVECEXP (x, 0, i);
+	    if (GET_MODE (vec_elm) != SET)
+	      {
+		debug_rtx (vec_elm);
+		internal_error ("Unknown element in parallel expression!");
+	      }
+	    if (GET_MODE (XEXP (vec_elm, 0)) == REG)
+	      {
+		/* Load multiple */
+		reglist16 |= 1 << ASM_REGNUM (REGNO (XEXP (vec_elm, 0)));
+	      }
+	    else
+	      {
+		/* Store multiple */
+		reglist16 |= 1 << ASM_REGNUM (REGNO (XEXP (vec_elm, 1)));
+	      }
+	  }
+
+	avr32_make_reglist16 (reglist16, reglist16_string);
+	fputs (reglist16_string, stream);
+
+	break;
+      }
+
+    case PLUS:
+      {
+        rtx op0 = XEXP (x, 0);
+        rtx op1 = XEXP (x, 1);
+        rtx base = NULL_RTX, offset = NULL_RTX;
+
+        if (avr32_address_register_rtx_p (op0, 1))
+          {
+            base = op0;
+            offset = op1;
+          }
+        else if (avr32_address_register_rtx_p (op1, 1))
+          {
+            /* Operands are switched. */
+            base = op1;
+            offset = op0;
+          }
+
+        gcc_assert (base && offset
+                    && avr32_address_register_rtx_p (base, 1)
+                    && avr32_legitimate_index_p (GET_MODE (x), offset, 1));
+
+        avr32_print_operand (stream, base, 0);
+        fputs ("[", stream);
+        avr32_print_operand (stream, offset, 0);
+        fputs ("]", stream);
+        break;
+      }
+
+    default:
+      error = 1;
+    }
+
+  if (error)
+    {
+      debug_rtx (x);
+      internal_error ("Illegal expression for avr32_print_operand");
+    }
+}
+
+rtx
+avr32_get_note_reg_equiv (rtx insn)
+{
+  rtx note;
+
+  note = find_reg_note (insn, REG_EQUIV, NULL_RTX);
+
+  if (note != NULL_RTX)
+    return XEXP (note, 0);
+  else
+    return NULL_RTX;
+}
+
+
+/*
+  Outputs to stdio stream stream the assembler syntax for an instruction
+  operand that is a memory reference whose address is x. x is an RTL
+  expression.
+
+  ToDo: fixme.
+*/
+void
+avr32_print_operand_address (FILE * stream, rtx x)
+{
+  fprintf (stream, "(%d) /* address */", REGNO (x));
+}
+
+
+/* Return true if _GLOBAL_OFFSET_TABLE_ symbol is mentioned.  */
+bool
+avr32_got_mentioned_p (rtx addr)
+{
+  if (GET_CODE (addr) == MEM)
+    addr = XEXP (addr, 0);
+  while (GET_CODE (addr) == CONST)
+    addr = XEXP (addr, 0);
+  if (GET_CODE (addr) == SYMBOL_REF)
+    {
+      return streq (XSTR (addr, 0), "_GLOBAL_OFFSET_TABLE_");
+    }
+  if (GET_CODE (addr) == PLUS || GET_CODE (addr) == MINUS)
+    {
+      bool l1, l2;
+
+      l1 = avr32_got_mentioned_p (XEXP (addr, 0));
+      l2 = avr32_got_mentioned_p (XEXP (addr, 1));
+      return l1 || l2;
+    }
+  return false;
+}
+
+
+/* Find the symbol in an address expression.  */
+rtx
+avr32_find_symbol (rtx addr)
+{
+  if (GET_CODE (addr) == MEM)
+    addr = XEXP (addr, 0);
+
+  while (GET_CODE (addr) == CONST)
+    addr = XEXP (addr, 0);
+
+  if (GET_CODE (addr) == SYMBOL_REF || GET_CODE (addr) == LABEL_REF)
+    return addr;
+  if (GET_CODE (addr) == PLUS)
+    {
+      rtx l1, l2;
+
+      l1 = avr32_find_symbol (XEXP (addr, 0));
+      l2 = avr32_find_symbol (XEXP (addr, 1));
+      if (l1 != NULL_RTX && l2 == NULL_RTX)
+	return l1;
+      else if (l1 == NULL_RTX && l2 != NULL_RTX)
+	return l2;
+    }
+
+  return NULL_RTX;
+}
+
+
+/* Routines for manipulation of the constant pool.  */
+
+/* AVR32 instructions cannot load a large constant directly into a
+   register; they have to come from a pc relative load.  The constant
+   must therefore be placed in the addressable range of the pc
+   relative load.  Depending on the precise pc relative load
+   instruction the range is somewhere between 256 bytes and 4k.  This
+   means that we often have to dump a constant inside a function, and
+   generate code to branch around it.
+
+   It is important to minimize this, since the branches will slow
+   things down and make the code larger.
+
+   Normally we can hide the table after an existing unconditional
+   branch so that there is no interruption of the flow, but in the
+   worst case the code looks like this:
+
+	lddpc	rn, L1
+	...
+	rjmp	L2
+	align
+	L1:	.long value
+	L2:
+	...
+
+	lddpc	rn, L3
+	...
+	rjmp	L4
+	align
+	L3:	.long value
+	L4:
+	...
+
+   We fix this by performing a scan after scheduling, which notices
+   which instructions need to have their operands fetched from the
+   constant table and builds the table.
+
+   The algorithm starts by building a table of all the constants that
+   need fixing up and all the natural barriers in the function (places
+   where a constant table can be dropped without breaking the flow).
+   For each fixup we note how far the pc-relative replacement will be
+   able to reach and the offset of the instruction into the function.
+
+   Having built the table we then group the fixes together to form
+   tables that are as large as possible (subject to addressing
+   constraints) and emit each table of constants after the last
+   barrier that is within range of all the instructions in the group.
+   If a group does not contain a barrier, then we forcibly create one
+   by inserting a jump instruction into the flow.  Once the table has
+   been inserted, the insns are then modified to reference the
+   relevant entry in the pool.
+
+   Possible enhancements to the algorithm (not implemented) are:
+
+   1) For some processors and object formats, there may be benefit in
+   aligning the pools to the start of cache lines; this alignment
+   would need to be taken into account when calculating addressability
+   of a pool.  */
+
+/* These typedefs are located at the start of this file, so that
+   they can be used in the prototypes there.  This comment is to
+   remind readers of that fact so that the following structures
+   can be understood more easily.
+
+     typedef struct minipool_node    Mnode;
+     typedef struct minipool_fixup   Mfix;  */
+
+struct minipool_node
+{
+  /* Doubly linked chain of entries.  */
+  Mnode *next;
+  Mnode *prev;
+  /* The maximum offset into the code that this entry can be placed.  While
+     pushing fixes for forward references, all entries are sorted in order of
+     increasing max_address.  */
+  HOST_WIDE_INT max_address;
+  /* Similarly for an entry inserted for a backwards ref.  */
+  HOST_WIDE_INT min_address;
+  /* The number of fixes referencing this entry.  This can become zero if we
+     "unpush" an entry.  In this case we ignore the entry when we come to
+     emit the code.  */
+  int refcount;
+  /* The offset from the start of the minipool.  */
+  HOST_WIDE_INT offset;
+  /* The value in table.  */
+  rtx value;
+  /* The mode of value.  */
+  enum machine_mode mode;
+  /* The size of the value.  */
+  int fix_size;
+};
+
+
+struct minipool_fixup
+{
+  Mfix *next;
+  rtx insn;
+  HOST_WIDE_INT address;
+  rtx *loc;
+  enum machine_mode mode;
+  int fix_size;
+  rtx value;
+  Mnode *minipool;
+  HOST_WIDE_INT forwards;
+  HOST_WIDE_INT backwards;
+};
+
+
+/* Fixes less than a word need padding out to a word boundary.  */
+#define MINIPOOL_FIX_SIZE(mode, value)                          \
+  (IS_FORCE_MINIPOOL(value) ? 0 :                               \
+   (GET_MODE_SIZE ((mode)) >= 4 ? GET_MODE_SIZE ((mode)) : 4))
+
+#define IS_FORCE_MINIPOOL(x)                    \
+  (GET_CODE(x) == UNSPEC &&                     \
+   XINT(x, 1) == UNSPEC_FORCE_MINIPOOL)
+
+static Mnode *minipool_vector_head;
+static Mnode *minipool_vector_tail;
+
+/* The linked list of all minipool fixes required for this function.  */
+Mfix *minipool_fix_head;
+Mfix *minipool_fix_tail;
+/* The fix entry for the current minipool, once it has been placed.  */
+Mfix *minipool_barrier;
+
+
+/* Determines if INSN is the start of a jump table.  Returns the end
+   of the TABLE or NULL_RTX.  */
+static rtx
+is_jump_table (rtx insn)
+{
+  rtx table;
+
+  if (GET_CODE (insn) == JUMP_INSN
+      && JUMP_LABEL (insn) != NULL
+      && ((table = next_real_insn (JUMP_LABEL (insn)))
+	  == next_real_insn (insn))
+      && table != NULL
+      && GET_CODE (table) == JUMP_INSN
+      && (GET_CODE (PATTERN (table)) == ADDR_VEC
+	  || GET_CODE (PATTERN (table)) == ADDR_DIFF_VEC))
+    return table;
+
+  return NULL_RTX;
+}
+
+
+static HOST_WIDE_INT
+get_jump_table_size (rtx insn)
+{
+  /* ADDR_VECs only take room if read-only data does into the text section.  */
+  if (JUMP_TABLES_IN_TEXT_SECTION
+#if !defined(READONLY_DATA_SECTION_ASM_OP)
+      || 1
+#endif
+    )
+    {
+      rtx body = PATTERN (insn);
+      int elt = GET_CODE (body) == ADDR_DIFF_VEC ? 1 : 0;
+
+      return GET_MODE_SIZE (GET_MODE (body)) * XVECLEN (body, elt);
+    }
+
+  return 0;
+}
+
+
+/* Move a minipool fix MP from its current location to before MAX_MP.
+   If MAX_MP is NULL, then MP doesn't need moving, but the addressing
+   constraints may need updating.  */
+static Mnode *
+move_minipool_fix_forward_ref (Mnode * mp, Mnode * max_mp,
+			       HOST_WIDE_INT max_address)
+{
+  /* This should never be true and the code below assumes these are
+     different.  */
+  if (mp == max_mp)
+    abort ();
+
+  if (max_mp == NULL)
+    {
+      if (max_address < mp->max_address)
+	mp->max_address = max_address;
+    }
+  else
+    {
+      if (max_address > max_mp->max_address - mp->fix_size)
+	mp->max_address = max_mp->max_address - mp->fix_size;
+      else
+	mp->max_address = max_address;
+
+      /* Unlink MP from its current position.  Since max_mp is non-null,
+         mp->prev must be non-null.  */
+      mp->prev->next = mp->next;
+      if (mp->next != NULL)
+	mp->next->prev = mp->prev;
+      else
+	minipool_vector_tail = mp->prev;
+
+      /* Re-insert it before MAX_MP.  */
+      mp->next = max_mp;
+      mp->prev = max_mp->prev;
+      max_mp->prev = mp;
+
+      if (mp->prev != NULL)
+	mp->prev->next = mp;
+      else
+	minipool_vector_head = mp;
+    }
+
+  /* Save the new entry.  */
+  max_mp = mp;
+
+  /* Scan over the preceding entries and adjust their addresses as required.
+   */
+  while (mp->prev != NULL
+	 && mp->prev->max_address > mp->max_address - mp->prev->fix_size)
+    {
+      mp->prev->max_address = mp->max_address - mp->prev->fix_size;
+      mp = mp->prev;
+    }
+
+  return max_mp;
+}
+
+
+/* Add a constant to the minipool for a forward reference.  Returns the
+   node added or NULL if the constant will not fit in this pool.  */
+static Mnode *
+add_minipool_forward_ref (Mfix * fix)
+{
+  /* If set, max_mp is the first pool_entry that has a lower constraint than
+     the one we are trying to add.  */
+  Mnode *max_mp = NULL;
+  HOST_WIDE_INT max_address = fix->address + fix->forwards;
+  Mnode *mp;
+
+  /* If this fix's address is greater than the address of the first entry,
+     then we can't put the fix in this pool.  We subtract the size of the
+     current fix to ensure that if the table is fully packed we still have
+     enough room to insert this value by suffling the other fixes forwards.  */
+  if (minipool_vector_head &&
+      fix->address >= minipool_vector_head->max_address - fix->fix_size)
+    return NULL;
+
+  /* Scan the pool to see if a constant with the same value has already been
+     added.  While we are doing this, also note the location where we must
+     insert the constant if it doesn't already exist.  */
+  for (mp = minipool_vector_head; mp != NULL; mp = mp->next)
+    {
+      if (GET_CODE (fix->value) == GET_CODE (mp->value)
+	  && fix->mode == mp->mode
+	  && (GET_CODE (fix->value) != CODE_LABEL
+	      || (CODE_LABEL_NUMBER (fix->value)
+		  == CODE_LABEL_NUMBER (mp->value)))
+	  && rtx_equal_p (fix->value, mp->value))
+	{
+	  /* More than one fix references this entry.  */
+	  mp->refcount++;
+	  return move_minipool_fix_forward_ref (mp, max_mp, max_address);
+	}
+
+      /* Note the insertion point if necessary.  */
+      if (max_mp == NULL && mp->max_address > max_address)
+	max_mp = mp;
+
+    }
+
+  /* The value is not currently in the minipool, so we need to create a new
+     entry for it.  If MAX_MP is NULL, the entry will be put on the end of
+     the list since the placement is less constrained than any existing
+     entry.  Otherwise, we insert the new fix before MAX_MP and, if
+     necessary, adjust the constraints on the other entries.  */
+  mp = xmalloc (sizeof (*mp));
+  mp->fix_size = fix->fix_size;
+  mp->mode = fix->mode;
+  mp->value = fix->value;
+  mp->refcount = 1;
+  /* Not yet required for a backwards ref.  */
+  mp->min_address = -65536;
+
+  if (max_mp == NULL)
+    {
+      mp->max_address = max_address;
+      mp->next = NULL;
+      mp->prev = minipool_vector_tail;
+
+      if (mp->prev == NULL)
+	{
+	  minipool_vector_head = mp;
+	  minipool_vector_label = gen_label_rtx ();
+	}
+      else
+	mp->prev->next = mp;
+
+      minipool_vector_tail = mp;
+    }
+  else
+    {
+      if (max_address > max_mp->max_address - mp->fix_size)
+	mp->max_address = max_mp->max_address - mp->fix_size;
+      else
+	mp->max_address = max_address;
+
+      mp->next = max_mp;
+      mp->prev = max_mp->prev;
+      max_mp->prev = mp;
+      if (mp->prev != NULL)
+	mp->prev->next = mp;
+      else
+	minipool_vector_head = mp;
+    }
+
+  /* Save the new entry.  */
+  max_mp = mp;
+
+  /* Scan over the preceding entries and adjust their addresses as required.
+   */
+  while (mp->prev != NULL
+	 && mp->prev->max_address > mp->max_address - mp->prev->fix_size)
+    {
+      mp->prev->max_address = mp->max_address - mp->prev->fix_size;
+      mp = mp->prev;
+    }
+
+  return max_mp;
+}
+
+
+static Mnode *
+move_minipool_fix_backward_ref (Mnode * mp, Mnode * min_mp,
+				HOST_WIDE_INT min_address)
+{
+  HOST_WIDE_INT offset;
+
+  /* This should never be true, and the code below assumes these are
+     different.  */
+  if (mp == min_mp)
+    abort ();
+
+  if (min_mp == NULL)
+    {
+      if (min_address > mp->min_address)
+	mp->min_address = min_address;
+    }
+  else
+    {
+      /* We will adjust this below if it is too loose.  */
+      mp->min_address = min_address;
+
+      /* Unlink MP from its current position.  Since min_mp is non-null,
+         mp->next must be non-null.  */
+      mp->next->prev = mp->prev;
+      if (mp->prev != NULL)
+	mp->prev->next = mp->next;
+      else
+	minipool_vector_head = mp->next;
+
+      /* Reinsert it after MIN_MP.  */
+      mp->prev = min_mp;
+      mp->next = min_mp->next;
+      min_mp->next = mp;
+      if (mp->next != NULL)
+	mp->next->prev = mp;
+      else
+	minipool_vector_tail = mp;
+    }
+
+  min_mp = mp;
+
+  offset = 0;
+  for (mp = minipool_vector_head; mp != NULL; mp = mp->next)
+    {
+      mp->offset = offset;
+      if (mp->refcount > 0)
+	offset += mp->fix_size;
+
+      if (mp->next && mp->next->min_address < mp->min_address + mp->fix_size)
+	mp->next->min_address = mp->min_address + mp->fix_size;
+    }
+
+  return min_mp;
+}
+
+
+/* Add a constant to the minipool for a backward reference.  Returns the
+   node added or NULL if the constant will not fit in this pool.
+
+   Note that the code for insertion for a backwards reference can be
+   somewhat confusing because the calculated offsets for each fix do
+   not take into account the size of the pool (which is still under
+   construction.  */
+static Mnode *
+add_minipool_backward_ref (Mfix * fix)
+{
+  /* If set, min_mp is the last pool_entry that has a lower constraint than
+     the one we are trying to add.  */
+  Mnode *min_mp = NULL;
+  /* This can be negative, since it is only a constraint.  */
+  HOST_WIDE_INT min_address = fix->address - fix->backwards;
+  Mnode *mp;
+
+  /* If we can't reach the current pool from this insn, or if we can't insert
+     this entry at the end of the pool without pushing other fixes out of
+     range, then we don't try.  This ensures that we can't fail later on.  */
+  if (min_address >= minipool_barrier->address
+      || (minipool_vector_tail->min_address + fix->fix_size
+	  >= minipool_barrier->address))
+    return NULL;
+
+  /* Scan the pool to see if a constant with the same value has already been
+     added.  While we are doing this, also note the location where we must
+     insert the constant if it doesn't already exist.  */
+  for (mp = minipool_vector_tail; mp != NULL; mp = mp->prev)
+    {
+      if (GET_CODE (fix->value) == GET_CODE (mp->value)
+	  && fix->mode == mp->mode
+	  && (GET_CODE (fix->value) != CODE_LABEL
+	      || (CODE_LABEL_NUMBER (fix->value)
+		  == CODE_LABEL_NUMBER (mp->value)))
+	  && rtx_equal_p (fix->value, mp->value)
+	  /* Check that there is enough slack to move this entry to the end
+	     of the table (this is conservative).  */
+	  && (mp->max_address
+	      > (minipool_barrier->address
+		 + minipool_vector_tail->offset
+		 + minipool_vector_tail->fix_size)))
+	{
+	  mp->refcount++;
+	  return move_minipool_fix_backward_ref (mp, min_mp, min_address);
+	}
+
+      if (min_mp != NULL)
+	mp->min_address += fix->fix_size;
+      else
+	{
+	  /* Note the insertion point if necessary.  */
+	  if (mp->min_address < min_address)
+	    {
+	      min_mp = mp;
+	    }
+	  else if (mp->max_address
+		   < minipool_barrier->address + mp->offset + fix->fix_size)
+	    {
+	      /* Inserting before this entry would push the fix beyond its
+	         maximum address (which can happen if we have re-located a
+	         forwards fix); force the new fix to come after it.  */
+	      min_mp = mp;
+	      min_address = mp->min_address + fix->fix_size;
+	    }
+	}
+    }
+
+  /* We need to create a new entry.  */
+  mp = xmalloc (sizeof (*mp));
+  mp->fix_size = fix->fix_size;
+  mp->mode = fix->mode;
+  mp->value = fix->value;
+  mp->refcount = 1;
+  mp->max_address = minipool_barrier->address + 65536;
+
+  mp->min_address = min_address;
+
+  if (min_mp == NULL)
+    {
+      mp->prev = NULL;
+      mp->next = minipool_vector_head;
+
+      if (mp->next == NULL)
+	{
+	  minipool_vector_tail = mp;
+	  minipool_vector_label = gen_label_rtx ();
+	}
+      else
+	mp->next->prev = mp;
+
+      minipool_vector_head = mp;
+    }
+  else
+    {
+      mp->next = min_mp->next;
+      mp->prev = min_mp;
+      min_mp->next = mp;
+
+      if (mp->next != NULL)
+	mp->next->prev = mp;
+      else
+	minipool_vector_tail = mp;
+    }
+
+  /* Save the new entry.  */
+  min_mp = mp;
+
+  if (mp->prev)
+    mp = mp->prev;
+  else
+    mp->offset = 0;
+
+  /* Scan over the following entries and adjust their offsets.  */
+  while (mp->next != NULL)
+    {
+      if (mp->next->min_address < mp->min_address + mp->fix_size)
+	mp->next->min_address = mp->min_address + mp->fix_size;
+
+      if (mp->refcount)
+	mp->next->offset = mp->offset + mp->fix_size;
+      else
+	mp->next->offset = mp->offset;
+
+      mp = mp->next;
+    }
+
+  return min_mp;
+}
+
+
+static void
+assign_minipool_offsets (Mfix * barrier)
+{
+  HOST_WIDE_INT offset = 0;
+  Mnode *mp;
+
+  minipool_barrier = barrier;
+
+  for (mp = minipool_vector_head; mp != NULL; mp = mp->next)
+    {
+      mp->offset = offset;
+
+      if (mp->refcount > 0)
+	offset += mp->fix_size;
+    }
+}
+
+
+/* Print a symbolic form of X to the debug file, F.  */
+static void
+avr32_print_value (FILE * f, rtx x)
+{
+  switch (GET_CODE (x))
+    {
+    case CONST_INT:
+      fprintf (f, "0x%x", (int) INTVAL (x));
+      return;
+
+    case CONST_DOUBLE:
+      fprintf (f, "<0x%lx,0x%lx>", (long) XWINT (x, 2), (long) XWINT (x, 3));
+      return;
+
+    case CONST_VECTOR:
+      {
+	int i;
+
+	fprintf (f, "<");
+	for (i = 0; i < CONST_VECTOR_NUNITS (x); i++)
+	  {
+	    fprintf (f, "0x%x", (int) INTVAL (CONST_VECTOR_ELT (x, i)));
+	    if (i < (CONST_VECTOR_NUNITS (x) - 1))
+	      fputc (',', f);
+	  }
+	fprintf (f, ">");
+      }
+      return;
+
+    case CONST_STRING:
+      fprintf (f, "\"%s\"", XSTR (x, 0));
+      return;
+
+    case SYMBOL_REF:
+      fprintf (f, "`%s'", XSTR (x, 0));
+      return;
+
+    case LABEL_REF:
+      fprintf (f, "L%d", INSN_UID (XEXP (x, 0)));
+      return;
+
+    case CONST:
+      avr32_print_value (f, XEXP (x, 0));
+      return;
+
+    case PLUS:
+      avr32_print_value (f, XEXP (x, 0));
+      fprintf (f, "+");
+      avr32_print_value (f, XEXP (x, 1));
+      return;
+
+    case PC:
+      fprintf (f, "pc");
+      return;
+
+    default:
+      fprintf (f, "????");
+      return;
+    }
+}
+
+
+int
+is_minipool_label (rtx label)
+{
+  minipool_labels *cur_mp_label = cfun->machine->minipool_label_head;
+
+  if (GET_CODE (label) != CODE_LABEL)
+    return FALSE;
+
+  while (cur_mp_label)
+    {
+      if (CODE_LABEL_NUMBER (label)
+	  == CODE_LABEL_NUMBER (cur_mp_label->label))
+	return TRUE;
+      cur_mp_label = cur_mp_label->next;
+    }
+  return FALSE;
+}
+
+
+static void
+new_minipool_label (rtx label)
+{
+  if (!cfun->machine->minipool_label_head)
+    {
+      cfun->machine->minipool_label_head =
+	ggc_alloc (sizeof (minipool_labels));
+      cfun->machine->minipool_label_tail = cfun->machine->minipool_label_head;
+      cfun->machine->minipool_label_head->label = label;
+      cfun->machine->minipool_label_head->next = 0;
+      cfun->machine->minipool_label_head->prev = 0;
+    }
+  else
+    {
+      cfun->machine->minipool_label_tail->next =
+	ggc_alloc (sizeof (minipool_labels));
+      cfun->machine->minipool_label_tail->next->label = label;
+      cfun->machine->minipool_label_tail->next->next = 0;
+      cfun->machine->minipool_label_tail->next->prev =
+	cfun->machine->minipool_label_tail;
+      cfun->machine->minipool_label_tail =
+	cfun->machine->minipool_label_tail->next;
+    }
+}
+
+
+/* Output the literal table */
+static void
+dump_minipool (rtx scan)
+{
+  Mnode *mp;
+  Mnode *nmp;
+
+  if (dump_file)
+    fprintf (dump_file,
+	     ";; Emitting minipool after insn %u; address %ld; align %d (bytes)\n",
+	     INSN_UID (scan), (unsigned long) minipool_barrier->address, 4);
+
+  scan = emit_insn_after (gen_consttable_start (), scan);
+  scan = emit_insn_after (gen_align_4 (), scan);
+  scan = emit_label_after (minipool_vector_label, scan);
+  new_minipool_label (minipool_vector_label);
+
+  for (mp = minipool_vector_head; mp != NULL; mp = nmp)
+    {
+      if (mp->refcount > 0)
+	{
+	  if (dump_file)
+	    {
+	      fprintf (dump_file,
+		       ";;  Offset %u, min %ld, max %ld ",
+		       (unsigned) mp->offset, (unsigned long) mp->min_address,
+		       (unsigned long) mp->max_address);
+	      avr32_print_value (dump_file, mp->value);
+	      fputc ('\n', dump_file);
+	    }
+
+	  switch (mp->fix_size)
+	    {
+#ifdef HAVE_consttable_4
+	    case 4:
+	      scan = emit_insn_after (gen_consttable_4 (mp->value), scan);
+	      break;
+
+#endif
+#ifdef HAVE_consttable_8
+	    case 8:
+	      scan = emit_insn_after (gen_consttable_8 (mp->value), scan);
+	      break;
+
+#endif
+#ifdef HAVE_consttable_16
+            case 16:
+              scan = emit_insn_after (gen_consttable_16 (mp->value), scan);
+              break;
+
+#endif
+            case 0:
+              /* This can happen for force-minipool entries which just are
+	         there to force the minipool to be generate. */
+	      break;
+	    default:
+	      abort ();
+	      break;
+	    }
+	}
+
+      nmp = mp->next;
+      free (mp);
+    }
+
+  minipool_vector_head = minipool_vector_tail = NULL;
+  scan = emit_insn_after (gen_consttable_end (), scan);
+  scan = emit_barrier_after (scan);
+}
+
+
+/* Return the cost of forcibly inserting a barrier after INSN.  */
+static int
+avr32_barrier_cost (rtx insn)
+{
+  /* Basing the location of the pool on the loop depth is preferable, but at
+     the moment, the basic block information seems to be corrupt by this
+     stage of the compilation.  */
+  int base_cost = 50;
+  rtx next = next_nonnote_insn (insn);
+
+  if (next != NULL && GET_CODE (next) == CODE_LABEL)
+    base_cost -= 20;
+
+  switch (GET_CODE (insn))
+    {
+    case CODE_LABEL:
+      /* It will always be better to place the table before the label, rather
+         than after it.  */
+      return 50;
+
+    case INSN:
+    case CALL_INSN:
+      return base_cost;
+
+    case JUMP_INSN:
+      return base_cost - 10;
+
+    default:
+      return base_cost + 10;
+    }
+}
+
+
+/* Find the best place in the insn stream in the range
+   (FIX->address,MAX_ADDRESS) to forcibly insert a minipool barrier.
+   Create the barrier by inserting a jump and add a new fix entry for
+   it.  */
+static Mfix *
+create_fix_barrier (Mfix * fix, HOST_WIDE_INT max_address)
+{
+  HOST_WIDE_INT count = 0;
+  rtx barrier;
+  rtx from = fix->insn;
+  rtx selected = from;
+  int selected_cost;
+  HOST_WIDE_INT selected_address;
+  Mfix *new_fix;
+  HOST_WIDE_INT max_count = max_address - fix->address;
+  rtx label = gen_label_rtx ();
+
+  selected_cost = avr32_barrier_cost (from);
+  selected_address = fix->address;
+
+  while (from && count < max_count)
+    {
+      rtx tmp;
+      int new_cost;
+
+      /* This code shouldn't have been called if there was a natural barrier
+         within range.  */
+      if (GET_CODE (from) == BARRIER)
+	abort ();
+
+      /* Count the length of this insn.  */
+      count += get_attr_length (from);
+
+      /* If there is a jump table, add its length.  */
+      tmp = is_jump_table (from);
+      if (tmp != NULL)
+	{
+	  count += get_jump_table_size (tmp);
+
+	  /* Jump tables aren't in a basic block, so base the cost on the
+	     dispatch insn.  If we select this location, we will still put
+	     the pool after the table.  */
+	  new_cost = avr32_barrier_cost (from);
+
+	  if (count < max_count && new_cost <= selected_cost)
+	    {
+	      selected = tmp;
+	      selected_cost = new_cost;
+	      selected_address = fix->address + count;
+	    }
+
+	  /* Continue after the dispatch table.  */
+	  from = NEXT_INSN (tmp);
+	  continue;
+	}
+
+      new_cost = avr32_barrier_cost (from);
+
+      if (count < max_count && new_cost <= selected_cost)
+	{
+	  selected = from;
+	  selected_cost = new_cost;
+	  selected_address = fix->address + count;
+	}
+
+      from = NEXT_INSN (from);
+    }
+
+  /* Create a new JUMP_INSN that branches around a barrier.  */
+  from = emit_jump_insn_after (gen_jump (label), selected);
+  JUMP_LABEL (from) = label;
+  barrier = emit_barrier_after (from);
+  emit_label_after (label, barrier);
+
+  /* Create a minipool barrier entry for the new barrier.  */
+  new_fix = (Mfix *) obstack_alloc (&minipool_obstack, sizeof (*new_fix));
+  new_fix->insn = barrier;
+  new_fix->address = selected_address;
+  new_fix->next = fix->next;
+  fix->next = new_fix;
+
+  return new_fix;
+}
+
+
+/* Record that there is a natural barrier in the insn stream at
+   ADDRESS.  */
+static void
+push_minipool_barrier (rtx insn, HOST_WIDE_INT address)
+{
+  Mfix *fix = (Mfix *) obstack_alloc (&minipool_obstack, sizeof (*fix));
+
+  fix->insn = insn;
+  fix->address = address;
+
+  fix->next = NULL;
+  if (minipool_fix_head != NULL)
+    minipool_fix_tail->next = fix;
+  else
+    minipool_fix_head = fix;
+
+  minipool_fix_tail = fix;
+}
+
+
+/* Record INSN, which will need fixing up to load a value from the
+   minipool.  ADDRESS is the offset of the insn since the start of the
+   function; LOC is a pointer to the part of the insn which requires
+   fixing; VALUE is the constant that must be loaded, which is of type
+   MODE.  */
+static void
+push_minipool_fix (rtx insn, HOST_WIDE_INT address, rtx * loc,
+		   enum machine_mode mode, rtx value)
+{
+  Mfix *fix = (Mfix *) obstack_alloc (&minipool_obstack, sizeof (*fix));
+  rtx body = PATTERN (insn);
+
+  fix->insn = insn;
+  fix->address = address;
+  fix->loc = loc;
+  fix->mode = mode;
+  fix->fix_size = MINIPOOL_FIX_SIZE (mode, value);
+  fix->value = value;
+
+  if (GET_CODE (body) == PARALLEL)
+    {
+      /* Mcall : Ks16 << 2 */
+      fix->forwards = ((1 << 15) - 1) << 2;
+      fix->backwards = (1 << 15) << 2;
+    }
+  else if (GET_CODE (body) == SET
+           && GET_MODE_SIZE (GET_MODE (SET_DEST (body))) == 4)
+    {
+          if (optimize_size)
+            {
+              /* Lddpc : Ku7 << 2 */
+              fix->forwards = ((1 << 7) - 1) << 2;
+              fix->backwards = 0;
+            }
+          else
+            {
+              /* Ld.w : Ks16 */
+              fix->forwards = ((1 << 15) - 4);
+              fix->backwards = (1 << 15);
+            }
+        }
+  else if (GET_CODE (body) == SET
+           && GET_MODE_SIZE (GET_MODE (SET_DEST (body))) == 8)
+    {
+          /* Ld.d : Ks16 */
+          fix->forwards = ((1 << 15) - 4);
+          fix->backwards = (1 << 15);
+        }
+  else if (GET_CODE (body) == UNSPEC_VOLATILE
+           && XINT (body, 1) == VUNSPEC_MVRC)
+    {
+      /* Coprocessor load */
+      /* Ldc : Ku8 << 2 */
+      fix->forwards = ((1 << 8) - 1) << 2;
+      fix->backwards = 0;
+    }
+  else
+    {
+      /* Assume worst case which is lddpc insn. */
+      fix->forwards = ((1 << 7) - 1) << 2;
+      fix->backwards = 0;
+    }
+
+  fix->minipool = NULL;
+
+  /* If an insn doesn't have a range defined for it, then it isn't expecting
+     to be reworked by this code.  Better to abort now than to generate duff
+     assembly code.  */
+  if (fix->forwards == 0 && fix->backwards == 0)
+    abort ();
+
+  if (dump_file)
+    {
+      fprintf (dump_file,
+	       ";; %smode fixup for i%d; addr %lu, range (%ld,%ld): ",
+	       GET_MODE_NAME (mode),
+	       INSN_UID (insn), (unsigned long) address,
+	       -1 * (long) fix->backwards, (long) fix->forwards);
+      avr32_print_value (dump_file, fix->value);
+      fprintf (dump_file, "\n");
+    }
+
+  /* Add it to the chain of fixes.  */
+  fix->next = NULL;
+
+  if (minipool_fix_head != NULL)
+    minipool_fix_tail->next = fix;
+  else
+    minipool_fix_head = fix;
+
+  minipool_fix_tail = fix;
+}
+
+
+/* Scan INSN and note any of its operands that need fixing.
+   If DO_PUSHES is false we do not actually push any of the fixups
+   needed.  The function returns TRUE is any fixups were needed/pushed.
+   This is used by avr32_memory_load_p() which needs to know about loads
+   of constants that will be converted into minipool loads.  */
+static bool
+note_invalid_constants (rtx insn, HOST_WIDE_INT address, int do_pushes)
+{
+  bool result = false;
+  int opno;
+
+  extract_insn (insn);
+
+  if (!constrain_operands (1))
+    fatal_insn_not_found (insn);
+
+  if (recog_data.n_alternatives == 0)
+    return false;
+
+  /* Fill in recog_op_alt with information about the constraints of this
+     insn.  */
+  preprocess_constraints ();
+
+  for (opno = 0; opno < recog_data.n_operands; opno++)
+    {
+      rtx op;
+
+      /* Things we need to fix can only occur in inputs.  */
+      if (recog_data.operand_type[opno] != OP_IN)
+	continue;
+
+      op = recog_data.operand[opno];
+
+      if (avr32_const_pool_ref_operand (op, GET_MODE (op)))
+	{
+	  if (do_pushes)
+	    {
+	      rtx cop = avoid_constant_pool_reference (op);
+
+	      /* Casting the address of something to a mode narrower than a
+	         word can cause avoid_constant_pool_reference() to return the
+	         pool reference itself.  That's no good to us here.  Lets
+	         just hope that we can use the constant pool value directly.
+	       */
+	      if (op == cop)
+		cop = get_pool_constant (XEXP (op, 0));
+
+	      push_minipool_fix (insn, address,
+				 recog_data.operand_loc[opno],
+				 recog_data.operand_mode[opno], cop);
+	    }
+
+	  result = true;
+	}
+      else if (TARGET_HAS_ASM_ADDR_PSEUDOS
+	       && avr32_address_operand (op, GET_MODE (op)))
+	{
+	  /* Handle pseudo instructions using a direct address. These pseudo
+	     instructions might need entries in the constant pool and we must
+	     therefor create a constant pool for them, in case the
+	     assembler/linker needs to insert entries. */
+	  if (do_pushes)
+	    {
+	      /* Push a dummy constant pool entry so that the .cpool
+	         directive should be inserted on the appropriate place in the
+	         code even if there are no real constant pool entries. This
+	         is used by the assembler and linker to know where to put
+	         generated constant pool entries. */
+	      push_minipool_fix (insn, address,
+				 recog_data.operand_loc[opno],
+				 recog_data.operand_mode[opno],
+				 gen_rtx_UNSPEC (VOIDmode,
+						 gen_rtvec (1, const0_rtx),
+						 UNSPEC_FORCE_MINIPOOL));
+	      result = true;
+	    }
+	}
+    }
+  return result;
+}
+
+
+static int
+avr32_insn_is_cast (rtx insn)
+{
+
+  if (NONJUMP_INSN_P (insn)
+      && GET_CODE (PATTERN (insn)) == SET
+      && (GET_CODE (SET_SRC (PATTERN (insn))) == ZERO_EXTEND
+	  || GET_CODE (SET_SRC (PATTERN (insn))) == SIGN_EXTEND)
+      && REG_P (XEXP (SET_SRC (PATTERN (insn)), 0))
+      && REG_P (SET_DEST (PATTERN (insn))))
+    return true;
+  return false;
+}
+
+
+/* Replace all occurances of reg FROM with reg TO in X. */
+rtx
+avr32_replace_reg (rtx x, rtx from, rtx to)
+{
+  int i, j;
+  const char *fmt;
+
+  gcc_assert ( REG_P (from) && REG_P (to) );
+
+  /* Allow this function to make replacements in EXPR_LISTs.  */
+  if (x == 0)
+    return 0;
+
+  if (rtx_equal_p (x, from))
+    return to;
+
+  if (GET_CODE (x) == SUBREG)
+    {
+      rtx new = avr32_replace_reg (SUBREG_REG (x), from, to);
+
+      if (GET_CODE (new) == CONST_INT)
+	{
+	  x = simplify_subreg (GET_MODE (x), new,
+			       GET_MODE (SUBREG_REG (x)),
+			       SUBREG_BYTE (x));
+	  gcc_assert (x);
+	}
+      else
+	SUBREG_REG (x) = new;
+
+      return x;
+    }
+  else if (GET_CODE (x) == ZERO_EXTEND)
+    {
+      rtx new = avr32_replace_reg (XEXP (x, 0), from, to);
+
+      if (GET_CODE (new) == CONST_INT)
+	{
+	  x = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),
+					new, GET_MODE (XEXP (x, 0)));
+	  gcc_assert (x);
+	}
+      else
+	XEXP (x, 0) = new;
+
+      return x;
+    }
+
+  fmt = GET_RTX_FORMAT (GET_CODE (x));
+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)
+    {
+      if (fmt[i] == 'e')
+	XEXP (x, i) = avr32_replace_reg (XEXP (x, i), from, to);
+      else if (fmt[i] == 'E')
+	for (j = XVECLEN (x, i) - 1; j >= 0; j--)
+	  XVECEXP (x, i, j) = avr32_replace_reg (XVECEXP (x, i, j), from, to);
+    }
+
+  return x;
+}
+
+
+/* FIXME: The level of nesting in this function is way too deep. It needs to be
+   torn apart.  */
+static void
+avr32_reorg_optimization (void)
+{
+  rtx first = get_first_nonnote_insn ();
+  rtx insn;
+
+  if (TARGET_MD_REORG_OPTIMIZATION && (optimize_size || (optimize > 0)))
+    {
+
+      /* Scan through all insns looking for cast operations. */
+      if (dump_file)
+	{
+	  fprintf (dump_file, ";; Deleting redundant cast operations:\n");
+	}
+      for (insn = first; insn; insn = NEXT_INSN (insn))
+	{
+	  rtx reg, src_reg, scan;
+	  enum machine_mode mode;
+	  int unused_cast;
+	  rtx label_ref;
+
+	  if (avr32_insn_is_cast (insn)
+	      && (GET_MODE (XEXP (SET_SRC (PATTERN (insn)), 0)) == QImode
+		  || GET_MODE (XEXP (SET_SRC (PATTERN (insn)), 0)) == HImode))
+	    {
+	      mode = GET_MODE (XEXP (SET_SRC (PATTERN (insn)), 0));
+	      reg = SET_DEST (PATTERN (insn));
+	      src_reg = XEXP (SET_SRC (PATTERN (insn)), 0);
+	    }
+	  else
+	    {
+	      continue;
+	    }
+
+	  unused_cast = false;
+	  label_ref = NULL_RTX;
+	  for (scan = NEXT_INSN (insn); scan; scan = NEXT_INSN (scan))
+	    {
+	      /* Check if we have reached the destination of a simple
+	         conditional jump which we have already scanned past. If so,
+	         we can safely continue scanning. */
+	      if (LABEL_P (scan) && label_ref != NULL_RTX)
+		{
+		  if (CODE_LABEL_NUMBER (scan) ==
+		      CODE_LABEL_NUMBER (XEXP (label_ref, 0)))
+		    label_ref = NULL_RTX;
+		  else
+		    break;
+		}
+
+	      if (!INSN_P (scan))
+		continue;
+
+	      /* For conditional jumps we can manage to keep on scanning if
+	         we meet the destination label later on before any new jump
+	         insns occure. */
+	      if (GET_CODE (scan) == JUMP_INSN)
+		{
+		  if (any_condjump_p (scan) && label_ref == NULL_RTX)
+		    label_ref = condjump_label (scan);
+		  else
+		    break;
+		}
+
+              /* Check if we have a call and the register is used as an argument. */
+              if (CALL_P (scan)
+                  && find_reg_fusage (scan, USE, reg) )
+                break;
+
+	      if (!reg_mentioned_p (reg, PATTERN (scan)))
+		continue;
+
+	      /* Check if casted register is used in this insn */
+	      if ((regno_use_in (REGNO (reg), PATTERN (scan)) != NULL_RTX)
+		  && (GET_MODE (regno_use_in (REGNO (reg), PATTERN (scan))) ==
+		      GET_MODE (reg)))
+		{
+		  /* If not used in the source to the set or in a memory
+		     expression in the destiantion then the register is used
+		     as a destination and is really dead. */
+		  if (single_set (scan)
+		      && GET_CODE (PATTERN (scan)) == SET
+		      && REG_P (SET_DEST (PATTERN (scan)))
+		      && !regno_use_in (REGNO (reg), SET_SRC (PATTERN (scan)))
+		      && label_ref == NULL_RTX)
+		    {
+		      unused_cast = true;
+		    }
+		  break;
+		}
+
+	      /* Check if register is dead or set in this insn */
+	      if (dead_or_set_p (scan, reg))
+		{
+		  unused_cast = true;
+		  break;
+		}
+	    }
+
+	  /* Check if we have unresolved conditional jumps */
+	  if (label_ref != NULL_RTX)
+	    continue;
+
+	  if (unused_cast)
+	    {
+	      if (REGNO (reg) == REGNO (XEXP (SET_SRC (PATTERN (insn)), 0)))
+		{
+		  /* One operand cast, safe to delete */
+		  if (dump_file)
+		    {
+		      fprintf (dump_file,
+			       ";;  INSN %i removed, casted register %i value not used.\n",
+			       INSN_UID (insn), REGNO (reg));
+		    }
+		  SET_INSN_DELETED (insn);
+		  /* Force the instruction to be recognized again */
+		  INSN_CODE (insn) = -1;
+		}
+	      else
+		{
+		  /* Two operand cast, which really could be substituted with
+		     a move, if the source register is dead after the cast
+		     insn and then the insn which sets the source register
+		     could instead directly set the destination register for
+		     the cast. As long as there are no insns in between which
+		     uses the register. */
+		  rtx link = NULL_RTX;
+		  rtx set;
+		  rtx src_reg = XEXP (SET_SRC (PATTERN (insn)), 0);
+		  unused_cast = false;
+
+		  if (!find_reg_note (insn, REG_DEAD, src_reg))
+		    continue;
+
+		  /* Search for the insn which sets the source register */
+                  for (scan = PREV_INSN (insn);
+                       scan && GET_CODE (scan) != CODE_LABEL;
+                       scan = PREV_INSN (scan))
+                    {
+                      if (! INSN_P (scan))
+                        continue;
+
+		      set = single_set (scan);
+                      // Fix for bug #11763 : the following if condition
+                      // has been modified and else part is included to 
+                      // set the link to NULL_RTX. 
+                      // if (set && rtx_equal_p (src_reg, SET_DEST (set)))
+                      if (set && (REGNO(src_reg) == REGNO(SET_DEST(set))))
+                       {
+                         if (rtx_equal_p (src_reg, SET_DEST (set)))
+			  {
+			    link = scan;
+			    break;
+                          }
+                         else
+                          {
+                            link = NULL_RTX;
+                            break;
+                          }
+                       }
+                    }
+
+
+		  /* Found no link or link is a call insn where we can not
+		     change the destination register */
+		  if (link == NULL_RTX || CALL_P (link))
+		    continue;
+
+		  /* Scan through all insn between link and insn */
+		  for (scan = NEXT_INSN (link); scan; scan = NEXT_INSN (scan))
+		    {
+		      /* Don't try to trace forward past a CODE_LABEL if we
+		         haven't seen INSN yet.  Ordinarily, we will only
+		         find the setting insn in LOG_LINKS if it is in the
+		         same basic block.  However, cross-jumping can insert
+		         code labels in between the load and the call, and
+		         can result in situations where a single call insn
+		         may have two targets depending on where we came
+		         from.  */
+
+		      if (GET_CODE (scan) == CODE_LABEL)
+			break;
+
+		      if (!INSN_P (scan))
+			continue;
+
+		      /* Don't try to trace forward past a JUMP.  To optimize
+		         safely, we would have to check that all the
+		         instructions at the jump destination did not use REG.
+		       */
+
+		      if (GET_CODE (scan) == JUMP_INSN)
+			{
+			  break;
+			}
+
+		      if (!reg_mentioned_p (src_reg, PATTERN (scan)))
+			continue;
+
+		      /* We have reached the cast insn */
+		      if (scan == insn)
+			{
+			  /* We can remove cast and replace the destination
+			     register of the link insn with the destination
+			     of the cast */
+			  if (dump_file)
+			    {
+			      fprintf (dump_file,
+				       ";;  INSN %i removed, casted value unused. "
+				       "Destination of removed cast operation: register %i,  folded into INSN %i.\n",
+				       INSN_UID (insn), REGNO (reg),
+				       INSN_UID (link));
+			    }
+			  /* Update link insn */
+			  SET_DEST (PATTERN (link)) =
+			    gen_rtx_REG (mode, REGNO (reg));
+			  /* Force the instruction to be recognized again */
+			  INSN_CODE (link) = -1;
+
+			  /* Delete insn */
+			  SET_INSN_DELETED (insn);
+			  /* Force the instruction to be recognized again */
+			  INSN_CODE (insn) = -1;
+			  break;
+			}
+		    }
+		}
+	    }
+	}
+    }
+
+  /* Disabled this optimization since it has a bug */
+  /* In the case where the data instruction the shifted insn gets folded
+   * into is a branch destination, this breaks, i.e.
+   *
+   *    add r8, r10, r8 << 2
+   * 1:
+   *    ld.w r11, r8[0]
+   *    ...
+   *    mov r8, sp
+   *    rjmp 1b
+   *
+   * gets folded to:
+   *
+   * 1:
+   *    ld.w r11, r10[r8 << 2]
+   *    ...
+   *    mov r8, sp
+   *    rjmp 1b
+   *
+   * which is clearly wrong..
+   */
+  if (0 && TARGET_MD_REORG_OPTIMIZATION && (optimize_size || (optimize > 0)))
+    {
+
+      /* Scan through all insns looking for shifted add operations */
+      if (dump_file)
+	{
+	  fprintf (dump_file,
+		   ";; Deleting redundant shifted add operations:\n");
+	}
+      for (insn = first; insn; insn = NEXT_INSN (insn))
+	{
+	  rtx reg, mem_expr, scan, op0, op1;
+	  int add_only_used_as_pointer;
+
+	  if (INSN_P (insn)
+	      && GET_CODE (PATTERN (insn)) == SET
+	      && GET_CODE (SET_SRC (PATTERN (insn))) == PLUS
+	      && (GET_CODE (XEXP (SET_SRC (PATTERN (insn)), 0)) == MULT
+		  || GET_CODE (XEXP (SET_SRC (PATTERN (insn)), 0)) == ASHIFT)
+	      && GET_CODE (XEXP (XEXP (SET_SRC (PATTERN (insn)), 0), 1)) ==
+	      CONST_INT && REG_P (SET_DEST (PATTERN (insn)))
+	      && REG_P (XEXP (SET_SRC (PATTERN (insn)), 1))
+	      && REG_P (XEXP (XEXP (SET_SRC (PATTERN (insn)), 0), 0)))
+	    {
+	      reg = SET_DEST (PATTERN (insn));
+	      mem_expr = SET_SRC (PATTERN (insn));
+	      op0 = XEXP (XEXP (mem_expr, 0), 0);
+	      op1 = XEXP (mem_expr, 1);
+	    }
+	  else
+	    {
+	      continue;
+	    }
+
+	  /* Scan forward the check if the result of the shifted add
+	     operation is only used as an address in memory operations and
+	     that the operands to the shifted add are not clobbered. */
+	  add_only_used_as_pointer = false;
+	  for (scan = NEXT_INSN (insn); scan; scan = NEXT_INSN (scan))
+	    {
+	      if (!INSN_P (scan))
+		continue;
+
+	      /* Don't try to trace forward past a JUMP or CALL.  To optimize
+	         safely, we would have to check that all the instructions at
+	         the jump destination did not use REG.  */
+
+	      if (GET_CODE (scan) == JUMP_INSN)
+		{
+		  break;
+		}
+
+	      /* If used in a call insn then we cannot optimize it away */
+	      if (CALL_P (scan) && find_regno_fusage (scan, USE, REGNO (reg)))
+		break;
+
+	      /* If any of the operands of the shifted add are clobbered we
+	         cannot optimize the shifted adda away */
+	      if ((reg_set_p (op0, scan) && (REGNO (op0) != REGNO (reg)))
+		  || (reg_set_p (op1, scan) && (REGNO (op1) != REGNO (reg))))
+		break;
+
+	      if (!reg_mentioned_p (reg, PATTERN (scan)))
+		continue;
+
+	      /* If used any other place than as a pointer or as the
+	         destination register we failed */
+              if (!(single_set (scan)
+                    && GET_CODE (PATTERN (scan)) == SET
+                    && ((MEM_P (SET_DEST (PATTERN (scan)))
+                         && REG_P (XEXP (SET_DEST (PATTERN (scan)), 0))
+                         && REGNO (XEXP (SET_DEST (PATTERN (scan)), 0)) == REGNO (reg))
+                        || (MEM_P (SET_SRC (PATTERN (scan)))
+                            && REG_P (XEXP (SET_SRC (PATTERN (scan)), 0))
+                            && REGNO (XEXP
+                                      (SET_SRC (PATTERN (scan)), 0)) == REGNO (reg))))
+                  && !(GET_CODE (PATTERN (scan)) == SET
+                       && REG_P (SET_DEST (PATTERN (scan)))
+                       && !regno_use_in (REGNO (reg),
+                                         SET_SRC (PATTERN (scan)))))
+                break;
+
+              /* We cannot replace the pointer in TImode insns
+                 as these has a differene addressing mode than the other
+                 memory insns. */
+              if ( GET_MODE (SET_DEST (PATTERN (scan))) == TImode )
+                break;
+
+	      /* Check if register is dead or set in this insn */
+	      if (dead_or_set_p (scan, reg))
+		{
+		  add_only_used_as_pointer = true;
+		  break;
+		}
+	    }
+
+	  if (add_only_used_as_pointer)
+	    {
+	      /* Lets delete the add insn and replace all memory references
+	         which uses the pointer with the full expression. */
+	      if (dump_file)
+		{
+		  fprintf (dump_file,
+			   ";; Deleting INSN %i since address expression can be folded into all "
+			   "memory references using this expression\n",
+			   INSN_UID (insn));
+		}
+	      SET_INSN_DELETED (insn);
+	      /* Force the instruction to be recognized again */
+	      INSN_CODE (insn) = -1;
+
+	      for (scan = NEXT_INSN (insn); scan; scan = NEXT_INSN (scan))
+		{
+		  if (!INSN_P (scan))
+		    continue;
+
+		  if (!reg_mentioned_p (reg, PATTERN (scan)))
+		    continue;
+
+		  /* If used any other place than as a pointer or as the
+		     destination register we failed */
+		  if ((single_set (scan)
+		       && GET_CODE (PATTERN (scan)) == SET
+		       && ((MEM_P (SET_DEST (PATTERN (scan)))
+			    && REG_P (XEXP (SET_DEST (PATTERN (scan)), 0))
+			    && REGNO (XEXP (SET_DEST (PATTERN (scan)), 0)) ==
+			    REGNO (reg)) || (MEM_P (SET_SRC (PATTERN (scan)))
+					     &&
+					     REG_P (XEXP
+						    (SET_SRC (PATTERN (scan)),
+						     0))
+					     &&
+					     REGNO (XEXP
+						    (SET_SRC (PATTERN (scan)),
+						     0)) == REGNO (reg)))))
+		    {
+		      if (dump_file)
+			{
+			  fprintf (dump_file,
+				   ";; Register %i replaced by indexed address in INSN %i\n",
+				   REGNO (reg), INSN_UID (scan));
+			}
+		      if (MEM_P (SET_DEST (PATTERN (scan))))
+			XEXP (SET_DEST (PATTERN (scan)), 0) = mem_expr;
+		      else
+			XEXP (SET_SRC (PATTERN (scan)), 0) = mem_expr;
+		    }
+
+		  /* Check if register is dead or set in this insn */
+		  if (dead_or_set_p (scan, reg))
+		    {
+		      break;
+		    }
+
+		}
+	    }
+	}
+    }
+
+
+  if (TARGET_MD_REORG_OPTIMIZATION && (optimize_size || (optimize > 0)))
+    {
+
+      /* Scan through all insns looking for conditional register to
+         register move operations */
+      if (dump_file)
+	{
+	  fprintf (dump_file,
+		   ";; Folding redundant conditional move operations:\n");
+	}
+      for (insn = first; insn; insn = next_nonnote_insn (insn))
+	{
+	  rtx src_reg, dst_reg, scan, test;
+
+	  if (INSN_P (insn)
+              && GET_CODE (PATTERN (insn)) == COND_EXEC
+	      && GET_CODE (COND_EXEC_CODE (PATTERN (insn))) == SET
+	      && REG_P (SET_SRC (COND_EXEC_CODE (PATTERN (insn))))
+	      && REG_P (SET_DEST (COND_EXEC_CODE (PATTERN (insn))))
+              && find_reg_note (insn, REG_DEAD, SET_SRC (COND_EXEC_CODE (PATTERN (insn)))))
+	    {
+	      src_reg = SET_SRC (COND_EXEC_CODE (PATTERN (insn)));
+	      dst_reg = SET_DEST (COND_EXEC_CODE (PATTERN (insn)));
+              test = COND_EXEC_TEST (PATTERN (insn));
+	    }
+	  else
+	    {
+	      continue;
+	    }
+
+          /* Scan backward through the rest of insns in this if-then or if-else
+             block and check if we can fold the move into another of the conditional
+             insns in the same block. */
+          scan = prev_nonnote_insn (insn);
+          while (INSN_P (scan)
+                 && GET_CODE (PATTERN (scan)) == COND_EXEC
+                 && rtx_equal_p (COND_EXEC_TEST (PATTERN (scan)), test))
+            {
+              rtx pattern = COND_EXEC_CODE (PATTERN (scan));
+              if ( GET_CODE (pattern) == PARALLEL )
+                pattern = XVECEXP (pattern, 0, 0);
+
+              if ( reg_set_p (src_reg, pattern) )
+                {
+                  /* Fold in the destination register for the cond. move
+                     into this insn. */
+                  SET_DEST (pattern) = dst_reg;
+                  if (dump_file)
+                    {
+                      fprintf (dump_file,
+                               ";; Deleting INSN %i since this operation can be folded into INSN %i\n",
+                               INSN_UID (insn), INSN_UID (scan));
+                    }
+
+                  /* Scan and check if any of the insns in between uses the src_reg. We
+                     must then replace it with the dst_reg. */
+                  while ( (scan = next_nonnote_insn (scan)) != insn ){
+                    avr32_replace_reg (scan, src_reg, dst_reg);
+                  }
+                  /* Delete the insn. */
+                  SET_INSN_DELETED (insn);
+
+                  /* Force the instruction to be recognized again */
+                  INSN_CODE (insn) = -1;
+                  break;
+                }
+
+              /* If the destination register is used but not set in this insn
+                 we cannot fold. */
+              if ( reg_mentioned_p (dst_reg, pattern) )
+                break;
+
+              scan = prev_nonnote_insn (scan);
+            }
+        }
+    }
+
+}
+
+
+/* Exported to toplev.c.
+
+   Do a final pass over the function, just before delayed branch
+   scheduling.  */
+static void
+avr32_reorg (void)
+{
+  rtx insn;
+  HOST_WIDE_INT address = 0;
+  Mfix *fix;
+
+  minipool_fix_head = minipool_fix_tail = NULL;
+
+  /* The first insn must always be a note, or the code below won't scan it
+     properly.  */
+  insn = get_insns ();
+  if (GET_CODE (insn) != NOTE)
+    abort ();
+
+  /* Scan all the insns and record the operands that will need fixing.  */
+  for (insn = next_nonnote_insn (insn); insn; insn = next_nonnote_insn (insn))
+    {
+      if (GET_CODE (insn) == BARRIER)
+	push_minipool_barrier (insn, address);
+      else if (INSN_P (insn))
+	{
+	  rtx table;
+
+	  note_invalid_constants (insn, address, true);
+	  address += get_attr_length (insn);
+
+	  /* If the insn is a vector jump, add the size of the table and skip
+	     the table.  */
+	  if ((table = is_jump_table (insn)) != NULL)
+	    {
+	      address += get_jump_table_size (table);
+	      insn = table;
+	    }
+	}
+    }
+
+  fix = minipool_fix_head;
+
+  /* Now scan the fixups and perform the required changes.  */
+  while (fix)
+    {
+      Mfix *ftmp;
+      Mfix *fdel;
+      Mfix *last_added_fix;
+      Mfix *last_barrier = NULL;
+      Mfix *this_fix;
+
+      /* Skip any further barriers before the next fix.  */
+      while (fix && GET_CODE (fix->insn) == BARRIER)
+	fix = fix->next;
+
+      /* No more fixes.  */
+      if (fix == NULL)
+	break;
+
+      last_added_fix = NULL;
+
+      for (ftmp = fix; ftmp; ftmp = ftmp->next)
+	{
+	  if (GET_CODE (ftmp->insn) == BARRIER)
+	    {
+	      if (ftmp->address >= minipool_vector_head->max_address)
+		break;
+
+	      last_barrier = ftmp;
+	    }
+	  else if ((ftmp->minipool = add_minipool_forward_ref (ftmp)) == NULL)
+	    break;
+
+	  last_added_fix = ftmp;	/* Keep track of the last fix added.
+					 */
+	}
+
+      /* If we found a barrier, drop back to that; any fixes that we could
+         have reached but come after the barrier will now go in the next
+         mini-pool.  */
+      if (last_barrier != NULL)
+	{
+	  /* Reduce the refcount for those fixes that won't go into this pool
+	     after all.  */
+	  for (fdel = last_barrier->next;
+	       fdel && fdel != ftmp; fdel = fdel->next)
+	    {
+	      fdel->minipool->refcount--;
+	      fdel->minipool = NULL;
+	    }
+
+	  ftmp = last_barrier;
+	}
+      else
+	{
+	  /* ftmp is first fix that we can't fit into this pool and there no
+	     natural barriers that we could use.  Insert a new barrier in the
+	     code somewhere between the previous fix and this one, and
+	     arrange to jump around it.  */
+	  HOST_WIDE_INT max_address;
+
+	  /* The last item on the list of fixes must be a barrier, so we can
+	     never run off the end of the list of fixes without last_barrier
+	     being set.  */
+	  if (ftmp == NULL)
+	    abort ();
+
+	  max_address = minipool_vector_head->max_address;
+	  /* Check that there isn't another fix that is in range that we
+	     couldn't fit into this pool because the pool was already too
+	     large: we need to put the pool before such an instruction.  */
+	  if (ftmp->address < max_address)
+	    max_address = ftmp->address;
+
+	  last_barrier = create_fix_barrier (last_added_fix, max_address);
+	}
+
+      assign_minipool_offsets (last_barrier);
+
+      while (ftmp)
+	{
+	  if (GET_CODE (ftmp->insn) != BARRIER
+	      && ((ftmp->minipool = add_minipool_backward_ref (ftmp))
+		  == NULL))
+	    break;
+
+	  ftmp = ftmp->next;
+	}
+
+      /* Scan over the fixes we have identified for this pool, fixing them up
+         and adding the constants to the pool itself.  */
+        for (this_fix = fix; this_fix && ftmp != this_fix;
+             this_fix = this_fix->next)
+          if (GET_CODE (this_fix->insn) != BARRIER
+              /* Do nothing for entries present just to force the insertion of
+	       a minipool. */
+	    && !IS_FORCE_MINIPOOL (this_fix->value))
+	  {
+	    rtx addr = plus_constant (gen_rtx_LABEL_REF (VOIDmode,
+							 minipool_vector_label),
+				      this_fix->minipool->offset);
+	    *this_fix->loc = gen_rtx_MEM (this_fix->mode, addr);
+	  }
+
+      dump_minipool (last_barrier->insn);
+      fix = ftmp;
+    }
+
+  /* Free the minipool memory.  */
+  obstack_free (&minipool_obstack, minipool_startobj);
+
+  avr32_reorg_optimization ();
+}
+
+
+/* Hook for doing some final scanning of instructions. Does nothing yet...*/
+void
+avr32_final_prescan_insn (rtx insn ATTRIBUTE_UNUSED,
+			  rtx * opvec ATTRIBUTE_UNUSED,
+			  int noperands ATTRIBUTE_UNUSED)
+{
+  return;
+}
+
+
+/* Function for changing the condition on the next instruction,
+   should be used when emmiting compare instructions and
+   the condition of the next instruction needs to change.
+*/
+int
+set_next_insn_cond (rtx cur_insn, rtx new_cond)
+{
+  rtx next_insn = next_nonnote_insn (cur_insn);
+   if ((next_insn != NULL_RTX)
+       && (INSN_P (next_insn)))
+     {
+       if ((GET_CODE (PATTERN (next_insn)) == SET)
+           && (GET_CODE (SET_SRC (PATTERN (next_insn))) == IF_THEN_ELSE))
+         {
+           /* Branch instructions */
+           XEXP (SET_SRC (PATTERN (next_insn)), 0) = new_cond;
+           /* Force the instruction to be recognized again */
+           INSN_CODE (next_insn) = -1;
+           return TRUE;
+         }
+       else if ((GET_CODE (PATTERN (next_insn)) == SET)
+                && avr32_comparison_operator (SET_SRC (PATTERN (next_insn)),
+                                              GET_MODE (SET_SRC (PATTERN (next_insn)))))
+         {
+           /* scc with no compare */
+           SET_SRC (PATTERN (next_insn)) = new_cond;
+           /* Force the instruction to be recognized again */
+           INSN_CODE (next_insn) = -1;
+           return TRUE;
+         }
+       else if (GET_CODE (PATTERN (next_insn)) == COND_EXEC)
+         {
+           if ( GET_CODE (new_cond) == UNSPEC )
+             {
+               COND_EXEC_TEST (PATTERN (next_insn)) =
+                 gen_rtx_UNSPEC (CCmode,
+                                 gen_rtvec (2,
+                                            XEXP (COND_EXEC_TEST (PATTERN (next_insn)), 0),
+                                            XEXP (COND_EXEC_TEST (PATTERN (next_insn)), 1)),
+                                 XINT (new_cond, 1));
+             }
+           else
+             {
+               PUT_CODE(COND_EXEC_TEST (PATTERN (next_insn)), GET_CODE(new_cond));
+             }
+         }
+     }
+
+  return FALSE;
+}
+
+
+/* Function for obtaining the condition for the next instruction after cur_insn.
+*/
+rtx
+get_next_insn_cond (rtx cur_insn)
+{
+  rtx next_insn = next_nonnote_insn (cur_insn);
+  rtx cond = NULL_RTX;
+  if (next_insn != NULL_RTX
+      && INSN_P (next_insn))
+    {
+      if ((GET_CODE (PATTERN (next_insn)) == SET)
+          && (GET_CODE (SET_SRC (PATTERN (next_insn))) == IF_THEN_ELSE))
+        {
+          /* Branch and cond if then else instructions */
+          cond = XEXP (SET_SRC (PATTERN (next_insn)), 0);
+        }
+      else if ((GET_CODE (PATTERN (next_insn)) == SET)
+               && avr32_comparison_operator (SET_SRC (PATTERN (next_insn)),
+                                             GET_MODE (SET_SRC (PATTERN (next_insn)))))
+        {
+          /* scc with no compare */
+          cond = SET_SRC (PATTERN (next_insn));
+        }
+      else if (GET_CODE (PATTERN (next_insn)) == COND_EXEC)
+        {
+          cond = COND_EXEC_TEST (PATTERN (next_insn));
+        }
+    }
+  return cond;
+}
+
+
+/* Check if the next insn is a conditional insn that will emit a compare
+   for itself.
+*/
+rtx
+next_insn_emits_cmp (rtx cur_insn)
+{
+  rtx next_insn = next_nonnote_insn (cur_insn);
+  rtx cond = NULL_RTX;
+  if (next_insn != NULL_RTX
+      && INSN_P (next_insn))
+    {
+      if ( ((GET_CODE (PATTERN (next_insn)) == SET)
+            && (GET_CODE (SET_SRC (PATTERN (next_insn))) == IF_THEN_ELSE)
+            && (XEXP (XEXP (SET_SRC (PATTERN (next_insn)), 0),0) != cc0_rtx))
+           || GET_CODE (PATTERN (next_insn)) == COND_EXEC )
+        return TRUE;
+    }
+  return FALSE;
+}
+
+
+rtx
+avr32_output_cmp (rtx cond, enum machine_mode mode, rtx op0, rtx op1)
+{
+
+  rtx new_cond = NULL_RTX;
+  rtx ops[2];
+  rtx compare_pattern;
+  ops[0] = op0;
+  ops[1] = op1;
+
+  if ( GET_CODE (op0) == AND )
+    compare_pattern = op0;
+  else
+    compare_pattern = gen_rtx_COMPARE (mode, op0, op1);
+
+  new_cond = is_compare_redundant (compare_pattern, cond);
+
+  if (new_cond != NULL_RTX)
+    return new_cond;
+
+  /* Check if we are inserting a bit-load instead of a compare. */
+  if ( GET_CODE (op0) == AND )
+    {
+      ops[0] = XEXP (op0, 0);
+      ops[1] = XEXP (op0, 1);
+      output_asm_insn ("bld\t%0, %p1", ops);
+      return cond;
+    }
+
+  /* Insert compare */
+  switch (mode)
+    {
+    case QImode:
+      output_asm_insn ("cp.b\t%0, %1", ops);
+      break;
+    case HImode:
+      output_asm_insn ("cp.h\t%0, %1", ops);
+      break;
+    case SImode:
+      output_asm_insn ("cp.w\t%0, %1", ops);
+      break;
+    case DImode:
+      if (GET_CODE (op1) != REG)
+	output_asm_insn ("cp.w\t%0, %1\ncpc\t%m0", ops);
+      else
+	output_asm_insn ("cp.w\t%0, %1\ncpc\t%m0, %m1", ops);
+      break;
+    default:
+      internal_error ("Unknown comparison mode");
+      break;
+    }
+
+  return cond;
+}
+
+
+int
+avr32_load_multiple_operation (rtx op,
+			       enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+  int count = XVECLEN (op, 0);
+  unsigned int dest_regno;
+  rtx src_addr;
+  rtx elt;
+  int i = 1, base = 0;
+
+  if (count <= 1 || GET_CODE (XVECEXP (op, 0, 0)) != SET)
+    return 0;
+
+  /* Check to see if this might be a write-back.  */
+  if (GET_CODE (SET_SRC (elt = XVECEXP (op, 0, 0))) == PLUS)
+    {
+      i++;
+      base = 1;
+
+      /* Now check it more carefully.  */
+      if (GET_CODE (SET_DEST (elt)) != REG
+	  || GET_CODE (XEXP (SET_SRC (elt), 0)) != REG
+	  || GET_CODE (XEXP (SET_SRC (elt), 1)) != CONST_INT
+	  || INTVAL (XEXP (SET_SRC (elt), 1)) != (count - 1) * 4)
+	return 0;
+    }
+
+  /* Perform a quick check so we don't blow up below.  */
+  if (count <= 1
+      || GET_CODE (XVECEXP (op, 0, i - 1)) != SET
+      || GET_CODE (SET_DEST (XVECEXP (op, 0, i - 1))) != REG
+      || GET_CODE (SET_SRC (XVECEXP (op, 0, i - 1))) != UNSPEC)
+    return 0;
+
+  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, i - 1)));
+  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, i - 1)), 0);
+
+  for (; i < count; i++)
+    {
+      elt = XVECEXP (op, 0, i);
+
+      if (GET_CODE (elt) != SET
+	  || GET_CODE (SET_DEST (elt)) != REG
+	  || GET_MODE (SET_DEST (elt)) != SImode
+	  || GET_CODE (SET_SRC (elt)) != UNSPEC)
+	return 0;
+    }
+
+  return 1;
+}
+
+
+int
+avr32_store_multiple_operation (rtx op,
+				enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+  int count = XVECLEN (op, 0);
+  int src_regno;
+  rtx dest_addr;
+  rtx elt;
+  int i = 1;
+
+  if (count <= 1 || GET_CODE (XVECEXP (op, 0, 0)) != SET)
+    return 0;
+
+  /* Perform a quick check so we don't blow up below.  */
+  if (count <= i
+      || GET_CODE (XVECEXP (op, 0, i - 1)) != SET
+      || GET_CODE (SET_DEST (XVECEXP (op, 0, i - 1))) != MEM
+      || GET_CODE (SET_SRC (XVECEXP (op, 0, i - 1))) != UNSPEC)
+    return 0;
+
+  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, i - 1)));
+  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, i - 1)), 0);
+
+  for (; i < count; i++)
+    {
+      elt = XVECEXP (op, 0, i);
+
+      if (GET_CODE (elt) != SET
+	  || GET_CODE (SET_DEST (elt)) != MEM
+	  || GET_MODE (SET_DEST (elt)) != SImode
+	  || GET_CODE (SET_SRC (elt)) != UNSPEC)
+	return 0;
+    }
+
+  return 1;
+}
+
+
+int
+avr32_valid_macmac_bypass (rtx insn_out, rtx insn_in)
+{
+  /* Check if they use the same accumulator */
+  if (rtx_equal_p
+      (SET_DEST (PATTERN (insn_out)), SET_DEST (PATTERN (insn_in))))
+    {
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+
+int
+avr32_valid_mulmac_bypass (rtx insn_out, rtx insn_in)
+{
+  /*
+     Check if the mul instruction produces the accumulator for the mac
+     instruction. */
+  if (rtx_equal_p
+      (SET_DEST (PATTERN (insn_out)), SET_DEST (PATTERN (insn_in))))
+    {
+      return TRUE;
+    }
+  return FALSE;
+}
+
+
+int
+avr32_store_bypass (rtx insn_out, rtx insn_in)
+{
+  /* Only valid bypass if the output result is used as an src in the store
+     instruction, NOT if used as a pointer or base. */
+  if (rtx_equal_p
+      (SET_DEST (PATTERN (insn_out)), SET_SRC (PATTERN (insn_in))))
+    {
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+
+int
+avr32_mul_waw_bypass (rtx insn_out, rtx insn_in)
+{
+  /* Check if the register holding the result from the mul instruction is
+     used as a result register in the input instruction. */
+  if (rtx_equal_p
+      (SET_DEST (PATTERN (insn_out)), SET_DEST (PATTERN (insn_in))))
+    {
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+
+int
+avr32_valid_load_double_bypass (rtx insn_out, rtx insn_in)
+{
+  /* Check if the first loaded word in insn_out is used in insn_in. */
+  rtx dst_reg;
+  rtx second_loaded_reg;
+
+  /* If this is a double alu operation then the bypass is not valid */
+  if ((get_attr_type (insn_in) == TYPE_ALU
+       || get_attr_type (insn_in) == TYPE_ALU2)
+      && (GET_MODE_SIZE (GET_MODE (SET_DEST (PATTERN (insn_out)))) > 4))
+    return FALSE;
+
+  /* Get the destination register in the load */
+  if (!REG_P (SET_DEST (PATTERN (insn_out))))
+    return FALSE;
+
+  dst_reg = SET_DEST (PATTERN (insn_out));
+  second_loaded_reg = gen_rtx_REG (SImode, REGNO (dst_reg) + 1);
+
+  if (!reg_mentioned_p (second_loaded_reg, PATTERN (insn_in)))
+    return TRUE;
+
+  return FALSE;
+}
+
+
+int
+avr32_valid_load_quad_bypass (rtx insn_out, rtx insn_in)
+{
+  /*
+     Check if the two first loaded word in insn_out are used in insn_in. */
+  rtx dst_reg;
+  rtx third_loaded_reg, fourth_loaded_reg;
+
+  /* Get the destination register in the load */
+  if (!REG_P (SET_DEST (PATTERN (insn_out))))
+    return FALSE;
+
+  dst_reg = SET_DEST (PATTERN (insn_out));
+  third_loaded_reg = gen_rtx_REG (SImode, REGNO (dst_reg) + 2);
+  fourth_loaded_reg = gen_rtx_REG (SImode, REGNO (dst_reg) + 3);
+
+  if (!reg_mentioned_p (third_loaded_reg, PATTERN (insn_in))
+      && !reg_mentioned_p (fourth_loaded_reg, PATTERN (insn_in)))
+    {
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+
+rtx
+avr32_ifcvt_modify_test (ce_if_block_t *ce_info, rtx test )
+{
+  rtx branch_insn;
+  rtx cmp_test;
+  rtx compare_op0;
+  rtx compare_op1;
+
+
+  if ( !ce_info
+       || test == NULL_RTX
+       || !reg_mentioned_p (cc0_rtx, test))
+    return test;
+
+  branch_insn = BB_END (ce_info->test_bb);
+  cmp_test = PATTERN(prev_nonnote_insn (branch_insn));
+
+  if (GET_CODE(cmp_test) != SET
+      || !CC0_P(XEXP(cmp_test, 0)) )
+    return cmp_test;
+
+  if ( GET_CODE(SET_SRC(cmp_test)) == COMPARE ){
+    compare_op0 = XEXP(SET_SRC(cmp_test), 0);
+    compare_op1 = XEXP(SET_SRC(cmp_test), 1);
+  } else {
+    compare_op0 = SET_SRC(cmp_test);
+    compare_op1 = const0_rtx;
+  }
+
+  return gen_rtx_fmt_ee (GET_CODE(test), GET_MODE (compare_op0),
+                         compare_op0, compare_op1);
+}
+
+
+rtx
+avr32_ifcvt_modify_insn (ce_if_block_t *ce_info, rtx pattern, rtx insn,
+                         int *num_true_changes)
+{
+  rtx test = COND_EXEC_TEST(pattern);
+  rtx op = COND_EXEC_CODE(pattern);
+  rtx cmp_insn;
+  rtx cond_exec_insn;
+  int inputs_set_outside_ifblock = 1;
+  basic_block current_bb = BLOCK_FOR_INSN (insn);
+  rtx bb_insn ;
+  enum machine_mode mode = GET_MODE (XEXP (op, 0));
+
+  if (CC0_P(XEXP(test, 0)))
+    test = avr32_ifcvt_modify_test (ce_info,
+                                    test );
+
+  /* We do not support multiple tests. */
+  if ( ce_info
+       && ce_info->num_multiple_test_blocks > 0 )
+    return NULL_RTX;
+
+  pattern = gen_rtx_COND_EXEC (VOIDmode, test, op);
+
+  if ( !reload_completed )
+    {
+      rtx start;
+      int num_insns;
+      int max_insns = MAX_CONDITIONAL_EXECUTE;
+
+      if ( !ce_info )
+        return op;
+
+      /* Check if the insn is not suitable for conditional
+         execution. */
+      start_sequence ();
+      cond_exec_insn = emit_insn (pattern);
+      if ( recog_memoized (cond_exec_insn) < 0
+           && can_create_pseudo_p () )
+        {
+          /* Insn is not suitable for conditional execution, try
+             to fix it up by using an extra scratch register or
+             by pulling the operation outside the if-then-else
+             and then emiting a conditional move inside the if-then-else. */
+          end_sequence ();
+          if ( GET_CODE (op) != SET
+               || !REG_P (SET_DEST (op))
+               || GET_CODE (SET_SRC (op)) == IF_THEN_ELSE
+               || GET_MODE_SIZE (mode) > UNITS_PER_WORD )
+            return NULL_RTX;
+
+          /* Check if any of the input operands to the insn is set inside the
+             current block. */
+          if ( current_bb->index == ce_info->then_bb->index )
+            start = PREV_INSN (BB_HEAD (ce_info->then_bb));
+          else
+            start = PREV_INSN (BB_HEAD (ce_info->else_bb));
+
+
+          for ( bb_insn = next_nonnote_insn (start); bb_insn != insn; bb_insn = next_nonnote_insn (bb_insn) )
+            {
+              rtx set = single_set (bb_insn);
+
+              if ( set && reg_mentioned_p (SET_DEST (set), SET_SRC (op)))
+                {
+                  inputs_set_outside_ifblock = 0;
+                  break;
+                }
+            }
+
+          cmp_insn = prev_nonnote_insn (BB_END (ce_info->test_bb));
+
+
+          /* Check if we can insert more insns. */
+          num_insns = ( ce_info->num_then_insns +
+                        ce_info->num_else_insns +
+                        ce_info->num_cond_clobber_insns +
+                        ce_info->num_extra_move_insns );
+
+          if ( ce_info->num_else_insns != 0 )
+            max_insns *=2;
+
+          if ( num_insns >= max_insns )
+            return NULL_RTX;
+
+          /* Check if we have an instruction which might be converted to
+             conditional form if we give it a scratch register to clobber. */
+          {
+            rtx clobber_insn;
+            rtx scratch_reg = gen_reg_rtx (mode);
+            rtx new_pattern = copy_rtx (pattern);
+            rtx set_src = SET_SRC (COND_EXEC_CODE (new_pattern));
+
+            rtx clobber = gen_rtx_CLOBBER (mode, scratch_reg);
+            rtx vec[2] = { COND_EXEC_CODE (new_pattern), clobber };
+            COND_EXEC_CODE (new_pattern) = gen_rtx_PARALLEL (mode, gen_rtvec_v (2, vec));
+
+            start_sequence ();
+            clobber_insn = emit_insn (new_pattern);
+
+            if ( recog_memoized (clobber_insn) >= 0
+                 && ( ( GET_RTX_LENGTH (GET_CODE (set_src)) == 2
+                        && CONST_INT_P (XEXP (set_src, 1))
+                        && avr32_const_ok_for_constraint_p (INTVAL (XEXP (set_src, 1)), 'K', "Ks08") )
+                      || !ce_info->else_bb
+                      || current_bb->index == ce_info->else_bb->index ))
+              {
+                end_sequence ();
+                /* Force the insn to be recognized again. */
+                INSN_CODE (insn) = -1;
+
+                /* If this is the first change in this IF-block then
+                   signal that we have made a change. */
+                if ( ce_info->num_cond_clobber_insns == 0
+                     && ce_info->num_extra_move_insns == 0 )
+                  *num_true_changes += 1;
+
+                ce_info->num_cond_clobber_insns++;
+
+                if (dump_file)
+                  fprintf (dump_file,
+                           "\nReplacing INSN %d with an insn using a scratch register for later ifcvt passes...\n",
+                           INSN_UID (insn));
+
+                return COND_EXEC_CODE (new_pattern);
+              }
+            end_sequence ();
+          }
+
+          if ( inputs_set_outside_ifblock )
+            {
+              /* Check if the insn before the cmp is an and which used
+                 together with the cmp can be optimized into a bld. If
+                 so then we should try to put the insn before the and
+                 so that we can catch the bld peephole. */
+              rtx set;
+              rtx insn_before_cmp_insn = prev_nonnote_insn (cmp_insn);
+              if (insn_before_cmp_insn
+                  && (set = single_set (insn_before_cmp_insn))
+                  && GET_CODE (SET_SRC (set)) == AND
+                  && one_bit_set_operand (XEXP (SET_SRC (set), 1), SImode)
+                  /* Also make sure that the insn does not set any
+                     of the input operands to the insn we are pulling out. */
+                  && !reg_mentioned_p (SET_DEST (set), SET_SRC (op)) )
+                cmp_insn = prev_nonnote_insn (cmp_insn);
+
+              /* We can try to put the operation outside the if-then-else
+                 blocks and insert a move. */
+              if ( !insn_invalid_p (insn)
+                   /* Do not allow conditional insns to be moved outside the
+                      if-then-else. */
+                   && !reg_mentioned_p (cc0_rtx, insn)
+                   /* We cannot move memory loads outside of the if-then-else
+                      since the memory access should not be perfomed if the
+                      condition is not met. */
+                   && !mem_mentioned_p (SET_SRC (op)) )
+                {
+                  rtx scratch_reg = gen_reg_rtx (mode);
+                  rtx op_pattern = copy_rtx (op);
+                  rtx new_insn, seq;
+                  rtx link, prev_link;
+                  op = copy_rtx (op);
+                  /* Emit the operation to a temp reg before the compare,
+                     and emit a move inside the if-then-else, hoping that the
+                     whole if-then-else can be converted to conditional
+                     execution. */
+                  SET_DEST (op_pattern) = scratch_reg;
+                  start_sequence ();
+                  new_insn = emit_insn (op_pattern);
+                  seq = get_insns();
+                  end_sequence ();
+
+                  /* Check again that the insn is valid. For some insns the insn might
+                     become invalid if the destination register is changed. Ie. for mulacc
+                     operations. */
+                  if ( insn_invalid_p (new_insn) )
+                    return NULL_RTX;
+
+                  emit_insn_before_setloc (seq, cmp_insn, INSN_LOCATOR (insn));
+
+                  if (dump_file)
+                    fprintf (dump_file,
+                             "\nMoving INSN %d out of IF-block by adding INSN %d...\n",
+                             INSN_UID (insn), INSN_UID (new_insn));
+
+                  ce_info->extra_move_insns[ce_info->num_extra_move_insns] = insn;
+                  ce_info->moved_insns[ce_info->num_extra_move_insns] = new_insn;
+                  XEXP (op, 1) = scratch_reg;
+                  /* Force the insn to be recognized again. */
+                  INSN_CODE (insn) = -1;
+
+                  /* Move REG_DEAD notes to the moved insn. */
+                  prev_link = NULL_RTX;
+                  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))
+                    {
+                      if (REG_NOTE_KIND (link) == REG_DEAD)
+                        {
+                          /* Add the REG_DEAD note to the new insn. */
+                          rtx dead_reg = XEXP (link, 0);
+                          REG_NOTES (new_insn) = gen_rtx_EXPR_LIST (REG_DEAD, dead_reg, REG_NOTES (new_insn));
+                          /* Remove the REG_DEAD note from the insn we convert to a move. */
+                          if ( prev_link )
+                            XEXP (prev_link, 1) = XEXP (link, 1);
+                          else
+                            REG_NOTES (insn) = XEXP (link, 1);
+                        }
+                      else
+                        {
+                          prev_link = link;
+                        }
+                    }
+                  /* Add a REG_DEAD note to signal that the scratch register is dead. */
+                  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD, scratch_reg, REG_NOTES (insn));
+
+                  /* If this is the first change in this IF-block then
+                     signal that we have made a change. */
+                  if ( ce_info->num_cond_clobber_insns == 0
+                       && ce_info->num_extra_move_insns == 0 )
+                    *num_true_changes += 1;
+
+                  ce_info->num_extra_move_insns++;
+                  return op;
+                }
+            }
+
+          /* We failed to fixup the insns, so this if-then-else can not be made
+             conditional. Just return NULL_RTX so that the if-then-else conversion
+             for this if-then-else will be cancelled. */
+          return NULL_RTX;
+        }
+      end_sequence ();
+      return op;
+    }
+
+  /* Signal that we have started if conversion after reload, which means
+     that it should be safe to split all the predicable clobber insns which
+     did not become cond_exec back into a simpler form if possible. */
+  cfun->machine->ifcvt_after_reload = 1;
+
+  return pattern;
+}
+
+
+void
+avr32_ifcvt_modify_cancel ( ce_if_block_t *ce_info, int *num_true_changes)
+{
+  int n;
+
+  if ( ce_info->num_extra_move_insns > 0
+       && ce_info->num_cond_clobber_insns == 0)
+    /* Signal that we did not do any changes after all. */
+    *num_true_changes -= 1;
+
+  /* Remove any inserted move insns. */
+  for ( n = 0; n < ce_info->num_extra_move_insns; n++ )
+    {
+      rtx link, prev_link;
+
+      /* Remove REG_DEAD note since we are not needing the scratch register anyway. */
+      prev_link = NULL_RTX;
+      for (link = REG_NOTES (ce_info->extra_move_insns[n]); link; link = XEXP (link, 1))
+        {
+          if (REG_NOTE_KIND (link) == REG_DEAD)
+            {
+              if ( prev_link )
+                XEXP (prev_link, 1) = XEXP (link, 1);
+              else
+                REG_NOTES (ce_info->extra_move_insns[n]) = XEXP (link, 1);
+            }
+          else
+            {
+              prev_link = link;
+            }
+        }
+
+      /* Revert all reg_notes for the moved insn. */
+      for (link = REG_NOTES (ce_info->moved_insns[n]); link; link = XEXP (link, 1))
+        {
+          REG_NOTES (ce_info->extra_move_insns[n]) = gen_rtx_EXPR_LIST (REG_NOTE_KIND (link),
+                                                                        XEXP (link, 0),
+                                                                        REG_NOTES (ce_info->extra_move_insns[n]));
+        }
+
+      /* Remove the moved insn. */
+      remove_insn ( ce_info->moved_insns[n] );
+    }
+}
+
+
+/* Function returning TRUE if INSN with OPERANDS is a splittable
+   conditional immediate clobber insn. We assume that the insn is
+   already a conditional immediate clobber insns and do not check
+   for that. */
+int
+avr32_cond_imm_clobber_splittable (rtx insn, rtx operands[])
+{
+  if ( REGNO (operands[0]) == REGNO (operands[1]) )
+    {
+      if ( (GET_CODE (SET_SRC (XVECEXP (PATTERN (insn),0,0))) == PLUS
+            && !avr32_const_ok_for_constraint_p (INTVAL (operands[2]), 'I', "Is21"))
+           || (GET_CODE (SET_SRC (XVECEXP (PATTERN (insn),0,0))) == MINUS
+               && !avr32_const_ok_for_constraint_p (INTVAL (operands[2]), 'K', "Ks21")))
+        return FALSE;
+    }
+  else if ( (logical_binary_operator (SET_SRC (XVECEXP (PATTERN (insn),0,0)), VOIDmode)
+             || (GET_CODE (SET_SRC (XVECEXP (PATTERN (insn),0,0))) == PLUS
+                 && !avr32_const_ok_for_constraint_p (INTVAL (operands[2]), 'I', "Is16"))
+             || (GET_CODE (SET_SRC (XVECEXP (PATTERN (insn),0,0))) == MINUS
+                 && !avr32_const_ok_for_constraint_p (INTVAL (operands[2]), 'K', "Ks16"))) )
+    return FALSE;
+
+  return TRUE;
+}
+
+
+/* Function for getting an integer value from a const_int or const_double
+   expression regardless of the HOST_WIDE_INT size. Each target cpu word
+   will be put into the val array where the LSW will be stored at the lowest
+   address and so forth. Assumes that const_expr is either a const_int or
+   const_double. Only valid for modes which have sizes that are a multiple
+   of the word size.
+*/
+void
+avr32_get_intval (enum machine_mode mode, rtx const_expr, HOST_WIDE_INT *val)
+{
+  int words_in_mode = GET_MODE_SIZE (mode)/UNITS_PER_WORD;
+  const int words_in_const_int = HOST_BITS_PER_WIDE_INT / BITS_PER_WORD;
+
+  if ( GET_CODE(const_expr) == CONST_DOUBLE ){
+    HOST_WIDE_INT hi = CONST_DOUBLE_HIGH(const_expr);
+    HOST_WIDE_INT lo = CONST_DOUBLE_LOW(const_expr);
+    /* Evaluate hi and lo values of const_double. */
+    avr32_get_intval (mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0),
+                      GEN_INT (lo),
+                      &val[0]);
+    avr32_get_intval (mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0),
+                      GEN_INT (hi),
+                      &val[words_in_const_int]);
+  } else if ( GET_CODE(const_expr) == CONST_INT ){
+    HOST_WIDE_INT value = INTVAL(const_expr);
+    int word;
+    for ( word = 0; (word < words_in_mode) && (word < words_in_const_int); word++ ){
+      /* Shift word up to the MSW and shift down again to extract the
+         word and sign-extend. */
+      int lshift = (words_in_const_int - word - 1) * BITS_PER_WORD;
+      int rshift = (words_in_const_int-1) * BITS_PER_WORD;
+      val[word] = (value << lshift) >> rshift;
+    }
+
+    for ( ; word < words_in_mode; word++ ){
+      /* Just put the sign bits in the remaining words. */
+      val[word] = value < 0 ? -1 : 0;
+    }
+  }
+}
+
+
+void
+avr32_split_const_expr (enum machine_mode mode, enum machine_mode new_mode,
+                        rtx expr, rtx *split_expr)
+{
+  int i, word;
+  int words_in_intval = GET_MODE_SIZE (mode)/UNITS_PER_WORD;
+  int words_in_split_values = GET_MODE_SIZE (new_mode)/UNITS_PER_WORD;
+  const int words_in_const_int = HOST_BITS_PER_WIDE_INT / BITS_PER_WORD;
+  HOST_WIDE_INT *val = alloca (words_in_intval * UNITS_PER_WORD);
+
+  avr32_get_intval (mode, expr, val);
+
+  for ( i=0; i < (words_in_intval/words_in_split_values); i++ )
+    {
+      HOST_WIDE_INT value_lo = 0, value_hi = 0;
+      for ( word = 0; word < words_in_split_values; word++ )
+        {
+          if ( word >= words_in_const_int )
+            value_hi |= ((val[i * words_in_split_values + word] &
+                          (((HOST_WIDE_INT)1 << BITS_PER_WORD)-1))
+                         << (BITS_PER_WORD * (word - words_in_const_int)));
+          else
+            value_lo |= ((val[i * words_in_split_values + word] &
+                          (((HOST_WIDE_INT)1 << BITS_PER_WORD)-1))
+                         << (BITS_PER_WORD * word));
+        }
+      split_expr[i] = immed_double_const(value_lo, value_hi, new_mode);
+    }
+}
+
+
+/* Set up library functions to comply to AVR32 ABI  */
+static void
+avr32_init_libfuncs (void)
+{
+  /* Convert gcc run-time function names to AVR32 ABI names */
+
+  /* Double-precision floating-point arithmetic. */
+  set_optab_libfunc (neg_optab, DFmode, NULL);
+
+  /* Double-precision comparisons.  */
+  set_optab_libfunc (eq_optab, DFmode, "__avr32_f64_cmp_eq");
+  set_optab_libfunc (ne_optab, DFmode, NULL);
+  set_optab_libfunc (lt_optab, DFmode, "__avr32_f64_cmp_lt");
+  set_optab_libfunc (le_optab, DFmode, NULL);
+  set_optab_libfunc (ge_optab, DFmode, "__avr32_f64_cmp_ge");
+  set_optab_libfunc (gt_optab, DFmode, NULL);
+
+  /* Single-precision floating-point arithmetic. */
+  set_optab_libfunc (smul_optab, SFmode, "__avr32_f32_mul");
+  set_optab_libfunc (neg_optab, SFmode, NULL);
+
+  /* Single-precision comparisons.  */
+  set_optab_libfunc (eq_optab, SFmode, "__avr32_f32_cmp_eq");
+  set_optab_libfunc (ne_optab, SFmode, NULL);
+  set_optab_libfunc (lt_optab, SFmode, "__avr32_f32_cmp_lt");
+  set_optab_libfunc (le_optab, SFmode, NULL);
+  set_optab_libfunc (ge_optab, SFmode, "__avr32_f32_cmp_ge");
+  set_optab_libfunc (gt_optab, SFmode, NULL);
+
+  /* Floating-point to integer conversions. */
+  set_conv_libfunc (sfix_optab, SImode, DFmode, "__avr32_f64_to_s32");
+  set_conv_libfunc (ufix_optab, SImode, DFmode, "__avr32_f64_to_u32");
+  set_conv_libfunc (sfix_optab, DImode, DFmode, "__avr32_f64_to_s64");
+  set_conv_libfunc (ufix_optab, DImode, DFmode, "__avr32_f64_to_u64");
+  set_conv_libfunc (sfix_optab, SImode, SFmode, "__avr32_f32_to_s32");
+  set_conv_libfunc (ufix_optab, SImode, SFmode, "__avr32_f32_to_u32");
+  set_conv_libfunc (sfix_optab, DImode, SFmode, "__avr32_f32_to_s64");
+  set_conv_libfunc (ufix_optab, DImode, SFmode, "__avr32_f32_to_u64");
+
+  /* Conversions between floating types.  */
+  set_conv_libfunc (trunc_optab, SFmode, DFmode, "__avr32_f64_to_f32");
+  set_conv_libfunc (sext_optab, DFmode, SFmode, "__avr32_f32_to_f64");
+
+  /* Integer to floating-point conversions.  Table 8.  */
+  set_conv_libfunc (sfloat_optab, DFmode, SImode, "__avr32_s32_to_f64");
+  set_conv_libfunc (sfloat_optab, DFmode, DImode, "__avr32_s64_to_f64");
+  set_conv_libfunc (sfloat_optab, SFmode, SImode, "__avr32_s32_to_f32");
+  set_conv_libfunc (sfloat_optab, SFmode, DImode, "__avr32_s64_to_f32");
+  set_conv_libfunc (ufloat_optab, DFmode, SImode, "__avr32_u32_to_f64");
+  set_conv_libfunc (ufloat_optab, SFmode, SImode, "__avr32_u32_to_f32");
+  /* TODO: Add these to gcc library functions */
+  //set_conv_libfunc (ufloat_optab, DFmode, DImode, NULL);
+  //set_conv_libfunc (ufloat_optab, SFmode, DImode, NULL);
+
+  /* Long long.  Table 9.  */
+  set_optab_libfunc (smul_optab, DImode, "__avr32_mul64");
+  set_optab_libfunc (sdiv_optab, DImode, "__avr32_sdiv64");
+  set_optab_libfunc (udiv_optab, DImode, "__avr32_udiv64");
+  set_optab_libfunc (smod_optab, DImode, "__avr32_smod64");
+  set_optab_libfunc (umod_optab, DImode, "__avr32_umod64");
+  set_optab_libfunc (ashl_optab, DImode, "__avr32_lsl64");
+  set_optab_libfunc (lshr_optab, DImode, "__avr32_lsr64");
+  set_optab_libfunc (ashr_optab, DImode, "__avr32_asr64");
+
+  /* Floating point library functions which have fast versions. */
+  if ( TARGET_FAST_FLOAT )
+    {
+      set_optab_libfunc (sdiv_optab, DFmode, "__avr32_f64_div_fast");
+      set_optab_libfunc (smul_optab, DFmode, "__avr32_f64_mul_fast");
+      set_optab_libfunc (add_optab, DFmode, "__avr32_f64_add_fast");
+      set_optab_libfunc (sub_optab, DFmode, "__avr32_f64_sub_fast");
+      set_optab_libfunc (add_optab, SFmode, "__avr32_f32_add_fast");
+      set_optab_libfunc (sub_optab, SFmode, "__avr32_f32_sub_fast");
+      set_optab_libfunc (sdiv_optab, SFmode, "__avr32_f32_div_fast");
+    }
+  else
+    {
+      set_optab_libfunc (sdiv_optab, DFmode, "__avr32_f64_div");
+      set_optab_libfunc (smul_optab, DFmode, "__avr32_f64_mul");
+      set_optab_libfunc (add_optab, DFmode, "__avr32_f64_add");
+      set_optab_libfunc (sub_optab, DFmode, "__avr32_f64_sub");
+      set_optab_libfunc (add_optab, SFmode, "__avr32_f32_add");
+      set_optab_libfunc (sub_optab, SFmode, "__avr32_f32_sub");
+      set_optab_libfunc (sdiv_optab, SFmode, "__avr32_f32_div");
+    }
+}
+
+
+/* Record a flashvault declaration.  */
+static void
+flashvault_decl_list_add (unsigned int vector_num, const char *name)
+{
+  struct flashvault_decl_list *p;
+
+  p = (struct flashvault_decl_list *)
+       xmalloc (sizeof (struct flashvault_decl_list));
+  p->next = flashvault_decl_list_head;
+  p->name = name;
+  p->vector_num = vector_num;
+  flashvault_decl_list_head = p;
+}
+
+
+static void
+avr32_file_end (void)
+{
+  struct flashvault_decl_list *p;
+  unsigned int num_entries = 0;
+
+  /* Check if a list of flashvault declarations exists. */
+  if (flashvault_decl_list_head != NULL)
+    {
+      /* Calculate the number of entries in the table. */
+      for (p = flashvault_decl_list_head; p != NULL; p = p->next)
+        {
+           num_entries++;
+        }
+
+      /* Generate the beginning of the flashvault data table. */
+      fputs ("\t.global     __fv_table\n"
+             "\t.data\n"
+             "\t.align 2\n"
+             "\t.set .LFVTABLE, . + 0\n"
+             "\t.type __fv_table, @object\n", asm_out_file);
+      /* Each table entry is 8 bytes. */
+      fprintf (asm_out_file, "\t.size __fv_table, %u\n", (num_entries * 8));
+
+      fputs("__fv_table:\n", asm_out_file);
+
+      for (p = flashvault_decl_list_head; p != NULL; p = p->next)
+        {
+          /* Output table entry. */
+          fprintf (asm_out_file, 
+                   "\t.align 2\n"
+                   "\t.int %u\n", p->vector_num);
+          fprintf (asm_out_file, 
+                   "\t.align 2\n"
+                   "\t.int %s\n", p->name);
+        }
+    }
+}
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/avr32-elf.h gcc-4.4.6/gcc/config/avr32/avr32-elf.h
--- gcc-4.4.6.orig/gcc/config/avr32/avr32-elf.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/avr32-elf.h	2011-08-27 19:45:42.679240416 +0200
@@ -0,0 +1,91 @@
+/*
+   Elf specific definitions.
+   Copyright 2003,2004,2005,2006,2007,2008,2009 Atmel Corporation.
+
+   This file is part of GCC.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
+
+
+/*****************************************************************************
+ * Controlling the Compiler Driver, 'gcc'
+ *****************************************************************************/
+
+/* Run-time Target Specification.  */
+#undef  TARGET_VERSION
+#define TARGET_VERSION  fputs (" (AVR32 GNU with ELF)", stderr);
+
+/*
+Another C string constant used much like LINK_SPEC.  The
+difference between the two is that STARTFILE_SPEC is used at
+the very beginning of the command given to the linker.
+
+If this macro is not defined, a default is provided that loads the
+standard C startup file from the usual place.  See gcc.c.
+*/
+#if 0
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC "crt0%O%s crti%O%s crtbegin%O%s"
+#endif
+#undef  STARTFILE_SPEC 
+#define STARTFILE_SPEC "%{mflashvault: crtfv.o%s} %{!mflashvault: crt0.o%s} \
+			crti.o%s crtbegin.o%s"
+
+#undef LINK_SPEC
+#define LINK_SPEC "%{muse-oscall:--defsym __do_not_use_oscall_coproc__=0} %{mrelax|O*:%{mno-relax|O0|O1: ;:--relax}} %{mpart=uc3a3revd:-mavr32elf_uc3a3256s;:%{mpart=*:-mavr32elf_%*}} %{mcpu=*:-mavr32elf_%*}"
+
+
+/*
+Another C string constant used much like LINK_SPEC.  The
+difference between the two is that ENDFILE_SPEC is used at
+the very end of the command given to the linker.
+
+Do not define this macro if it does not need to do anything.
+*/
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC "crtend%O%s crtn%O%s"
+
+
+/* Target CPU builtins.  */
+#define TARGET_CPU_CPP_BUILTINS()								\
+  do															\
+    {															\
+      builtin_define ("__avr32__");								\
+      builtin_define ("__AVR32__");								\
+      builtin_define ("__AVR32_ELF__");							\
+      builtin_define (avr32_part->macro);						\
+      builtin_define (avr32_arch->macro);						\
+      if (avr32_arch->uarch_type == UARCH_TYPE_AVR32A)			\
+        builtin_define ("__AVR32_AVR32A__");					\
+      else														\
+        builtin_define ("__AVR32_AVR32B__");					\
+      if (TARGET_UNALIGNED_WORD)								\
+        builtin_define ("__AVR32_HAS_UNALIGNED_WORD__");		\
+      if (TARGET_SIMD)											\
+        builtin_define ("__AVR32_HAS_SIMD__");					\
+      if (TARGET_DSP)											\
+        builtin_define ("__AVR32_HAS_DSP__");					\
+      if (TARGET_RMW)											\
+        builtin_define ("__AVR32_HAS_RMW__");					\
+      if (TARGET_BRANCH_PRED)									\
+        builtin_define ("__AVR32_HAS_BRANCH_PRED__");			\
+      if (TARGET_FAST_FLOAT)                                    \
+        builtin_define ("__AVR32_FAST_FLOAT__");                \
+      if (TARGET_FLASHVAULT)                                    \
+        builtin_define ("__AVR32_FLASHVAULT__");                \
+      if (TARGET_NO_MUL_INSNS)                                  \
+        builtin_define ("__AVR32_NO_MUL__");                    \
+    }															\
+  while (0)
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/avr32.h gcc-4.4.6/gcc/config/avr32/avr32.h
--- gcc-4.4.6.orig/gcc/config/avr32/avr32.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/avr32.h	2011-08-27 19:45:42.757981238 +0200
@@ -0,0 +1,3316 @@
+/*
+   Definitions of target machine for AVR32.
+   Copyright 2003,2004,2005,2006,2007,2008,2009,2010 Atmel Corporation.
+
+   This file is part of GCC.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
+
+#ifndef GCC_AVR32_H
+#define GCC_AVR32_H
+
+
+#ifndef OBJECT_FORMAT_ELF
+#error avr32.h included before elfos.h
+#endif
+
+#ifndef LOCAL_LABEL_PREFIX
+#define LOCAL_LABEL_PREFIX "."
+#endif
+
+#ifndef SUBTARGET_CPP_SPEC
+#define SUBTARGET_CPP_SPEC  "-D__ELF__"
+#endif
+
+
+extern struct rtx_def *avr32_compare_op0;
+extern struct rtx_def *avr32_compare_op1;
+
+/* comparison type */
+enum avr32_cmp_type {
+  CMP_QI,				/* 1 byte ->char */
+  CMP_HI,				/* 2 byte->half word */
+  CMP_SI,				/* four byte->word*/
+  CMP_DI,				/* eight byte->double word */
+  CMP_SF,				/* single precision floats */
+  CMP_MAX				/* max comparison type */
+};
+
+extern enum avr32_cmp_type avr32_branch_type;	/* type of branch to use */
+
+
+extern struct rtx_def *avr32_acc_cache;
+
+/* cache instruction op5 codes */
+#define AVR32_CACHE_INVALIDATE_ICACHE 1
+
+/* 
+These bits describe the different types of function supported by the AVR32
+backend. They are exclusive, e.g. a function cannot be both a normal function
+and an interworked function.  Knowing the type of a function is important for
+determining its prologue and epilogue sequences. Note value 7 is currently 
+unassigned.  Also note that the interrupt function types all have bit 2 set, 
+so that they can be tested for easily. Note that 0 is deliberately chosen for
+AVR32_FT_UNKNOWN so that when the machine_function structure is initialized
+(to zero) func_type will default to unknown. This will force the first use of
+avr32_current_func_type to call avr32_compute_func_type. 
+*/
+#define AVR32_FT_UNKNOWN           0  /* Type has not yet been determined. */
+#define AVR32_FT_NORMAL            1  /* Normal function. */
+#define AVR32_FT_ACALL             2  /* An acall function. */
+#define AVR32_FT_EXCEPTION_HANDLER 3  /* A C++ exception handler. */
+#define AVR32_FT_ISR_FULL          4  /* A fully shadowed interrupt mode. */
+#define AVR32_FT_ISR_HALF          5  /* A half shadowed interrupt mode. */
+#define AVR32_FT_ISR_NONE          6  /* No shadow registers. */
+
+#define AVR32_FT_TYPE_MASK	((1 << 3) - 1)
+
+/* In addition functions can have several type modifiers, outlined by these bit masks: */
+#define AVR32_FT_INTERRUPT       (1 << 2)  /* Note overlap with FT_ISR and above. */
+#define AVR32_FT_NAKED           (1 << 3)  /* No prologue or epilogue. */
+#define AVR32_FT_VOLATILE        (1 << 4)  /* Does not return. */
+#define AVR32_FT_NESTED          (1 << 5)  /* Embedded inside another func. */
+#define AVR32_FT_FLASHVAULT      (1 << 6)  /* Flashvault function call. */
+#define AVR32_FT_FLASHVAULT_IMPL (1 << 7)  /* Function definition in FlashVault. */
+
+
+/* Some macros to test these flags.  */
+#define AVR32_FUNC_TYPE(t)     (t & AVR32_FT_TYPE_MASK)
+#define IS_INTERRUPT(t)        (t & AVR32_FT_INTERRUPT)
+#define IS_NAKED(t)            (t & AVR32_FT_NAKED)
+#define IS_VOLATILE(t)         (t & AVR32_FT_VOLATILE)
+#define IS_NESTED(t)           (t & AVR32_FT_NESTED)
+#define IS_FLASHVAULT(t)       (t & AVR32_FT_FLASHVAULT)
+#define IS_FLASHVAULT_IMPL(t)  (t & AVR32_FT_FLASHVAULT_IMPL)
+
+#define SYMBOL_FLAG_RMW_ADDR_SHIFT    SYMBOL_FLAG_MACH_DEP_SHIFT
+#define SYMBOL_REF_RMW_ADDR(RTX)                                        \
+  ((SYMBOL_REF_FLAGS (RTX) & (1 << SYMBOL_FLAG_RMW_ADDR_SHIFT)) != 0)
+
+
+typedef struct minipool_labels
+GTY ((chain_next ("%h.next"), chain_prev ("%h.prev")))
+{
+  rtx label;
+  struct minipool_labels *prev;
+  struct minipool_labels *next;
+} minipool_labels;
+
+/* A C structure for machine-specific, per-function data.
+   This is added to the cfun structure.  */
+
+typedef struct machine_function
+GTY (())
+{
+  /* Records the type of the current function.  */
+  unsigned long func_type;
+  /* List of minipool labels, use for checking if code label is valid in a
+     memory expression */
+  minipool_labels *minipool_label_head;
+  minipool_labels *minipool_label_tail;
+  int ifcvt_after_reload;
+} machine_function;
+
+/* Initialize data used by insn expanders.  This is called from insn_emit,
+   once for every function before code is generated.  */
+#define INIT_EXPANDERS avr32_init_expanders ()
+
+/******************************************************************************
+ * SPECS
+ *****************************************************************************/
+
+#ifndef ASM_SPEC
+#define ASM_SPEC "%{fpic:--pic} %{mrelax|O*:%{mno-relax|O0|O1: ;:--linkrelax}} %{march=ucr2nomul:-march=ucr2;:%{march=*:-march=%*}} %{mpart=uc3a3revd:-mpart=uc3a3256s;:%{mpart=*:-mpart=%*}}"
+#endif
+
+#ifndef MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS { "march=ap", "" }
+#endif
+
+/******************************************************************************
+ * Run-time Target Specification
+ *****************************************************************************/
+#ifndef TARGET_VERSION
+#define TARGET_VERSION fprintf(stderr, " (AVR32, GNU assembler syntax)");
+#endif
+
+
+/* Part types. Keep this in sync with the order of avr32_part_types in avr32.c*/
+enum part_type
+{
+  PART_TYPE_AVR32_NONE,
+  PART_TYPE_AVR32_AP7000,
+  PART_TYPE_AVR32_AP7001,
+  PART_TYPE_AVR32_AP7002,
+  PART_TYPE_AVR32_AP7200,
+  PART_TYPE_AVR32_UC3A0128,
+  PART_TYPE_AVR32_UC3A0256,
+  PART_TYPE_AVR32_UC3A0512,
+  PART_TYPE_AVR32_UC3A0512ES,
+  PART_TYPE_AVR32_UC3A1128,
+  PART_TYPE_AVR32_UC3A1256,
+  PART_TYPE_AVR32_UC3A1512,
+  PART_TYPE_AVR32_UC3A1512ES,
+  PART_TYPE_AVR32_UC3A3REVD,
+  PART_TYPE_AVR32_UC3A364,
+  PART_TYPE_AVR32_UC3A364S,
+  PART_TYPE_AVR32_UC3A3128,
+  PART_TYPE_AVR32_UC3A3128S,
+  PART_TYPE_AVR32_UC3A3256,
+  PART_TYPE_AVR32_UC3A3256S,
+  PART_TYPE_AVR32_UC3A464,
+  PART_TYPE_AVR32_UC3A464S,
+  PART_TYPE_AVR32_UC3A4128,
+  PART_TYPE_AVR32_UC3A4128S,
+  PART_TYPE_AVR32_UC3A4256,
+  PART_TYPE_AVR32_UC3A4256S,
+  PART_TYPE_AVR32_UC3B064,
+  PART_TYPE_AVR32_UC3B0128,
+  PART_TYPE_AVR32_UC3B0256,
+  PART_TYPE_AVR32_UC3B0256ES,
+  PART_TYPE_AVR32_UC3B0512,
+  PART_TYPE_AVR32_UC3B0512REVC,
+  PART_TYPE_AVR32_UC3B164,
+  PART_TYPE_AVR32_UC3B1128,
+  PART_TYPE_AVR32_UC3B1256,
+  PART_TYPE_AVR32_UC3B1256ES,
+  PART_TYPE_AVR32_UC3B1512,
+  PART_TYPE_AVR32_UC3B1512REVC,
+  PART_TYPE_AVR32_UC64D3,
+  PART_TYPE_AVR32_UC128D3,
+  PART_TYPE_AVR32_UC64D4,
+  PART_TYPE_AVR32_UC128D4,
+  PART_TYPE_AVR32_UC3C0512CREVC,
+  PART_TYPE_AVR32_UC3C1512CREVC,
+  PART_TYPE_AVR32_UC3C2512CREVC,
+  PART_TYPE_AVR32_UC3L0256,
+  PART_TYPE_AVR32_UC3L0128,
+  PART_TYPE_AVR32_UC3L064,
+  PART_TYPE_AVR32_UC3L032,
+  PART_TYPE_AVR32_UC3L016,
+  PART_TYPE_AVR32_UC3L064REVB,
+  PART_TYPE_AVR32_UC64L3U,
+  PART_TYPE_AVR32_UC128L3U,
+  PART_TYPE_AVR32_UC256L3U,
+  PART_TYPE_AVR32_UC64L4U,
+  PART_TYPE_AVR32_UC128L4U,
+  PART_TYPE_AVR32_UC256L4U,
+  PART_TYPE_AVR32_UC3C064C,
+  PART_TYPE_AVR32_UC3C0128C,
+  PART_TYPE_AVR32_UC3C0256C,
+  PART_TYPE_AVR32_UC3C0512C,
+  PART_TYPE_AVR32_UC3C164C,
+  PART_TYPE_AVR32_UC3C1128C,
+  PART_TYPE_AVR32_UC3C1256C,
+  PART_TYPE_AVR32_UC3C1512C,
+  PART_TYPE_AVR32_UC3C264C,
+  PART_TYPE_AVR32_UC3C2128C,
+  PART_TYPE_AVR32_UC3C2256C,
+  PART_TYPE_AVR32_UC3C2512C,
+  PART_TYPE_AVR32_MXT768E
+};
+
+/* Microarchitectures. */
+enum microarchitecture_type
+{
+  UARCH_TYPE_AVR32A,
+  UARCH_TYPE_AVR32B,
+  UARCH_TYPE_NONE
+};
+
+/* Architectures types which specifies the pipeline.
+ Keep this in sync with avr32_arch_types in avr32.c
+ and the pipeline attribute in avr32.md */
+enum architecture_type
+{
+  ARCH_TYPE_AVR32_AP,
+  ARCH_TYPE_AVR32_UCR1,
+  ARCH_TYPE_AVR32_UCR2,
+  ARCH_TYPE_AVR32_UCR2NOMUL,
+  ARCH_TYPE_AVR32_UCR3,
+  ARCH_TYPE_AVR32_UCR3FP,
+  ARCH_TYPE_AVR32_NONE
+};
+
+/* Flag specifying if the cpu has support for DSP instructions.*/
+#define FLAG_AVR32_HAS_DSP (1 << 0)
+/* Flag specifying if the cpu has support for Read-Modify-Write
+   instructions.*/
+#define FLAG_AVR32_HAS_RMW (1 << 1)
+/* Flag specifying if the cpu has support for SIMD instructions. */
+#define FLAG_AVR32_HAS_SIMD (1 << 2)
+/* Flag specifying if the cpu has support for unaligned memory word access. */
+#define FLAG_AVR32_HAS_UNALIGNED_WORD (1 << 3)
+/* Flag specifying if the cpu has support for branch prediction. */
+#define FLAG_AVR32_HAS_BRANCH_PRED (1 << 4)
+/* Flag specifying if the cpu has support for a return stack. */
+#define FLAG_AVR32_HAS_RETURN_STACK (1 << 5)
+/* Flag specifying if the cpu has caches. */
+#define FLAG_AVR32_HAS_CACHES (1 << 6)
+/* Flag specifying if the cpu has support for v2 insns. */
+#define FLAG_AVR32_HAS_V2_INSNS (1 << 7)
+/* Flag specifying that the cpu has buggy mul insns. */
+#define FLAG_AVR32_HAS_NO_MUL_INSNS (1 << 8)
+/* Flag specifying that the device has FPU instructions according 
+   to AVR32002 specifications*/
+#define FLAG_AVR32_HAS_FPU (1 << 9)
+
+/* Structure for holding information about different avr32 CPUs/parts */
+struct part_type_s
+{
+  const char *const name;
+  enum part_type part_type;
+  enum architecture_type arch_type;
+  /* Must lie outside user's namespace.  NULL == no macro.  */
+  const char *const macro;
+};
+
+/* Structure for holding information about different avr32 pipeline
+ architectures. */
+struct arch_type_s
+{
+  const char *const name;
+  enum architecture_type arch_type;
+  enum microarchitecture_type uarch_type;
+  const unsigned long feature_flags;
+  /* Must lie outside user's namespace.  NULL == no macro.  */
+  const char *const macro;
+};
+
+extern const struct part_type_s *avr32_part;
+extern const struct arch_type_s *avr32_arch;
+
+#define TARGET_SIMD  (avr32_arch->feature_flags & FLAG_AVR32_HAS_SIMD)
+#define TARGET_DSP  (avr32_arch->feature_flags & FLAG_AVR32_HAS_DSP)
+#define TARGET_RMW  (avr32_arch->feature_flags & FLAG_AVR32_HAS_RMW)
+#define TARGET_UNALIGNED_WORD  (avr32_arch->feature_flags & FLAG_AVR32_HAS_UNALIGNED_WORD)
+#define TARGET_BRANCH_PRED  (avr32_arch->feature_flags & FLAG_AVR32_HAS_BRANCH_PRED)
+#define TARGET_RETURN_STACK  (avr32_arch->feature_flags & FLAG_AVR32_HAS_RETURN_STACK)
+#define TARGET_V2_INSNS  (avr32_arch->feature_flags & FLAG_AVR32_HAS_V2_INSNS)
+#define TARGET_CACHES  (avr32_arch->feature_flags & FLAG_AVR32_HAS_CACHES)
+#define TARGET_NO_MUL_INSNS  (avr32_arch->feature_flags & FLAG_AVR32_HAS_NO_MUL_INSNS)
+#define TARGET_ARCH_AP (avr32_arch->arch_type == ARCH_TYPE_AVR32_AP)
+#define TARGET_ARCH_UCR1 (avr32_arch->arch_type == ARCH_TYPE_AVR32_UCR1)
+#define TARGET_ARCH_UCR2 (avr32_arch->arch_type == ARCH_TYPE_AVR32_UCR2)
+#define TARGET_ARCH_UC (TARGET_ARCH_UCR1 || TARGET_ARCH_UCR2)
+#define TARGET_UARCH_AVR32A (avr32_arch->uarch_type == UARCH_TYPE_AVR32A)
+#define TARGET_UARCH_AVR32B (avr32_arch->uarch_type == UARCH_TYPE_AVR32B)
+#define TARGET_ARCH_FPU (avr32_arch->feature_flags & FLAG_AVR32_HAS_FPU)
+
+#define CAN_DEBUG_WITHOUT_FP
+
+
+
+
+/******************************************************************************
+ * Storage Layout
+ *****************************************************************************/
+
+/*
+Define this macro to have the value 1 if the most significant bit in a
+byte has the lowest number; otherwise define it to have the value zero.
+This means that bit-field instructions count from the most significant
+bit.  If the machine has no bit-field instructions, then this must still
+be defined, but it doesn't matter which value it is defined to.  This
+macro need not be a constant.
+
+This macro does not affect the way structure fields are packed into
+bytes or words; that is controlled by BYTES_BIG_ENDIAN.
+*/
+#define BITS_BIG_ENDIAN 0
+
+/*
+Define this macro to have the value 1 if the most significant byte in a
+word has the lowest number. This macro need not be a constant.
+*/
+/*
+  Data is stored in an big-endian way.
+*/
+#define BYTES_BIG_ENDIAN 1
+
+/*
+Define this macro to have the value 1 if, in a multiword object, the
+most significant word has the lowest number.  This applies to both
+memory locations and registers; GCC fundamentally assumes that the
+order of words in memory is the same as the order in registers.  This
+macro need not be a constant.
+*/
+/*
+  Data is stored in an bin-endian way.
+*/
+#define WORDS_BIG_ENDIAN 1
+
+/*
+Define this macro if WORDS_BIG_ENDIAN is not constant.  This must be a
+constant value with the same meaning as WORDS_BIG_ENDIAN, which will be
+used only when compiling libgcc2.c.  Typically the value will be set
+based on preprocessor defines.
+*/
+#define LIBGCC2_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN
+
+/*
+Define this macro to have the value 1 if DFmode, XFmode or
+TFmode floating point numbers are stored in memory with the word
+containing the sign bit at the lowest address; otherwise define it to
+have the value 0.  This macro need not be a constant.
+
+You need not define this macro if the ordering is the same as for
+multi-word integers.
+*/
+/* #define FLOAT_WORDS_BIG_ENDIAN 1 */
+
+/*
+Define this macro to be the number of bits in an addressable storage
+unit (byte); normally 8.
+*/
+#define BITS_PER_UNIT 8
+
+/*
+Number of bits in a word; normally 32.
+*/
+#define BITS_PER_WORD 32
+
+/*
+Maximum number of bits in a word.  If this is undefined, the default is
+BITS_PER_WORD.  Otherwise, it is the constant value that is the
+largest value that BITS_PER_WORD can have at run-time.
+*/
+/* MAX_BITS_PER_WORD not defined*/
+
+/*
+Number of storage units in a word; normally 4.
+*/
+#define UNITS_PER_WORD 4
+
+/*
+Minimum number of units in a word.  If this is undefined, the default is
+UNITS_PER_WORD.  Otherwise, it is the constant value that is the
+smallest value that UNITS_PER_WORD can have at run-time.
+*/
+/* MIN_UNITS_PER_WORD not defined */
+
+/*
+Width of a pointer, in bits.  You must specify a value no wider than the
+width of Pmode.  If it is not equal to the width of Pmode,
+you must define POINTERS_EXTEND_UNSIGNED.
+*/
+#define POINTER_SIZE 32
+
+/*
+A C expression whose value is greater than zero if pointers that need to be
+extended from being POINTER_SIZE bits wide to Pmode are to
+be zero-extended and zero if they are to be sign-extended.  If the value
+is less then zero then there must be an "ptr_extend" instruction that
+extends a pointer from POINTER_SIZE to Pmode.
+
+You need not define this macro if the POINTER_SIZE is equal
+to the width of Pmode.
+*/
+/* #define POINTERS_EXTEND_UNSIGNED */
+
+/*
+A Macro to update M and UNSIGNEDP when an object whose type
+is TYPE and which has the specified mode and signedness is to be
+stored in a register.  This macro is only called when TYPE is a
+scalar type.
+
+On most RISC machines, which only have operations that operate on a full
+register, define this macro to set M to word_mode if
+M is an integer mode narrower than BITS_PER_WORD.  In most
+cases, only integer modes should be widened because wider-precision
+floating-point operations are usually more expensive than their narrower
+counterparts.
+
+For most machines, the macro definition does not change UNSIGNEDP.
+However, some machines, have instructions that preferentially handle
+either signed or unsigned quantities of certain modes.  For example, on
+the DEC Alpha, 32-bit loads from memory and 32-bit add instructions
+sign-extend the result to 64 bits.  On such machines, set
+UNSIGNEDP according to which kind of extension is more efficient.
+
+Do not define this macro if it would never modify M.
+*/
+#define PROMOTE_MODE(M, UNSIGNEDP, TYPE)                                \
+  {                                                                     \
+    if (!AGGREGATE_TYPE_P (TYPE)                                        \
+        && GET_MODE_CLASS (mode) == MODE_INT                            \
+        && GET_MODE_SIZE (mode) < 4)                                    \
+      {                                                                 \
+        if (M == QImode)                                                \
+          (UNSIGNEDP) = 1;                                              \
+        else if (M == HImode)                                           \
+          (UNSIGNEDP) = 0;                                              \
+        (M) = SImode;                                                   \
+      }                                                                 \
+  }
+
+#define PROMOTE_FUNCTION_MODE(M, UNSIGNEDP, TYPE)  \
+        PROMOTE_MODE(M, UNSIGNEDP, TYPE)
+
+/* Define if operations between registers always perform the operation
+   on the full register even if a narrower mode is specified.  */
+#define WORD_REGISTER_OPERATIONS
+
+/* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD
+   will either zero-extend or sign-extend.  The value of this macro should
+   be the code that says which one of the two operations is implicitly
+   done, UNKNOWN if not known.  */
+#define LOAD_EXTEND_OP(MODE)				\
+   (((MODE) == QImode) ? ZERO_EXTEND			\
+   : ((MODE) == HImode) ? SIGN_EXTEND : UNKNOWN)
+
+
+/*
+Normal alignment required for function parameters on the stack, in
+bits.  All stack parameters receive at least this much alignment
+regardless of data type.  On most machines, this is the same as the
+size of an integer.
+*/
+#define PARM_BOUNDARY 32
+
+/*
+Define this macro to the minimum alignment enforced by hardware for the
+stack pointer on this machine.  The definition is a C expression for the
+desired alignment (measured in bits).  This value is used as a default
+if PREFERRED_STACK_BOUNDARY is not defined.  On most machines,
+this should be the same as PARM_BOUNDARY.
+*/
+#define STACK_BOUNDARY 32
+
+/*
+Define this macro if you wish to preserve a certain alignment for the
+stack pointer, greater than what the hardware enforces.  The definition
+is a C expression for the desired alignment (measured in bits).  This
+macro must evaluate to a value equal to or larger than
+STACK_BOUNDARY.
+*/
+#define PREFERRED_STACK_BOUNDARY (TARGET_FORCE_DOUBLE_ALIGN ? 64 : 32 )
+
+/*
+Alignment required for a function entry point, in bits.
+*/
+#define FUNCTION_BOUNDARY 16
+
+/*
+Biggest alignment that any data type can require on this machine, in bits.
+*/
+#define BIGGEST_ALIGNMENT  (TARGET_FORCE_DOUBLE_ALIGN ? 64 : 32 )
+
+/*
+If defined, the smallest alignment, in bits, that can be given to an
+object that can be referenced in one operation, without disturbing any
+nearby object.  Normally, this is BITS_PER_UNIT, but may be larger
+on machines that don't have byte or half-word store operations.
+*/
+#define MINIMUM_ATOMIC_ALIGNMENT BITS_PER_UNIT
+
+
+/*
+An integer expression for the size in bits of the largest integer machine mode that
+should actually be used. All integer machine modes of this size or smaller can be
+used for structures and unions with the appropriate sizes. If this macro is undefined,
+GET_MODE_BITSIZE (DImode) is assumed.*/
+#define MAX_FIXED_MODE_SIZE  GET_MODE_BITSIZE (DImode)
+
+
+/*
+If defined, a C expression to compute the alignment given to a constant
+that is being placed in memory.  CONSTANT is the constant and
+BASIC_ALIGN is the alignment that the object would ordinarily
+have.  The value of this macro is used instead of that alignment to
+align the object.
+
+If this macro is not defined, then BASIC_ALIGN is used.
+
+The typical use of this macro is to increase alignment for string
+constants to be word aligned so that strcpy calls that copy
+constants can be done inline.
+*/
+#define CONSTANT_ALIGNMENT(CONSTANT, BASIC_ALIGN) \
+ ((TREE_CODE(CONSTANT) == STRING_CST) ? BITS_PER_WORD : BASIC_ALIGN)
+
+/* Try to align string to a word. */
+#define DATA_ALIGNMENT(TYPE, ALIGN)                                     \
+  ({(TREE_CODE (TYPE) == ARRAY_TYPE                                     \
+     && TYPE_MODE (TREE_TYPE (TYPE)) == QImode                          \
+     && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN));})
+
+/* Try to align local store strings to a word. */
+#define LOCAL_ALIGNMENT(TYPE, ALIGN)                                    \
+  ({(TREE_CODE (TYPE) == ARRAY_TYPE                                     \
+     && TYPE_MODE (TREE_TYPE (TYPE)) == QImode                          \
+     && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN));})
+
+/*
+Define this macro to be the value 1 if instructions will fail to work
+if given data not on the nominal alignment.  If instructions will merely
+go slower in that case, define this macro as 0.
+*/
+#define STRICT_ALIGNMENT 1
+
+/*
+Define this if you wish to imitate the way many other C compilers handle
+alignment of bit-fields and the structures that contain them.
+
+The behavior is that the type written for a bit-field (int,
+short, or other integer type) imposes an alignment for the
+entire structure, as if the structure really did contain an ordinary
+field of that type.  In addition, the bit-field is placed within the
+structure so that it would fit within such a field, not crossing a
+boundary for it.
+
+Thus, on most machines, a bit-field whose type is written as int
+would not cross a four-byte boundary, and would force four-byte
+alignment for the whole structure.  (The alignment used may not be four
+bytes; it is controlled by the other alignment parameters.)
+
+If the macro is defined, its definition should be a C expression;
+a nonzero value for the expression enables this behavior.
+
+Note that if this macro is not defined, or its value is zero, some
+bit-fields may cross more than one alignment boundary.  The compiler can
+support such references if there are insv, extv, and
+extzv insns that can directly reference memory.
+
+The other known way of making bit-fields work is to define
+STRUCTURE_SIZE_BOUNDARY as large as BIGGEST_ALIGNMENT.
+Then every structure can be accessed with fullwords.
+
+Unless the machine has bit-field instructions or you define
+STRUCTURE_SIZE_BOUNDARY that way, you must define
+PCC_BITFIELD_TYPE_MATTERS to have a nonzero value.
+
+If your aim is to make GCC use the same conventions for laying out
+bit-fields as are used by another compiler, here is how to investigate
+what the other compiler does.  Compile and run this program:
+
+struct foo1
+{
+  char x;
+  char :0;
+  char y;
+};
+
+struct foo2
+{
+  char x;
+  int :0;
+  char y;
+};
+
+main ()
+{
+  printf ("Size of foo1 is %d\n",
+          sizeof (struct foo1));
+  printf ("Size of foo2 is %d\n",
+          sizeof (struct foo2));
+  exit (0);
+}
+
+If this prints 2 and 5, then the compiler's behavior is what you would
+get from PCC_BITFIELD_TYPE_MATTERS.
+*/
+#define PCC_BITFIELD_TYPE_MATTERS 1
+
+
+/******************************************************************************
+ * Layout of Source Language Data Types
+ *****************************************************************************/
+
+/*
+A C expression for the size in bits of the type int on the
+target machine.  If you don't define this, the default is one word.
+*/
+#define INT_TYPE_SIZE 32
+
+/*
+A C expression for the size in bits of the type short on the
+target machine.  If you don't define this, the default is half a word. (If
+this would be less than one storage unit, it is rounded up to one unit.)
+*/
+#define SHORT_TYPE_SIZE 16
+
+/*
+A C expression for the size in bits of the type long on the
+target machine.  If you don't define this, the default is one word.
+*/
+#define LONG_TYPE_SIZE 32
+
+
+/*
+A C expression for the size in bits of the type long long on the
+target machine.  If you don't define this, the default is two
+words.  If you want to support GNU Ada on your machine, the value of this
+macro must be at least 64.
+*/
+#define LONG_LONG_TYPE_SIZE 64
+
+/*
+A C expression for the size in bits of the type char on the
+target machine.  If you don't define this, the default is
+BITS_PER_UNIT.
+*/
+#define CHAR_TYPE_SIZE 8
+
+
+/*
+A C expression for the size in bits of the C++ type bool and
+C99 type _Bool on the target machine.  If you don't define
+this, and you probably shouldn't, the default is CHAR_TYPE_SIZE.
+*/
+#define BOOL_TYPE_SIZE 8
+
+
+/*
+An expression whose value is 1 or 0, according to whether the type
+char should be signed or unsigned by default.  The user can
+always override this default with the options -fsigned-char
+and -funsigned-char.
+*/
+/* We are using unsigned char */
+#define DEFAULT_SIGNED_CHAR 0
+
+
+/*
+A C expression for a string describing the name of the data type to use
+for size values.  The typedef name size_t is defined using the
+contents of the string.
+
+The string can contain more than one keyword.  If so, separate them with
+spaces, and write first any length keyword, then unsigned if
+appropriate, and finally int.  The string must exactly match one
+of the data type names defined in the function
+init_decl_processing in the file c-decl.c.  You may not
+omit int or change the order - that would cause the compiler to
+crash on startup.
+
+If you don't define this macro, the default is "long unsigned int".
+*/
+#define SIZE_TYPE "long unsigned int"
+
+/*
+A C expression for a string describing the name of the data type to use
+for the result of subtracting two pointers.  The typedef name
+ptrdiff_t is defined using the contents of the string.  See
+SIZE_TYPE above for more information.
+
+If you don't define this macro, the default is "long int".
+*/
+#define PTRDIFF_TYPE "long int"
+
+
+/*
+A C expression for the size in bits of the data type for wide
+characters.  This is used in cpp, which cannot make use of
+WCHAR_TYPE.
+*/
+#define WCHAR_TYPE_SIZE 32
+
+
+/*
+A C expression for a string describing the name of the data type to
+use for wide characters passed to printf and returned from
+getwc.  The typedef name wint_t is defined using the
+contents of the string.  See SIZE_TYPE above for more
+information.
+
+If you don't define this macro, the default is "unsigned int".
+*/
+#define WINT_TYPE "unsigned int"
+
+/*
+A C expression for a string describing the name of the data type that
+can represent any value of any standard or extended signed integer type.
+The typedef name intmax_t is defined using the contents of the
+string.  See SIZE_TYPE above for more information.
+
+If you don't define this macro, the default is the first of
+"int", "long int", or "long long int" that has as
+much precision as long long int.
+*/
+#define INTMAX_TYPE "long long int"
+
+/*
+A C expression for a string describing the name of the data type that
+can represent any value of any standard or extended unsigned integer
+type.  The typedef name uintmax_t is defined using the contents
+of the string.  See SIZE_TYPE above for more information.
+
+If you don't define this macro, the default is the first of
+"unsigned int", "long unsigned int", or "long long unsigned int"
+that has as much precision as long long unsigned int.
+*/
+#define UINTMAX_TYPE "long long unsigned int"
+
+
+/******************************************************************************
+ * Register Usage
+ *****************************************************************************/
+
+/* Convert from gcc internal register number to register number
+   used in assembly code */
+#define ASM_REGNUM(reg) (LAST_REGNUM - (reg))
+
+/* Convert between register number used in assembly to gcc
+   internal register number  */
+#define INTERNAL_REGNUM(reg) (LAST_REGNUM - (reg))
+
+/** Basic Characteristics of Registers **/
+
+/*
+Number of hardware registers known to the compiler.  They receive
+numbers 0 through FIRST_PSEUDO_REGISTER-1; thus, the first
+pseudo register's number really is assigned the number
+FIRST_PSEUDO_REGISTER.
+*/
+#define FIRST_PSEUDO_REGISTER (LAST_REGNUM + 1)
+
+#define FIRST_REGNUM 0
+#define LAST_REGNUM 15
+
+/*
+An initializer that says which registers are used for fixed purposes
+all throughout the compiled code and are therefore not available for
+general allocation.  These would include the stack pointer, the frame
+pointer (except on machines where that can be used as a general
+register when no frame pointer is needed), the program counter on
+machines where that is considered one of the addressable registers,
+and any other numbered register with a standard use.
+
+This information is expressed as a sequence of numbers, separated by
+commas and surrounded by braces.  The nth number is 1 if
+register n is fixed, 0 otherwise.
+
+The table initialized from this macro, and the table initialized by
+the following one, may be overridden at run time either automatically,
+by the actions of the macro CONDITIONAL_REGISTER_USAGE, or by
+the user with the command options -ffixed-[reg],
+-fcall-used-[reg] and -fcall-saved-[reg].
+*/
+
+/* The internal gcc register numbers are reversed
+   compared to the real register numbers since
+   gcc expects data types stored over multiple
+   registers in the register file to be big endian
+   if the memory layout is big endian. But this
+   is not the case for avr32 so we fake a big
+   endian register file. */
+
+#define FIXED_REGISTERS {	\
+  1, /* Program Counter */	\
+  0, /* Link Register */	\
+  1, /* Stack Pointer */	\
+  0, /* r12 */			\
+  0, /* r11 */			\
+  0, /* r10 */			\
+  0, /* r9 */			\
+  0, /* r8 */			\
+  0, /* r7 */			\
+  0, /* r6 */			\
+  0, /* r5 */			\
+  0, /* r4 */			\
+  0, /* r3 */			\
+  0, /* r2 */			\
+  0, /* r1 */			\
+  0, /* r0 */			\
+}
+
+/*
+Like FIXED_REGISTERS but has 1 for each register that is
+clobbered (in general) by function calls as well as for fixed
+registers.  This macro therefore identifies the registers that are not
+available for general allocation of values that must live across
+function calls.
+
+If a register has 0 in CALL_USED_REGISTERS, the compiler
+automatically saves it on function entry and restores it on function
+exit, if the register is used within the function.
+*/
+#define CALL_USED_REGISTERS {	\
+  1, /* Program Counter */	\
+  0, /* Link Register */	\
+  1, /* Stack Pointer */	\
+  1, /* r12 */			\
+  1, /* r11 */			\
+  1, /* r10 */			\
+  1, /* r9 */			\
+  1, /* r8 */			\
+  0, /* r7 */			\
+  0, /* r6 */			\
+  0, /* r5 */			\
+  0, /* r4 */			\
+  0, /* r3 */			\
+  0, /* r2 */			\
+  0, /* r1 */			\
+  0, /* r0 */			\
+}
+
+/* Interrupt functions can only use registers that have already been
+   saved by the prologue, even if they would normally be
+   call-clobbered.  */
+#define HARD_REGNO_RENAME_OK(SRC, DST)					\
+	(! IS_INTERRUPT (cfun->machine->func_type) ||			\
+         df_regs_ever_live_p (DST))
+
+
+/*
+Zero or more C statements that may conditionally modify five variables
+fixed_regs, call_used_regs, global_regs,
+reg_names, and reg_class_contents, to take into account
+any dependence of these register sets on target flags.  The first three
+of these are of type char [] (interpreted as Boolean vectors).
+global_regs is a const char *[], and
+reg_class_contents is a HARD_REG_SET.  Before the macro is
+called, fixed_regs, call_used_regs,
+reg_class_contents, and reg_names have been initialized
+from FIXED_REGISTERS, CALL_USED_REGISTERS,
+REG_CLASS_CONTENTS, and REGISTER_NAMES, respectively.
+global_regs has been cleared, and any -ffixed-[reg],
+-fcall-used-[reg] and -fcall-saved-[reg]
+command options have been applied.
+
+You need not define this macro if it has no work to do.
+
+If the usage of an entire class of registers depends on the target
+flags, you may indicate this to GCC by using this macro to modify
+fixed_regs and call_used_regs to 1 for each of the
+registers in the classes which should not be used by GCC.  Also define
+the macro REG_CLASS_FROM_LETTER to return NO_REGS if it
+is called with a letter for a class that shouldn't be used.
+
+ (However, if this class is not included in GENERAL_REGS and all
+of the insn patterns whose constraints permit this class are
+controlled by target switches, then GCC will automatically avoid using
+these registers when the target switches are opposed to them.)
+*/
+#define CONDITIONAL_REGISTER_USAGE                              \
+  do								\
+    {								\
+      if (flag_pic)						\
+	{							\
+	  fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;		\
+	  call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;		\
+	}							\
+    }								\
+  while (0)
+
+
+/*
+If the program counter has a register number, define this as that
+register number.  Otherwise, do not define it.
+*/
+
+#define LAST_AVR32_REGNUM 16
+
+
+/** Order of Allocation of Registers **/
+
+/*
+If defined, an initializer for a vector of integers, containing the
+numbers of hard registers in the order in which GCC should prefer
+to use them (from most preferred to least).
+
+If this macro is not defined, registers are used lowest numbered first
+(all else being equal).
+
+One use of this macro is on machines where the highest numbered
+registers must always be saved and the save-multiple-registers
+instruction supports only sequences of consecutive registers.  On such
+machines, define REG_ALLOC_ORDER to be an initializer that lists
+the highest numbered allocable register first.
+*/
+#define REG_ALLOC_ORDER 	\
+{				\
+  INTERNAL_REGNUM(8),		\
+  INTERNAL_REGNUM(9),		\
+  INTERNAL_REGNUM(10),		\
+  INTERNAL_REGNUM(11),		\
+  INTERNAL_REGNUM(12),		\
+  LR_REGNUM,			\
+  INTERNAL_REGNUM(7),		\
+  INTERNAL_REGNUM(6),		\
+  INTERNAL_REGNUM(5),		\
+  INTERNAL_REGNUM(4),		\
+  INTERNAL_REGNUM(3),		\
+  INTERNAL_REGNUM(2),		\
+  INTERNAL_REGNUM(1),		\
+  INTERNAL_REGNUM(0),		\
+  SP_REGNUM,           		\
+  PC_REGNUM			\
+}
+
+
+/** How Values Fit in Registers **/
+
+/*
+A C expression for the number of consecutive hard registers, starting
+at register number REGNO, required to hold a value of mode
+MODE.
+
+On a machine where all registers are exactly one word, a suitable
+definition of this macro is
+
+#define HARD_REGNO_NREGS(REGNO, MODE)            \
+   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \
+    / UNITS_PER_WORD)
+*/
+#define HARD_REGNO_NREGS(REGNO, MODE) \
+  ((unsigned int)((GET_MODE_SIZE(MODE) + UNITS_PER_WORD -1 ) / UNITS_PER_WORD))
+
+/*
+A C expression that is nonzero if it is permissible to store a value
+of mode MODE in hard register number REGNO (or in several
+registers starting with that one).  For a machine where all registers
+are equivalent, a suitable definition is
+
+  #define HARD_REGNO_MODE_OK(REGNO, MODE) 1
+
+You need not include code to check for the numbers of fixed registers,
+because the allocation mechanism considers them to be always occupied.
+
+On some machines, double-precision values must be kept in even/odd
+register pairs.  You can implement that by defining this macro to reject
+odd register numbers for such modes.
+
+The minimum requirement for a mode to be OK in a register is that the
+mov[mode] instruction pattern support moves between the
+register and other hard register in the same class and that moving a
+value into the register and back out not alter it.
+
+Since the same instruction used to move word_mode will work for
+all narrower integer modes, it is not necessary on any machine for
+HARD_REGNO_MODE_OK to distinguish between these modes, provided
+you define patterns movhi, etc., to take advantage of this.  This
+is useful because of the interaction between HARD_REGNO_MODE_OK
+and MODES_TIEABLE_P; it is very desirable for all integer modes
+to be tieable.
+
+Many machines have special registers for floating point arithmetic.
+Often people assume that floating point machine modes are allowed only
+in floating point registers.  This is not true.  Any registers that
+can hold integers can safely hold a floating point machine
+mode, whether or not floating arithmetic can be done on it in those
+registers.  Integer move instructions can be used to move the values.
+
+On some machines, though, the converse is true: fixed-point machine
+modes may not go in floating registers.  This is true if the floating
+registers normalize any value stored in them, because storing a
+non-floating value there would garble it.  In this case,
+HARD_REGNO_MODE_OK should reject fixed-point machine modes in
+floating registers.  But if the floating registers do not automatically
+normalize, if you can store any bit pattern in one and retrieve it
+unchanged without a trap, then any machine mode may go in a floating
+register, so you can define this macro to say so.
+
+The primary significance of special floating registers is rather that
+they are the registers acceptable in floating point arithmetic
+instructions.  However, this is of no concern to
+HARD_REGNO_MODE_OK.  You handle it by writing the proper
+constraints for those instructions.
+
+On some machines, the floating registers are especially slow to access,
+so that it is better to store a value in a stack frame than in such a
+register if floating point arithmetic is not being done.  As long as the
+floating registers are not in class GENERAL_REGS, they will not
+be used unless some pattern's constraint asks for one.
+*/
+#define HARD_REGNO_MODE_OK(REGNO, MODE) avr32_hard_regno_mode_ok(REGNO, MODE)
+
+/*
+A C expression that is nonzero if a value of mode
+MODE1 is accessible in mode MODE2 without copying.
+
+If HARD_REGNO_MODE_OK(R, MODE1) and
+HARD_REGNO_MODE_OK(R, MODE2) are always the same for
+any R, then MODES_TIEABLE_P(MODE1, MODE2)
+should be nonzero.  If they differ for any R, you should define
+this macro to return zero unless some other mechanism ensures the
+accessibility of the value in a narrower mode.
+
+You should define this macro to return nonzero in as many cases as
+possible since doing so will allow GCC to perform better register
+allocation.
+*/
+#define MODES_TIEABLE_P(MODE1, MODE2)  \
+  (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))
+
+
+
+/******************************************************************************
+ * Register Classes
+ *****************************************************************************/
+
+/*
+An enumeral type that must be defined with all the register class names
+as enumeral values.  NO_REGS must be first.  ALL_REGS
+must be the last register class, followed by one more enumeral value,
+LIM_REG_CLASSES, which is not a register class but rather
+tells how many classes there are.
+
+Each register class has a number, which is the value of casting
+the class name to type int.  The number serves as an index
+in many of the tables described below.
+*/
+enum reg_class
+{
+  NO_REGS,
+  GENERAL_REGS,
+  ALL_REGS,
+  LIM_REG_CLASSES
+};
+
+/*
+The number of distinct register classes, defined as follows:
+  #define N_REG_CLASSES (int) LIM_REG_CLASSES
+*/
+#define N_REG_CLASSES (int)LIM_REG_CLASSES
+
+/*
+An initializer containing the names of the register classes as C string
+constants.  These names are used in writing some of the debugging dumps.
+*/
+#define REG_CLASS_NAMES		\
+{				\
+  "NO_REGS",			\
+  "GENERAL_REGS",		\
+  "ALL_REGS"			\
+}
+
+/*
+An initializer containing the contents of the register classes, as integers
+which are bit masks.  The nth integer specifies the contents of class
+n.  The way the integer mask is interpreted is that
+register r is in the class if mask & (1 << r) is 1.
+
+When the machine has more than 32 registers, an integer does not suffice.
+Then the integers are replaced by sub-initializers, braced groupings containing
+several integers.  Each sub-initializer must be suitable as an initializer
+for the type HARD_REG_SET which is defined in hard-reg-set.h.
+In this situation, the first integer in each sub-initializer corresponds to
+registers 0 through 31, the second integer to registers 32 through 63, and
+so on.
+*/
+#define REG_CLASS_CONTENTS {		\
+  {0x00000000}, /* NO_REGS */		\
+  {0x0000FFFF}, /* GENERAL_REGS */	\
+  {0x7FFFFFFF}, /* ALL_REGS */		\
+}
+
+
+/*
+A C expression whose value is a register class containing hard register
+REGNO.  In general there is more than one such class; choose a class
+which is minimal, meaning that no smaller class also contains the
+register.
+*/
+#define REGNO_REG_CLASS(REGNO) (GENERAL_REGS)
+
+/*
+A macro whose definition is the name of the class to which a valid
+base register must belong.  A base register is one used in an address
+which is the register value plus a displacement.
+*/
+#define BASE_REG_CLASS GENERAL_REGS
+
+/*
+This is a variation of the BASE_REG_CLASS macro which allows
+the selection of a base register in a mode depenedent manner.  If
+mode is VOIDmode then it should return the same value as
+BASE_REG_CLASS.
+*/
+#define MODE_BASE_REG_CLASS(MODE) BASE_REG_CLASS
+
+/*
+A macro whose definition is the name of the class to which a valid
+index register must belong.  An index register is one used in an
+address where its value is either multiplied by a scale factor or
+added to another register (as well as added to a displacement).
+*/
+#define INDEX_REG_CLASS BASE_REG_CLASS
+
+/*
+A C expression which defines the machine-dependent operand constraint
+letters for register classes.  If CHAR is such a letter, the
+value should be the register class corresponding to it.  Otherwise,
+the value should be NO_REGS.  The register letter r,
+corresponding to class GENERAL_REGS, will not be passed
+to this macro; you do not need to handle it.
+*/
+#define REG_CLASS_FROM_LETTER(CHAR) NO_REGS
+
+/* These assume that REGNO is a hard or pseudo reg number.
+   They give nonzero only if REGNO is a hard reg of the suitable class
+   or a pseudo reg currently allocated to a suitable hard reg.
+   Since they use reg_renumber, they are safe only once reg_renumber
+   has been allocated, which happens in local-alloc.c.  */
+#define TEST_REGNO(R, TEST, VALUE) \
+  ((R TEST VALUE) || ((unsigned) reg_renumber[R] TEST VALUE))
+
+/*
+A C expression which is nonzero if register number num is suitable for use as a base
+register in operand addresses. It may be either a suitable hard register or a pseudo
+register that has been allocated such a hard register.
+*/
+#define REGNO_OK_FOR_BASE_P(NUM)  TEST_REGNO(NUM, <=, LAST_REGNUM)
+
+/* The following macro defines cover classes for Integrated Register
+   Allocator.  Cover classes is a set of non-intersected register
+   classes covering all hard registers used for register allocation
+   purpose.  Any move between two registers of a cover class should be
+   cheaper than load or store of the registers.  The macro value is
+   array of register classes with LIM_REG_CLASSES used as the end
+   marker.  */
+
+#define IRA_COVER_CLASSES               \
+{                                       \
+  GENERAL_REGS, LIM_REG_CLASSES         \
+}
+
+/*
+A C expression which is nonzero if register number NUM is
+suitable for use as an index register in operand addresses.  It may be
+either a suitable hard register or a pseudo register that has been
+allocated such a hard register.
+
+The difference between an index register and a base register is that
+the index register may be scaled.  If an address involves the sum of
+two registers, neither one of them scaled, then either one may be
+labeled the ``base'' and the other the ``index''; but whichever
+labeling is used must fit the machine's constraints of which registers
+may serve in each capacity.  The compiler will try both labelings,
+looking for one that is valid, and will reload one or both registers
+only if neither labeling works.
+*/
+#define REGNO_OK_FOR_INDEX_P(NUM) TEST_REGNO(NUM, <=, LAST_REGNUM)
+
+/*
+A C expression that places additional restrictions on the register class
+to use when it is necessary to copy value X into a register in class
+CLASS.  The value is a register class; perhaps CLASS, or perhaps
+another, smaller class.  On many machines, the following definition is
+safe: #define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS
+
+Sometimes returning a more restrictive class makes better code.  For
+example, on the 68000, when X is an integer constant that is in range
+for a 'moveq' instruction, the value of this macro is always
+DATA_REGS as long as CLASS includes the data registers.
+Requiring a data register guarantees that a 'moveq' will be used.
+
+If X is a const_double, by returning NO_REGS
+you can force X into a memory constant.  This is useful on
+certain machines where immediate floating values cannot be loaded into
+certain kinds of registers.
+*/
+#define PREFERRED_RELOAD_CLASS(X, CLASS)  CLASS
+
+
+
+/*
+A C expression for the maximum number of consecutive registers
+of class CLASS needed to hold a value of mode MODE.
+
+This is closely related to the macro HARD_REGNO_NREGS.  In fact,
+the value of the macro CLASS_MAX_NREGS(CLASS, MODE)
+should be the maximum value of HARD_REGNO_NREGS(REGNO, MODE)
+for all REGNO values in the class CLASS.
+
+This macro helps control the handling of multiple-word values
+in the reload pass.
+*/
+#define CLASS_MAX_NREGS(CLASS, MODE) /* ToDo:fixme */ \
+  (unsigned int)((GET_MODE_SIZE(MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+
+
+/*
+  Using CONST_OK_FOR_CONSTRAINT_P instead of CONS_OK_FOR_LETTER_P
+  in order to support constraints with more than one letter.
+  Only two letters are then used for constant constraints,
+  the letter 'K' and the letter 'I'. The constraint starting with
+  these letters must consist of four characters. The character following
+  'K' or 'I' must be either 'u' (unsigned) or 's' (signed) to specify
+  if the constant is zero or sign extended. The last two characters specify
+  the length in bits of the constant. The base constraint letter 'I' means
+  that this is an negated constant, meaning that actually -VAL should be
+  checked to lie withing the valid range instead of VAL which is used when
+  'K' is the base constraint letter.
+
+*/
+
+#define CONSTRAINT_LEN(C, STR)				\
+  ( ((C) == 'K' || (C) == 'I') ?  4 :			\
+    ((C) == 'R') ?  5 :					\
+    ((C) == 'P') ? -1 :                                 \
+    DEFAULT_CONSTRAINT_LEN((C), (STR)) )
+
+#define CONST_OK_FOR_CONSTRAINT_P(VALUE, C, STR)	\
+  avr32_const_ok_for_constraint_p(VALUE, C, STR)
+
+/*
+A C expression that defines the machine-dependent operand constraint
+letters that specify particular ranges of const_double values ('G' or 'H').
+
+If C is one of those letters, the expression should check that
+VALUE, an RTX of code const_double, is in the appropriate
+range and return 1 if so, 0 otherwise.  If C is not one of those
+letters, the value should be 0 regardless of VALUE.
+
+const_double is used for all floating-point constants and for
+DImode fixed-point constants.  A given letter can accept either
+or both kinds of values.  It can use GET_MODE to distinguish
+between these kinds.
+*/
+#define CONST_DOUBLE_OK_FOR_LETTER_P(OP, C) \
+  ((C) == 'G' ? avr32_const_double_immediate(OP) : 0)
+
+/*
+A C expression that defines the optional machine-dependent constraint
+letters that can be used to segregate specific types of operands, usually
+memory references, for the target machine.  Any letter that is not
+elsewhere defined and not matched by REG_CLASS_FROM_LETTER
+may be used.  Normally this macro will not be defined.
+
+If it is required for a particular target machine, it should return 1
+if VALUE corresponds to the operand type represented by the
+constraint letter C.  If C is not defined as an extra
+constraint, the value returned should be 0 regardless of VALUE.
+
+For example, on the ROMP, load instructions cannot have their output
+in r0 if the memory reference contains a symbolic address.  Constraint
+letter 'Q' is defined as representing a memory address that does
+not contain a symbolic address.  An alternative is specified with
+a 'Q' constraint on the input and 'r' on the output.  The next
+alternative specifies 'm' on the input and a register class that
+does not include r0 on the output.
+*/
+#define EXTRA_CONSTRAINT_STR(OP, C, STR)				\
+  ((C) == 'W' ? avr32_address_operand(OP, GET_MODE(OP)) :		\
+   (C) == 'R' ? (avr32_indirect_register_operand(OP, GET_MODE(OP)) ||	\
+                 (avr32_imm_disp_memory_operand(OP, GET_MODE(OP))	\
+                  && avr32_const_ok_for_constraint_p(			\
+				INTVAL(XEXP(XEXP(OP, 0), 1)),		\
+				(STR)[1], &(STR)[1]))) :		\
+   (C) == 'S' ? avr32_indexed_memory_operand(OP, GET_MODE(OP)) :	\
+   (C) == 'T' ? avr32_const_pool_ref_operand(OP, GET_MODE(OP)) :	\
+   (C) == 'U' ? SYMBOL_REF_RCALL_FUNCTION_P(OP) :			\
+   (C) == 'Z' ? avr32_cop_memory_operand(OP, GET_MODE(OP)) :		\
+   (C) == 'Q' ? avr32_non_rmw_memory_operand(OP, GET_MODE(OP)) :		\
+   (C) == 'Y' ? avr32_rmw_memory_operand(OP, GET_MODE(OP)) :            \
+   0)
+
+
+#define EXTRA_MEMORY_CONSTRAINT(C, STR) ( ((C) == 'R') ||               \
+                                          ((C) == 'Q') ||               \
+                                          ((C) == 'S') ||               \
+                                          ((C) == 'Y') ||               \
+                                          ((C) == 'Z') )
+
+
+/* Returns nonzero if op is a function SYMBOL_REF which
+   can be called using an rcall instruction */
+#define SYMBOL_REF_RCALL_FUNCTION_P(op)  \
+  ( GET_CODE(op) == SYMBOL_REF           \
+    && SYMBOL_REF_FUNCTION_P(op)         \
+    && SYMBOL_REF_LOCAL_P(op)            \
+    && !SYMBOL_REF_EXTERNAL_P(op)        \
+    && !TARGET_HAS_ASM_ADDR_PSEUDOS )
+
+/******************************************************************************
+ * Stack Layout and Calling Conventions
+ *****************************************************************************/
+
+/** Basic Stack Layout **/
+
+/*
+Define this macro if pushing a word onto the stack moves the stack
+pointer to a smaller address.
+
+When we say, ``define this macro if ...,'' it means that the
+compiler checks this macro only with #ifdef so the precise
+definition used does not matter.
+*/
+/* pushm decrece SP: *(--SP) <-- Rx */
+#define STACK_GROWS_DOWNWARD
+
+/*
+This macro defines the operation used when something is pushed
+on the stack.  In RTL, a push operation will be
+(set (mem (STACK_PUSH_CODE (reg sp))) ...)
+
+The choices are PRE_DEC, POST_DEC, PRE_INC,
+and POST_INC.  Which of these is correct depends on
+the stack direction and on whether the stack pointer points
+to the last item on the stack or whether it points to the
+space for the next item on the stack.
+
+The default is PRE_DEC when STACK_GROWS_DOWNWARD is
+defined, which is almost always right, and PRE_INC otherwise,
+which is often wrong.
+*/
+/* pushm: *(--SP) <-- Rx */
+#define STACK_PUSH_CODE PRE_DEC
+
+/* Define this to nonzero if the nominal address of the stack frame
+   is at the high-address end of the local variables;
+   that is, each additional local variable allocated
+   goes at a more negative offset in the frame.  */
+#define FRAME_GROWS_DOWNWARD 1
+
+
+/*
+Offset from the frame pointer to the first local variable slot to be allocated.
+
+If FRAME_GROWS_DOWNWARD, find the next slot's offset by
+subtracting the first slot's length from STARTING_FRAME_OFFSET.
+Otherwise, it is found by adding the length of the first slot to the
+value STARTING_FRAME_OFFSET.
+  (i'm not sure if the above is still correct.. had to change it to get
+   rid of an overfull.  --mew 2feb93 )
+*/
+#define STARTING_FRAME_OFFSET 0
+
+/*
+Offset from the stack pointer register to the first location at which
+outgoing arguments are placed.  If not specified, the default value of
+zero is used.  This is the proper value for most machines.
+
+If ARGS_GROW_DOWNWARD, this is the offset to the location above
+the first location at which outgoing arguments are placed.
+*/
+#define STACK_POINTER_OFFSET 0
+
+/*
+Offset from the argument pointer register to the first argument's
+address.  On some machines it may depend on the data type of the
+function.
+
+If ARGS_GROW_DOWNWARD, this is the offset to the location above
+the first argument's address.
+*/
+#define FIRST_PARM_OFFSET(FUNDECL) 0
+
+
+/*
+A C expression whose value is RTL representing the address in a stack
+frame where the pointer to the caller's frame is stored.  Assume that
+FRAMEADDR is an RTL expression for the address of the stack frame
+itself.
+
+If you don't define this macro, the default is to return the value
+of FRAMEADDR - that is, the stack frame address is also the
+address of the stack word that points to the previous frame.
+*/
+#define DYNAMIC_CHAIN_ADDRESS(FRAMEADDR) plus_constant ((FRAMEADDR), 4)
+
+
+/*
+A C expression whose value is RTL representing the value of the return
+address for the frame COUNT steps up from the current frame, after
+the prologue.  FRAMEADDR is the frame pointer of the COUNT
+frame, or the frame pointer of the COUNT - 1 frame if
+RETURN_ADDR_IN_PREVIOUS_FRAME is defined.
+
+The value of the expression must always be the correct address when
+COUNT is zero, but may be NULL_RTX if there is not way to
+determine the return address of other frames.
+*/
+#define RETURN_ADDR_RTX(COUNT, FRAMEADDR) avr32_return_addr(COUNT, FRAMEADDR)
+
+
+/*
+A C expression whose value is RTL representing the location of the
+incoming return address at the beginning of any function, before the
+prologue.  This RTL is either a REG, indicating that the return
+value is saved in 'REG', or a MEM representing a location in
+the stack.
+
+You only need to define this macro if you want to support call frame
+debugging information like that provided by DWARF 2.
+
+If this RTL is a REG, you should also define
+DWARF_FRAME_RETURN_COLUMN to DWARF_FRAME_REGNUM (REGNO).
+*/
+#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, LR_REGNUM)
+
+/*
+A C expression whose value is an integer giving the offset, in bytes,
+from the value of the stack pointer register to the top of the stack
+frame at the beginning of any function, before the prologue.  The top of
+the frame is defined to be the value of the stack pointer in the
+previous frame, just before the call instruction.
+
+You only need to define this macro if you want to support call frame
+debugging information like that provided by DWARF 2.
+*/
+#define INCOMING_FRAME_SP_OFFSET 0
+
+
+/** Exception Handling Support **/
+
+/* Use setjump/longjump for exception handling. */
+#define DWARF2_UNWIND_INFO 0
+#define MUST_USE_SJLJ_EXCEPTIONS 1
+
+/*
+A C expression whose value is the Nth register number used for
+data by exception handlers, or INVALID_REGNUM if fewer than
+N registers are usable.
+
+The exception handling library routines communicate with the exception
+handlers via a set of agreed upon registers.  Ideally these registers
+should be call-clobbered; it is possible to use call-saved registers,
+but may negatively impact code size.  The target must support at least
+2 data registers, but should define 4 if there are enough free registers.
+
+You must define this macro if you want to support call frame exception
+handling like that provided by DWARF 2.
+*/
+/*
+  Use r9-r11
+*/
+#define EH_RETURN_DATA_REGNO(N)                                         \
+  ((N<3) ? INTERNAL_REGNUM(N+9) : INVALID_REGNUM)
+
+/*
+A C expression whose value is RTL representing a location in which
+to store a stack adjustment to be applied before function return.
+This is used to unwind the stack to an exception handler's call frame.
+It will be assigned zero on code paths that return normally.
+
+Typically this is a call-clobbered hard register that is otherwise
+untouched by the epilogue, but could also be a stack slot.
+
+You must define this macro if you want to support call frame exception
+handling like that provided by DWARF 2.
+*/
+/*
+  Use r8
+*/
+#define EH_RETURN_STACKADJ_REGNO INTERNAL_REGNUM(8)
+#define EH_RETURN_STACKADJ_RTX gen_rtx_REG(SImode, EH_RETURN_STACKADJ_REGNO)
+
+/*
+A C expression whose value is RTL representing a location in which
+to store the address of an exception handler to which we should
+return.  It will not be assigned on code paths that return normally.
+
+Typically this is the location in the call frame at which the normal
+return address is stored.  For targets that return by popping an
+address off the stack, this might be a memory address just below
+the target call frame rather than inside the current call
+frame.  EH_RETURN_STACKADJ_RTX will have already been assigned,
+so it may be used to calculate the location of the target call frame.
+
+Some targets have more complex requirements than storing to an
+address calculable during initial code generation.  In that case
+the eh_return instruction pattern should be used instead.
+
+If you want to support call frame exception handling, you must
+define either this macro or the eh_return instruction pattern.
+*/
+/*
+  We define the eh_return instruction pattern, so this isn't needed.
+*/
+/* #define EH_RETURN_HANDLER_RTX gen_rtx_REG(Pmode, RET_REGISTER) */
+
+/*
+  This macro chooses the encoding of pointers embedded in the
+  exception handling sections. If at all possible, this should be
+  defined such that the exception handling section will not require
+  dynamic relocations, and so may be read-only.
+
+  code is 0 for data, 1 for code labels, 2 for function
+  pointers. global is true if the symbol may be affected by dynamic
+  relocations. The macro should return a combination of the DW_EH_PE_*
+  defines as found in dwarf2.h.
+
+  If this macro is not defined, pointers will not be encoded but
+  represented directly.
+*/
+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL)	\
+  ((flag_pic && (GLOBAL) ? DW_EH_PE_indirect : 0)	\
+   | (flag_pic ? DW_EH_PE_pcrel : DW_EH_PE_absptr)	\
+   | DW_EH_PE_sdata4)
+
+/* ToDo: The rest of this subsection */
+
+/** Specifying How Stack Checking is Done **/
+/* ToDo: All in this subsection */
+
+/** Registers That Address the Stack Frame **/
+
+/*
+The register number of the stack pointer register, which must also be a
+fixed register according to FIXED_REGISTERS.  On most machines,
+the hardware determines which register this is.
+*/
+/* Using r13 as stack pointer. */
+#define STACK_POINTER_REGNUM INTERNAL_REGNUM(13)
+
+/*
+The register number of the frame pointer register, which is used to
+access automatic variables in the stack frame.  On some machines, the
+hardware determines which register this is.  On other machines, you can
+choose any register you wish for this purpose.
+*/
+/* Use r7 */
+#define FRAME_POINTER_REGNUM INTERNAL_REGNUM(7)
+
+/*
+The register number of the arg pointer register, which is used to access
+the function's argument list.  On some machines, this is the same as the
+frame pointer register.  On some machines, the hardware determines which
+register this is.  On other machines, you can choose any register you
+wish for this purpose.  If this is not the same register as the frame
+pointer register, then you must mark it as a fixed register according to
+FIXED_REGISTERS, or arrange to be able to eliminate it (see Section
+10.10.5 [Elimination], page 224).
+*/
+/* Using r5 */
+#define ARG_POINTER_REGNUM INTERNAL_REGNUM(4)
+
+
+/*
+Register numbers used for passing a function's static chain pointer.  If
+register windows are used, the register number as seen by the called
+function is STATIC_CHAIN_INCOMING_REGNUM, while the register
+number as seen by the calling function is STATIC_CHAIN_REGNUM.  If
+these registers are the same, STATIC_CHAIN_INCOMING_REGNUM need
+not be defined.
+
+The static chain register need not be a fixed register.
+
+If the static chain is passed in memory, these macros should not be
+defined; instead, the next two macros should be defined.
+*/
+/* Using r0 */
+#define STATIC_CHAIN_REGNUM INTERNAL_REGNUM(0)
+
+/** Eliminating Frame Pointer and Arg Pointer **/
+
+/*
+A C expression which is nonzero if a function must have and use a frame
+pointer.  This expression is evaluated  in the reload pass.  If its value is
+nonzero the function will have a frame pointer.
+
+The expression can in principle examine the current function and decide
+according to the facts, but on most machines the constant 0 or the
+constant 1 suffices.  Use 0 when the machine allows code to be generated
+with no frame pointer, and doing so saves some time or space.  Use 1
+when there is no possible advantage to avoiding a frame pointer.
+
+In certain cases, the compiler does not know how to produce valid code
+without a frame pointer.  The compiler recognizes those cases and
+automatically gives the function a frame pointer regardless of what
+FRAME_POINTER_REQUIRED says.  You don't need to worry about
+them.
+
+In a function that does not require a frame pointer, the frame pointer
+register can be allocated for ordinary usage, unless you mark it as a
+fixed register.  See FIXED_REGISTERS for more information.
+*/
+/* We need the frame pointer when compiling for profiling */
+#define FRAME_POINTER_REQUIRED (crtl->profile)
+
+/*
+A C statement to store in the variable DEPTH_VAR the difference
+between the frame pointer and the stack pointer values immediately after
+the function prologue.  The value would be computed from information
+such as the result of get_frame_size () and the tables of
+registers regs_ever_live and call_used_regs.
+
+If ELIMINABLE_REGS is defined, this macro will be not be used and
+need not be defined.  Otherwise, it must be defined even if
+FRAME_POINTER_REQUIRED is defined to always be true; in that
+case, you may set DEPTH_VAR to anything.
+*/
+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH_VAR) ((DEPTH_VAR) = get_frame_size())
+
+/*
+If defined, this macro specifies a table of register pairs used to
+eliminate unneeded registers that point into the stack frame.  If it is not
+defined, the only elimination attempted by the compiler is to replace
+references to the frame pointer with references to the stack pointer.
+
+The definition of this macro is a list of structure initializations, each
+of which specifies an original and replacement register.
+
+On some machines, the position of the argument pointer is not known until
+the compilation is completed.  In such a case, a separate hard register
+must be used for the argument pointer.  This register can be eliminated by
+replacing it with either the frame pointer or the argument pointer,
+depending on whether or not the frame pointer has been eliminated.
+
+In this case, you might specify:
+  #define ELIMINABLE_REGS  \
+  {{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM}, \
+   {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}, \
+   {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}
+
+Note that the elimination of the argument pointer with the stack pointer is
+specified first since that is the preferred elimination.
+*/
+#define ELIMINABLE_REGS					\
+{							\
+  { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM },	\
+  { ARG_POINTER_REGNUM, STACK_POINTER_REGNUM },		\
+  { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM }		\
+}
+
+/*
+A C expression that returns nonzero if the compiler is allowed to try
+to replace register number FROM with register number
+TO.  This macro need only be defined if ELIMINABLE_REGS
+is defined, and will usually be the constant 1, since most of the cases
+preventing register elimination are things that the compiler already
+knows about.
+*/
+#define CAN_ELIMINATE(FROM, TO) 1
+
+/*
+This macro is similar to INITIAL_FRAME_POINTER_OFFSET.  It
+specifies the initial difference between the specified pair of
+registers.  This macro must be defined if ELIMINABLE_REGS is
+defined.
+*/
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)		\
+  ((OFFSET) = avr32_initial_elimination_offset(FROM, TO))
+
+/** Passing Function Arguments on the Stack **/
+
+
+/*
+A C expression.  If nonzero, push insns will be used to pass
+outgoing arguments.
+If the target machine does not have a push instruction, set it to zero.
+That directs GCC to use an alternate strategy: to
+allocate the entire argument block and then store the arguments into
+it.  When PUSH_ARGS is nonzero, PUSH_ROUNDING must be defined too.
+*/
+#define PUSH_ARGS 1
+
+/*
+A C expression that is the number of bytes actually pushed onto the
+stack when an instruction attempts to push NPUSHED bytes.
+
+On some machines, the definition
+
+  #define PUSH_ROUNDING(BYTES) (BYTES)
+
+will suffice.  But on other machines, instructions that appear
+to push one byte actually push two bytes in an attempt to maintain
+alignment.  Then the definition should be
+
+  #define PUSH_ROUNDING(BYTES) (((BYTES) + 1) & ~1)
+*/
+/* Push 4 bytes at the time. */
+#define PUSH_ROUNDING(NPUSHED) (((NPUSHED) + 3) & ~3)
+
+/*
+A C expression.  If nonzero, the maximum amount of space required for
+outgoing arguments will be computed and placed into the variable
+current_function_outgoing_args_size.  No space will be pushed
+onto the stack for each call; instead, the function prologue should
+increase the stack frame size by this amount.
+
+Setting both PUSH_ARGS and ACCUMULATE_OUTGOING_ARGS is not proper.
+*/
+#define ACCUMULATE_OUTGOING_ARGS 0
+
+/*
+A C expression that should indicate the number of bytes of its own
+arguments that a function pops on returning, or 0 if the
+function pops no arguments and the caller must therefore pop them all
+after the function returns.
+
+FUNDECL is a C variable whose value is a tree node that describes
+the function in question.  Normally it is a node of type
+FUNCTION_DECL that describes the declaration of the function.
+From this you can obtain the DECL_ATTRIBUTES of the function.
+
+FUNTYPE is a C variable whose value is a tree node that
+describes the function in question.  Normally it is a node of type
+FUNCTION_TYPE that describes the data type of the function.
+From this it is possible to obtain the data types of the value and
+arguments (if known).
+
+When a call to a library function is being considered, FUNDECL
+will contain an identifier node for the library function.  Thus, if
+you need to distinguish among various library functions, you can do so
+by their names.  Note that ``library function'' in this context means
+a function used to perform arithmetic, whose name is known specially
+in the compiler and was not mentioned in the C code being compiled.
+
+STACK_SIZE is the number of bytes of arguments passed on the
+stack.  If a variable number of bytes is passed, it is zero, and
+argument popping will always be the responsibility of the calling function.
+
+On the VAX, all functions always pop their arguments, so the definition
+of this macro is STACK_SIZE.  On the 68000, using the standard
+calling convention, no functions pop their arguments, so the value of
+the macro is always 0 in this case.  But an alternative calling
+convention is available in which functions that take a fixed number of
+arguments pop them but other functions (such as printf) pop
+nothing (the caller pops all).  When this convention is in use,
+FUNTYPE is examined to determine whether a function takes a fixed
+number of arguments.
+*/
+#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, STACK_SIZE) 0
+
+
+/*Return true if this function can we use a single return instruction*/
+#define USE_RETURN_INSN(ISCOND) avr32_use_return_insn(ISCOND)
+
+/*
+A C expression that should indicate the number of bytes a call sequence
+pops off the stack.  It is added to the value of RETURN_POPS_ARGS
+when compiling a function call.
+
+CUM is the variable in which all arguments to the called function
+have been accumulated.
+
+On certain architectures, such as the SH5, a call trampoline is used
+that pops certain registers off the stack, depending on the arguments
+that have been passed to the function.  Since this is a property of the
+call site, not of the called function, RETURN_POPS_ARGS is not
+appropriate.
+*/
+#define CALL_POPS_ARGS(CUM) 0
+
+/* Passing Arguments in Registers */
+
+/*
+A C expression that controls whether a function argument is passed
+in a register, and which register.
+
+The arguments are CUM, which summarizes all the previous
+arguments; MODE, the machine mode of the argument; TYPE,
+the data type of the argument as a tree node or 0 if that is not known
+(which happens for C support library functions); and NAMED,
+which is 1 for an ordinary argument and 0 for nameless arguments that
+correspond to '...' in the called function's prototype.
+TYPE can be an incomplete type if a syntax error has previously
+occurred.
+
+The value of the expression is usually either a reg RTX for the
+hard register in which to pass the argument, or zero to pass the
+argument on the stack.
+
+For machines like the VAX and 68000, where normally all arguments are
+pushed, zero suffices as a definition.
+
+The value of the expression can also be a parallel RTX.  This is
+used when an argument is passed in multiple locations.  The mode of the
+of the parallel should be the mode of the entire argument.  The
+parallel holds any number of expr_list pairs; each one
+describes where part of the argument is passed.  In each
+expr_list the first operand must be a reg RTX for the hard
+register in which to pass this part of the argument, and the mode of the
+register RTX indicates how large this part of the argument is.  The
+second operand of the expr_list is a const_int which gives
+the offset in bytes into the entire argument of where this part starts.
+As a special exception the first expr_list in the parallel
+RTX may have a first operand of zero.  This indicates that the entire
+argument is also stored on the stack.
+
+The last time this macro is called, it is called with MODE == VOIDmode,
+and its result is passed to the call or call_value
+pattern as operands 2 and 3 respectively.
+
+The usual way to make the ISO library 'stdarg.h' work on a machine
+where some arguments are usually passed in registers, is to cause
+nameless arguments to be passed on the stack instead.  This is done
+by making FUNCTION_ARG return 0 whenever NAMED is 0.
+
+You may use the macro MUST_PASS_IN_STACK (MODE, TYPE)
+in the definition of this macro to determine if this argument is of a
+type that must be passed in the stack.  If REG_PARM_STACK_SPACE
+is not defined and FUNCTION_ARG returns nonzero for such an
+argument, the compiler will abort.  If REG_PARM_STACK_SPACE is
+defined, the argument will be computed in the stack and then loaded into
+a register.  */
+
+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \
+  avr32_function_arg(&(CUM), MODE, TYPE, NAMED)
+
+/*
+A C type for declaring a variable that is used as the first argument of
+FUNCTION_ARG and other related values.  For some target machines,
+the type int suffices and can hold the number of bytes of
+argument so far.
+
+There is no need to record in CUMULATIVE_ARGS anything about the
+arguments that have been passed on the stack.  The compiler has other
+variables to keep track of that.  For target machines on which all
+arguments are passed on the stack, there is no need to store anything in
+CUMULATIVE_ARGS; however, the data structure must exist and
+should not be empty, so use int.
+*/
+typedef struct avr32_args
+{
+  /* Index representing the argument register the current function argument
+     will occupy */
+  int index;
+  /* A mask with bits representing the argument registers: if a bit is set
+     then this register is used for an argument */
+  int used_index;
+  /* TRUE if this function has anonymous arguments */
+  int uses_anonymous_args;
+  /* The size in bytes of the named arguments pushed on the stack */
+  int stack_pushed_args_size;
+  /* Set to true if this function needs a Return Value Pointer */
+  int use_rvp;
+  /* Set to true if function is a flashvault function. */
+  int flashvault_func;
+
+} CUMULATIVE_ARGS;
+
+
+#define FIRST_CUM_REG_INDEX 0
+#define LAST_CUM_REG_INDEX 4
+#define GET_REG_INDEX(CUM) ((CUM)->index)
+#define SET_REG_INDEX(CUM, INDEX) ((CUM)->index = (INDEX));
+#define GET_USED_INDEX(CUM, INDEX) ((CUM)->used_index & (1 << (INDEX)))
+#define SET_USED_INDEX(CUM, INDEX)		\
+  do						\
+    {						\
+      if (INDEX >= 0)				\
+        (CUM)->used_index |= (1 << (INDEX));	\
+    }						\
+  while (0)
+#define SET_INDEXES_UNUSED(CUM) ((CUM)->used_index = 0)
+
+/*
+   A C statement (sans semicolon) for initializing the variable cum for the
+   state at the beginning of the argument list. The variable has type
+   CUMULATIVE_ARGS. The value of FNTYPE is the tree node for the data type of
+   the function which will receive the args, or 0 if the args are to a compiler
+   support library function. For direct calls that are not libcalls, FNDECL
+   contain the declaration node of the function. FNDECL is also set when
+   INIT_CUMULATIVE_ARGS is used to find arguments for the function being
+   compiled.  N_NAMED_ARGS is set to the number of named arguments, including a
+   structure return address if it is passed as a parameter, when making a call.
+   When processing incoming arguments, N_NAMED_ARGS is set to -1.
+
+   When processing a call to a compiler support library function, LIBNAME
+   identifies which one.  It is a symbol_ref rtx which contains the name of the
+   function, as a string. LIBNAME is 0 when an ordinary C function call is
+   being processed. Thus, each time this macro is called, either LIBNAME or
+   FNTYPE is nonzero, but never both of them at once.
+*/
+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \
+  avr32_init_cumulative_args(&(CUM), FNTYPE, LIBNAME, FNDECL)
+
+/*
+A C statement (sans semicolon) to update the summarizer variable
+CUM to advance past an argument in the argument list.  The
+values MODE, TYPE and NAMED describe that argument.
+Once this is done, the variable CUM is suitable for analyzing
+the following argument with FUNCTION_ARG, etc.
+
+This macro need not do anything if the argument in question was passed
+on the stack.  The compiler knows how to track the amount of stack space
+used for arguments without any special help.
+*/
+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \
+  avr32_function_arg_advance(&(CUM), MODE, TYPE, NAMED)
+
+/*
+If defined, a C expression which determines whether, and in which direction,
+to pad out an argument with extra space.  The value should be of type
+enum direction: either 'upward' to pad above the argument,
+'downward' to pad below, or 'none' to inhibit padding.
+
+The amount of padding is always just enough to reach the next
+multiple of FUNCTION_ARG_BOUNDARY; this macro does not control
+it.
+
+This macro has a default definition which is right for most systems.
+For little-endian machines, the default is to pad upward.  For
+big-endian machines, the default is to pad downward for an argument of
+constant size shorter than an int, and upward otherwise.
+*/
+#define FUNCTION_ARG_PADDING(MODE, TYPE) \
+  avr32_function_arg_padding(MODE, TYPE)
+
+/*
+  Specify padding for the last element of a block move between registers
+  and memory. First is nonzero if this is the only element. Defining
+  this macro allows better control of register function parameters on
+  big-endian machines, without using PARALLEL rtl. In particular,
+  MUST_PASS_IN_STACK need not test padding and mode of types in registers,
+  as there is no longer a "wrong" part of a register; For example, a three
+  byte aggregate may be passed in the high part of a register if so required.
+*/
+#define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \
+  avr32_function_arg_padding(MODE, TYPE)
+
+/*
+If defined, a C expression which determines whether the default
+implementation of va_arg will attempt to pad down before reading the
+next argument, if that argument is smaller than its aligned space as
+controlled by PARM_BOUNDARY.  If this macro is not defined, all such
+arguments are padded down if BYTES_BIG_ENDIAN is true.
+*/
+#define PAD_VARARGS_DOWN \
+  (FUNCTION_ARG_PADDING (TYPE_MODE (type), type) == downward)
+
+/*
+A C expression that is nonzero if REGNO is the number of a hard
+register in which function arguments are sometimes passed.  This does
+not include implicit arguments such as the static chain and
+the structure-value address.  On many machines, no registers can be
+used for this purpose since all function arguments are pushed on the
+stack.
+*/
+/*
+  Use r8 - r12 for function arguments.
+*/
+#define FUNCTION_ARG_REGNO_P(REGNO) \
+  (REGNO >= 3 && REGNO <= 7)
+
+/* Number of registers used for passing function arguments */
+#define NUM_ARG_REGS 5
+
+/*
+If defined, the order in which arguments are loaded into their
+respective argument registers is reversed so that the last
+argument is loaded first.  This macro only affects arguments
+passed in registers.
+*/
+/* #define LOAD_ARGS_REVERSED */
+
+/** How Scalar Function Values Are Returned **/
+
+/* AVR32 is using r12 as return register. */
+#define RET_REGISTER (15 - 12)
+
+/*
+A C expression to create an RTX representing the place where a library
+function returns a value of mode MODE.  If the precise function
+being called is known, FUNC is a tree node
+(FUNCTION_DECL) for it; otherwise, func is a null
+pointer.  This makes it possible to use a different value-returning
+convention for specific functions when all their calls are
+known.
+
+Note that "library function" in this context means a compiler
+support routine, used to perform arithmetic, whose name is known
+specially by the compiler and was not mentioned in the C code being
+compiled.
+
+The definition of LIBRARY_VALUE need not be concerned aggregate
+data types, because none of the library functions returns such types.
+*/
+#define LIBCALL_VALUE(MODE) avr32_libcall_value(MODE)
+
+/*
+A C expression that is nonzero if REGNO is the number of a hard
+register in which the values of called function may come back.
+
+A register whose use for returning values is limited to serving as the
+second of a pair (for a value of type double, say) need not be
+recognized by this macro.  So for most machines, this definition
+suffices:
+  #define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)
+
+If the machine has register windows, so that the caller and the called
+function use different registers for the return value, this macro
+should recognize only the caller's register numbers.
+*/
+/*
+  When returning a value of mode DImode, r11:r10 is used, else r12 is used.
+*/
+#define FUNCTION_VALUE_REGNO_P(REGNO) ((REGNO) == RET_REGISTER \
+                                       || (REGNO) == INTERNAL_REGNUM(11))
+
+
+/** How Large Values Are Returned **/
+
+
+/*
+Define this macro to be 1 if all structure and union return values must be
+in memory.  Since this results in slower code, this should be defined
+only if needed for compatibility with other compilers or with an ABI.
+If you define this macro to be 0, then the conventions used for structure
+and union return values are decided by the RETURN_IN_MEMORY macro.
+
+If not defined, this defaults to the value 1.
+*/
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+
+
+
+/** Generating Code for Profiling **/
+
+/*
+A C statement or compound statement to output to FILE some
+assembler code to call the profiling subroutine mcount.
+
+The details of how mcount expects to be called are determined by
+your operating system environment, not by GCC.  To figure them out,
+compile a small program for profiling using the system's installed C
+compiler and look at the assembler code that results.
+
+Older implementations of mcount expect the address of a counter
+variable to be loaded into some register.  The name of this variable is
+'LP' followed by the number LABELNO, so you would generate
+the name using 'LP%d' in a fprintf.
+*/
+/* ToDo: fixme */
+#ifndef FUNCTION_PROFILER
+#define FUNCTION_PROFILER(FILE, LABELNO) \
+  fprintf((FILE), "/* profiler %d */", (LABELNO))
+#endif
+
+
+/*****************************************************************************
+ * Trampolines for Nested Functions                                          *
+ *****************************************************************************/
+
+/*
+A C statement to output, on the stream FILE, assembler code for a
+block of data that contains the constant parts of a trampoline.  This
+code should not include a label - the label is taken care of
+automatically.
+
+If you do not define this macro, it means no template is needed
+for the target.  Do not define this macro on systems where the block move
+code to copy the trampoline into place would be larger than the code
+to generate it on the spot.
+*/
+/* ToDo: correct? */
+#define TRAMPOLINE_TEMPLATE(FILE) avr32_trampoline_template(FILE);
+
+
+/*
+A C expression for the size in bytes of the trampoline, as an integer.
+*/
+/* ToDo: fixme */
+#define TRAMPOLINE_SIZE 0x0C
+
+/*
+Alignment required for trampolines, in bits.
+
+If you don't define this macro, the value of BIGGEST_ALIGNMENT
+is used for aligning trampolines.
+*/
+#define TRAMPOLINE_ALIGNMENT 16
+
+/*
+A C statement to initialize the variable parts of a trampoline.
+ADDR is an RTX for the address of the trampoline; FNADDR is
+an RTX for the address of the nested function; STATIC_CHAIN is an
+RTX for the static chain value that should be passed to the function
+when it is called.
+*/
+#define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, STATIC_CHAIN) \
+  avr32_initialize_trampoline(ADDR, FNADDR, STATIC_CHAIN)
+
+
+/******************************************************************************
+ * Implicit Calls to Library Routines
+ *****************************************************************************/
+
+/* Tail calling.  */
+
+/* A C expression that evaluates to true if it is ok to perform a sibling
+   call to DECL.  */
+#define FUNCTION_OK_FOR_SIBCALL(DECL) 0
+
+#define OVERRIDE_OPTIONS  avr32_override_options ()
+
+#define OPTIMIZATION_OPTIONS(LEVEL, SIZE) avr32_optimization_options (LEVEL, SIZE)
+
+/******************************************************************************
+ * Addressing Modes
+ *****************************************************************************/
+
+/*
+A C expression that is nonzero if the machine supports pre-increment,
+pre-decrement, post-increment, or post-decrement addressing respectively.
+*/
+/*
+  AVR32 supports Rp++ and --Rp
+*/
+#define HAVE_PRE_INCREMENT 0
+#define HAVE_PRE_DECREMENT 1
+#define HAVE_POST_INCREMENT 1
+#define HAVE_POST_DECREMENT 0
+
+/*
+A C expression that is nonzero if the machine supports pre- or
+post-address side-effect generation involving constants other than
+the size of the memory operand.
+*/
+#define HAVE_PRE_MODIFY_DISP 0
+#define HAVE_POST_MODIFY_DISP 0
+
+/*
+A C expression that is nonzero if the machine supports pre- or
+post-address side-effect generation involving a register displacement.
+*/
+#define HAVE_PRE_MODIFY_REG 0
+#define HAVE_POST_MODIFY_REG 0
+
+/*
+A C expression that is 1 if the RTX X is a constant which
+is a valid address.  On most machines, this can be defined as
+CONSTANT_P (X), but a few machines are more restrictive
+in which constant addresses are supported.
+
+CONSTANT_P accepts integer-values expressions whose values are
+not explicitly known, such as symbol_ref, label_ref, and
+high expressions and const arithmetic expressions, in
+addition to const_int and const_double expressions.
+*/
+#define CONSTANT_ADDRESS_P(X) CONSTANT_P(X)
+
+/*
+A number, the maximum number of registers that can appear in a valid
+memory address.  Note that it is up to you to specify a value equal to
+the maximum number that GO_IF_LEGITIMATE_ADDRESS would ever
+accept.
+*/
+#define MAX_REGS_PER_ADDRESS 2
+
+/*
+A C compound statement with a conditional goto LABEL;
+executed if X (an RTX) is a legitimate memory address on the
+target machine for a memory operand of mode MODE.
+
+It usually pays to define several simpler macros to serve as
+subroutines for this one.  Otherwise it may be too complicated to
+understand.
+
+This macro must exist in two variants: a strict variant and a
+non-strict one.  The strict variant is used in the reload pass.  It
+must be defined so that any pseudo-register that has not been
+allocated a hard register is considered a memory reference.  In
+contexts where some kind of register is required, a pseudo-register
+with no hard register must be rejected.
+
+The non-strict variant is used in other passes.  It must be defined to
+accept all pseudo-registers in every context where some kind of
+register is required.
+
+Compiler source files that want to use the strict variant of this
+macro define the macro REG_OK_STRICT.  You should use an
+#ifdef REG_OK_STRICT conditional to define the strict variant
+in that case and the non-strict variant otherwise.
+
+Subroutines to check for acceptable registers for various purposes (one
+for base registers, one for index registers, and so on) are typically
+among the subroutines used to define GO_IF_LEGITIMATE_ADDRESS.
+Then only these subroutine macros need have two variants; the higher
+levels of macros may be the same whether strict or not.
+
+Normally, constant addresses which are the sum of a symbol_ref
+and an integer are stored inside a const RTX to mark them as
+constant.  Therefore, there is no need to recognize such sums
+specifically as legitimate addresses.  Normally you would simply
+recognize any const as legitimate.
+
+Usually PRINT_OPERAND_ADDRESS is not prepared to handle constant
+sums that are not marked with  const.  It assumes that a naked
+plus indicates indexing.  If so, then you must reject such
+naked constant sums as illegitimate addresses, so that none of them will
+be given to PRINT_OPERAND_ADDRESS.
+
+On some machines, whether a symbolic address is legitimate depends on
+the section that the address refers to.  On these machines, define the
+macro ENCODE_SECTION_INFO to store the information into the
+symbol_ref, and then check for it here.  When you see a
+const, you will have to look inside it to find the
+symbol_ref in order to determine the section.
+
+The best way to modify the name string is by adding text to the
+beginning, with suitable punctuation to prevent any ambiguity.  Allocate
+the new name in saveable_obstack.  You will have to modify
+ASM_OUTPUT_LABELREF to remove and decode the added text and
+output the name accordingly, and define STRIP_NAME_ENCODING to
+access the original name string.
+
+You can check the information stored here into the symbol_ref in
+the definitions of the macros GO_IF_LEGITIMATE_ADDRESS and
+PRINT_OPERAND_ADDRESS.
+*/
+#ifdef REG_OK_STRICT
+#  define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)	\
+  do							\
+    {							\
+      if (avr32_legitimate_address(MODE, X, 1))		\
+	goto LABEL;					\
+    }							\
+  while (0)
+#else
+#  define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)	\
+  do							\
+    {							\
+      if (avr32_legitimate_address(MODE, X, 0))		\
+	goto LABEL;					\
+    }							\
+  while (0)
+#endif
+
+
+
+/*
+A C compound statement that attempts to replace X with a valid
+memory address for an operand of mode MODE.  win will be a
+C statement label elsewhere in the code; the macro definition may use
+
+  GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN);
+
+to avoid further processing if the address has become legitimate.
+
+X will always be the result of a call to break_out_memory_refs,
+and OLDX will be the operand that was given to that function to produce
+X.
+
+The code generated by this macro should not alter the substructure of
+X.  If it transforms X into a more legitimate form, it
+should assign X (which will always be a C variable) a new value.
+
+It is not necessary for this macro to come up with a legitimate
+address.  The compiler has standard ways of doing so in all cases.  In
+fact, it is safe for this macro to do nothing.  But often a
+machine-dependent strategy can generate better code.
+*/
+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)			\
+  do								\
+    {								\
+      if (GET_CODE(X) == PLUS					\
+	  && GET_CODE(XEXP(X, 0)) == REG			\
+	  && GET_CODE(XEXP(X, 1)) == CONST_INT			\
+	  && !CONST_OK_FOR_CONSTRAINT_P(INTVAL(XEXP(X, 1)),	\
+					'K', "Ks16"))		\
+	{							\
+	  rtx index = force_reg(SImode, XEXP(X, 1));		\
+	  X = gen_rtx_PLUS( SImode, XEXP(X, 0), index);		\
+	}							\
+      GO_IF_LEGITIMATE_ADDRESS(MODE, X, WIN);			\
+    }								\
+  while(0)
+
+
+/*
+A C statement or compound statement with a conditional
+goto LABEL; executed if memory address X (an RTX) can have
+different meanings depending on the machine mode of the memory
+reference it is used for or if the address is valid for some modes
+but not others.
+
+Autoincrement and autodecrement addresses typically have mode-dependent
+effects because the amount of the increment or decrement is the size
+of the operand being addressed.  Some machines have other mode-dependent
+addresses.  Many RISC machines have no mode-dependent addresses.
+
+You may assume that ADDR is a valid address for the machine.
+*/
+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)	\
+  do							\
+    {							\
+      if (GET_CODE (ADDR) == POST_INC			\
+	  || GET_CODE (ADDR) == PRE_DEC)		\
+	goto LABEL;					\
+    }							\
+  while (0)
+
+/*
+A C expression that is nonzero if X is a legitimate constant for
+an immediate operand on the target machine.  You can assume that
+X satisfies CONSTANT_P, so you need not check this.  In fact,
+'1' is a suitable definition for this macro on machines where
+anything CONSTANT_P is valid.
+*/
+#define LEGITIMATE_CONSTANT_P(X) avr32_legitimate_constant_p(X)
+
+
+/******************************************************************************
+ * Condition Code Status
+ *****************************************************************************/
+
+/*
+C code for a data type which is used for declaring the mdep
+component of cc_status.  It defaults to int.
+
+This macro is not used on machines that do not use cc0.
+*/
+
+typedef struct
+{
+  int flags;
+  rtx value;
+  int cond_exec_cmp_clobbered;
+} avr32_status_reg;
+
+
+#define CC_STATUS_MDEP avr32_status_reg
+
+/*
+A C expression to initialize the mdep field to "empty".
+The default definition does nothing, since most machines don't use
+the field anyway.  If you want to use the field, you should probably
+define this macro to initialize it.
+
+This macro is not used on machines that do not use cc0.
+*/
+
+#define CC_STATUS_MDEP_INIT  \
+   (cc_status.mdep.flags = CC_NONE , cc_status.mdep.cond_exec_cmp_clobbered = 0, cc_status.mdep.value = 0)
+
+/*
+A C compound statement to set the components of cc_status
+appropriately for an insn INSN whose body is EXP.  It is
+this macro's responsibility to recognize insns that set the condition
+code as a byproduct of other activity as well as those that explicitly
+set (cc0).
+
+This macro is not used on machines that do not use cc0.
+
+If there are insns that do not set the condition code but do alter
+other machine registers, this macro must check to see whether they
+invalidate the expressions that the condition code is recorded as
+reflecting.  For example, on the 68000, insns that store in address
+registers do not set the condition code, which means that usually
+NOTICE_UPDATE_CC can leave cc_status unaltered for such
+insns.  But suppose that the previous insn set the condition code
+based on location 'a4@@(102)' and the current insn stores a new
+value in 'a4'.  Although the condition code is not changed by
+this, it will no longer be true that it reflects the contents of
+'a4@@(102)'.  Therefore, NOTICE_UPDATE_CC must alter
+cc_status in this case to say that nothing is known about the
+condition code value.
+
+The definition of NOTICE_UPDATE_CC must be prepared to deal
+with the results of peephole optimization: insns whose patterns are
+parallel RTXs containing various reg, mem or
+constants which are just the operands.  The RTL structure of these
+insns is not sufficient to indicate what the insns actually do.  What
+NOTICE_UPDATE_CC should do when it sees one is just to run
+CC_STATUS_INIT.
+
+A possible definition of NOTICE_UPDATE_CC is to call a function
+that looks at an attribute (see Insn Attributes) named, for example,
+'cc'.  This avoids having detailed information about patterns in
+two places, the 'md' file and in NOTICE_UPDATE_CC.
+*/
+
+#define NOTICE_UPDATE_CC(EXP, INSN) avr32_notice_update_cc(EXP, INSN)
+
+
+
+
+/******************************************************************************
+ * Describing Relative Costs of Operations
+ *****************************************************************************/
+
+
+
+/*
+A C expression for the cost of moving data of mode MODE from a
+register in class FROM to one in class TO.  The classes are
+expressed using the enumeration values such as GENERAL_REGS.  A
+value of 2 is the default; other values are interpreted relative to
+that.
+
+It is not required that the cost always equal 2 when FROM is the
+same as TO; on some machines it is expensive to move between
+registers if they are not general registers.
+
+If reload sees an insn consisting of a single set between two
+hard registers, and if REGISTER_MOVE_COST applied to their
+classes returns a value of 2, reload does not check to ensure that the
+constraints of the insn are met.  Setting a cost of other than 2 will
+allow reload to verify that the constraints are met.  You should do this
+if the movm pattern's constraints do not allow such copying.
+*/
+#define REGISTER_MOVE_COST(MODE, FROM, TO) \
+  ((GET_MODE_SIZE(MODE) <= 4) ? 2:         \
+   (GET_MODE_SIZE(MODE) <= 8) ? 3:         \
+   4)
+
+/*
+A C expression for the cost of moving data of mode MODE between a
+register of class CLASS and memory; IN is zero if the value
+is to be written to memory, nonzero if it is to be read in.  This cost
+is relative to those in REGISTER_MOVE_COST.  If moving between
+registers and memory is more expensive than between two registers, you
+should define this macro to express the relative cost.
+
+If you do not define this macro, GCC uses a default cost of 4 plus
+the cost of copying via a secondary reload register, if one is
+needed.  If your machine requires a secondary reload register to copy
+between memory and a register of CLASS but the reload mechanism is
+more complex than copying via an intermediate, define this macro to
+reflect the actual cost of the move.
+
+GCC defines the function memory_move_secondary_cost if
+secondary reloads are needed.  It computes the costs due to copying via
+a secondary register.  If your machine copies from memory using a
+secondary register in the conventional way but the default base value of
+4 is not correct for your machine, define this macro to add some other
+value to the result of that function.  The arguments to that function
+are the same as to this macro.
+*/
+/*
+  Memory moves are costly
+*/
+#define MEMORY_MOVE_COST(MODE, CLASS, IN)            \
+  (((IN) ? ((GET_MODE_SIZE(MODE) < 4) ? 4 :          \
+            (GET_MODE_SIZE(MODE) > 8) ? 6 :          \
+            3)                                       \
+    : ((GET_MODE_SIZE(MODE) > 8) ? 6 : 3)))
+
+/*
+A C expression for the cost of a branch instruction.  A value of 1 is
+the default; other values are interpreted relative to that.
+*/
+  /* Try to use conditionals as much as possible */
+#define BRANCH_COST(speed_p, predictable_p) (TARGET_BRANCH_PRED ? 3 : 4)
+
+/*A C expression for the maximum number of instructions to execute via conditional
+  execution instructions instead of a branch. A value of BRANCH_COST+1 is the default
+  if the machine does not use cc0, and 1 if it does use cc0.*/
+#define MAX_CONDITIONAL_EXECUTE 4
+
+/*
+Define this macro as a C expression which is nonzero if accessing less
+than a word of memory (i.e.: a char or a short) is no
+faster than accessing a word of memory, i.e., if such access
+require more than one instruction or if there is no difference in cost
+between byte and (aligned) word loads.
+
+When this macro is not defined, the compiler will access a field by
+finding the smallest containing object; when it is defined, a fullword
+load will be used if alignment permits.  Unless bytes accesses are
+faster than word accesses, using word accesses is preferable since it
+may eliminate subsequent memory access if subsequent accesses occur to
+other fields in the same word of the structure, but to different bytes.
+*/
+#define SLOW_BYTE_ACCESS 1
+
+
+/*
+Define this macro if it is as good or better to call a constant
+function address than to call an address kept in a register.
+*/
+#define NO_FUNCTION_CSE
+
+
+/******************************************************************************
+ * Adjusting the Instruction Scheduler
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Dividing the Output into Sections (Texts, Data, ...)                      *
+ *****************************************************************************/
+
+/*
+A C expression whose value is a string, including spacing, containing the
+assembler operation that should precede instructions and read-only data.
+Normally "\t.text" is right.
+*/
+#define TEXT_SECTION_ASM_OP "\t.text"
+/*
+A C statement that switches to the default section containing instructions.
+Normally this is not needed, as simply defining TEXT_SECTION_ASM_OP
+is enough.  The MIPS port uses this to sort all functions after all data
+declarations.
+*/
+/* #define TEXT_SECTION */
+
+/*
+A C expression whose value is a string, including spacing, containing the
+assembler operation to identify the following data as writable initialized
+data.  Normally "\t.data" is right.
+*/
+#define DATA_SECTION_ASM_OP "\t.data"
+
+/*
+If defined, a C expression whose value is a string, including spacing,
+containing the assembler operation to identify the following data as
+shared data.  If not defined, DATA_SECTION_ASM_OP will be used.
+*/
+
+/*
+A C expression whose value is a string, including spacing, containing
+the assembler operation to identify the following data as read-only
+initialized data.
+*/
+#undef READONLY_DATA_SECTION_ASM_OP
+#define READONLY_DATA_SECTION_ASM_OP \
+  ((TARGET_USE_RODATA_SECTION) ?  \
+   "\t.section\t.rodata" :                \
+   TEXT_SECTION_ASM_OP )
+
+
+/*
+If defined, a C expression whose value is a string, including spacing,
+containing the assembler operation to identify the following data as
+uninitialized global data.  If not defined, and neither
+ASM_OUTPUT_BSS nor ASM_OUTPUT_ALIGNED_BSS are defined,
+uninitialized global data will be output in the data section if
+-fno-common is passed, otherwise ASM_OUTPUT_COMMON will be
+used.
+*/
+#define BSS_SECTION_ASM_OP	"\t.section\t.bss"
+
+/*
+If defined, a C expression whose value is a string, including spacing,
+containing the assembler operation to identify the following data as
+uninitialized global shared data.  If not defined, and
+BSS_SECTION_ASM_OP is, the latter will be used.
+*/
+/*#define SHARED_BSS_SECTION_ASM_OP "\trseg\tshared_bbs_section:data:noroot(0)\n"*/
+/*
+If defined, a C expression whose value is a string, including spacing,
+containing the assembler operation to identify the following data as
+initialization code.  If not defined, GCC will assume such a section does
+not exist.
+*/
+#undef  INIT_SECTION_ASM_OP
+#define INIT_SECTION_ASM_OP "\t.section\t.init"
+
+/*
+If defined, a C expression whose value is a string, including spacing,
+containing the assembler operation to identify the following data as
+finalization code.  If not defined, GCC will assume such a section does
+not exist.
+*/
+#undef  FINI_SECTION_ASM_OP
+#define FINI_SECTION_ASM_OP "\t.section\t.fini"
+
+/*
+If defined, an ASM statement that switches to a different section
+via SECTION_OP, calls FUNCTION, and switches back to
+the text section.  This is used in crtstuff.c if
+INIT_SECTION_ASM_OP or FINI_SECTION_ASM_OP to calls
+to initialization and finalization functions from the init and fini
+sections.  By default, this macro uses a simple function call.  Some
+ports need hand-crafted assembly code to avoid dependencies on
+registers initialized in the function prologue or to ensure that
+constant pools don't end up too far way in the text section.
+*/
+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)      \
+   asm ( SECTION_OP "\n" \
+         "mcall   r6[" USER_LABEL_PREFIX #FUNC "@got]\n" \
+         TEXT_SECTION_ASM_OP);
+
+
+/*
+Define this macro to be an expression with a nonzero value if jump
+tables (for tablejump insns) should be output in the text
+section, along with the assembler instructions.  Otherwise, the
+readonly data section is used.
+
+This macro is irrelevant if there is no separate readonly data section.
+*/
+/* Put jump tables in text section if we have caches. Otherwise assume that
+   loading data from code memory is slow. */
+#define JUMP_TABLES_IN_TEXT_SECTION    \
+    (TARGET_CACHES ? 1 : 0)
+
+
+/******************************************************************************
+ * Position Independent Code (PIC)
+ *****************************************************************************/
+
+#ifndef AVR32_ALWAYS_PIC
+#define AVR32_ALWAYS_PIC 0
+#endif
+
+/* GOT is set to r6 */
+#define PIC_OFFSET_TABLE_REGNUM INTERNAL_REGNUM(6)
+
+/*
+A C expression that is nonzero if X is a legitimate immediate
+operand on the target machine when generating position independent code.
+You can assume that X satisfies CONSTANT_P, so you need not
+check this.  You can also assume flag_pic is true, so you need not
+check it either.  You need not define this macro if all constants
+(including SYMBOL_REF) can be immediate operands when generating
+position independent code.
+*/
+/* We can't directly access anything that contains a symbol,
+   nor can we indirect via the constant pool.  */
+#define LEGITIMATE_PIC_OPERAND_P(X) avr32_legitimate_pic_operand_p(X)
+
+
+/* We need to know when we are making a constant pool; this determines
+   whether data needs to be in the GOT or can be referenced via a GOT
+   offset.  */
+extern int making_const_table;
+
+/******************************************************************************
+ * Defining the Output Assembler Language
+ *****************************************************************************/
+
+
+/*
+A C string constant describing how to begin a comment in the target
+assembler language.  The compiler assumes that the comment will end at
+the end of the line.
+*/
+#define ASM_COMMENT_START "# "
+
+/*
+A C string constant for text to be output before each asm
+statement or group of consecutive ones.  Normally this is
+"#APP", which is a comment that has no effect on most
+assemblers but tells the GNU assembler that it must check the lines
+that follow for all valid assembler constructs.
+*/
+#undef ASM_APP_ON
+#define ASM_APP_ON "#APP\n"
+
+/*
+A C string constant for text to be output after each asm
+statement or group of consecutive ones.  Normally this is
+"#NO_APP", which tells the GNU assembler to resume making the
+time-saving assumptions that are valid for ordinary compiler output.
+*/
+#undef ASM_APP_OFF
+#define ASM_APP_OFF "#NO_APP\n"
+
+
+
+#define FILE_ASM_OP 		"\t.file\n"
+#define IDENT_ASM_OP 		"\t.ident\t"
+#define SET_ASM_OP		"\t.set\t"
+
+
+/*
+ * Output assembly directives to switch to section name. The section
+ * should have attributes as specified by flags, which is a bit mask
+ * of the SECTION_* flags defined in 'output.h'. If align is nonzero,
+ * it contains an alignment in bytes to be used for the section,
+ * otherwise some target default should be used. Only targets that
+ * must specify an alignment within the section directive need pay
+ * attention to align -- we will still use ASM_OUTPUT_ALIGN.
+ *
+ * NOTE: This one must not be moved to avr32.c
+ */
+#undef TARGET_ASM_NAMED_SECTION
+#define TARGET_ASM_NAMED_SECTION default_elf_asm_named_section
+
+
+/*
+You may define this macro as a C expression.  You should define the
+expression to have a nonzero value if GCC should output the constant
+pool for a function before the code for the function, or a zero value if
+GCC should output the constant pool after the function.  If you do
+not define this macro, the usual case, GCC will output the constant
+pool before the function.
+*/
+#define CONSTANT_POOL_BEFORE_FUNCTION 0
+
+
+/*
+Define this macro as a C expression which is nonzero if the constant
+EXP, of type tree, should be output after the code for a
+function.  The compiler will normally output all constants before the
+function; you need not define this macro if this is OK.
+*/
+#define CONSTANT_AFTER_FUNCTION_P(EXP) 1
+
+
+/*
+Define this macro as a C expression which is nonzero if C is
+as a logical line separator by the assembler.  STR points to the
+position in the string where C was found; this can be used if a
+line separator uses multiple characters.
+
+If you do not define this macro, the default is that only
+the character ';' is treated as a logical line separator.
+*/
+#define IS_ASM_LOGICAL_LINE_SEPARATOR(C,STR) (((C) == '\n') || ((C) == ';'))
+
+
+/** Output of Uninitialized Variables **/
+
+/*
+A C statement (sans semicolon) to output to the stdio stream
+STREAM the assembler definition of a common-label named
+NAME whose size is SIZE bytes.  The variable ROUNDED
+is the size rounded up to whatever alignment the caller wants.
+
+Use the expression assemble_name(STREAM, NAME) to
+output the name itself; before and after that, output the additional
+assembler syntax for defining the name, and a newline.
+
+This macro controls how the assembler definitions of uninitialized
+common global variables are output.
+*/
+/*
+#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED) \
+  avr32_asm_output_common(STREAM, NAME, SIZE, ROUNDED)
+*/
+
+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)	\
+  do							\
+    {							\
+      fputs ("\t.comm ", (FILE));			\
+      assemble_name ((FILE), (NAME));			\
+      fprintf ((FILE), ",%d\n", (SIZE));		\
+    }							\
+  while (0)
+
+/*
+ * Like ASM_OUTPUT_BSS except takes the required alignment as a
+ * separate, explicit argument.  If you define this macro, it is used
+ * in place of ASM_OUTPUT_BSS, and gives you more flexibility in
+ * handling the required alignment of the variable.  The alignment is
+ * specified as the number of bits.
+ *
+ * Try to use function asm_output_aligned_bss defined in file varasm.c
+ * when defining this macro.
+ */
+#define ASM_OUTPUT_ALIGNED_BSS(STREAM, DECL, NAME, SIZE, ALIGNMENT) \
+  asm_output_aligned_bss (STREAM, DECL, NAME, SIZE, ALIGNMENT)
+
+/*
+A C statement (sans semicolon) to output to the stdio stream
+STREAM the assembler definition of a local-common-label named
+NAME whose size is SIZE bytes.  The variable ROUNDED
+is the size rounded up to whatever alignment the caller wants.
+
+Use the expression assemble_name(STREAM, NAME) to
+output the name itself; before and after that, output the additional
+assembler syntax for defining the name, and a newline.
+
+This macro controls how the assembler definitions of uninitialized
+static variables are output.
+*/
+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)	\
+  do							\
+    {							\
+      fputs ("\t.lcomm ", (FILE));			\
+      assemble_name ((FILE), (NAME));			\
+      fprintf ((FILE), ",%d, %d\n", (SIZE), 2);		\
+    }							\
+  while (0)
+
+
+/*
+A C statement (sans semicolon) to output to the stdio stream
+STREAM the assembler definition of a label named NAME.
+Use the expression assemble_name(STREAM, NAME) to
+output the name itself; before and after that, output the additional
+assembler syntax for defining the name, and a newline.
+*/
+#define ASM_OUTPUT_LABEL(STREAM, NAME) avr32_asm_output_label(STREAM, NAME)
+
+/* A C string containing the appropriate assembler directive to
+ * specify the size of a symbol, without any arguments. On systems
+ * that use ELF, the default (in 'config/elfos.h') is '"\t.size\t"';
+ * on other systems, the default is not to define this macro.
+ *
+ * Define this macro only if it is correct to use the default
+ * definitions of ASM_ OUTPUT_SIZE_DIRECTIVE and
+ * ASM_OUTPUT_MEASURED_SIZE for your system. If you need your own
+ * custom definitions of those macros, or if you do not need explicit
+ * symbol sizes at all, do not define this macro.
+ */
+#define SIZE_ASM_OP "\t.size\t"
+
+
+/*
+A C statement (sans semicolon) to output to the stdio stream
+STREAM some commands that will make the label NAME global;
+that is, available for reference from other files.  Use the expression
+assemble_name(STREAM, NAME) to output the name
+itself; before and after that, output the additional assembler syntax
+for making that name global, and a newline.
+*/
+#define GLOBAL_ASM_OP "\t.global\t"
+
+
+
+/*
+A C expression which evaluates to true if the target supports weak symbols.
+
+If you don't define this macro, defaults.h provides a default
+definition.  If either ASM_WEAKEN_LABEL or ASM_WEAKEN_DECL
+is defined, the default definition is '1'; otherwise, it is
+'0'.  Define this macro if you want to control weak symbol support
+with a compiler flag such as -melf.
+*/
+#define SUPPORTS_WEAK 1
+
+/*
+A C statement (sans semicolon) to output to the stdio stream
+STREAM a reference in assembler syntax to a label named
+NAME.  This should add '_' to the front of the name, if that
+is customary on your operating system, as it is in most Berkeley Unix
+systems.  This macro is used in assemble_name.
+*/
+#define ASM_OUTPUT_LABELREF(STREAM, NAME) \
+  avr32_asm_output_labelref(STREAM, NAME)
+
+
+
+/*
+A C expression to assign to OUTVAR (which is a variable of type
+char *) a newly allocated string made from the string
+NAME and the number NUMBER, with some suitable punctuation
+added.  Use alloca to get space for the string.
+
+The string will be used as an argument to ASM_OUTPUT_LABELREF to
+produce an assembler label for an internal static variable whose name is
+NAME.  Therefore, the string must be such as to result in valid
+assembler code.  The argument NUMBER is different each time this
+macro is executed; it prevents conflicts between similarly-named
+internal static variables in different scopes.
+
+Ideally this string should not be a valid C identifier, to prevent any
+conflict with the user's own symbols.  Most assemblers allow periods
+or percent signs in assembler symbols; putting at least one of these
+between the name and the number will suffice.
+*/
+#define ASM_FORMAT_PRIVATE_NAME(OUTVAR, NAME, NUMBER)		\
+  do								\
+    {								\
+      (OUTVAR) = (char *) alloca (strlen ((NAME)) + 10);	\
+      sprintf ((OUTVAR), "%s.%d", (NAME), (NUMBER));		\
+    }								\
+  while (0)
+
+
+/** Macros Controlling Initialization Routines **/
+
+
+/*
+If defined, main will not call __main as described above.
+This macro should be defined for systems that control start-up code
+on a symbol-by-symbol basis, such as OSF/1, and should not
+be defined explicitly for systems that support INIT_SECTION_ASM_OP.
+*/
+/*
+  __main is not defined when debugging.
+*/
+#define HAS_INIT_SECTION
+
+
+/** Output of Assembler Instructions **/
+
+/*
+A C initializer containing the assembler's names for the machine
+registers, each one as a C string constant.  This is what translates
+register numbers in the compiler into assembler language.
+*/
+
+#define REGISTER_NAMES	\
+{			\
+  "pc",  "lr",		\
+  "sp",  "r12",		\
+  "r11", "r10",		\
+  "r9",  "r8",		\
+  "r7",  "r6",		\
+  "r5",  "r4",		\
+  "r3",  "r2",		\
+  "r1",  "r0",		\
+}
+
+/*
+A C compound statement to output to stdio stream STREAM the
+assembler syntax for an instruction operand X.  X is an
+RTL expression.
+
+CODE is a value that can be used to specify one of several ways
+of printing the operand.  It is used when identical operands must be
+printed differently depending on the context.  CODE comes from
+the '%' specification that was used to request printing of the
+operand.  If the specification was just '%digit' then
+CODE is 0; if the specification was '%ltr digit'
+then CODE is the ASCII code for ltr.
+
+If X is a register, this macro should print the register's name.
+The names can be found in an array reg_names whose type is
+char *[].  reg_names is initialized from REGISTER_NAMES.
+
+When the machine description has a specification '%punct'
+(a '%' followed by a punctuation character), this macro is called
+with a null pointer for X and the punctuation character for
+CODE.
+*/
+#define PRINT_OPERAND(STREAM, X, CODE) avr32_print_operand(STREAM, X, CODE)
+
+/* A C statement to be executed just prior to the output of
+   assembler code for INSN, to modify the extracted operands so
+   they will be output differently.
+
+   Here the argument OPVEC is the vector containing the operands
+   extracted from INSN, and NOPERANDS is the number of elements of
+   the vector which contain meaningful data for this insn.
+   The contents of this vector are what will be used to convert the insn
+   template into assembler code, so you can change the assembler output
+   by changing the contents of the vector.  */
+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) \
+  avr32_final_prescan_insn ((INSN), (OPVEC), (NOPERANDS))
+
+/*
+A C expression which evaluates to true if CODE is a valid
+punctuation character for use in the PRINT_OPERAND macro.  If
+PRINT_OPERAND_PUNCT_VALID_P is not defined, it means that no
+punctuation characters (except for the standard one, '%') are used
+in this way.
+*/
+#define PRINT_OPERAND_PUNCT_VALID_P(CODE)                          \
+  (((CODE) == '?')                                                 \
+   || ((CODE) == '!'))
+
+/*
+A C compound statement to output to stdio stream STREAM the
+assembler syntax for an instruction operand that is a memory reference
+whose address is X.  X is an RTL expression.
+
+On some machines, the syntax for a symbolic address depends on the
+section that the address refers to.  On these machines, define the macro
+ENCODE_SECTION_INFO to store the information into the
+symbol_ref, and then check for it here.  (see Assembler Format.)
+*/
+#define PRINT_OPERAND_ADDRESS(STREAM, X) avr32_print_operand_address(STREAM, X)
+
+
+/** Output of Dispatch Tables **/
+
+/*
+ * A C statement to output to the stdio stream stream an assembler
+ * pseudo-instruction to generate a difference between two
+ * labels. value and rel are the numbers of two internal labels. The
+ * definitions of these labels are output using
+ * (*targetm.asm_out.internal_label), and they must be printed in the
+ * same way here. For example,
+ *
+ *         fprintf (stream, "\t.word L%d-L%d\n",
+ *                  value, rel)
+ *
+ * You must provide this macro on machines where the addresses in a
+ * dispatch table are relative to the table's own address. If defined,
+ * GCC will also use this macro on all machines when producing
+ * PIC. body is the body of the ADDR_DIFF_VEC; it is provided so that
+ * the mode and flags can be read.
+ */
+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)	    \
+    fprintf(STREAM, "\tbral\t%sL%d\n", LOCAL_LABEL_PREFIX, VALUE)
+
+/*
+This macro should be provided on machines where the addresses
+in a dispatch table are absolute.
+
+The definition should be a C statement to output to the stdio stream
+STREAM an assembler pseudo-instruction to generate a reference to
+a label.  VALUE is the number of an internal label whose
+definition is output using ASM_OUTPUT_INTERNAL_LABEL.
+For example,
+
+fprintf(STREAM, "\t.word L%d\n", VALUE)
+*/
+
+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)  \
+  fprintf(STREAM, "\t.long %sL%d\n", LOCAL_LABEL_PREFIX, VALUE)
+
+/** Assembler Commands for Exception Regions */
+
+/* ToDo: All of this subsection */
+
+/** Assembler Commands for Alignment */
+
+
+/*
+A C statement to output to the stdio stream STREAM an assembler
+command to advance the location counter to a multiple of 2 to the
+POWER bytes.  POWER will be a C expression of type int.
+*/
+#define ASM_OUTPUT_ALIGN(STREAM, POWER)			\
+  do							\
+    {							\
+      if ((POWER) != 0)					\
+	fprintf(STREAM, "\t.align\t%d\n", POWER);	\
+    }							\
+  while (0)
+
+/*
+Like ASM_OUTPUT_ALIGN, except that the \nop" instruction is used for padding, if
+necessary.
+*/
+#define ASM_OUTPUT_ALIGN_WITH_NOP(STREAM, POWER) \
+ fprintf(STREAM, "\t.balignw\t%d, 0xd703\n", (1 << POWER))
+
+
+
+/******************************************************************************
+ * Controlling Debugging Information Format
+ *****************************************************************************/
+
+/* How to renumber registers for dbx and gdb.  */
+#define DBX_REGISTER_NUMBER(REGNO) ASM_REGNUM (REGNO)
+
+/* The DWARF 2 CFA column which tracks the return address.  */
+#define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM(LR_REGNUM)
+
+/*
+Define this macro if GCC should produce dwarf version 2 format
+debugging output in response to the -g option.
+
+To support optional call frame debugging information, you must also
+define INCOMING_RETURN_ADDR_RTX and either set
+RTX_FRAME_RELATED_P on the prologue insns if you use RTL for the
+prologue, or call dwarf2out_def_cfa and dwarf2out_reg_save
+as appropriate from TARGET_ASM_FUNCTION_PROLOGUE if you don't.
+*/
+#define DWARF2_DEBUGGING_INFO 1
+
+
+#define DWARF2_ASM_LINE_DEBUG_INFO 1
+#define DWARF2_FRAME_INFO 1
+
+
+/******************************************************************************
+ * Miscellaneous Parameters
+ *****************************************************************************/
+
+/* ToDo: a lot */
+
+/*
+An alias for a machine mode name.  This is the machine mode that
+elements of a jump-table should have.
+*/
+#define CASE_VECTOR_MODE SImode
+
+/*
+Define this macro to be a C expression to indicate when jump-tables
+should contain relative addresses.  If jump-tables never contain
+relative addresses, then you need not define this macro.
+*/
+#define CASE_VECTOR_PC_RELATIVE 0
+
+/* Increase the threshold for using table jumps on the UC arch. */
+#define CASE_VALUES_THRESHOLD  (TARGET_BRANCH_PRED ? 4 : 7)
+
+/*
+The maximum number of bytes that a single instruction can move quickly
+between memory and registers or between two memory locations.
+*/
+#define MOVE_MAX (2*UNITS_PER_WORD)
+
+
+/* A C expression that is nonzero if on this machine the number of bits actually used
+   for the count of a shift operation is equal to the number of bits needed to represent
+   the size of the object being shifted. When this macro is nonzero, the compiler will
+   assume that it is safe to omit a sign-extend, zero-extend, and certain bitwise 'and'
+   instructions that truncates the count of a shift operation. On machines that have
+   instructions that act on bit-fields at variable positions, which may include 'bit test'
+   378 GNU Compiler Collection (GCC) Internals
+   instructions, a nonzero SHIFT_COUNT_TRUNCATED also enables deletion of truncations
+   of the values that serve as arguments to bit-field instructions.
+   If both types of instructions truncate the count (for shifts) and position (for bit-field
+   operations), or if no variable-position bit-field instructions exist, you should define
+   this macro.
+   However, on some machines, such as the 80386 and the 680x0, truncation only applies
+   to shift operations and not the (real or pretended) bit-field operations. Define SHIFT_
+   COUNT_TRUNCATED to be zero on such machines. Instead, add patterns to the 'md' file
+   that include the implied truncation of the shift instructions.
+   You need not dene this macro if it would always have the value of zero. */
+#define SHIFT_COUNT_TRUNCATED 1
+
+/*
+A C expression which is nonzero if on this machine it is safe to
+convert an integer of INPREC bits to one of OUTPREC
+bits (where OUTPREC is smaller than INPREC) by merely
+operating on it as if it had only OUTPREC bits.
+
+On many machines, this expression can be 1.
+
+When TRULY_NOOP_TRUNCATION returns 1 for a pair of sizes for
+modes for which MODES_TIEABLE_P is 0, suboptimal code can result.
+If this is the case, making TRULY_NOOP_TRUNCATION return 0 in
+such cases may improve things.
+*/
+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1
+
+/*
+An alias for the machine mode for pointers.  On most machines, define
+this to be the integer mode corresponding to the width of a hardware
+pointer; SImode on 32-bit machine or DImode on 64-bit machines.
+On some machines you must define this to be one of the partial integer
+modes, such as PSImode.
+
+The width of Pmode must be at least as large as the value of
+POINTER_SIZE.  If it is not equal, you must define the macro
+POINTERS_EXTEND_UNSIGNED to specify how pointers are extended
+to Pmode.
+*/
+#define Pmode SImode
+
+/*
+An alias for the machine mode used for memory references to functions
+being called, in call RTL expressions.  On most machines this
+should be QImode.
+*/
+#define FUNCTION_MODE SImode
+
+
+#define REG_S_P(x) \
+ (REG_P (x) || (GET_CODE (x) == SUBREG && REG_P (XEXP (x, 0))))
+
+
+/* If defined, modifies the length assigned to instruction INSN as a
+   function of the context in which it is used.  LENGTH is an lvalue
+   that contains the initially computed length of the insn and should
+   be updated with the correct length of the insn.  */
+#define ADJUST_INSN_LENGTH(INSN, LENGTH) \
+  ((LENGTH) = avr32_adjust_insn_length ((INSN), (LENGTH)))
+
+
+#define CLZ_DEFINED_VALUE_AT_ZERO(mode, value) \
+  (value = 32, (mode == SImode))
+
+#define CTZ_DEFINED_VALUE_AT_ZERO(mode, value) \
+  (value = 32, (mode == SImode))
+
+#define UNITS_PER_SIMD_WORD(mode) UNITS_PER_WORD
+
+#define STORE_FLAG_VALUE 1
+
+
+/* IF-conversion macros. */
+#define IFCVT_MODIFY_INSN( CE_INFO, PATTERN, INSN )                     \
+  {                                                                     \
+    (PATTERN) = avr32_ifcvt_modify_insn (CE_INFO, PATTERN, INSN, &num_true_changes); \
+  }
+
+#define IFCVT_EXTRA_FIELDS                              \
+  int num_cond_clobber_insns;                           \
+  int num_extra_move_insns;                             \
+  rtx extra_move_insns[MAX_CONDITIONAL_EXECUTE];        \
+  rtx moved_insns[MAX_CONDITIONAL_EXECUTE];
+
+#define IFCVT_INIT_EXTRA_FIELDS( CE_INFO )       \
+  {                                              \
+    (CE_INFO)->num_cond_clobber_insns = 0;       \
+    (CE_INFO)->num_extra_move_insns = 0;         \
+  }
+
+
+#define IFCVT_MODIFY_CANCEL( CE_INFO )  avr32_ifcvt_modify_cancel (CE_INFO, &num_true_changes)
+
+#define IFCVT_ALLOW_MODIFY_TEST_IN_INSN 1
+#define IFCVT_COND_EXEC_BEFORE_RELOAD (TARGET_COND_EXEC_BEFORE_RELOAD)
+
+enum avr32_builtins
+{
+  AVR32_BUILTIN_MTSR,
+  AVR32_BUILTIN_MFSR,
+  AVR32_BUILTIN_MTDR,
+  AVR32_BUILTIN_MFDR,
+  AVR32_BUILTIN_CACHE,
+  AVR32_BUILTIN_SYNC,
+  AVR32_BUILTIN_SSRF,
+  AVR32_BUILTIN_CSRF,
+  AVR32_BUILTIN_TLBR,
+  AVR32_BUILTIN_TLBS,
+  AVR32_BUILTIN_TLBW,
+  AVR32_BUILTIN_BREAKPOINT,
+  AVR32_BUILTIN_XCHG,
+  AVR32_BUILTIN_LDXI,
+  AVR32_BUILTIN_BSWAP16,
+  AVR32_BUILTIN_BSWAP32,
+  AVR32_BUILTIN_COP,
+  AVR32_BUILTIN_MVCR_W,
+  AVR32_BUILTIN_MVRC_W,
+  AVR32_BUILTIN_MVCR_D,
+  AVR32_BUILTIN_MVRC_D,
+  AVR32_BUILTIN_MULSATHH_H,
+  AVR32_BUILTIN_MULSATHH_W,
+  AVR32_BUILTIN_MULSATRNDHH_H,
+  AVR32_BUILTIN_MULSATRNDWH_W,
+  AVR32_BUILTIN_MULSATWH_W,
+  AVR32_BUILTIN_MACSATHH_W,
+  AVR32_BUILTIN_SATADD_H,
+  AVR32_BUILTIN_SATSUB_H,
+  AVR32_BUILTIN_SATADD_W,
+  AVR32_BUILTIN_SATSUB_W,
+  AVR32_BUILTIN_MULWH_D,
+  AVR32_BUILTIN_MULNWH_D,
+  AVR32_BUILTIN_MACWH_D,
+  AVR32_BUILTIN_MACHH_D,
+  AVR32_BUILTIN_MUSFR,
+  AVR32_BUILTIN_MUSTR,
+  AVR32_BUILTIN_SATS,
+  AVR32_BUILTIN_SATU,
+  AVR32_BUILTIN_SATRNDS,
+  AVR32_BUILTIN_SATRNDU,
+  AVR32_BUILTIN_MEMS,
+  AVR32_BUILTIN_MEMC,
+  AVR32_BUILTIN_MEMT,
+  AVR32_BUILTIN_SLEEP,
+  AVR32_BUILTIN_DELAY_CYCLES
+};
+
+
+#define FLOAT_LIB_COMPARE_RETURNS_BOOL(MODE, COMPARISON) \
+  ((MODE == SFmode) || (MODE == DFmode))
+
+#define RENAME_LIBRARY_SET ".set"
+
+/* Make ABI_NAME an alias for __GCC_NAME.  */
+#define RENAME_LIBRARY(GCC_NAME, ABI_NAME)		\
+  __asm__ (".globl\t__avr32_" #ABI_NAME "\n"		\
+	   ".set\t__avr32_" #ABI_NAME 	\
+	     ", __" #GCC_NAME "\n");
+
+/* Give libgcc functions avr32 ABI name.  */
+#ifdef L_muldi3
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (muldi3, mul64)
+#endif
+#ifdef L_divdi3
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (divdi3, sdiv64)
+#endif
+#ifdef L_udivdi3
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (udivdi3, udiv64)
+#endif
+#ifdef L_moddi3
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (moddi3, smod64)
+#endif
+#ifdef L_umoddi3
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (umoddi3, umod64)
+#endif
+#ifdef L_ashldi3
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (ashldi3, lsl64)
+#endif
+#ifdef L_lshrdi3
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (lshrdi3, lsr64)
+#endif
+#ifdef L_ashrdi3
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (ashrdi3, asr64)
+#endif
+
+#ifdef L_fixsfdi
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixsfdi, f32_to_s64)
+#endif
+#ifdef L_fixunssfdi
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixunssfdi, f32_to_u64)
+#endif
+#ifdef L_floatdidf
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (floatdidf, s64_to_f64)
+#endif
+#ifdef L_floatdisf
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (floatdisf, s64_to_f32)
+#endif
+
+#endif
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/avr32.md gcc-4.4.6/gcc/config/avr32/avr32.md
--- gcc-4.4.6.orig/gcc/config/avr32/avr32.md	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/avr32.md	2011-08-27 19:45:42.807981430 +0200
@@ -0,0 +1,5198 @@
+;;   AVR32 machine description file.
+;;   Copyright 2003,2004,2005,2006,2007,2008,2009 Atmel Corporation.
+;;
+;;   This file is part of GCC.
+;;
+;;   This program is free software; you can redistribute it and/or modify
+;;   it under the terms of the GNU General Public License as published by
+;;   the Free Software Foundation; either version 2 of the License, or
+;;   (at your option) any later version.
+;;
+;;   This program is distributed in the hope that it will be useful,
+;;   but WITHOUT ANY WARRANTY; without even the implied warranty of
+;;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;;   GNU General Public License for more details.
+;;
+;;   You should have received a copy of the GNU General Public License
+;;   along with this program; if not, write to the Free Software
+;;   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+;; -*- Mode: Scheme -*-
+
+(define_attr "type" "alu,alu2,alu_sat,mulhh,mulwh,mulww_w,mulww_d,div,machh_w,macww_w,macww_d,branch,call,load,load_rm,store,load2,load4,store2,store4,fmul,fcmps,fcmpd,fcast,fmv,fmvcpu,fldd,fstd,flds,fsts,fstm"
+  (const_string "alu"))
+
+
+(define_attr "cc" "none,set_vncz,set_ncz,set_cz,set_z,set_z_if_not_v2,bld,compare,cmp_cond_insn,clobber,call_set,fpcompare,from_fpcc"
+  (const_string "none"))
+
+
+; NB! Keep this in sync with enum architecture_type in avr32.h
+(define_attr "pipeline" "ap,ucr1,ucr2,ucr2nomul,ucr3,ucr3fp"
+  (const (symbol_ref "avr32_arch->arch_type")))
+
+; Insn length in bytes
+(define_attr "length" ""
+  (const_int 4))
+
+; Signal if an insn is predicable and hence can be conditionally executed.
+(define_attr "predicable" "no,yes" (const_string "no"))
+
+;; Uses of UNSPEC in this file:
+(define_constants
+  [(UNSPEC_PUSHM                0)
+   (UNSPEC_POPM                 1)
+   (UNSPEC_UDIVMODSI4_INTERNAL	2)
+   (UNSPEC_DIVMODSI4_INTERNAL   3)
+   (UNSPEC_STM                  4)
+   (UNSPEC_LDM                  5)
+   (UNSPEC_MOVSICC              6)
+   (UNSPEC_ADDSICC              7)
+   (UNSPEC_COND_MI              8)
+   (UNSPEC_COND_PL              9)
+   (UNSPEC_PIC_SYM              10)
+   (UNSPEC_PIC_BASE             11)
+   (UNSPEC_STORE_MULTIPLE       12)
+   (UNSPEC_STMFP                13)
+   (UNSPEC_FRCPA                14)
+   (UNSPEC_REG_TO_CC            15)
+   (UNSPEC_FORCE_MINIPOOL       16)
+   (UNSPEC_SATS                 17)
+   (UNSPEC_SATU                 18)
+   (UNSPEC_SATRNDS              19)
+   (UNSPEC_SATRNDU              20)
+  ])
+
+(define_constants
+  [(VUNSPEC_EPILOGUE                  0)
+   (VUNSPEC_CACHE                     1)
+   (VUNSPEC_MTSR                      2)
+   (VUNSPEC_MFSR                      3)
+   (VUNSPEC_BLOCKAGE                  4)
+   (VUNSPEC_SYNC                      5)
+   (VUNSPEC_TLBR                      6)
+   (VUNSPEC_TLBW                      7)
+   (VUNSPEC_TLBS                      8)
+   (VUNSPEC_BREAKPOINT                9)
+   (VUNSPEC_MTDR                      10)
+   (VUNSPEC_MFDR                      11)
+   (VUNSPEC_MVCR                      12)
+   (VUNSPEC_MVRC                      13)
+   (VUNSPEC_COP                       14)
+   (VUNSPEC_ALIGN                     15)
+   (VUNSPEC_POOL_START                16)
+   (VUNSPEC_POOL_END                  17)
+   (VUNSPEC_POOL_4                    18)
+   (VUNSPEC_POOL_8                    19)
+   (VUNSPEC_POOL_16                   20)
+   (VUNSPEC_MUSFR                     21)
+   (VUNSPEC_MUSTR                     22)
+   (VUNSPEC_SYNC_CMPXCHG              23)
+   (VUNSPEC_SYNC_SET_LOCK_AND_LOAD    24)
+   (VUNSPEC_SYNC_STORE_IF_LOCK        25)
+   (VUNSPEC_EH_RETURN                 26)
+   (VUNSPEC_FRS                       27)
+   (VUNSPEC_CSRF                      28)
+   (VUNSPEC_SSRF                      29)
+   (VUNSPEC_SLEEP                     30)
+   (VUNSPEC_DELAY_CYCLES              31)
+   (VUNSPEC_DELAY_CYCLES_1            32)
+   (VUNSPEC_DELAY_CYCLES_2            33)
+   (VUNSPEC_NOP		       34)
+   (VUNSPEC_NOP3		       35)
+   ])
+
+(define_constants
+  [
+   ;; R7 = 15-7 = 8
+   (FP_REGNUM   8)
+   ;; Return Register = R12 = 15 - 12 = 3
+   (RETVAL_REGNUM   3)
+   ;; SP = R13 = 15 - 13 = 2
+   (SP_REGNUM   2)
+   ;; LR = R14 = 15 - 14 = 1
+   (LR_REGNUM   1)
+   ;; PC = R15 = 15 - 15 = 0
+   (PC_REGNUM   0)
+   ;; FPSR = GENERAL_REGS + 1 = 17
+   (FPCC_REGNUM 17)
+   ])
+
+
+
+
+;;******************************************************************************
+;; Macros
+;;******************************************************************************
+
+;; Integer Modes for basic alu insns
+(define_mode_iterator INTM [SI HI QI])
+(define_mode_attr  alu_cc_attr [(SI "set_vncz") (HI "clobber") (QI "clobber")])
+
+;; Move word modes
+(define_mode_iterator MOVM [SI V2HI V4QI])
+
+;; For mov/addcc insns
+(define_mode_iterator ADDCC [SI HI QI])
+(define_mode_iterator MOVCC [SF SI HI QI])
+(define_mode_iterator CMP [DI SI HI QI])
+(define_mode_attr  store_postfix [(SF ".w") (SI ".w") (HI ".h") (QI ".b")])
+(define_mode_attr  load_postfix [(SF ".w") (SI ".w") (HI ".sh") (QI ".ub")])
+(define_mode_attr  load_postfix_s [(SI ".w") (HI ".sh") (QI ".sb")])
+(define_mode_attr  load_postfix_u [(SI ".w") (HI ".uh") (QI ".ub")])
+(define_mode_attr  pred_mem_constraint [(SF "RKu11") (SI "RKu11") (HI "RKu10") (QI "RKu09")])
+(define_mode_attr  cmp_constraint [(DI "rKu20") (SI "rKs21") (HI "r") (QI "r")])
+(define_mode_attr  cmp_predicate [(DI "register_immediate_operand")
+                                  (SI "register_const_int_operand")
+                                  (HI "register_operand")
+                                  (QI "register_operand")])
+(define_mode_attr  cmp_length [(DI "6")
+                               (SI "4")
+                               (HI "4")
+                               (QI "4")])
+
+;; For all conditional insns
+(define_code_iterator any_cond_b [ge lt geu ltu])
+(define_code_iterator any_cond [gt ge lt le gtu geu ltu leu])
+(define_code_iterator any_cond4 [gt le gtu leu])
+(define_code_attr cond [(eq "eq") (ne "ne") (gt "gt") (ge "ge") (lt "lt") (le "le")
+                        (gtu "hi") (geu "hs") (ltu "lo") (leu "ls")])
+(define_code_attr invcond [(eq "ne") (ne "eq") (gt "le") (ge "lt") (lt "ge") (le "gt")
+                           (gtu "ls") (geu "lo") (ltu "hs") (leu "hi")])
+
+;; For logical operations
+(define_code_iterator logical [and ior xor])
+(define_code_attr logical_insn [(and "and") (ior "or") (xor "eor")])
+
+;; Predicable operations with three register operands 
+(define_code_iterator predicable_op3 [and ior xor plus minus])
+(define_code_attr predicable_insn3 [(and "and") (ior "or") (xor "eor") (plus "add") (minus "sub")])
+(define_code_attr predicable_commutative3 [(and "%") (ior "%") (xor "%") (plus "%") (minus "")])
+
+;; Load the predicates
+(include "predicates.md")
+
+
+;;******************************************************************************
+;; Automaton pipeline description for avr32
+;;******************************************************************************
+
+(define_automaton "avr32_ap")
+
+
+(define_cpu_unit "is" "avr32_ap")
+(define_cpu_unit "a1,m1,da" "avr32_ap")
+(define_cpu_unit "a2,m2,d" "avr32_ap")
+
+;;Alu instructions
+(define_insn_reservation "alu_op" 1
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "alu"))
+  "is,a1,a2")
+
+(define_insn_reservation "alu2_op" 2
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "alu2"))
+  "is,is+a1,a1+a2,a2")
+
+(define_insn_reservation "alu_sat_op" 2
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "alu_sat"))
+  "is,a1,a2")
+
+
+;;Mul instructions
+(define_insn_reservation "mulhh_op" 2
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "mulhh,mulwh"))
+  "is,m1,m2")
+
+(define_insn_reservation "mulww_w_op" 3
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "mulww_w"))
+  "is,m1,m1+m2,m2")
+
+(define_insn_reservation "mulww_d_op" 5
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "mulww_d"))
+  "is,m1,m1+m2,m1+m2,m2,m2")
+
+(define_insn_reservation "div_op" 33
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "div"))
+  "is,m1,m1*31 + m2*31,m2")
+
+(define_insn_reservation "machh_w_op" 3
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "machh_w"))
+  "is*2,m1,m2")
+
+
+(define_insn_reservation "macww_w_op" 4
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "macww_w"))
+  "is*2,m1,m1,m2")
+
+
+(define_insn_reservation "macww_d_op" 6
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "macww_d"))
+  "is*2,m1,m1+m2,m1+m2,m2")
+
+;;Bypasses for Mac instructions, because of accumulator cache.
+;;Set latency as low as possible in order to let the compiler let
+;;mul -> mac and mac -> mac combinations which use the same
+;;accumulator cache be placed close together to avoid any
+;;instructions which can ruin the accumulator cache come inbetween.
+(define_bypass 4 "machh_w_op" "alu_op,alu2_op,alu_sat_op,load_op" "avr32_mul_waw_bypass")
+(define_bypass 5 "macww_w_op" "alu_op,alu2_op,alu_sat_op,load_op" "avr32_mul_waw_bypass")
+(define_bypass 7 "macww_d_op" "alu_op,alu2_op,alu_sat_op,load_op" "avr32_mul_waw_bypass")
+
+(define_bypass 3 "mulhh_op" "alu_op,alu2_op,alu_sat_op,load_op" "avr32_mul_waw_bypass")
+(define_bypass 4 "mulww_w_op" "alu_op,alu2_op,alu_sat_op,load_op" "avr32_mul_waw_bypass")
+(define_bypass 6 "mulww_d_op" "alu_op,alu2_op,alu_sat_op,load_op" "avr32_mul_waw_bypass")
+
+
+;;Bypasses for all mul/mac instructions followed by an instruction
+;;which reads the output AND writes the result to the same register.
+;;This will generate an Write After Write hazard which gives an
+;;extra cycle before the result is ready.
+(define_bypass 0 "machh_w_op" "machh_w_op" "avr32_valid_macmac_bypass")
+(define_bypass 0 "macww_w_op" "macww_w_op" "avr32_valid_macmac_bypass")
+(define_bypass 0 "macww_d_op" "macww_d_op" "avr32_valid_macmac_bypass")
+
+(define_bypass 0 "mulhh_op" "machh_w_op" "avr32_valid_mulmac_bypass")
+(define_bypass 0 "mulww_w_op" "macww_w_op" "avr32_valid_mulmac_bypass")
+(define_bypass 0 "mulww_d_op" "macww_d_op" "avr32_valid_mulmac_bypass")
+
+;;Branch and call instructions
+;;We assume that all branches and rcalls are predicted correctly :-)
+;;while calls use a lot of cycles.
+(define_insn_reservation "branch_op" 0
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "branch"))
+  "nothing")
+
+(define_insn_reservation "call_op" 10
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "call"))
+  "nothing")
+
+
+;;Load store instructions
+(define_insn_reservation "load_op" 2
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "load"))
+  "is,da,d")
+
+(define_insn_reservation "load_rm_op" 3
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "load_rm"))
+  "is,da,d")
+
+
+(define_insn_reservation "store_op" 0
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "store"))
+  "is,da,d")
+
+
+(define_insn_reservation "load_double_op" 3
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "load2"))
+  "is,da,da+d,d")
+
+(define_insn_reservation "load_quad_op" 4
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "load4"))
+  "is,da,da+d,da+d,d")
+
+(define_insn_reservation "store_double_op" 0
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "store2"))
+  "is,da,da+d,d")
+
+
+(define_insn_reservation "store_quad_op" 0
+  (and (eq_attr "pipeline" "ap")
+       (eq_attr "type" "store4"))
+  "is,da,da+d,da+d,d")
+
+;;For store the operand to write to memory is read in d and
+;;the real latency between any instruction and a store is therefore
+;;one less than for the instructions which reads the operands in the first
+;;excecution stage
+(define_bypass 2 "load_double_op" "store_double_op" "avr32_store_bypass")
+(define_bypass 3 "load_quad_op" "store_quad_op" "avr32_store_bypass")
+(define_bypass 1 "load_op" "store_op" "avr32_store_bypass")
+(define_bypass 2 "load_rm_op" "store_op" "avr32_store_bypass")
+(define_bypass 1 "alu_sat_op" "store_op" "avr32_store_bypass")
+(define_bypass 1 "alu2_op" "store_op" "avr32_store_bypass")
+(define_bypass 1 "mulhh_op" "store_op" "avr32_store_bypass")
+(define_bypass 2 "mulww_w_op" "store_op" "avr32_store_bypass")
+(define_bypass 4 "mulww_d_op" "store_op" "avr32_store_bypass" )
+(define_bypass 2 "machh_w_op" "store_op" "avr32_store_bypass")
+(define_bypass 3 "macww_w_op" "store_op" "avr32_store_bypass")
+(define_bypass 5 "macww_d_op" "store_op" "avr32_store_bypass")
+
+
+; Bypass for load double operation. If only the first loaded word is needed
+; then the latency is 2
+(define_bypass 2 "load_double_op"
+                 "load_op,load_rm_op,alu_sat_op, alu2_op, alu_op, mulhh_op, mulww_w_op,
+                  mulww_d_op, machh_w_op, macww_w_op, macww_d_op"
+                 "avr32_valid_load_double_bypass")
+
+; Bypass for load quad operation. If only the first or second loaded word is needed
+; we set the latency to 2
+(define_bypass 2 "load_quad_op"
+                 "load_op,load_rm_op,alu_sat_op, alu2_op, alu_op, mulhh_op, mulww_w_op,
+                  mulww_d_op, machh_w_op, macww_w_op, macww_d_op"
+                 "avr32_valid_load_quad_bypass")
+
+
+;;******************************************************************************
+;; End of Automaton pipeline description for avr32
+;;******************************************************************************
+
+(define_cond_exec
+  [(match_operator 0 "avr32_comparison_operator"
+    [(match_operand:CMP 1 "register_operand" "r")         
+     (match_operand:CMP 2 "<CMP:cmp_predicate>" "<CMP:cmp_constraint>")])]
+  "TARGET_V2_INSNS" 
+  "%!"
+)
+
+(define_cond_exec
+  [(match_operator 0 "avr32_comparison_operator"
+     [(and:SI (match_operand:SI 1 "register_operand" "r")         
+              (match_operand:SI 2 "one_bit_set_operand" "i"))
+      (const_int 0)])]
+  "TARGET_V2_INSNS" 
+  "%!"
+  )
+
+;;=============================================================================
+;; move
+;;-----------------------------------------------------------------------------
+
+
+;;== char - 8 bits ============================================================
+(define_expand "movqi"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "")
+	(match_operand:QI 1 "general_operand" ""))]
+  ""
+  {
+   if ( can_create_pseudo_p () ){
+     if (GET_CODE (operands[1]) == MEM && optimize){
+         rtx reg = gen_reg_rtx (SImode);
+
+         emit_insn (gen_zero_extendqisi2 (reg, operands[1]));
+         operands[1] = gen_lowpart (QImode, reg);
+     }
+
+     /* One of the ops has to be in a register.  */
+     if (GET_CODE (operands[0]) == MEM)
+       operands[1] = force_reg (QImode, operands[1]);
+   }
+
+  })
+
+(define_insn "*movqi_internal"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=r,r,m,r")
+	(match_operand:QI 1 "general_operand"  "rKs08,m,r,i"))]
+  "register_operand (operands[0], QImode)
+   || register_operand (operands[1], QImode)"
+  "@
+   mov\t%0, %1
+   ld.ub\t%0, %1
+   st.b\t%0, %1
+   mov\t%0, %1"
+  [(set_attr "length" "2,4,4,4")
+   (set_attr "type" "alu,load_rm,store,alu")])
+
+
+
+;;== short - 16 bits ==========================================================
+(define_expand "movhi"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "")
+	(match_operand:HI 1 "general_operand" ""))]
+  ""
+  {
+   if ( can_create_pseudo_p () ){
+     if (GET_CODE (operands[1]) == MEM && optimize){
+         rtx reg = gen_reg_rtx (SImode);
+
+         emit_insn (gen_extendhisi2 (reg, operands[1]));
+         operands[1] = gen_lowpart (HImode, reg);
+     }
+
+     /* One of the ops has to be in a register.  */
+     if (GET_CODE (operands[0]) == MEM)
+       operands[1] = force_reg (HImode, operands[1]);
+   }
+
+  })
+
+
+(define_insn "*movhi_internal"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,m,r")
+	(match_operand:HI 1 "general_operand"  "rKs08,m,r,i"))]
+  "register_operand (operands[0], HImode)
+   || register_operand (operands[1], HImode)"
+  "@
+   mov\t%0, %1
+   ld.sh\t%0, %1
+   st.h\t%0, %1
+   mov\t%0, %1"
+  [(set_attr "length" "2,4,4,4")
+   (set_attr "type" "alu,load_rm,store,alu")])
+
+
+;;== int - 32 bits ============================================================
+
+(define_expand "movmisalignsi"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "")
+	(match_operand:SI 1 "nonimmediate_operand" ""))]
+  "TARGET_UNALIGNED_WORD"
+  {
+  }
+)
+
+(define_expand "mov<mode>"
+  [(set (match_operand:MOVM 0 "avr32_non_rmw_nonimmediate_operand" "")
+	(match_operand:MOVM 1 "avr32_non_rmw_general_operand" ""))]
+  ""
+  {
+
+    /* One of the ops has to be in a register.  */
+    if (GET_CODE (operands[0]) == MEM)
+      operands[1] = force_reg (<MODE>mode, operands[1]);
+
+    /* Check for out of range immediate constants as these may
+       occur during reloading, since it seems like reload does
+       not check if the immediate is legitimate. Don't know if
+       this is a bug? */
+    if ( reload_in_progress
+         && avr32_imm_in_const_pool
+         && GET_CODE(operands[1]) == CONST_INT
+         && !avr32_const_ok_for_constraint_p(INTVAL(operands[1]), 'K', "Ks21") ){
+        operands[1] = force_const_mem(SImode, operands[1]);
+    }
+    /* Check for RMW memory operands. They are not allowed for mov operations
+       only the atomic memc/s/t operations */
+    if ( !reload_in_progress
+         && avr32_rmw_memory_operand (operands[0], <MODE>mode) ){
+       operands[0] = copy_rtx (operands[0]);                                                              
+       XEXP(operands[0], 0) = force_reg (<MODE>mode, XEXP(operands[0], 0));
+    }
+
+    if ( !reload_in_progress
+         && avr32_rmw_memory_operand (operands[1], <MODE>mode) ){
+       operands[1] = copy_rtx (operands[1]);                                                              
+      XEXP(operands[1], 0) = force_reg (<MODE>mode, XEXP(operands[1], 0));
+    }
+    if ( (flag_pic || TARGET_HAS_ASM_ADDR_PSEUDOS)
+         && !avr32_legitimate_pic_operand_p(operands[1]) )
+      operands[1] = legitimize_pic_address (operands[1], <MODE>mode,
+                                            (can_create_pseudo_p () ? 0: operands[0]));
+    else if ( flag_pic && avr32_address_operand(operands[1], GET_MODE(operands[1])) )
+      /* If we have an address operand then this function uses the pic register. */
+      crtl->uses_pic_offset_table = 1;
+  })
+
+
+(define_insn "mov<mode>_internal"
+  [(set (match_operand:MOVM 0 "avr32_non_rmw_nonimmediate_operand" "=r,   r,   r,r,r,Q,r")
+	(match_operand:MOVM 1 "avr32_non_rmw_general_operand"      "rKs08,Ks21,J,n,Q,r,W"))]
+  "(register_operand (operands[0], <MODE>mode)
+    || register_operand (operands[1], <MODE>mode))
+    && !avr32_rmw_memory_operand (operands[0], <MODE>mode) 
+    && !avr32_rmw_memory_operand (operands[1], <MODE>mode)"
+  {
+    switch (which_alternative) {
+      case 0:
+      case 1: return "mov\t%0, %1";
+      case 2:
+        if ( TARGET_V2_INSNS )
+           return "movh\t%0, hi(%1)";
+        /* Fallthrough */
+      case 3: return "mov\t%0, lo(%1)\;orh\t%0,hi(%1)";
+      case 4:
+        if ( (REG_P(XEXP(operands[1], 0))
+              && REGNO(XEXP(operands[1], 0)) == SP_REGNUM)
+             || (GET_CODE(XEXP(operands[1], 0)) == PLUS
+                 && REGNO(XEXP(XEXP(operands[1], 0), 0)) == SP_REGNUM
+	         && GET_CODE(XEXP(XEXP(operands[1], 0), 1)) == CONST_INT
+	         && INTVAL(XEXP(XEXP(operands[1], 0), 1)) % 4 == 0
+	         && INTVAL(XEXP(XEXP(operands[1], 0), 1)) <= 0x1FC) )
+          return "lddsp\t%0, %1";
+	else if ( avr32_const_pool_ref_operand(operands[1], GET_MODE(operands[1])) )
+          return "lddpc\t%0, %1";
+        else
+          return "ld.w\t%0, %1";
+      case 5:
+        if ( (REG_P(XEXP(operands[0], 0))
+              && REGNO(XEXP(operands[0], 0)) == SP_REGNUM)
+             || (GET_CODE(XEXP(operands[0], 0)) == PLUS
+                 && REGNO(XEXP(XEXP(operands[0], 0), 0)) == SP_REGNUM
+	         && GET_CODE(XEXP(XEXP(operands[0], 0), 1)) == CONST_INT
+	         && INTVAL(XEXP(XEXP(operands[0], 0), 1)) % 4 == 0
+	         && INTVAL(XEXP(XEXP(operands[0], 0), 1)) <= 0x1FC) )
+          return "stdsp\t%0, %1";
+	else
+          return "st.w\t%0, %1";
+      case 6:
+        if ( TARGET_HAS_ASM_ADDR_PSEUDOS )
+          return "lda.w\t%0, %1";
+        else
+          return "ld.w\t%0, r6[%1@got]";
+      default:
+	abort();
+    }
+  }
+  
+  [(set_attr "length" "2,4,4,8,4,4,8")
+   (set_attr "type" "alu,alu,alu,alu2,load,store,load")
+   (set_attr "cc" "none,none,set_z_if_not_v2,set_z,none,none,clobber")])
+
+
+(define_expand "reload_out_rmw_memory_operand"
+  [(set (match_operand:SI 2 "register_operand" "=r")
+        (match_operand:SI 0 "address_operand" ""))
+   (set (mem:SI (match_dup 2))
+        (match_operand:SI 1 "register_operand" ""))]
+  ""
+  {
+   operands[0] = XEXP(operands[0], 0);
+  }
+)
+
+(define_expand "reload_in_rmw_memory_operand"
+  [(set (match_operand:SI 2 "register_operand" "=r")
+        (match_operand:SI 1 "address_operand" ""))
+   (set (match_operand:SI 0 "register_operand" "")
+        (mem:SI (match_dup 2)))]
+  ""
+  {
+   operands[1] = XEXP(operands[1], 0);
+  }
+)
+
+
+;; These instructions are for loading constants which cannot be loaded
+;; directly from the constant pool because the offset is too large
+;; high and lo_sum are used even tough for our case it should be
+;; low and high sum :-)
+(define_insn "mov_symbol_lo"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(high:SI (match_operand:SI 1 "immediate_operand" "i" )))]
+  ""
+  "mov\t%0, lo(%1)"
+  [(set_attr "type" "alu")
+   (set_attr "length" "4")]
+)
+
+(define_insn "add_symbol_hi"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(lo_sum:SI (match_dup 0)
+                   (match_operand:SI 1 "immediate_operand" "i" )))]
+  ""
+  "orh\t%0, hi(%1)"
+  [(set_attr "type" "alu")
+   (set_attr "length" "4")]
+)
+
+
+
+;; When generating pic, we need to load the symbol offset into a register.
+;; So that the optimizer does not confuse this with a normal symbol load
+;; we use an unspec.  The offset will be loaded from a constant pool entry,
+;; since that is the only type of relocation we can use.
+(define_insn "pic_load_addr"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(match_operand:SI 1 "" "")] UNSPEC_PIC_SYM))]
+  "flag_pic && CONSTANT_POOL_ADDRESS_P(XEXP(operands[1], 0))"
+  "lddpc\t%0, %1"
+  [(set_attr "type" "load")
+   (set_attr "length" "4")]
+)
+
+(define_insn "pic_compute_got_from_pc"
+  [(set (match_operand:SI 0 "register_operand" "+r")
+	(unspec:SI [(minus:SI (pc)
+                              (match_dup 0))] UNSPEC_PIC_BASE))
+   (use (label_ref (match_operand 1 "" "")))]
+  "flag_pic"
+  {
+   (*targetm.asm_out.internal_label) (asm_out_file, "L",
+	 		     CODE_LABEL_NUMBER (operands[1]));
+   return \"rsub\t%0, pc\";
+  }
+  [(set_attr "cc" "clobber")
+   (set_attr "length" "2")]
+)
+
+;;== long long int - 64 bits ==================================================
+
+(define_expand "movdi"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "")
+	(match_operand:DI 1 "general_operand" ""))]
+  ""
+  {
+
+    /* One of the ops has to be in a register.  */
+    if (GET_CODE (operands[0]) != REG)
+      operands[1] = force_reg (DImode, operands[1]);
+
+  })
+
+
+(define_insn_and_split "*movdi_internal"
+  [(set (match_operand:DI 0 "nonimmediate_operand"     "=r,r,   r,   r,r,r,m")
+	(match_operand:DI 1 "general_operand"          "r, Ks08,Ks21,G,n,m,r"))]
+  "register_operand (operands[0], DImode)
+   || register_operand (operands[1], DImode)"
+  {
+    switch (which_alternative ){
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+        return "#";
+    case 5:
+      if ( avr32_const_pool_ref_operand(operands[1], GET_MODE(operands[1])))
+        return "ld.d\t%0, pc[%1 - .]";
+      else
+        return "ld.d\t%0, %1";
+    case 6:
+      return "st.d\t%0, %1";
+    default:
+      abort();
+    }
+  }
+;; Lets split all reg->reg or imm->reg transfers into two SImode transfers 
+  "reload_completed &&
+   (REG_P (operands[0]) &&
+   (REG_P (operands[1]) 
+    || GET_CODE (operands[1]) == CONST_INT
+    || GET_CODE (operands[1]) == CONST_DOUBLE))"
+  [(set (match_dup 0) (match_dup 1))
+   (set (match_dup 2) (match_dup 3))]
+  {
+    operands[2] = gen_highpart (SImode, operands[0]);
+    operands[0] = gen_lowpart (SImode, operands[0]);
+    if ( REG_P(operands[1]) ){
+      operands[3] = gen_highpart(SImode, operands[1]);
+      operands[1] = gen_lowpart(SImode, operands[1]);
+    } else if ( GET_CODE(operands[1]) == CONST_DOUBLE 
+                || GET_CODE(operands[1]) == CONST_INT ){
+      rtx split_const[2];
+      avr32_split_const_expr (DImode, SImode, operands[1], split_const);
+      operands[3] = split_const[1];
+      operands[1] = split_const[0];
+    } else {
+      internal_error("Illegal operand[1] for movdi split!");
+    }
+  }
+
+  [(set_attr "length" "*,*,*,*,*,4,4")
+   (set_attr "type" "*,*,*,*,*,load2,store2")
+   (set_attr "cc" "*,*,*,*,*,none,none")])
+
+
+;;== 128 bits ==================================================
+(define_expand "movti"
+  [(set (match_operand:TI 0 "nonimmediate_operand" "")
+	(match_operand:TI 1 "nonimmediate_operand" ""))]
+  "TARGET_ARCH_AP"    
+  {     
+        
+    /* One of the ops has to be in a register.  */
+    if (GET_CODE (operands[0]) != REG)
+      operands[1] = force_reg (TImode, operands[1]);
+
+    /* We must fix any pre_dec for loads and post_inc stores */
+    if ( GET_CODE (operands[0]) == MEM
+         && GET_CODE (XEXP(operands[0],0)) == POST_INC ){
+       emit_move_insn(gen_rtx_MEM(TImode, XEXP(XEXP(operands[0],0),0)), operands[1]);
+       emit_insn(gen_addsi3(XEXP(XEXP(operands[0],0),0), XEXP(XEXP(operands[0],0),0), GEN_INT(GET_MODE_SIZE(TImode))));
+       DONE;
+    }
+
+    if ( GET_CODE (operands[1]) == MEM
+         && GET_CODE (XEXP(operands[1],0)) == PRE_DEC ){
+       emit_insn(gen_addsi3(XEXP(XEXP(operands[1],0),0), XEXP(XEXP(operands[1],0),0), GEN_INT(-GET_MODE_SIZE(TImode))));
+       emit_move_insn(operands[0], gen_rtx_MEM(TImode, XEXP(XEXP(operands[1],0),0)));
+       DONE;
+    }
+  })
+
+
+(define_insn_and_split "*movti_internal"
+  [(set (match_operand:TI 0 "avr32_movti_dst_operand"  "=r,&r,    r,    <RKu00,r,r")
+	(match_operand:TI 1 "avr32_movti_src_operand"  " r,RKu00>,RKu00,r,     n,T"))]
+  "(register_operand (operands[0], TImode)
+    || register_operand (operands[1], TImode))"
+  {
+    switch (which_alternative ){
+    case 0:
+    case 2:
+    case 4:
+        return "#";
+    case 1:
+        return "ldm\t%p1, %0";
+    case 3:
+        return "stm\t%p0, %1";
+    case 5:
+        return "ld.d\t%U0, pc[%1 - .]\;ld.d\t%B0, pc[%1 - . + 8]";
+    }
+  }
+
+  "reload_completed &&
+   (REG_P (operands[0]) &&
+   (REG_P (operands[1]) 
+    /* If this is a load from the constant pool we split it into
+       two double loads. */
+    || (GET_CODE (operands[1]) == MEM
+        && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF
+        && CONSTANT_POOL_ADDRESS_P (XEXP (operands[1], 0)))               
+    /* If this is a load where the pointer register is a part
+       of the register list, we must split it into two double
+       loads in order for it to be exception safe. */
+    || (GET_CODE (operands[1]) == MEM
+        && register_operand (XEXP (operands[1], 0), SImode)
+        && reg_overlap_mentioned_p (operands[0], XEXP (operands[1], 0)))               
+    || GET_CODE (operands[1]) == CONST_INT
+    || GET_CODE (operands[1]) == CONST_DOUBLE))"
+  [(set (match_dup 0) (match_dup 1))
+   (set (match_dup 2) (match_dup 3))]
+  {
+    operands[2] = simplify_gen_subreg ( DImode, operands[0], 
+                                        TImode, 0 );
+    operands[0] = simplify_gen_subreg ( DImode, operands[0], 
+                                        TImode, 8 );
+    if ( REG_P(operands[1]) ){
+      operands[3] = simplify_gen_subreg ( DImode, operands[1], 
+                                          TImode, 0 );
+      operands[1] = simplify_gen_subreg ( DImode, operands[1], 
+                                          TImode, 8 );
+    } else if ( GET_CODE(operands[1]) == CONST_DOUBLE 
+                || GET_CODE(operands[1]) == CONST_INT ){
+      rtx split_const[2];
+      avr32_split_const_expr (TImode, DImode, operands[1], split_const);
+      operands[3] = split_const[1];
+      operands[1] = split_const[0];
+    } else if (avr32_const_pool_ref_operand (operands[1], GET_MODE(operands[1]))){
+      rtx split_const[2];
+      rtx cop = avoid_constant_pool_reference (operands[1]);
+      if (operands[1] == cop)
+        cop = get_pool_constant (XEXP (operands[1], 0));
+      avr32_split_const_expr (TImode, DImode, cop, split_const);
+      operands[3] = force_const_mem (DImode, split_const[1]); 
+      operands[1] = force_const_mem (DImode, split_const[0]); 
+   } else {
+      rtx ptr_reg = XEXP (operands[1], 0);
+      operands[1] = gen_rtx_MEM (DImode, 
+                                 gen_rtx_PLUS ( SImode,
+                                                ptr_reg,
+                                                GEN_INT (8) ));
+      operands[3] = gen_rtx_MEM (DImode,
+                                 ptr_reg);
+              
+      /* Check if the first load will clobber the pointer.
+         If so, we must switch the order of the operations. */
+      if ( reg_overlap_mentioned_p (operands[0], ptr_reg) )
+        {
+          /* We need to switch the order of the operations
+             so that the pointer register does not get clobbered
+             after the first double word load. */
+          rtx tmp;
+          tmp = operands[0];
+          operands[0] = operands[2];
+          operands[2] = tmp;
+          tmp = operands[1];
+          operands[1] = operands[3];
+          operands[3] = tmp;
+        }
+
+
+   }
+  }
+  [(set_attr "length" "*,*,4,4,*,8")
+   (set_attr "type" "*,*,load4,store4,*,load4")])
+
+
+;;== float - 32 bits ==========================================================
+(define_expand "movsf"
+  [(set (match_operand:SF 0 "nonimmediate_operand" "")
+	(match_operand:SF 1 "general_operand" ""))]
+  ""
+  {
+
+
+    /* One of the ops has to be in a register.  */
+    if (GET_CODE (operands[0]) != REG)
+      operands[1] = force_reg (SFmode, operands[1]);
+
+  })
+
+(define_insn "*movsf_internal"
+  [(set (match_operand:SF 0 "nonimmediate_operand"     "=r,r,r,r,m")
+	(match_operand:SF 1 "general_operand"          "r, G,F,m,r"))]
+  "(register_operand (operands[0], SFmode)
+    || register_operand (operands[1], SFmode))"
+  {
+    switch (which_alternative) {
+      case 0:
+      case 1: return "mov\t%0, %1";
+      case 2: 
+       {
+        HOST_WIDE_INT target_float[2];
+        real_to_target (target_float, CONST_DOUBLE_REAL_VALUE (operands[1]), SFmode);
+        if ( TARGET_V2_INSNS 
+             && avr32_hi16_immediate_operand (GEN_INT (target_float[0]), VOIDmode) )
+           return "movh\t%0, hi(%1)";
+        else
+           return "mov\t%0, lo(%1)\;orh\t%0, hi(%1)";
+       }
+      case 3:
+        if ( (REG_P(XEXP(operands[1], 0))
+              && REGNO(XEXP(operands[1], 0)) == SP_REGNUM)
+             || (GET_CODE(XEXP(operands[1], 0)) == PLUS
+                 && REGNO(XEXP(XEXP(operands[1], 0), 0)) == SP_REGNUM
+	         && GET_CODE(XEXP(XEXP(operands[1], 0), 1)) == CONST_INT
+	         && INTVAL(XEXP(XEXP(operands[1], 0), 1)) % 4 == 0
+	         && INTVAL(XEXP(XEXP(operands[1], 0), 1)) <= 0x1FC) )
+          return "lddsp\t%0, %1";
+          else if ( avr32_const_pool_ref_operand(operands[1], GET_MODE(operands[1])) )
+          return "lddpc\t%0, %1";
+        else
+          return "ld.w\t%0, %1";
+      case 4:
+        if ( (REG_P(XEXP(operands[0], 0))
+              && REGNO(XEXP(operands[0], 0)) == SP_REGNUM)
+             || (GET_CODE(XEXP(operands[0], 0)) == PLUS
+                 && REGNO(XEXP(XEXP(operands[0], 0), 0)) == SP_REGNUM
+	         && GET_CODE(XEXP(XEXP(operands[0], 0), 1)) == CONST_INT
+	         && INTVAL(XEXP(XEXP(operands[0], 0), 1)) % 4 == 0
+	         && INTVAL(XEXP(XEXP(operands[0], 0), 1)) <= 0x1FC) )
+          return "stdsp\t%0, %1";
+	else
+          return "st.w\t%0, %1";
+      default:
+	abort();
+    }
+  }
+
+  [(set_attr "length" "2,4,8,4,4")
+   (set_attr "type" "alu,alu,alu2,load,store")
+   (set_attr "cc" "none,none,clobber,none,none")])
+
+
+
+;;== double - 64 bits =========================================================
+(define_expand "movdf"
+  [(set (match_operand:DF 0 "nonimmediate_operand" "")
+	(match_operand:DF 1 "general_operand" ""))]
+  ""
+  {
+    /* One of the ops has to be in a register.  */
+    if (GET_CODE (operands[0]) != REG){
+      operands[1] = force_reg (DFmode, operands[1]);
+    }
+  })
+
+
+(define_insn_and_split "*movdf_internal"
+  [(set (match_operand:DF 0 "nonimmediate_operand"     "=r,r,r,r,m")
+	(match_operand:DF 1 "general_operand"          " r,G,F,m,r"))]
+  "(register_operand (operands[0], DFmode)
+       || register_operand (operands[1], DFmode))"
+  {
+    switch (which_alternative ){
+    case 0:
+    case 1:
+    case 2: 
+        return "#";
+    case 3:
+      if ( avr32_const_pool_ref_operand(operands[1], GET_MODE(operands[1])))
+        return "ld.d\t%0, pc[%1 - .]";
+      else
+        return "ld.d\t%0, %1";
+    case 4:
+      return "st.d\t%0, %1";
+    default:
+      abort();
+    }
+  }
+  "reload_completed
+   && (REG_P (operands[0]) 
+        && (REG_P (operands[1])
+            || GET_CODE (operands[1]) == CONST_DOUBLE))"
+  [(set (match_dup 0) (match_dup 1))
+   (set (match_dup 2) (match_dup 3))]
+  "
+   {
+    operands[2] = gen_highpart (SImode, operands[0]);
+    operands[0] = gen_lowpart (SImode, operands[0]);
+    operands[3] = gen_highpart(SImode, operands[1]);
+    operands[1] = gen_lowpart(SImode, operands[1]);
+   }
+  "
+
+  [(set_attr "length" "*,*,*,4,4")
+   (set_attr "type" "*,*,*,load2,store2")
+   (set_attr "cc" "*,*,*,none,none")])
+
+
+;;=============================================================================
+;; Conditional Moves
+;;=============================================================================
+(define_insn "ld<mode>_predicable"
+  [(set (match_operand:MOVCC 0 "register_operand" "=r")
+	(match_operand:MOVCC 1 "avr32_non_rmw_memory_operand" "<MOVCC:pred_mem_constraint>"))]
+  "TARGET_V2_INSNS"
+  "ld<MOVCC:load_postfix>%?\t%0, %1"
+  [(set_attr "length" "4")
+   (set_attr "cc" "cmp_cond_insn")
+   (set_attr "type" "load")
+   (set_attr "predicable" "yes")]
+)
+
+
+(define_insn "st<mode>_predicable"
+  [(set (match_operand:MOVCC 0 "avr32_non_rmw_memory_operand" "=<MOVCC:pred_mem_constraint>")
+	(match_operand:MOVCC 1 "register_operand" "r"))]
+  "TARGET_V2_INSNS"
+  "st<MOVCC:store_postfix>%?\t%0, %1"
+  [(set_attr "length" "4")
+   (set_attr "cc" "cmp_cond_insn")
+   (set_attr "type" "store")
+   (set_attr "predicable" "yes")]
+)
+
+(define_insn "mov<mode>_predicable"
+  [(set (match_operand:MOVCC 0 "register_operand" "=r")
+	(match_operand:MOVCC 1 "avr32_cond_register_immediate_operand" "rKs08"))]
+  ""
+  "mov%?\t%0, %1"
+  [(set_attr "length" "4")
+   (set_attr "cc" "cmp_cond_insn")
+   (set_attr "type" "alu")
+   (set_attr "predicable" "yes")]
+)
+
+
+;;=============================================================================
+;; Move chunks of memory
+;;=============================================================================
+
+(define_expand "movmemsi"
+  [(match_operand:BLK 0 "general_operand" "")
+   (match_operand:BLK 1 "general_operand" "")
+   (match_operand:SI 2 "const_int_operand" "")
+   (match_operand:SI 3 "const_int_operand" "")]
+  ""
+  "
+   if (avr32_gen_movmemsi (operands))
+     DONE;
+   FAIL;
+  "
+  )
+
+
+
+
+;;=============================================================================
+;; Bit field instructions
+;;-----------------------------------------------------------------------------
+;; Instructions to insert or extract bit-fields
+;;=============================================================================
+
+(define_insn "insv"
+  [ (set (zero_extract:SI (match_operand:SI 0 "register_operand" "+r")
+                          (match_operand:SI 1 "immediate_operand" "Ku05")
+                          (match_operand:SI 2 "immediate_operand" "Ku05"))
+         (match_operand 3 "register_operand" "r"))]
+  ""
+  "bfins\t%0, %3, %2, %1"
+  [(set_attr "type" "alu")
+   (set_attr "length" "4")
+   (set_attr "cc" "set_ncz")])
+
+
+
+(define_expand "extv"
+  [ (set (match_operand:SI 0 "register_operand" "")
+         (sign_extract:SI (match_operand:SI 1 "register_operand" "")
+                          (match_operand:SI 2 "immediate_operand" "")
+                          (match_operand:SI 3 "immediate_operand" "")))]
+  ""
+  {
+   if ( INTVAL(operands[2]) >= 32 )
+      FAIL;
+  }
+)
+
+(define_expand "extzv"
+  [ (set (match_operand:SI 0 "register_operand" "")
+         (zero_extract:SI (match_operand:SI 1 "register_operand" "")
+                          (match_operand:SI 2 "immediate_operand" "")
+                          (match_operand:SI 3 "immediate_operand" "")))]
+  ""
+  {
+   if ( INTVAL(operands[2]) >= 32 )
+      FAIL;
+  }
+)
+
+(define_insn "extv_internal"
+  [ (set (match_operand:SI 0 "register_operand" "=r")
+         (sign_extract:SI (match_operand:SI 1 "register_operand" "r")
+                          (match_operand:SI 2 "immediate_operand" "Ku05")
+                          (match_operand:SI 3 "immediate_operand" "Ku05")))]
+  "INTVAL(operands[2]) < 32"
+  "bfexts\t%0, %1, %3, %2"
+  [(set_attr "type" "alu")
+   (set_attr "length" "4")
+   (set_attr "cc" "set_ncz")])
+
+
+(define_insn "extzv_internal"
+  [ (set (match_operand:SI 0 "register_operand" "=r")
+         (zero_extract:SI (match_operand:SI 1 "register_operand" "r")
+                          (match_operand:SI 2 "immediate_operand" "Ku05")
+                          (match_operand:SI 3 "immediate_operand" "Ku05")))]
+  "INTVAL(operands[2]) < 32"
+  "bfextu\t%0, %1, %3, %2"
+  [(set_attr "type" "alu")
+   (set_attr "length" "4")
+   (set_attr "cc" "set_ncz")])
+
+
+
+;;=============================================================================
+;; Some peepholes for avoiding unnecessary cast instructions
+;; followed by bfins.
+;;-----------------------------------------------------------------------------
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (zero_extend:SI (match_operand:QI 1 "register_operand" "")))
+   (set (zero_extract:SI (match_operand 2 "register_operand" "")
+                         (match_operand:SI 3 "immediate_operand" "")
+                         (match_operand:SI 4 "immediate_operand" ""))
+        (match_dup 0))]
+  "((peep2_reg_dead_p(2, operands[0]) &&
+    (INTVAL(operands[3]) <= 8)))"
+  [(set (zero_extract:SI (match_dup 2)
+                         (match_dup 3)
+                         (match_dup 4))
+        (match_dup 1))]
+  )
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (zero_extend:SI (match_operand:HI 1 "register_operand" "")))
+   (set (zero_extract:SI (match_operand 2 "register_operand" "")
+                         (match_operand:SI 3 "immediate_operand" "")
+                         (match_operand:SI 4 "immediate_operand" ""))
+        (match_dup 0))]
+  "((peep2_reg_dead_p(2, operands[0]) &&
+    (INTVAL(operands[3]) <= 16)))"
+  [(set (zero_extract:SI (match_dup 2)
+                         (match_dup 3)
+                         (match_dup 4))
+        (match_dup 1))]
+  )
+
+;;=============================================================================
+;; push bytes
+;;-----------------------------------------------------------------------------
+;; Implements the push instruction
+;;=============================================================================
+(define_insn "pushm"
+  [(set (mem:BLK (pre_dec:BLK (reg:SI SP_REGNUM)))
+        (unspec:BLK [(match_operand 0 "const_int_operand" "")]
+                    UNSPEC_PUSHM))]
+  ""
+  {
+    if (INTVAL(operands[0])) {
+      return "pushm\t%r0";
+    } else {
+      return "";
+    }
+  }
+  [(set_attr "type" "store")
+   (set_attr "length" "2")
+   (set_attr "cc" "none")])
+
+(define_insn "stm"
+  [(unspec [(match_operand 0 "register_operand" "r")
+            (match_operand 1 "const_int_operand" "")
+            (match_operand 2 "const_int_operand" "")]
+	   UNSPEC_STM)]
+  ""
+  {
+    if (INTVAL(operands[1])) {
+      if (INTVAL(operands[2]) != 0)
+         return "stm\t--%0, %s1";
+      else
+         return "stm\t%0, %s1";
+    } else {
+      return "";
+    }
+  }
+  [(set_attr "type" "store")
+   (set_attr "length" "4")
+   (set_attr "cc" "none")])
+
+
+
+(define_insn "popm"
+  [(unspec [(match_operand 0 "const_int_operand" "")]
+	   UNSPEC_POPM)]
+  ""
+  {
+    if (INTVAL(operands[0])) {
+      return "popm   %r0";
+    } else {
+      return "";
+    }
+  }
+  [(set_attr "type" "load")
+   (set_attr "length" "2")])
+
+
+
+;;=============================================================================
+;; add
+;;-----------------------------------------------------------------------------
+;; Adds reg1 with reg2 and puts the result in reg0.
+;;=============================================================================
+(define_insn "add<mode>3"
+  [(set (match_operand:INTM 0 "register_operand" "=r,r,r,r,r")
+	(plus:INTM (match_operand:INTM 1 "register_operand" "%0,r,0,r,0")
+                   (match_operand:INTM 2 "avr32_add_operand" "r,r,Is08,Is16,Is21")))]
+  ""
+  "@
+   add     %0, %2
+   add     %0, %1, %2
+   sub     %0, %n2
+   sub     %0, %1, %n2
+   sub     %0, %n2"
+
+  [(set_attr "length" "2,4,2,4,4")
+   (set_attr "cc" "<INTM:alu_cc_attr>")])
+
+(define_insn "add<mode>3_lsl"
+  [(set (match_operand:INTM 0 "register_operand" "=r")
+	(plus:INTM (ashift:INTM (match_operand:INTM 1 "register_operand" "r")
+                                (match_operand:INTM 3 "avr32_add_shift_immediate_operand" "Ku02"))
+                   (match_operand:INTM 2 "register_operand" "r")))]
+  ""
+  "add     %0, %2, %1 << %3"
+  [(set_attr "length" "4")
+   (set_attr "cc" "<INTM:alu_cc_attr>")])
+
+(define_insn "add<mode>3_lsl2"
+  [(set (match_operand:INTM 0 "register_operand" "=r")
+	(plus:INTM (match_operand:INTM 1 "register_operand" "r")
+                   (ashift:INTM (match_operand:INTM 2 "register_operand" "r")
+                                (match_operand:INTM 3 "avr32_add_shift_immediate_operand" "Ku02"))))]
+  ""
+  "add     %0, %1, %2 << %3"
+  [(set_attr "length" "4")
+   (set_attr "cc" "<INTM:alu_cc_attr>")])
+
+
+(define_insn "add<mode>3_mul"
+  [(set (match_operand:INTM 0 "register_operand" "=r")
+	(plus:INTM (mult:INTM (match_operand:INTM 1 "register_operand" "r")
+                              (match_operand:INTM 3 "immediate_operand" "Ku04" ))
+                   (match_operand:INTM 2 "register_operand" "r")))]
+  "(INTVAL(operands[3]) == 0) || (INTVAL(operands[3]) == 2) ||
+   (INTVAL(operands[3]) == 4) || (INTVAL(operands[3]) == 8)"
+  "add     %0, %2, %1 << %p3"
+  [(set_attr "length" "4")
+   (set_attr "cc" "<INTM:alu_cc_attr>")])
+
+(define_insn "add<mode>3_mul2"
+  [(set (match_operand:INTM 0 "register_operand" "=r")
+	(plus:INTM (match_operand:INTM 1 "register_operand" "r")
+                   (mult:INTM (match_operand:INTM 2 "register_operand" "r")
+                              (match_operand:INTM 3 "immediate_operand" "Ku04" ))))]
+  "(INTVAL(operands[3]) == 0) || (INTVAL(operands[3]) == 2) ||
+   (INTVAL(operands[3]) == 4) || (INTVAL(operands[3]) == 8)"
+  "add     %0, %1, %2 << %p3"
+  [(set_attr "length" "4")
+   (set_attr "cc" "<INTM:alu_cc_attr>")])
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (ashift:SI (match_operand:SI 1 "register_operand" "")
+                   (match_operand:SI 2 "immediate_operand" "")))
+   (set (match_operand:SI 3 "register_operand" "")
+	(plus:SI (match_dup 0)
+                 (match_operand:SI 4 "register_operand" "")))]
+  "(peep2_reg_dead_p(2, operands[0]) &&
+    (INTVAL(operands[2]) < 4 && INTVAL(operands[2]) > 0))"
+  [(set (match_dup 3)
+	(plus:SI (ashift:SI (match_dup 1)
+                            (match_dup 2))
+                 (match_dup 4)))]
+  )
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (ashift:SI (match_operand:SI 1 "register_operand" "")
+                   (match_operand:SI 2 "immediate_operand" "")))
+   (set (match_operand:SI 3 "register_operand" "")
+	(plus:SI (match_operand:SI 4 "register_operand" "")
+                 (match_dup 0)))]
+  "(peep2_reg_dead_p(2, operands[0]) &&
+    (INTVAL(operands[2]) < 4 && INTVAL(operands[2]) > 0))"
+  [(set (match_dup 3)
+	(plus:SI (ashift:SI (match_dup 1)
+                            (match_dup 2))
+                 (match_dup 4)))]
+  )
+
+(define_insn "adddi3"
+  [(set (match_operand:DI 0 "register_operand" "=r,r")
+	(plus:DI (match_operand:DI 1 "register_operand" "%0,r")
+		 (match_operand:DI 2 "register_operand" "r,r")))]
+  ""
+  "@
+   add     %0, %2\;adc    %m0, %m0, %m2
+   add     %0, %1, %2\;adc    %m0, %m1, %m2"
+  [(set_attr "length" "6,8")
+   (set_attr "type" "alu2")
+   (set_attr "cc" "set_vncz")])
+
+
+(define_insn "add<mode>_imm_predicable"
+  [(set (match_operand:INTM 0 "register_operand" "+r")
+	(plus:INTM (match_dup 0)
+                   (match_operand:INTM 1 "avr32_cond_immediate_operand" "%Is08")))]
+  ""
+  "sub%?\t%0, -%1"
+  [(set_attr "length" "4")
+   (set_attr "cc" "cmp_cond_insn")
+   (set_attr "predicable" "yes")]
+)
+
+;;=============================================================================
+;; subtract
+;;-----------------------------------------------------------------------------
+;; Subtract reg2 or immediate value from reg0 and puts the result in reg0.
+;;=============================================================================
+
+(define_insn "sub<mode>3"
+  [(set (match_operand:INTM 0 "general_operand" "=r,r,r,r,r,r,r")
+	(minus:INTM (match_operand:INTM 1 "register_const_int_operand" "0,r,0,r,0,r,Ks08")
+		  (match_operand:INTM 2 "register_const_int_operand" "r,r,Ks08,Ks16,Ks21,0,r")))]
+  ""
+  "@
+   sub     %0, %2
+   sub     %0, %1, %2
+   sub     %0, %2
+   sub     %0, %1, %2
+   sub     %0, %2
+   rsub    %0, %1
+   rsub    %0, %2, %1"
+  [(set_attr "length" "2,4,2,4,4,2,4")
+   (set_attr "cc" "<INTM:alu_cc_attr>")])
+
+(define_insn "*sub<mode>3_mul"
+  [(set (match_operand:INTM 0 "register_operand" "=r")
+	(minus:INTM (match_operand:INTM 1 "register_operand" "r")
+                    (mult:INTM (match_operand:INTM 2 "register_operand" "r")
+                               (match_operand:SI 3 "immediate_operand" "Ku04" ))))]
+  "(INTVAL(operands[3]) == 0) || (INTVAL(operands[3]) == 2) ||
+   (INTVAL(operands[3]) == 4) || (INTVAL(operands[3]) == 8)"
+  "sub     %0, %1, %2 << %p3"
+  [(set_attr "length" "4")
+   (set_attr "cc" "<INTM:alu_cc_attr>")])
+
+(define_insn "*sub<mode>3_lsl"
+  [(set (match_operand:INTM 0 "register_operand" "=r")
+	(minus:INTM  (match_operand:INTM 1 "register_operand" "r")
+                     (ashift:INTM (match_operand:INTM 2 "register_operand" "r")
+                                  (match_operand:SI 3 "avr32_add_shift_immediate_operand" "Ku02"))))]
+  ""
+  "sub     %0, %1, %2 << %3"
+  [(set_attr "length" "4")
+   (set_attr "cc" "<INTM:alu_cc_attr>")])
+
+
+(define_insn "subdi3"
+  [(set (match_operand:DI 0 "register_operand" "=r,r")
+	(minus:DI (match_operand:DI 1 "register_operand" "%0,r")
+		 (match_operand:DI 2 "register_operand" "r,r")))]
+  ""
+  "@
+   sub     %0, %2\;sbc    %m0, %m0, %m2
+   sub     %0, %1, %2\;sbc    %m0, %m1, %m2"
+  [(set_attr "length" "6,8")
+   (set_attr "type" "alu2")
+   (set_attr "cc" "set_vncz")])
+
+
+(define_insn "sub<mode>_imm_predicable"
+  [(set (match_operand:INTM 0 "register_operand" "+r")
+	(minus:INTM (match_dup 0)
+                    (match_operand:INTM 1 "avr32_cond_immediate_operand" "Ks08")))]
+  ""
+  "sub%?\t%0, %1"
+  [(set_attr "length" "4")
+   (set_attr "cc" "cmp_cond_insn")
+   (set_attr "predicable" "yes")])
+
+(define_insn "rsub<mode>_imm_predicable"
+  [(set (match_operand:INTM 0 "register_operand" "+r")
+	(minus:INTM (match_operand:INTM 1 "avr32_cond_immediate_operand"  "Ks08")
+                    (match_dup 0)))]
+  ""
+  "rsub%?\t%0, %1"
+  [(set_attr "length" "4")
+   (set_attr "cc" "cmp_cond_insn")
+   (set_attr "predicable" "yes")])
+
+;;=============================================================================
+;; multiply
+;;-----------------------------------------------------------------------------
+;; Multiply op1 and op2 and put the value in op0.
+;;=============================================================================
+
+
+(define_insn "mulqi3"
+  [(set (match_operand:QI 0 "register_operand"         "=r,r,r")
+	(mult:QI (match_operand:QI 1 "register_operand" "%0,r,r")
+		 (match_operand:QI 2 "avr32_mul_operand" "r,r,Ks08")))]
+  "!TARGET_NO_MUL_INSNS"
+  {
+   switch (which_alternative){
+    case 0:
+      return "mul     %0, %2";
+    case 1:
+      return "mul     %0, %1, %2";
+    case 2:
+      return "mul     %0, %1, %2";
+    default:
+      gcc_unreachable();
+   }
+  }
+  [(set_attr "type" "mulww_w,mulww_w,mulwh")
+   (set_attr "length" "2,4,4")
+   (set_attr "cc" "none")])
+
+(define_insn "mulsi3"
+  [(set (match_operand:SI 0 "register_operand"         "=r,r,r")
+	(mult:SI (match_operand:SI 1 "register_operand" "%0,r,r")
+		 (match_operand:SI 2 "avr32_mul_operand" "r,r,Ks08")))]
+  "!TARGET_NO_MUL_INSNS"
+  {
+   switch (which_alternative){
+    case 0:
+      return "mul     %0, %2";
+    case 1:
+      return "mul     %0, %1, %2";
+    case 2:
+      return "mul     %0, %1, %2";
+    default:
+      gcc_unreachable();
+   }
+  }
+  [(set_attr "type" "mulww_w,mulww_w,mulwh")
+   (set_attr "length" "2,4,4")
+   (set_attr "cc" "none")])
+
+
+(define_insn "mulhisi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(mult:SI
+	 (sign_extend:SI (match_operand:HI 1 "register_operand" "%r"))
+	 (sign_extend:SI (match_operand:HI 2 "register_operand" "r"))))]
+  "!TARGET_NO_MUL_INSNS && TARGET_DSP"
+  "mulhh.w %0, %1:b, %2:b"
+  [(set_attr "type" "mulhh")
+   (set_attr "length" "4")
+   (set_attr "cc" "none")])
+
+(define_peephole2
+  [(match_scratch:DI 6 "r")
+   (set (match_operand:SI 0 "register_operand" "")
+	(mult:SI
+	 (sign_extend:SI (match_operand:HI 1 "register_operand" ""))
+         (sign_extend:SI (match_operand:HI 2 "register_operand" ""))))
+   (set (match_operand:SI 3 "register_operand" "")
+        (ashiftrt:SI (match_dup 0)
+                     (const_int 16)))]
+  "!TARGET_NO_MUL_INSNS && TARGET_DSP
+   && (peep2_reg_dead_p(1, operands[0]) || (REGNO(operands[0]) == REGNO(operands[3])))"
+  [(set (match_dup 4) (sign_extend:SI (match_dup 1)))
+   (set (match_dup 6)
+        (ashift:DI (mult:DI (sign_extend:DI (match_dup 4))
+                            (sign_extend:DI (match_dup 2)))
+                   (const_int 16)))
+   (set (match_dup 3) (match_dup 5))]
+
+  "{
+     operands[4] = gen_rtx_REG(SImode, REGNO(operands[1]));
+     operands[5] = gen_highpart (SImode, operands[4]);
+   }"
+  )
+
+(define_insn "mulnhisi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (mult:SI
+         (sign_extend:SI (neg:HI (match_operand:HI 1 "register_operand" "r")))
+         (sign_extend:SI (match_operand:HI 2 "register_operand" "r"))))]
+  "!TARGET_NO_MUL_INSNS && TARGET_DSP"
+  "mulnhh.w %0, %1:b, %2:b"
+  [(set_attr "type" "mulhh")
+   (set_attr "length" "4")
+   (set_attr "cc" "none")])
+
+(define_insn "machisi3"
+  [(set (match_operand:SI 0 "register_operand" "+r")
+	(plus:SI (mult:SI
+                  (sign_extend:SI (match_operand:HI 1 "register_operand" "%r"))
+                  (sign_extend:SI (match_operand:HI 2 "register_operand" "r")))
+                 (match_dup 0)))]
+  "!TARGET_NO_MUL_INSNS && TARGET_DSP"
+  "machh.w %0, %1:b, %2:b"
+  [(set_attr "type" "machh_w")
+   (set_attr "length" "4")
+   (set_attr "cc" "none")])
+
+
+
+(define_insn "mulsidi3"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(mult:DI
+	 (sign_extend:DI (match_operand:SI 1 "register_operand" "%r"))
+	 (sign_extend:DI (match_operand:SI 2 "register_operand" "r"))))]
+  "!TARGET_NO_MUL_INSNS"
+  "muls.d  %0, %1, %2"
+  [(set_attr "type" "mulww_d")
+   (set_attr "length" "4")
+   (set_attr "cc" "none")])
+
+(define_insn "umulsidi3"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(mult:DI
+	 (zero_extend:DI (match_operand:SI 1 "register_operand" "%r"))
+	 (zero_extend:DI (match_operand:SI 2 "register_operand" "r"))))]
+  "!TARGET_NO_MUL_INSNS"
+  "mulu.d  %0, %1, %2"
+  [(set_attr "type" "mulww_d")
+   (set_attr "length" "4")
+   (set_attr "cc" "none")])
+
+(define_insn "*mulaccsi3"
+  [(set (match_operand:SI 0 "register_operand" "+r")
+	(plus:SI (mult:SI (match_operand:SI 1 "register_operand" "%r")
+			  (match_operand:SI 2 "register_operand" "r"))
+		 (match_dup 0)))]
+  "!TARGET_NO_MUL_INSNS"
+  "mac     %0, %1, %2"
+  [(set_attr "type" "macww_w")
+   (set_attr "length" "4")
+   (set_attr "cc" "none")])
+
+(define_insn "*mulaccsidi3"
+  [(set (match_operand:DI 0 "register_operand" "+r")
+	(plus:DI (mult:DI
+		  (sign_extend:DI (match_operand:SI 1 "register_operand" "%r"))
+		  (sign_extend:DI (match_operand:SI 2 "register_operand" "r")))
+		 (match_dup 0)))]
+  "!TARGET_NO_MUL_INSNS"
+  "macs.d  %0, %1, %2"
+  [(set_attr "type" "macww_d")
+   (set_attr "length" "4")
+   (set_attr "cc" "none")])
+
+(define_insn "*umulaccsidi3"
+  [(set (match_operand:DI 0 "register_operand" "+r")
+	(plus:DI (mult:DI
+		  (zero_extend:DI (match_operand:SI 1 "register_operand" "%r"))
+		  (zero_extend:DI (match_operand:SI 2 "register_operand" "r")))
+		 (match_dup 0)))]
+  "!TARGET_NO_MUL_INSNS"
+  "macu.d  %0, %1, %2"
+  [(set_attr "type" "macww_d")
+   (set_attr "length" "4")
+   (set_attr "cc" "none")])
+
+
+
+;; Try to avoid Write-After-Write hazards for mul operations
+;; if it can be done
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(mult:SI
+	 (sign_extend:SI (match_operand 1 "general_operand" ""))
+         (sign_extend:SI (match_operand 2 "general_operand" ""))))
+   (set (match_dup 0)
+	(match_operator:SI 3 "alu_operator" [(match_dup 0)
+                                             (match_operand 4 "general_operand" "")]))]
+  "peep2_reg_dead_p(1, operands[2])"
+  [(set (match_dup 5)
+        (mult:SI
+         (sign_extend:SI (match_dup 1))
+         (sign_extend:SI (match_dup 2))))
+   (set (match_dup 0)
+	(match_op_dup 3 [(match_dup 5)
+                         (match_dup 4)]))]
+  "{operands[5] = gen_rtx_REG(SImode, REGNO(operands[2]));}"
+  )
+
+
+
+;;=============================================================================
+;; DSP instructions
+;;=============================================================================
+(define_insn "mulsathh_h"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (ss_truncate:HI (ashiftrt:SI (mult:SI (sign_extend:SI (match_operand:HI 1 "register_operand" "%r"))
+                                              (sign_extend:SI (match_operand:HI 2 "register_operand" "r")))
+                                     (const_int 15))))]
+  "!TARGET_NO_MUL_INSNS && TARGET_DSP"
+  "mulsathh.h\t%0, %1:b, %2:b"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none")
+   (set_attr "type" "mulhh")])
+
+(define_insn "mulsatrndhh_h"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (ss_truncate:HI (ashiftrt:SI
+                         (plus:SI (mult:SI (sign_extend:SI (match_operand:HI 1 "register_operand" "%r"))
+                                           (sign_extend:SI (match_operand:HI 2 "register_operand" "r")))
+                                  (const_int 1073741824))
+                         (const_int 15))))]
+  "!TARGET_NO_MUL_INSNS && TARGET_DSP"
+  "mulsatrndhh.h\t%0, %1:b, %2:b"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none")
+   (set_attr "type" "mulhh")])
+
+(define_insn "mulsathh_w"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (ss_truncate:SI (ashift:DI (mult:DI (sign_extend:DI (match_operand:HI 1 "register_operand" "%r"))
+                                            (sign_extend:DI (match_operand:HI 2 "register_operand" "r")))
+                                   (const_int 1))))]
+  "!TARGET_NO_MUL_INSNS && TARGET_DSP"
+  "mulsathh.w\t%0, %1:b, %2:b"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none")
+   (set_attr "type" "mulhh")])
+
+(define_insn "mulsatwh_w"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (ss_truncate:SI (ashiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 1 "register_operand" "r"))
+                                              (sign_extend:DI (match_operand:HI 2 "register_operand" "r")))
+                                     (const_int 15))))]
+  "!TARGET_NO_MUL_INSNS && TARGET_DSP"
+  "mulsatwh.w\t%0, %1, %2:b"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none")
+   (set_attr "type" "mulwh")])
+
+(define_insn "mulsatrndwh_w"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (ss_truncate:SI (ashiftrt:DI (plus:DI (mult:DI (sign_extend:DI (match_operand:SI 1 "register_operand" "r"))
+                                                       (sign_extend:DI (match_operand:HI 2 "register_operand" "r")))
+                                              (const_int 1073741824))
+                                     (const_int 15))))]
+  "!TARGET_NO_MUL_INSNS && TARGET_DSP"
+  "mulsatrndwh.w\t%0, %1, %2:b"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none")
+   (set_attr "type" "mulwh")])
+
+(define_insn "macsathh_w"
+  [(set (match_operand:SI 0 "register_operand" "+r")
+        (plus:SI (match_dup 0)
+                 (ss_truncate:SI (ashift:DI (mult:DI (sign_extend:DI (match_operand:HI 1 "register_operand" "%r"))
+                                                     (sign_extend:DI (match_operand:HI 2 "register_operand" "r")))
+                                            (const_int 1)))))]
+  "!TARGET_NO_MUL_INSNS && TARGET_DSP"
+  "macsathh.w\t%0, %1:b, %2:b"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none")
+   (set_attr "type" "mulhh")])
+
+
+(define_insn "mulwh_d"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+        (ashift:DI (mult:DI (sign_extend:DI (match_operand:SI 1 "register_operand" "r"))
+                            (sign_extend:DI (match_operand:HI 2 "register_operand" "r")))
+                   (const_int 16)))]
+  "!TARGET_NO_MUL_INSNS && TARGET_DSP"
+  "mulwh.d\t%0, %1, %2:b"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none")
+   (set_attr "type" "mulwh")])
+
+
+(define_insn "mulnwh_d"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+        (ashift:DI (mult:DI (not:DI (sign_extend:DI (match_operand:SI 1 "register_operand" "r")))
+                            (sign_extend:DI (match_operand:HI 2 "register_operand" "r")))
+                   (const_int 16)))]
+  "!TARGET_NO_MUL_INSNS && TARGET_DSP"
+  "mulnwh.d\t%0, %1, %2:b"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none")
+   (set_attr "type" "mulwh")])
+
+(define_insn "macwh_d"
+  [(set (match_operand:DI 0 "register_operand" "+r")
+        (plus:DI (match_dup 0)
+                 (ashift:DI (mult:DI (sign_extend:DI (match_operand:SI 1 "register_operand" "%r"))
+                                     (sign_extend:DI (match_operand:HI 2 "register_operand" "r")))
+                            (const_int 16))))]
+  "!TARGET_NO_MUL_INSNS && TARGET_DSP"
+  "macwh.d\t%0, %1, %2:b"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none")
+   (set_attr "type" "mulwh")])
+
+(define_insn "machh_d"
+  [(set (match_operand:DI 0 "register_operand" "+r")
+        (plus:DI (match_dup 0)
+                 (mult:DI (sign_extend:DI (match_operand:HI 1 "register_operand" "%r"))
+                          (sign_extend:DI (match_operand:HI 2 "register_operand" "r")))))]
+  "!TARGET_NO_MUL_INSNS && TARGET_DSP"
+  "machh.d\t%0, %1:b, %2:b"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none")
+   (set_attr "type" "mulwh")])
+
+(define_insn "satadd_w"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (ss_plus:SI (match_operand:SI 1 "register_operand" "r")
+                    (match_operand:SI 2 "register_operand" "r")))]
+  "TARGET_DSP"
+  "satadd.w\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none")
+   (set_attr "type" "alu_sat")])
+
+(define_insn "satsub_w"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (ss_minus:SI (match_operand:SI 1 "register_operand" "r")
+                     (match_operand:SI 2 "register_operand" "r")))]
+  "TARGET_DSP"
+  "satsub.w\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none")
+   (set_attr "type" "alu_sat")])
+
+(define_insn "satadd_h"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (ss_plus:HI (match_operand:HI 1 "register_operand" "r")
+                    (match_operand:HI 2 "register_operand" "r")))]
+  "TARGET_DSP"
+  "satadd.h\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none")
+   (set_attr "type" "alu_sat")])
+
+(define_insn "satsub_h"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (ss_minus:HI (match_operand:HI 1 "register_operand" "r")
+                     (match_operand:HI 2 "register_operand" "r")))]
+  "TARGET_DSP"
+  "satsub.h\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none")
+   (set_attr "type" "alu_sat")])
+
+
+;;=============================================================================
+;; smin
+;;-----------------------------------------------------------------------------
+;; Set reg0 to the smallest value of reg1 and reg2. It is used for signed
+;; values in the registers.
+;;=============================================================================
+(define_insn "sminsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(smin:SI (match_operand:SI 1 "register_operand" "r")
+		 (match_operand:SI 2 "register_operand" "r")))]
+  ""
+  "min     %0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none")])
+
+;;=============================================================================
+;; smax
+;;-----------------------------------------------------------------------------
+;; Set reg0 to the largest value of reg1 and reg2. It is used for signed
+;; values in the registers.
+;;=============================================================================
+(define_insn "smaxsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(smax:SI (match_operand:SI 1 "register_operand" "r")
+		 (match_operand:SI 2 "register_operand" "r")))]
+  ""
+  "max     %0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "cc" "none")])
+
+
+
+;;=============================================================================
+;; Logical operations
+;;-----------------------------------------------------------------------------
+
+
+;; Split up simple DImode logical operations.  Simply perform the logical
+;; operation on the upper and lower halves of the registers.
+(define_split
+  [(set (match_operand:DI 0 "register_operand" "")
+	(match_operator:DI 6 "logical_binary_operator"
+	  [(match_operand:DI 1 "register_operand" "")
+	   (match_operand:DI 2 "register_operand" "")]))]
+  "reload_completed"
+  [(set (match_dup 0) (match_op_dup:SI 6 [(match_dup 1) (match_dup 2)]))
+   (set (match_dup 3) (match_op_dup:SI 6 [(match_dup 4) (match_dup 5)]))]
+  "
+  {
+    operands[3] = gen_highpart (SImode, operands[0]);
+    operands[0] = gen_lowpart (SImode, operands[0]);
+    operands[4] = gen_highpart (SImode, operands[1]);
+    operands[1] = gen_lowpart (SImode, operands[1]);
+    operands[5] = gen_highpart (SImode, operands[2]);
+    operands[2] = gen_lowpart (SImode, operands[2]);
+  }"
+)
+
+;;=============================================================================
+;; Logical operations with shifted operand
+;;=============================================================================
+(define_insn "<code>si_lshift"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (logical:SI (match_operator:SI 4 "logical_shift_operator"
+                                       [(match_operand:SI 2 "register_operand" "r")
+                                        (match_operand:SI 3 "immediate_operand" "Ku05")])
+                    (match_operand:SI 1 "register_operand" "r")))]
+  ""
+  {
+   if ( GET_CODE(operands[4]) == ASHIFT )
+      return "<logical_insn>\t%0, %1, %2 << %3";
+   else
+      return "<logical_insn>\t%0, %1, %2 >> %3";
+      }
+
+  [(set_attr "cc" "set_z")]
+)
+
+
+;;************************************************
+;; Peepholes for detecting logical operantions
+;; with shifted operands
+;;************************************************
+
+(define_peephole
+  [(set (match_operand:SI 3 "register_operand" "")
+        (match_operator:SI 5 "logical_shift_operator"
+                           [(match_operand:SI 1 "register_operand" "")
+                            (match_operand:SI 2 "immediate_operand" "")]))
+   (set (match_operand:SI 0 "register_operand" "")
+        (logical:SI (match_operand:SI 4 "register_operand" "")
+                    (match_dup 3)))]
+  "(dead_or_set_p(insn, operands[3])) || (REGNO(operands[3]) == REGNO(operands[0]))"
+  {
+   if ( GET_CODE(operands[5]) == ASHIFT )
+      return "<logical_insn>\t%0, %4, %1 << %2";
+   else
+      return "<logical_insn>\t%0, %4, %1 >> %2";
+  }
+  [(set_attr "cc" "set_z")]
+  )
+
+(define_peephole
+  [(set (match_operand:SI 3 "register_operand" "")
+        (match_operator:SI 5 "logical_shift_operator"
+                           [(match_operand:SI 1 "register_operand" "")
+                            (match_operand:SI 2 "immediate_operand" "")]))
+   (set (match_operand:SI 0 "register_operand" "")
+        (logical:SI (match_dup 3)
+                    (match_operand:SI 4 "register_operand" "")))]
+  "(dead_or_set_p(insn, operands[3])) || (REGNO(operands[3]) == REGNO(operands[0]))"
+  {
+   if ( GET_CODE(operands[5]) == ASHIFT )
+      return "<logical_insn>\t%0, %4, %1 << %2";
+   else
+      return "<logical_insn>\t%0, %4, %1 >> %2";
+  }
+  [(set_attr "cc" "set_z")]
+  )
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (match_operator:SI 5 "logical_shift_operator"
+                           [(match_operand:SI 1 "register_operand" "")
+                            (match_operand:SI 2 "immediate_operand" "")]))
+   (set (match_operand:SI 3 "register_operand" "")
+        (logical:SI (match_operand:SI 4 "register_operand" "")
+                    (match_dup 0)))]
+  "(peep2_reg_dead_p(2, operands[0])) || (REGNO(operands[3]) == REGNO(operands[0]))"
+
+  [(set (match_dup 3)
+        (logical:SI  (match_op_dup:SI 5 [(match_dup 1) (match_dup 2)])
+                     (match_dup 4)))]
+
+  ""
+)
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (match_operator:SI 5 "logical_shift_operator"
+                           [(match_operand:SI 1 "register_operand" "")
+                            (match_operand:SI 2 "immediate_operand" "")]))
+   (set (match_operand:SI 3 "register_operand" "")
+        (logical:SI (match_dup 0)
+                    (match_operand:SI 4 "register_operand" "")))]
+  "(peep2_reg_dead_p(2, operands[0])) || (REGNO(operands[3]) == REGNO(operands[0]))"
+
+  [(set (match_dup 3)
+        (logical:SI (match_op_dup:SI 5 [(match_dup 1) (match_dup 2)])
+                    (match_dup 4)))]
+
+  ""
+)
+
+
+;;=============================================================================
+;; and
+;;-----------------------------------------------------------------------------
+;; Store the result after a bitwise logical-and between reg0 and reg2 in reg0.
+;;=============================================================================
+
+(define_insn "andnsi"
+  [(set (match_operand:SI 0 "register_operand" "+r")
+        (and:SI (match_dup 0)
+                (not:SI (match_operand:SI 1 "register_operand" "r"))))]
+  ""
+  "andn    %0, %1"
+  [(set_attr "cc" "set_z")
+   (set_attr "length" "2")]
+)
+
+
+(define_insn "andsi3"
+   [(set (match_operand:SI 0 "avr32_rmw_memory_or_register_operand"          "=Y,r,r,r,   r,   r,r,r,r,r")
+ 	(and:SI (match_operand:SI 1 "avr32_rmw_memory_or_register_operand"  "%0,r,0,0,   0,   0,0,0,0,r" )
+ 		(match_operand:SI 2 "nonmemory_operand"                     " N,M,N,Ku16,Ks17,J,L,r,i,r")))]
+  ""
+   "@
+    memc\t%0, %z2
+    bfextu\t%0, %1, 0, %z2
+    cbr\t%0, %z2
+    andl\t%0, %2, COH
+    andl\t%0, lo(%2)
+    andh\t%0, hi(%2), COH
+    andh\t%0, hi(%2)
+    and\t%0, %2
+    andh\t%0, hi(%2)\;andl\t%0, lo(%2)
+    and\t%0, %1, %2"
+
+   [(set_attr "length" "4,4,2,4,4,4,4,2,8,4")
+    (set_attr "cc" "none,set_z,set_z,set_z,set_z,set_z,set_z,set_z,set_z,set_z")])
+
+  
+
+(define_insn "anddi3"
+  [(set (match_operand:DI 0 "register_operand" "=&r,&r")
+	(and:DI (match_operand:DI 1 "register_operand" "%0,r")
+                (match_operand:DI 2 "register_operand" "r,r")))]
+  ""
+  "#"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")]
+)
+
+;;=============================================================================
+;; or
+;;-----------------------------------------------------------------------------
+;; Store the result after a bitwise inclusive-or between reg0 and reg2 in reg0.
+;;=============================================================================
+
+(define_insn "iorsi3"
+  [(set (match_operand:SI 0 "avr32_rmw_memory_or_register_operand"          "=Y,r,r,   r,r,r,r")
+	(ior:SI (match_operand:SI 1 "avr32_rmw_memory_or_register_operand"  "%0,0,0,   0,0,0,r" )
+		(match_operand:SI 2 "nonmemory_operand"                     " O,O,Ku16,J,r,i,r")))]
+  ""
+  "@
+   mems\t%0, %p2
+   sbr\t%0, %p2
+   orl\t%0, %2
+   orh\t%0, hi(%2)
+   or\t%0, %2
+   orh\t%0, hi(%2)\;orl\t%0, lo(%2)
+   or\t%0, %1, %2"
+
+  [(set_attr "length" "4,2,4,4,2,8,4")
+   (set_attr "cc" "none,set_z,set_z,set_z,set_z,set_z,set_z")])
+
+
+(define_insn "iordi3"
+  [(set (match_operand:DI 0 "register_operand" "=&r,&r")
+	(ior:DI (match_operand:DI 1 "register_operand" "%0,r")
+                (match_operand:DI 2 "register_operand" "r,r")))]
+  ""
+  "#"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")]
+)
+
+;;=============================================================================
+;; xor bytes
+;;-----------------------------------------------------------------------------
+;; Store the result after a bitwise exclusive-or between reg0 and reg2 in reg0.
+;;=============================================================================
+
+(define_insn "xorsi3"
+   [(set (match_operand:SI 0 "avr32_rmw_memory_or_register_operand"          "=Y,r,   r,r,r,r")
+ 	(xor:SI (match_operand:SI 1 "avr32_rmw_memory_or_register_operand"  "%0,0,   0,0,0,r" )
+ 		(match_operand:SI 2 "nonmemory_operand"                     " O,Ku16,J,r,i,r")))]
+  ""
+   "@
+    memt\t%0, %p2
+    eorl\t%0, %2
+    eorh\t%0, hi(%2)
+    eor\t%0, %2
+    eorh\t%0, hi(%2)\;eorl\t%0, lo(%2)
+    eor\t%0, %1, %2"
+
+   [(set_attr "length" "4,4,4,2,8,4")
+    (set_attr "cc" "none,set_z,set_z,set_z,set_z,set_z")])
+
+(define_insn "xordi3"
+  [(set (match_operand:DI 0 "register_operand" "=&r,&r")
+	(xor:DI (match_operand:DI 1 "register_operand" "%0,r")
+                (match_operand:DI 2 "register_operand" "r,r")))]
+  ""
+  "#"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")]
+)
+
+;;=============================================================================
+;; Three operand predicable insns
+;;=============================================================================
+
+(define_insn "<predicable_insn3><mode>_predicable"
+  [(set (match_operand:INTM 0 "register_operand" "=r")
+	(predicable_op3:INTM (match_operand:INTM 1 "register_operand" "<predicable_commutative3>r")
+                             (match_operand:INTM 2 "register_operand" "r")))]
+  "TARGET_V2_INSNS"
+  "<predicable_insn3>%?\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "cc" "cmp_cond_insn")
+   (set_attr "predicable" "yes")]
+)
+
+(define_insn_and_split "<predicable_insn3><mode>_imm_clobber_predicable"
+  [(parallel 
+    [(set (match_operand:INTM 0 "register_operand" "=r")
+          (predicable_op3:INTM (match_operand:INTM 1 "register_operand" "<predicable_commutative3>r")
+                               (match_operand:INTM 2 "avr32_mov_immediate_operand" "JKs21")))
+     (clobber (match_operand:INTM 3 "register_operand" "=&r"))])]
+  "TARGET_V2_INSNS"
+  {
+   if ( current_insn_predicate != NULL_RTX ) 
+      {
+       if ( avr32_const_ok_for_constraint_p (INTVAL (operands[2]), 'K', "Ks08") )
+          return "%! mov%?\t%3, %2\;<predicable_insn3>%?\t%0, %1, %3";
+       else if ( avr32_const_ok_for_constraint_p (INTVAL (operands[2]), 'K', "Ks21") )
+          return "%! mov\t%3, %2\;<predicable_insn3>%?\t%0, %1, %3";
+       else
+          return "%! movh\t%3, hi(%2)\;<predicable_insn3>%?\t%0, %1, %3";
+       }
+   else
+      {
+       if ( !avr32_cond_imm_clobber_splittable (insn, operands) )
+          {
+                if ( avr32_const_ok_for_constraint_p (INTVAL (operands[2]), 'K', "Ks08") )
+                   return "mov%?\t%3, %2\;<predicable_insn3>%?\t%0, %1, %3";
+                else if ( avr32_const_ok_for_constraint_p (INTVAL (operands[2]), 'K', "Ks21") )
+                   return "mov\t%3, %2\;<predicable_insn3>%?\t%0, %1, %3";
+                else
+                   return "movh\t%3, hi(%2)\;<predicable_insn3>%?\t%0, %1, %3";
+          }
+       return "#";
+      }
+      
+  }
+  ;; If we find out that we could not actually do if-conversion on the block
+  ;; containing this insn we convert it back to normal immediate format
+  ;; to avoid outputing a redundant move insn
+  ;; Do not split until after we have checked if we can make the insn 
+  ;; conditional.
+  "(GET_CODE (PATTERN (insn)) != COND_EXEC
+    && cfun->machine->ifcvt_after_reload
+    && avr32_cond_imm_clobber_splittable (insn, operands))"
+  [(set (match_dup 0)
+        (predicable_op3:INTM (match_dup 1)
+                             (match_dup 2)))]
+  ""
+  [(set_attr "length" "8")
+   (set_attr "cc" "cmp_cond_insn")
+   (set_attr "predicable" "yes")]
+  )
+
+
+;;=============================================================================
+;; Zero extend predicable insns
+;;=============================================================================
+(define_insn_and_split "zero_extendhisi_clobber_predicable"
+  [(parallel 
+    [(set (match_operand:SI 0 "register_operand" "=r")
+          (zero_extend:SI (match_operand:HI 1 "register_operand" "r")))
+     (clobber (match_operand:SI 2 "register_operand" "=&r"))])]
+  "TARGET_V2_INSNS"
+  {
+   if ( current_insn_predicate != NULL_RTX ) 
+      {
+         return "%! mov\t%2, 0xffff\;and%?\t%0, %1, %2";
+       }
+   else
+      {
+       return "#";
+      }
+      
+  }
+  ;; If we find out that we could not actually do if-conversion on the block
+  ;; containing this insn we convert it back to normal immediate format
+  ;; to avoid outputing a redundant move insn
+  ;; Do not split until after we have checked if we can make the insn 
+  ;; conditional.
+  "(GET_CODE (PATTERN (insn)) != COND_EXEC
+    && cfun->machine->ifcvt_after_reload)"
+  [(set (match_dup 0)
+        (zero_extend:SI (match_dup 1)))]
+  ""
+  [(set_attr "length" "8")
+   (set_attr "cc" "cmp_cond_insn")
+   (set_attr "predicable" "yes")]
+  )
+
+(define_insn_and_split "zero_extendqisi_clobber_predicable"
+  [(parallel 
+    [(set (match_operand:SI 0 "register_operand" "=r")
+          (zero_extend:SI (match_operand:QI 1 "register_operand" "r")))
+     (clobber (match_operand:SI 2 "register_operand" "=&r"))])]
+  "TARGET_V2_INSNS"
+  {
+   if ( current_insn_predicate != NULL_RTX ) 
+      {
+         return "%! mov\t%2, 0xff\;and%?\t%0, %1, %2";
+       }
+   else
+      {
+       return "#";
+      }
+      
+  }
+  ;; If we find out that we could not actually do if-conversion on the block
+  ;; containing this insn we convert it back to normal immediate format
+  ;; to avoid outputing a redundant move insn
+  ;; Do not split until after we have checked if we can make the insn 
+  ;; conditional.
+  "(GET_CODE (PATTERN (insn)) != COND_EXEC
+    && cfun->machine->ifcvt_after_reload)"
+  [(set (match_dup 0)
+        (zero_extend:SI (match_dup 1)))]
+  ""
+  [(set_attr "length" "8")
+   (set_attr "cc" "cmp_cond_insn")
+   (set_attr "predicable" "yes")]
+  )
+
+(define_insn_and_split "zero_extendqihi_clobber_predicable"
+  [(parallel 
+    [(set (match_operand:HI 0 "register_operand" "=r")
+          (zero_extend:HI (match_operand:QI 1 "register_operand" "r")))
+     (clobber (match_operand:SI 2 "register_operand" "=&r"))])]
+  "TARGET_V2_INSNS"
+  {
+   if ( current_insn_predicate != NULL_RTX ) 
+      {
+         return "%! mov\t%2, 0xff\;and%?\t%0, %1, %2";
+       }
+   else
+      {
+       return "#";
+      }
+      
+  }
+  ;; If we find out that we could not actually do if-conversion on the block
+  ;; containing this insn we convert it back to normal immediate format
+  ;; to avoid outputing a redundant move insn
+  ;; Do not split until after we have checked if we can make the insn 
+  ;; conditional.
+  "(GET_CODE (PATTERN (insn)) != COND_EXEC
+    && cfun->machine->ifcvt_after_reload)"
+  [(set (match_dup 0)
+        (zero_extend:HI (match_dup 1)))]
+  ""
+  [(set_attr "length" "8")
+   (set_attr "cc" "cmp_cond_insn")
+   (set_attr "predicable" "yes")]
+  )
+;;=============================================================================
+;; divmod
+;;-----------------------------------------------------------------------------
+;; Signed division that produces both a quotient and a remainder.
+;;=============================================================================
+
+(define_expand "divmodsi4"
+  [(parallel [
+     (parallel [
+       (set (match_operand:SI 0 "register_operand" "=r")
+	    (div:SI (match_operand:SI 1 "register_operand" "r")
+		    (match_operand:SI 2 "register_operand" "r")))
+       (set (match_operand:SI 3 "register_operand" "=r")
+	    (mod:SI (match_dup 1)
+		    (match_dup 2)))])
+     (use (match_dup 4))])]
+  ""
+  {
+    if (can_create_pseudo_p ()) {
+      operands[4] = gen_reg_rtx (DImode);
+      emit_insn(gen_divmodsi4_internal(operands[4],operands[1],operands[2]));
+      emit_move_insn(operands[0], gen_rtx_SUBREG( SImode, operands[4], 4));
+      emit_move_insn(operands[3], gen_rtx_SUBREG( SImode, operands[4], 0));
+      DONE;
+    } else {
+      FAIL;
+    }
+  })
+
+
+(define_insn "divmodsi4_internal"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(unspec:DI [(match_operand:SI 1 "register_operand" "r")
+		    (match_operand:SI 2 "register_operand" "r")]
+		   UNSPEC_DIVMODSI4_INTERNAL))]
+  ""
+  "divs    %0, %1, %2"
+  [(set_attr "type" "div")
+   (set_attr "cc" "none")])
+
+
+;;=============================================================================
+;; udivmod
+;;-----------------------------------------------------------------------------
+;; Unsigned division that produces both a quotient and a remainder.
+;;=============================================================================
+(define_expand "udivmodsi4"
+ [(parallel [
+    (parallel [
+      (set (match_operand:SI 0 "register_operand" "=r")
+	   (udiv:SI (match_operand:SI 1 "register_operand" "r")
+		    (match_operand:SI 2 "register_operand" "r")))
+      (set (match_operand:SI 3 "register_operand" "=r")
+	   (umod:SI (match_dup 1)
+		    (match_dup 2)))])
+    (use (match_dup 4))])]
+  ""
+  {
+    if (can_create_pseudo_p ()) {
+      operands[4] = gen_reg_rtx (DImode);
+
+      emit_insn(gen_udivmodsi4_internal(operands[4],operands[1],operands[2]));
+      emit_move_insn(operands[0], gen_rtx_SUBREG( SImode, operands[4], 4));
+      emit_move_insn(operands[3], gen_rtx_SUBREG( SImode, operands[4], 0));
+
+      DONE;
+    } else {
+      FAIL;
+    }
+  })
+
+(define_insn "udivmodsi4_internal"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(unspec:DI [(match_operand:SI 1 "register_operand" "r")
+		    (match_operand:SI 2 "register_operand" "r")]
+		   UNSPEC_UDIVMODSI4_INTERNAL))]
+  ""
+  "divu    %0, %1, %2"
+  [(set_attr "type" "div")
+   (set_attr "cc" "none")])
+
+
+;;=============================================================================
+;; Arithmetic-shift left
+;;-----------------------------------------------------------------------------
+;; Arithmetic-shift reg0 left by reg2 or immediate value.
+;;=============================================================================
+
+(define_insn "ashlsi3"
+  [(set (match_operand:SI 0 "register_operand"                      "=r,r,r")
+	(ashift:SI (match_operand:SI 1 "register_operand"           "r,0,r")
+		   (match_operand:SI 2 "register_const_int_operand" "r,Ku05,Ku05")))]
+  ""
+  "@
+   lsl     %0, %1, %2
+   lsl     %0, %2
+   lsl     %0, %1, %2"
+  [(set_attr "length" "4,2,4")
+   (set_attr "cc" "set_ncz")])
+
+;;=============================================================================
+;; Arithmetic-shift right
+;;-----------------------------------------------------------------------------
+;; Arithmetic-shift reg0 right by an immediate value.
+;;=============================================================================
+
+(define_insn "ashrsi3"
+  [(set (match_operand:SI 0 "register_operand"                        "=r,r,r")
+	(ashiftrt:SI (match_operand:SI 1 "register_operand"           "r,0,r")
+		     (match_operand:SI 2 "register_const_int_operand" "r,Ku05,Ku05")))]
+  ""
+  "@
+   asr     %0, %1, %2
+   asr     %0, %2
+   asr     %0, %1, %2"
+  [(set_attr "length" "4,2,4")
+   (set_attr "cc" "set_ncz")])
+
+;;=============================================================================
+;; Logical shift right
+;;-----------------------------------------------------------------------------
+;; Logical shift reg0 right by an immediate value.
+;;=============================================================================
+
+(define_insn "lshrsi3"
+  [(set (match_operand:SI 0 "register_operand"                        "=r,r,r")
+	(lshiftrt:SI (match_operand:SI 1 "register_operand"           "r,0,r")
+		     (match_operand:SI 2 "register_const_int_operand" "r,Ku05,Ku05")))]
+  ""
+  "@
+   lsr     %0, %1, %2
+   lsr     %0, %2
+   lsr     %0, %1, %2"
+  [(set_attr "length" "4,2,4")
+   (set_attr "cc" "set_ncz")])
+
+
+;;=============================================================================
+;; neg
+;;-----------------------------------------------------------------------------
+;; Negate operand 1 and store the result in operand 0.
+;;=============================================================================
+(define_insn "negsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(neg:SI (match_operand:SI 1 "register_operand" "0,r")))]
+  ""
+  "@
+   neg\t%0
+   rsub\t%0, %1, 0"
+  [(set_attr "length" "2,4")
+   (set_attr "cc" "set_vncz")])
+
+(define_insn "negsi2_predicable"
+  [(set (match_operand:SI 0 "register_operand" "+r")
+	(neg:SI (match_dup 0)))]
+  "TARGET_V2_INSNS"
+  "rsub%?\t%0, 0"
+  [(set_attr "length" "4")
+   (set_attr "cc" "cmp_cond_insn")
+   (set_attr "predicable" "yes")])
+
+;;=============================================================================
+;; abs
+;;-----------------------------------------------------------------------------
+;; Store the absolute value of operand 1 into operand 0.
+;;=============================================================================
+(define_insn "abssi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(abs:SI (match_operand:SI 1 "register_operand" "0")))]
+  ""
+  "abs\t%0"
+  [(set_attr "length" "2")
+   (set_attr "cc" "set_z")])
+
+
+;;=============================================================================
+;; one_cmpl
+;;-----------------------------------------------------------------------------
+;; Store the bitwise-complement of operand 1 into operand 0.
+;;=============================================================================
+
+(define_insn "one_cmplsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(not:SI (match_operand:SI 1 "register_operand" "0,r")))]
+  ""
+  "@
+   com\t%0
+   rsub\t%0, %1, -1"
+  [(set_attr "length" "2,4")
+   (set_attr "cc" "set_z")])
+
+
+(define_insn "one_cmplsi2_predicable"
+  [(set (match_operand:SI 0 "register_operand" "+r")
+	(not:SI (match_dup 0)))]
+  "TARGET_V2_INSNS"
+  "rsub%?\t%0, -1"
+  [(set_attr "length" "4")
+   (set_attr "cc" "cmp_cond_insn")
+   (set_attr "predicable" "yes")])
+
+
+;;=============================================================================
+;; Bit load
+;;-----------------------------------------------------------------------------
+;; Load a bit into Z and C flags
+;;=============================================================================
+(define_insn "bldsi"
+  [(set (cc0)
+        (and:SI (match_operand:SI 0 "register_operand" "r")
+                (match_operand:SI 1 "one_bit_set_operand" "i")))]
+  ""
+  "bld\t%0, %p1"
+  [(set_attr "length" "4")
+   (set_attr "cc" "bld")]
+  )
+
+
+;;=============================================================================
+;; Compare
+;;-----------------------------------------------------------------------------
+;; Compare reg0 with reg1 or an immediate value.
+;;=============================================================================
+
+(define_expand "cmp<mode>"
+  [(set (cc0)
+	(compare:CMP
+	 (match_operand:CMP 0 "register_operand" "")
+	 (match_operand:CMP 1 "<CMP:cmp_predicate>"  "")))]
+  ""
+  "{
+   avr32_compare_op0 = operands[0];
+   avr32_compare_op1 = operands[1];
+  }"
+)
+
+(define_insn "cmp<mode>_internal"
+  [(set (cc0)
+        (compare:CMP
+         (match_operand:CMP 0 "register_operand" "r")
+         (match_operand:CMP 1 "<CMP:cmp_predicate>" "<CMP:cmp_constraint>")))]
+  ""
+  {
+switch(GET_MODE(operands[0]))
+  {
+  case QImode:
+	avr32_branch_type = CMP_QI;
+	break;
+  case HImode:
+	avr32_branch_type = CMP_HI;
+	break;
+  case SImode:
+	avr32_branch_type = CMP_SI;
+	break;
+  case DImode:
+	avr32_branch_type = CMP_DI;
+	break;
+  default:
+	abort();
+  }
+   /* Check if the next insn already will output a compare. */
+   if (!next_insn_emits_cmp (insn))  
+     set_next_insn_cond(insn,
+                        avr32_output_cmp(get_next_insn_cond(insn), GET_MODE (operands[0]), operands[0], operands[1]));
+   return "";
+  }
+  [(set_attr "length" "4")
+   (set_attr "cc" "compare")])
+
+(define_expand "cmpsf"
+  [(set (cc0)
+	(compare:SF
+	 (match_operand:SF 0 "general_operand" "")
+	 (match_operand:SF 1 "general_operand"  "")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "{
+   if ( !REG_P(operands[0]) )
+     operands[0] = force_reg(SFmode, operands[0]);
+
+   if ( !REG_P(operands[1]) )
+     operands[1] = force_reg(SFmode, operands[1]);
+
+   avr32_compare_op0 = operands[0];
+   avr32_compare_op1 = operands[1];
+   emit_insn(gen_cmpsf_internal_uc3fp(operands[0], operands[1]));
+   DONE;
+  }"
+)
+
+;;;=============================================================================
+;; Test if zero
+;;-----------------------------------------------------------------------------
+;; Compare reg against zero and set the condition codes.
+;;=============================================================================
+
+
+(define_expand "tstsi"
+  [(set (cc0)
+	(match_operand:SI 0 "register_operand" ""))]
+  ""
+  {
+   avr32_compare_op0 = operands[0];
+   avr32_compare_op1 = const0_rtx;
+  }
+)
+
+(define_insn "tstsi_internal"
+  [(set (cc0)
+	(match_operand:SI 0 "register_operand" "r"))]
+  ""
+  {
+   /* Check if the next insn already will output a compare. */
+   if (!next_insn_emits_cmp (insn))  
+     set_next_insn_cond(insn,
+                        avr32_output_cmp(get_next_insn_cond(insn), SImode, operands[0], const0_rtx));
+
+   return "";
+  }
+  [(set_attr "length" "2")
+   (set_attr "cc" "compare")])
+
+
+(define_expand "tstdi"
+  [(set (cc0)
+	(match_operand:DI 0 "register_operand" ""))]
+  ""
+  {
+   avr32_compare_op0 = operands[0];
+   avr32_compare_op1 = const0_rtx;
+  }
+)
+
+(define_insn "tstdi_internal"
+  [(set (cc0)
+	(match_operand:DI 0 "register_operand" "r"))]
+  ""
+  {
+   /* Check if the next insn already will output a compare. */
+   if (!next_insn_emits_cmp (insn))  
+     set_next_insn_cond(insn,
+                        avr32_output_cmp(get_next_insn_cond(insn), DImode, operands[0], const0_rtx));
+   return "";
+  }
+  [(set_attr "length" "4")
+   (set_attr "type" "alu2")
+   (set_attr "cc" "compare")])
+
+
+
+;;=============================================================================
+;; Convert operands
+;;-----------------------------------------------------------------------------
+;;
+;;=============================================================================
+(define_insn "truncdisi2"
+  [(set (match_operand:SI 0 "general_operand" "")
+	(truncate:SI (match_operand:DI 1 "general_operand" "")))]
+  ""
+  "truncdisi2")
+
+;;=============================================================================
+;; Extend
+;;-----------------------------------------------------------------------------
+;;
+;;=============================================================================
+
+
+(define_insn "extendhisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
+	(sign_extend:SI (match_operand:HI 1 "nonimmediate_operand" "0,r,<RKu00>,m")))]
+  ""
+  {
+   switch ( which_alternative ){
+     case 0:
+       return    "casts.h\t%0";
+     case 1:
+       return    "bfexts\t%0, %1, 0, 16";
+     case 2:
+     case 3:
+       return    "ld.sh\t%0, %1";
+     default:
+       abort();
+   }
+  }
+  [(set_attr "length" "2,4,2,4")
+   (set_attr "cc" "set_ncz,set_ncz,none,none")
+   (set_attr "type" "alu,alu,load_rm,load_rm")])
+
+(define_insn "extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
+	(sign_extend:SI (match_operand:QI 1 "extendqi_operand" "0,r,RKu00,m")))]
+  ""
+  {
+   switch ( which_alternative ){
+     case 0:
+       return    "casts.b\t%0";
+     case 1:
+       return    "bfexts\t%0, %1, 0, 8";
+     case 2:
+     case 3:
+       return    "ld.sb\t%0, %1";
+     default:
+       abort();
+   }
+  }
+  [(set_attr "length" "2,4,2,4")
+   (set_attr "cc" "set_ncz,set_ncz,none,none")
+   (set_attr "type" "alu,alu,load_rm,load_rm")])
+
+(define_insn "extendqihi2"
+  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r")
+	(sign_extend:HI (match_operand:QI 1 "extendqi_operand" "0,r,RKu00,m")))]
+  ""
+  {
+   switch ( which_alternative ){
+     case 0:
+       return    "casts.b\t%0";
+     case 1:
+       return    "bfexts\t%0, %1, 0, 8";
+     case 2:
+     case 3:
+       return    "ld.sb\t%0, %1";
+     default:
+       abort();
+   }
+  }
+  [(set_attr "length" "2,4,2,4")
+   (set_attr "cc" "set_ncz,set_ncz,none,none")
+   (set_attr "type" "alu,alu,load_rm,load_rm")])
+
+
+;;=============================================================================
+;; Zero-extend
+;;-----------------------------------------------------------------------------
+;;
+;;=============================================================================
+
+(define_insn "zero_extendhisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
+	(zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "0,r,<RKu00>,m")))]
+  ""
+  {
+   switch ( which_alternative ){
+     case 0:
+       return    "castu.h\t%0";
+     case 1:
+       return    "bfextu\t%0, %1, 0, 16";
+     case 2:
+     case 3:
+       return    "ld.uh\t%0, %1";
+     default:
+       abort();
+   }
+  }
+
+  [(set_attr "length" "2,4,2,4")
+   (set_attr "cc" "set_ncz,set_ncz,none,none")
+   (set_attr "type" "alu,alu,load_rm,load_rm")])
+
+(define_insn "zero_extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
+	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "0,r,<RKu00>,m")))]
+  ""
+  {
+   switch ( which_alternative ){
+     case 0:
+       return    "castu.b\t%0";
+     case 1:
+       return    "bfextu\t%0, %1, 0, 8";
+     case 2:
+     case 3:
+       return    "ld.ub\t%0, %1";
+     default:
+       abort();
+   }
+  }
+  [(set_attr "length" "2,4,2,4")
+   (set_attr "cc" "set_ncz, set_ncz, none, none")
+   (set_attr "type" "alu, alu, load_rm, load_rm")])
+
+(define_insn "zero_extendqihi2"
+  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r")
+	(zero_extend:HI (match_operand:QI 1 "nonimmediate_operand" "0,r,<RKu00>,m")))]
+  ""
+  {
+   switch ( which_alternative ){
+     case 0:
+       return    "castu.b\t%0";
+     case 1:
+       return    "bfextu\t%0, %1, 0, 8";
+     case 2:
+     case 3:
+       return    "ld.ub\t%0, %1";
+     default:
+       abort();
+   }
+  }
+  [(set_attr "length" "2,4,2,4")
+   (set_attr "cc" "set_ncz, set_ncz, none, none")
+   (set_attr "type" "alu, alu, load_rm, load_rm")])
+
+
+;;=============================================================================
+;; Conditional load and extend insns
+;;=============================================================================
+(define_insn "ldsi<mode>_predicable_se"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (sign_extend:SI 
+         (match_operand:INTM 1 "memory_operand" "<INTM:pred_mem_constraint>")))]
+  "TARGET_V2_INSNS"
+  "ld<INTM:load_postfix_s>%?\t%0, %1"
+  [(set_attr "length" "4")
+   (set_attr "cc" "cmp_cond_insn")
+   (set_attr "type" "load")
+   (set_attr "predicable" "yes")]
+)
+
+(define_insn "ldsi<mode>_predicable_ze"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (zero_extend:SI 
+         (match_operand:INTM 1 "memory_operand" "<INTM:pred_mem_constraint>")))]
+  "TARGET_V2_INSNS"
+  "ld<INTM:load_postfix_u>%?\t%0, %1"
+  [(set_attr "length" "4")
+   (set_attr "cc" "cmp_cond_insn")
+   (set_attr "type" "load")
+   (set_attr "predicable" "yes")]
+)
+
+(define_insn "ldhi_predicable_ze"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (zero_extend:HI 
+         (match_operand:QI 1 "memory_operand" "RKs10")))]
+  "TARGET_V2_INSNS"
+  "ld.ub%?\t%0, %1"
+  [(set_attr "length" "4")
+   (set_attr "cc" "cmp_cond_insn")
+   (set_attr "type" "load")
+   (set_attr "predicable" "yes")]
+)
+
+(define_insn "ldhi_predicable_se"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (sign_extend:HI 
+         (match_operand:QI 1 "memory_operand" "RKs10")))]
+  "TARGET_V2_INSNS"
+  "ld.sb%?\t%0, %1"
+  [(set_attr "length" "4")
+   (set_attr "cc" "cmp_cond_insn")
+   (set_attr "type" "load")
+   (set_attr "predicable" "yes")]
+)
+
+;;=============================================================================
+;; Conditional set register
+;; sr{cond4}  rd
+;;-----------------------------------------------------------------------------
+
+;;Because of the same issue as with conditional moves and adds we must
+;;not separate the compare instrcution from the scc instruction as
+;;they might be sheduled "badly".
+
+(define_expand "s<code>"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(any_cond:SI (cc0)
+                     (const_int 0)))]
+""
+{
+  if(TARGET_HARD_FLOAT && TARGET_ARCH_FPU)
+    FAIL;
+})
+
+(define_insn "*s<code>"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(any_cond:SI (cc0)
+                     (const_int 0)))]
+  ""
+{
+    return "sr<cond>\t%0";
+}
+[(set_attr "length" "2")
+(set_attr "cc" "none")])
+
+(define_insn "seq"
+[(set (match_operand:SI 0 "register_operand" "=r")
+(eq:SI (cc0)
+				 (const_int 0)))]
+  ""
+"sreq\t%0"
+[(set_attr "length" "2")
+(set_attr "cc" "none")])
+
+(define_insn "sne"
+[(set (match_operand:SI 0 "register_operand" "=r")
+(ne:SI (cc0)
+				 (const_int 0)))]
+  ""
+"srne\t%0"
+  [(set_attr "length" "2")
+   (set_attr "cc" "none")])
+
+(define_insn "smi"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(cc0)
+                    (const_int 0)] UNSPEC_COND_MI))]
+  ""
+  "srmi\t%0"
+  [(set_attr "length" "2")
+   (set_attr "cc" "none")])
+
+(define_insn "spl"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(cc0)
+                    (const_int 0)] UNSPEC_COND_PL))]
+  ""
+  "srpl\t%0"
+  [(set_attr "length" "2")
+   (set_attr "cc" "none")])
+
+
+;;=============================================================================
+;; Conditional branch
+;;-----------------------------------------------------------------------------
+;; Branch to label if the specified condition codes are set.
+;;=============================================================================
+; branch if negative
+(define_insn "bmi"
+  [(set (pc)
+	(if_then_else (unspec:CC [(cc0) (const_int 0)] UNSPEC_COND_MI)
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "brmi    %0"
+  [(set_attr "type" "branch")
+   (set (attr "length")
+	(cond [(and (le (minus (match_dup 0) (pc)) (const_int 254))
+		    (le (minus (pc) (match_dup 0)) (const_int 256)))
+	       (const_int 2)] ; use compact branch
+              (const_int 4))) ; use extended branch
+   (set_attr "cc" "none")])
+
+(define_insn "*bmi-reverse"
+  [(set (pc)
+	(if_then_else (unspec:CC [(cc0) (const_int 0)] UNSPEC_COND_MI)
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  "brpl    %0"
+  [(set_attr "type" "branch")
+   (set (attr "length")
+	(cond [(and (le (minus (match_dup 0) (pc)) (const_int 254))
+		    (le (minus (pc) (match_dup 0)) (const_int 256)))
+	       (const_int 2)] ; use compact branch
+              (const_int 4))) ; use extended branch
+   (set_attr "cc" "none")])
+
+; branch if positive
+(define_insn "bpl"
+  [(set (pc)
+	(if_then_else (unspec:CC [(cc0) (const_int 0)] UNSPEC_COND_PL)
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "brpl    %0"
+  [(set_attr "type" "branch")
+   (set (attr "length")
+	(cond [(and (le (minus (match_dup 0) (pc)) (const_int 254))
+		    (le (minus (pc) (match_dup 0)) (const_int 256)))
+	       (const_int 2)] ; use compact branch
+              (const_int 4))) ; use extended branch
+   (set_attr "cc" "none")])
+
+(define_insn "*bpl-reverse"
+  [(set (pc)
+	(if_then_else (unspec:CC [(cc0) (const_int 0)] UNSPEC_COND_PL)
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  "brmi    %0"
+  [(set_attr "type" "branch")
+   (set (attr "length")
+	(cond [(and (le (minus (match_dup 0) (pc)) (const_int 254))
+		    (le (minus (pc) (match_dup 0)) (const_int 256)))
+	       (const_int 2)] ; use compact branch
+              (const_int 4))) ; use extended branch
+   (set_attr "cc" "none")])
+
+; branch if equal
+(define_insn "b<code>"
+  [(set (pc)
+	(if_then_else (any_cond_b:CC (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+    if (TARGET_HARD_FLOAT && TARGET_ARCH_FPU && (avr32_branch_type == CMP_SF))
+       return get_attr_length(insn) == 6 ? "brvs .+6\;br<cond> %0" : "brvs .+8\;br<cond> %0";
+    else
+       return "br<cond> %0";
+  }
+  [(set_attr "type" "branch")
+   (set (attr "length")
+	(if_then_else (eq (const_int 1)(symbol_ref "TARGET_HARD_FLOAT && TARGET_ARCH_FPU"))
+		      (if_then_else 
+			   (and (le (minus (match_dup 0) (pc)) (const_int 254))
+		    (le (minus (pc) (match_dup 0)) (const_int 256)))
+		                 (const_int 6)
+		                 (const_int 8))
+		      (if_then_else 
+			   (and (le (minus (match_dup 0) (pc)) (const_int 254))
+		    (le (minus (pc) (match_dup 0)) (const_int 256)))
+				    (const_int 2)
+				    (const_int 4))))
+   (set_attr "cc" "none")])
+
+(define_insn "beq"
+  [(set (pc)
+	(if_then_else (eq:CC (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "breq %0";
+  [(set_attr "type" "branch")
+   (set (attr "length")
+	(cond [(and (le (minus (match_dup 0) (pc)) (const_int 254))
+		    (le (minus (pc) (match_dup 0)) (const_int 256)))
+	       (const_int 2)] ; use compact branch
+              (const_int 4))) ; use extended branch
+   (set_attr "cc" "none")])
+
+(define_insn "bne"
+  [(set (pc)
+	(if_then_else (ne:CC (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "brne %0";
+  [(set_attr "type" "branch")
+   (set (attr "length")
+	(cond [(and (le (minus (match_dup 0) (pc)) (const_int 254))
+		    (le (minus (pc) (match_dup 0)) (const_int 256)))
+	       (const_int 2)] ; use compact branch
+              (const_int 4))) ; use extended branch
+   (set_attr "cc" "none")])
+
+(define_insn "b<code>"
+  [(set (pc)
+	(if_then_else (any_cond4:CC (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  {
+	if(TARGET_HARD_FLOAT && TARGET_ARCH_FPU && (avr32_branch_type == CMP_SF))
+		return "brvs .+8\;br<cond> %l0";
+	else
+		return "br<cond> %l0";
+  }
+  [(set_attr "type" "branch")
+   (set (attr "length") 
+    (cond [(eq (const_int 1)(symbol_ref "TARGET_HARD_FLOAT && TARGET_ARCH_FPU"))
+		       (const_int 8)]
+               (const_int 4)))
+   (set_attr "cc" "none")])
+
+(define_insn "*b<code>-reverse"
+  [(set (pc)
+	(if_then_else (any_cond_b:CC (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    if (TARGET_HARD_FLOAT && TARGET_ARCH_FPU && (avr32_branch_type == CMP_SF))
+       return "brvs %0\;br<invcond> %0";
+    else
+       return "br<invcond> %0";
+  }
+  [(set_attr "type" "branch")
+   (set (attr "length")
+	(if_then_else (eq (const_int 1)(symbol_ref "TARGET_HARD_FLOAT && TARGET_ARCH_FPU"))
+		      (if_then_else 
+			   (and (le (minus (match_dup 0) (pc)) (const_int 254))
+		    (le (minus (pc) (match_dup 0)) (const_int 256)))
+		                 (const_int 6)
+		                 (const_int 8))
+		      (if_then_else 
+			   (and (le (minus (match_dup 0) (pc)) (const_int 254))
+		    (le (minus (pc) (match_dup 0)) (const_int 256)))
+				    (const_int 2)
+				    (const_int 4))))
+   (set_attr "cc" "none")])
+
+(define_insn "*beq-reverse"
+  [(set (pc)
+	(if_then_else (eq:CC (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  "brne %0";
+  [(set_attr "type" "branch")
+   (set (attr "length")
+	(cond [(and (le (minus (match_dup 0) (pc)) (const_int 254))
+		    (le (minus (pc) (match_dup 0)) (const_int 256)))
+	       (const_int 2)] ; use compact branch
+              (const_int 4))) ; use extended branch
+   (set_attr "cc" "none")])
+
+(define_insn "*bne-reverse"
+  [(set (pc)
+	(if_then_else (ne:CC (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  "breq %0";
+  [(set_attr "type" "branch")
+   (set (attr "length")
+	(cond [(and (le (minus (match_dup 0) (pc)) (const_int 254))
+		    (le (minus (pc) (match_dup 0)) (const_int 256)))
+	       (const_int 2)] ; use compact branch
+              (const_int 4))) ; use extended branch
+   (set_attr "cc" "none")])
+
+(define_insn "*b<code>-reverse"
+  [(set (pc)
+	(if_then_else (any_cond4:CC (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  {
+    if (TARGET_HARD_FLOAT && TARGET_ARCH_FPU && (avr32_branch_type == CMP_SF))
+       return "brvs %l0\;br<invcond> %l0";
+    else
+       return "br<invcond> %0";
+  }
+  [(set_attr "type" "branch")
+   (set (attr "length") 
+    (cond [(eq (const_int 1)(symbol_ref "TARGET_HARD_FLOAT && TARGET_ARCH_FPU"))
+		       (const_int 8)]
+               (const_int 4)))
+   (set_attr "cc" "none")])
+
+;=============================================================================
+; Conditional Add/Subtract
+;-----------------------------------------------------------------------------
+; sub{cond4}  Rd, imm
+;=============================================================================
+
+
+(define_expand "add<mode>cc"
+  [(set (match_operand:ADDCC 0 "register_operand" "")
+        (if_then_else:ADDCC (match_operator 1 "avr32_comparison_operator" 
+                                            [(match_dup 4)
+                                             (match_dup 5)])
+                            (match_operand:ADDCC 2 "register_operand" "")
+                            (plus:ADDCC 
+                             (match_dup 2)
+                             (match_operand:ADDCC 3 "" ""))))]
+  ""
+  {
+   if ( !(GET_CODE (operands[3]) == CONST_INT
+          || (TARGET_V2_INSNS && REG_P(operands[3]))) ){
+      FAIL;
+   }
+
+   /* Delete compare instruction as it is merged into this instruction */
+   remove_insn (get_last_insn_anywhere ());
+
+   operands[4] = avr32_compare_op0;
+   operands[5] = avr32_compare_op1;
+   
+   if ( TARGET_V2_INSNS 
+        && REG_P(operands[3]) 
+        && REGNO(operands[0]) != REGNO(operands[2]) ){
+       emit_move_insn (operands[0], operands[2]);
+       operands[2] = operands[0];
+   }
+  }
+  )
+
+(define_insn "add<ADDCC:mode>cc_cmp<CMP:mode>_reg"
+  [(set (match_operand:ADDCC 0 "register_operand" "=r")
+        (if_then_else:ADDCC (match_operator 1 "avr32_comparison_operator" 
+                                            [(match_operand:CMP 4 "register_operand" "r")
+                                             (match_operand:CMP 5 "<CMP:cmp_predicate>" "<CMP:cmp_constraint>")])
+                            (match_dup 0)
+                            (plus:ADDCC 
+                             (match_operand:ADDCC 2 "register_operand" "r")
+                             (match_operand:ADDCC 3 "register_operand" "r"))))]
+  "TARGET_V2_INSNS"
+  {
+   operands[1] = avr32_output_cmp(operands[1], GET_MODE(operands[4]), operands[4], operands[5]);
+   return "add%i1\t%0, %2, %3";
+  }
+  [(set_attr "length" "8")
+   (set_attr "cc" "cmp_cond_insn")])
+
+(define_insn "add<ADDCC:mode>cc_cmp<CMP:mode>"
+  [(set (match_operand:ADDCC 0 "register_operand" "=r")
+        (if_then_else:ADDCC (match_operator 1 "avr32_comparison_operator" 
+                                            [(match_operand:CMP 4 "register_operand" "r")
+                                             (match_operand:CMP 5 "<CMP:cmp_predicate>" "<CMP:cmp_constraint>")])
+                            (match_operand:ADDCC 2 "register_operand" "0")
+                            (plus:ADDCC 
+                             (match_dup 2)
+                             (match_operand:ADDCC 3 "avr32_cond_immediate_operand" "Is08"))))]
+  ""
+  {
+   operands[1] = avr32_output_cmp(operands[1], GET_MODE(operands[4]), operands[4], operands[5]);
+   return "sub%i1\t%0, -%3";
+  }
+  [(set_attr "length" "8")
+   (set_attr "cc" "cmp_cond_insn")])
+
+;=============================================================================
+; Conditional Move
+;-----------------------------------------------------------------------------
+; mov{cond4}  Rd, (Rs/imm)
+;=============================================================================
+(define_expand "mov<mode>cc"
+  [(set (match_operand:MOVCC 0 "register_operand" "")
+        (if_then_else:MOVCC (match_operator 1 "avr32_comparison_operator" 
+                                            [(match_dup 4)
+                                             (match_dup 5)])
+                            (match_operand:MOVCC 2 "avr32_cond_register_immediate_operand" "")
+                            (match_operand:MOVCC 3 "avr32_cond_register_immediate_operand" "")))]
+  ""
+  {
+   /* Delete compare instruction as it is merged into this instruction */
+   remove_insn (get_last_insn_anywhere ());
+
+   operands[4] = avr32_compare_op0;
+   operands[5] = avr32_compare_op1;
+  }
+  )
+
+
+(define_insn "mov<MOVCC:mode>cc_cmp<CMP:mode>"
+  [(set (match_operand:MOVCC 0 "register_operand" "=r,r,r")
+        (if_then_else:MOVCC (match_operator 1 "avr32_comparison_operator" 
+                                            [(match_operand:CMP 4 "register_operand" "r,r,r")
+                                             (match_operand:CMP 5 "<CMP:cmp_predicate>" "<CMP:cmp_constraint>,<CMP:cmp_constraint>,<CMP:cmp_constraint>")])
+                            (match_operand:MOVCC 2 "avr32_cond_register_immediate_operand" "0, rKs08,rKs08")
+                            (match_operand:MOVCC 3 "avr32_cond_register_immediate_operand" "rKs08,0,rKs08")))]
+  ""
+  {
+   operands[1] = avr32_output_cmp(operands[1], GET_MODE(operands[4]), operands[4], operands[5]);
+           
+   switch( which_alternative ){
+    case 0:
+      return "mov%i1    %0, %3";
+    case 1:
+      return "mov%1    %0, %2";
+    case 2:
+      return "mov%1    %0, %2\;mov%i1    %0, %3";
+    default:
+      abort();
+    }
+
+  }
+  [(set_attr "length" "8,8,12")
+   (set_attr "cc" "cmp_cond_insn")])
+
+  
+
+
+;;=============================================================================
+;; jump
+;;-----------------------------------------------------------------------------
+;; Jump inside a function; an unconditional branch to a label.
+;;=============================================================================
+(define_insn "jump"
+  [(set (pc)
+	(label_ref (match_operand 0 "" "")))]
+  ""
+  {
+    if (get_attr_length(insn) > 4)
+      return "Can't jump this far";
+    return (get_attr_length(insn) == 2 ?
+	    "rjmp    %0" : "bral    %0");
+  }
+  [(set_attr "type" "branch")
+   (set (attr "length")
+	(cond [(and (le (minus (match_dup 0) (pc)) (const_int 1022))
+		    (le (minus (pc) (match_dup 0)) (const_int 1024)))
+	       (const_int 2) ; use rjmp
+	       (le (match_dup 0) (const_int 1048575))
+	       (const_int 4)] ; use bral
+	      (const_int 8))) ; do something else
+   (set_attr "cc" "none")])
+
+;;=============================================================================
+;; call
+;;-----------------------------------------------------------------------------
+;; Subroutine call instruction returning no value.
+;;=============================================================================
+(define_insn "call_internal"
+  [(parallel [(call (mem:SI (match_operand:SI 0 "avr32_call_operand" "r,U,T,W"))
+                    (match_operand 1 "" ""))
+              (clobber (reg:SI LR_REGNUM))])]
+  ""
+  {
+
+    /* Check for a flashvault call. */
+    if (avr32_flashvault_call (SYMBOL_REF_DECL (operands[0])))
+      {
+        /* Assembly is already emitted. */
+        return "";
+      }
+
+    switch (which_alternative) {
+      case 0:
+        return "icall\t%0";
+      case 1:
+        return "rcall\t%0";
+      case 2:
+        return "mcall\t%0";
+      case 3:
+        if (TARGET_HAS_ASM_ADDR_PSEUDOS)
+          return "call\t%0";
+        else
+          return "mcall\tr6[%0@got]";
+      default:
+        abort();
+    }
+  }
+  [(set_attr "type" "call")
+   (set_attr "length" "2,4,4,10")
+   (set_attr "cc" "clobber")])
+
+
+(define_expand "call"
+  [(parallel [(call (match_operand:SI 0 "" "")
+                    (match_operand 1 "" ""))
+              (clobber (reg:SI LR_REGNUM))])]
+  ""
+  {
+    rtx call_address;
+    if ( GET_CODE(operands[0]) != MEM )
+      FAIL;
+
+    call_address = XEXP(operands[0], 0);
+
+   /* If assembler supports call pseudo insn and the call address is a symbol then nothing special needs to be done. */
+    if (TARGET_HAS_ASM_ADDR_PSEUDOS && (GET_CODE(call_address) == SYMBOL_REF) )
+    {
+       /* We must however mark the function as using the GOT if flag_pic is set, since the call insn might turn into a mcall using the GOT ptr register. */
+       if (flag_pic)
+       {
+          crtl->uses_pic_offset_table = 1;
+          emit_call_insn(gen_call_internal(call_address, operands[1]));
+          DONE;
+       }
+    } 
+    else 
+    {
+      if (flag_pic && GET_CODE(call_address) == SYMBOL_REF )
+      {
+        crtl->uses_pic_offset_table = 1;
+        emit_call_insn(gen_call_internal(call_address, operands[1]));
+        DONE;
+      }
+
+      if (!SYMBOL_REF_RCALL_FUNCTION_P(operands[0]) )
+      {
+        if (optimize_size && GET_CODE(call_address) == SYMBOL_REF )
+        {
+          call_address = force_const_mem(SImode, call_address);
+        } 
+        else 
+        {
+          call_address = force_reg(SImode, call_address);
+        }
+      }
+    }
+    emit_call_insn(gen_call_internal(call_address, operands[1]));
+    DONE;
+
+  }
+)
+
+;;=============================================================================
+;; call_value
+;;-----------------------------------------------------------------------------
+;; Subroutine call instruction returning a value.
+;;=============================================================================
+(define_expand "call_value"
+   [(parallel [(set (match_operand:SI 0 "" "")
+                    (call (match_operand:SI 1 "" "")
+                          (match_operand 2 "" "")))
+               (clobber (reg:SI LR_REGNUM))])]
+   ""
+   {
+    rtx call_address;
+    if ( GET_CODE(operands[1]) != MEM )
+      FAIL;
+
+    call_address = XEXP(operands[1], 0);
+
+   /* Check for a flashvault call. 
+   if (GET_CODE (call_address) == SYMBOL_REF 
+       && avr32_flashvault_call (SYMBOL_REF_DECL (call_address)))
+     DONE;  
+     
+    */ 
+
+    /* If assembler supports call pseudo insn and the call
+       address is a symbol then nothing special needs to be done. */
+    if ( TARGET_HAS_ASM_ADDR_PSEUDOS
+         && (GET_CODE(call_address) == SYMBOL_REF) ){
+       /* We must however mark the function as using the GOT if
+          flag_pic is set, since the call insn might turn into
+          a mcall using the GOT ptr register. */
+       if ( flag_pic ) {
+          crtl->uses_pic_offset_table = 1;
+          emit_call_insn(gen_call_value_internal(operands[0], call_address, operands[2]));
+          DONE;
+       }
+    } else {
+      if ( flag_pic &&
+           GET_CODE(call_address) == SYMBOL_REF ){
+        crtl->uses_pic_offset_table = 1;
+        emit_call_insn(gen_call_value_internal(operands[0], call_address, operands[2]));
+        DONE;
+      }
+
+      if ( !SYMBOL_REF_RCALL_FUNCTION_P(operands[1]) ){
+        if ( optimize_size &&
+             GET_CODE(call_address) == SYMBOL_REF){
+          call_address = force_const_mem(SImode, call_address);
+        } else {
+          call_address = force_reg(SImode, call_address);
+        }
+      }
+    }
+    emit_call_insn(gen_call_value_internal(operands[0], call_address,
+                                           operands[2]));
+    DONE;
+
+   })
+
+(define_insn "call_value_internal"
+  [(parallel [(set (match_operand 0 "register_operand" "=r,r,r,r")
+                   (call (mem:SI (match_operand:SI 1 "avr32_call_operand" "r,U,T,W"))
+                         (match_operand 2 "" "")))
+              (clobber (reg:SI LR_REGNUM))])]
+  ;; Operand 2 not used on the AVR32.
+  ""
+  {
+    /* Check for a flashvault call. */
+    if (avr32_flashvault_call (SYMBOL_REF_DECL (operands[1])))
+      {
+        /* Assembly is already emitted. */
+        return "";
+      }
+
+
+    switch (which_alternative) {
+      case 0:
+        return "icall\t%1";
+      case 1:
+        return "rcall\t%1";
+      case 2:
+        return "mcall\t%1";
+      case 3:
+        if ( TARGET_HAS_ASM_ADDR_PSEUDOS )
+          return "call\t%1";
+        else
+          return "mcall\tr6[%1@got]";
+      default:
+        abort();
+    }
+  }
+  [(set_attr "type" "call")
+   (set_attr "length" "2,4,4,10")
+   (set_attr "cc" "call_set")])
+
+
+;;=============================================================================
+;; untyped_call
+;;-----------------------------------------------------------------------------
+;; Subrutine call instruction returning a value of any type.
+;; The code is copied from m68k.md (except gen_blockage is removed)
+;; Fixme!
+;;=============================================================================
+(define_expand "untyped_call"
+  [(parallel [(call (match_operand 0 "avr32_call_operand" "")
+		    (const_int 0))
+	      (match_operand 1 "" "")
+	      (match_operand 2 "" "")])]
+  ""
+  {
+    int i;
+
+    emit_call_insn (GEN_CALL (operands[0], const0_rtx, NULL, const0_rtx));
+
+    for (i = 0; i < XVECLEN (operands[2], 0); i++) {
+      rtx set = XVECEXP (operands[2], 0, i);
+      emit_move_insn (SET_DEST (set), SET_SRC (set));
+    }
+
+    /* The optimizer does not know that the call sets the function value
+       registers we stored in the result block.  We avoid problems by
+       claiming that all hard registers are used and clobbered at this
+       point.  */
+    emit_insn (gen_blockage ());
+
+    DONE;
+  })
+
+
+;;=============================================================================
+;; return
+;;=============================================================================
+
+(define_insn "return"
+  [(return)]
+  "USE_RETURN_INSN (FALSE)"
+  {
+   avr32_output_return_instruction(TRUE, FALSE, NULL, NULL);
+   return "";
+  }
+  [(set_attr "length" "4")
+   (set_attr "type" "call")]
+  )
+
+
+(define_insn "return_cond"
+  [(set (pc) 
+        (if_then_else (match_operand 0 "avr32_comparison_operand" "")
+                      (return)
+                      (pc)))]
+  "USE_RETURN_INSN (TRUE)"
+  "ret%0\tr12";
+  [(set_attr "type" "call")])
+  
+(define_insn "return_cond_predicable"
+  [(return)]
+  "USE_RETURN_INSN (TRUE)"
+  "ret%?\tr12";
+  [(set_attr "type" "call")
+   (set_attr "predicable" "yes")])
+
+
+(define_insn "return_imm"
+  [(parallel [(set (reg RETVAL_REGNUM) (match_operand 0 "immediate_operand" "i"))
+              (use (reg RETVAL_REGNUM))
+              (return)])]
+  "USE_RETURN_INSN (FALSE) &&
+   ((INTVAL(operands[0]) == -1) || (INTVAL(operands[0]) == 0) || (INTVAL(operands[0]) == 1))"
+  {
+   avr32_output_return_instruction(TRUE, FALSE, NULL, operands[0]);
+   return "";
+  }
+  [(set_attr "length" "4")
+   (set_attr "type" "call")]
+  )
+
+(define_insn "return_imm_cond"
+  [(parallel [(set (reg RETVAL_REGNUM) (match_operand 0 "immediate_operand" "i"))
+              (use (reg RETVAL_REGNUM))
+              (set (pc) 
+                   (if_then_else (match_operand 1 "avr32_comparison_operand" "")
+                                 (return)
+                                 (pc)))])]
+  "USE_RETURN_INSN (TRUE) &&
+   ((INTVAL(operands[0]) == -1) || (INTVAL(operands[0]) == 0) || (INTVAL(operands[0]) == 1))"
+  "ret%1\t%0";
+  [(set_attr "type" "call")]
+  )
+
+(define_insn "return_imm_predicable"
+  [(parallel [(set (reg RETVAL_REGNUM) (match_operand 0 "immediate_operand" "i"))
+              (use (reg RETVAL_REGNUM))
+              (return)])]
+  "USE_RETURN_INSN (TRUE) &&
+   ((INTVAL(operands[0]) == -1) || (INTVAL(operands[0]) == 0) || (INTVAL(operands[0]) == 1))"
+  "ret%?\t%0";
+  [(set_attr "type" "call")
+   (set_attr "predicable" "yes")])
+
+(define_insn "return_<mode>reg"
+  [(set (reg RETVAL_REGNUM) (match_operand:MOVM 0 "register_operand" "r"))
+   (use (reg RETVAL_REGNUM))
+   (return)]
+  "USE_RETURN_INSN (TRUE)"
+  "ret%?\t%0";
+  [(set_attr "type" "call")
+   (set_attr "predicable" "yes")])
+
+(define_insn "return_<mode>reg_cond"
+  [(set (reg RETVAL_REGNUM) (match_operand:MOVM 0 "register_operand" "r"))
+   (use (reg RETVAL_REGNUM))
+   (set (pc) 
+        (if_then_else (match_operator 1 "avr32_comparison_operator"
+                                      [(cc0) (const_int 0)])
+                      (return)
+                      (pc)))]
+  "USE_RETURN_INSN (TRUE)"
+  "ret%1\t%0";
+  [(set_attr "type" "call")])
+  
+;;=============================================================================
+;; nonlocal_goto_receiver
+;;-----------------------------------------------------------------------------
+;; For targets with a return stack we must make sure to flush the return stack
+;; since it will be corrupt after a nonlocal goto.
+;;=============================================================================
+(define_expand "nonlocal_goto_receiver"
+  [(const_int 0)]
+  "TARGET_RETURN_STACK"
+  "
+   {
+    emit_insn ( gen_frs() );
+    DONE;
+   }
+  "
+  )
+
+
+;;=============================================================================
+;; builtin_setjmp_receiver
+;;-----------------------------------------------------------------------------
+;; For pic code we need to reload the pic register.
+;; For targets with a return stack we must make sure to flush the return stack
+;; since it will probably be corrupted.
+;;=============================================================================
+(define_expand "builtin_setjmp_receiver"
+  [(label_ref (match_operand 0 "" ""))]
+  "flag_pic"
+  "
+   {
+    if ( TARGET_RETURN_STACK ) 
+     emit_insn ( gen_frs() );
+
+    avr32_load_pic_register ();
+    DONE;
+   }
+  "
+)
+
+
+;;=============================================================================
+;; indirect_jump
+;;-----------------------------------------------------------------------------
+;; Jump to an address in reg or memory.
+;;=============================================================================
+(define_expand "indirect_jump"
+  [(set (pc)
+	(match_operand:SI 0 "general_operand" ""))]
+  ""
+  {
+    /* One of the ops has to be in a register.  */
+    if ( (flag_pic || TARGET_HAS_ASM_ADDR_PSEUDOS )
+         && !avr32_legitimate_pic_operand_p(operands[0]) )
+      operands[0] = legitimize_pic_address (operands[0], SImode, 0);
+    else if ( flag_pic && avr32_address_operand(operands[0], GET_MODE(operands[0])) )
+      /* If we have an address operand then this function uses the pic register. */
+      crtl->uses_pic_offset_table = 1;
+  })
+
+
+(define_insn "indirect_jump_internal"
+  [(set (pc)
+	(match_operand:SI 0 "avr32_non_rmw_general_operand" "r,m,W"))]
+  ""
+  {
+    switch( which_alternative ){
+      case 0:
+        return "mov\tpc, %0";
+      case 1:
+        if ( avr32_const_pool_ref_operand(operands[0], GET_MODE(operands[0])) )
+          return "lddpc\tpc, %0";
+        else
+          return "ld.w\tpc, %0";
+      case 2:
+        if ( flag_pic )
+          return "ld.w\tpc, r6[%0@got]";
+        else
+          return "lda.w\tpc, %0";
+      default:
+	abort();
+    }
+   }
+  [(set_attr "length" "2,4,8")
+   (set_attr "type" "call,call,call")
+   (set_attr "cc" "none,none,clobber")])
+
+
+
+;;=============================================================================
+;; casesi and tablejump
+;;=============================================================================
+(define_insn "tablejump_add"
+  [(set (pc)
+	(plus:SI (match_operand:SI 0 "register_operand" "r")
+                 (mult:SI (match_operand:SI 1 "register_operand" "r")
+                          (match_operand:SI 2 "immediate_operand" "Ku04" ))))
+   (use (label_ref (match_operand 3 "" "")))]
+  "flag_pic &&
+   ((INTVAL(operands[2]) == 0) || (INTVAL(operands[2]) == 2) ||
+    (INTVAL(operands[2]) == 4) || (INTVAL(operands[2]) == 8))"
+  "add\tpc, %0, %1 << %p2"
+  [(set_attr "length" "4")
+   (set_attr "cc" "clobber")])
+
+(define_insn "tablejump_insn"
+  [(set (pc) (match_operand:SI 0 "memory_operand" "m"))
+   (use (label_ref (match_operand 1 "" "")))]
+  "!flag_pic"
+  "ld.w\tpc, %0"
+  [(set_attr "length" "4")
+   (set_attr "type" "call")
+   (set_attr "cc" "none")])
+
+(define_expand "casesi"
+  [(match_operand:SI 0 "register_operand" "")	; index to jump on
+   (match_operand:SI 1 "const_int_operand" "")	; lower bound
+   (match_operand:SI 2 "const_int_operand" "")	; total range
+   (match_operand:SI 3 "" "")			; table label
+   (match_operand:SI 4 "" "")]			; Out of range label
+  ""
+  "
+  {
+    rtx reg;
+    rtx index = operands[0];
+    rtx low_bound = operands[1];
+    rtx range = operands[2];
+    rtx table_label = operands[3];
+    rtx oor_label = operands[4];
+
+    index = force_reg ( SImode, index );
+    if (low_bound != const0_rtx)
+      {
+        if (!avr32_const_ok_for_constraint_p(INTVAL (low_bound), 'I', \"Is21\")){
+          reg = force_reg(SImode, GEN_INT (INTVAL (low_bound)));
+	  emit_insn (gen_subsi3 (reg, index,
+			         reg));
+        } else {
+          reg = gen_reg_rtx (SImode);
+          emit_insn (gen_addsi3 (reg, index,
+		         	 GEN_INT (-INTVAL (low_bound))));
+        }
+	index = reg;
+      }
+
+    if (!avr32_const_ok_for_constraint_p (INTVAL (range), 'K', \"Ks21\"))
+      range = force_reg (SImode, range);
+
+    emit_cmp_and_jump_insns ( index, range, GTU, NULL_RTX, SImode, 1, oor_label );
+    reg = gen_reg_rtx (SImode);
+    emit_move_insn ( reg, gen_rtx_LABEL_REF (VOIDmode, table_label));
+
+    if ( flag_pic ) 
+       emit_jump_insn ( gen_tablejump_add ( reg, index, GEN_INT(4), table_label));
+    else
+       emit_jump_insn ( 
+           gen_tablejump_insn ( gen_rtx_MEM ( SImode, 
+                                              gen_rtx_PLUS ( SImode, 
+                                                             reg, 
+                                                             gen_rtx_MULT ( SImode, 
+                                                                            index, 
+                                                                            GEN_INT(4)))),
+                                table_label));
+    DONE;
+  }"
+)
+
+
+
+(define_insn "prefetch"
+  [(prefetch (match_operand:SI 0 "avr32_ks16_address_operand" "p")
+	     (match_operand 1 "const_int_operand" "")
+	     (match_operand 2 "const_int_operand" ""))]
+  ""
+  {
+     return "pref\t%0";
+  }
+
+  [(set_attr "length" "4")
+   (set_attr "type" "load")
+   (set_attr "cc" "none")])
+
+
+
+;;=============================================================================
+;; prologue
+;;-----------------------------------------------------------------------------
+;; This pattern, if defined, emits RTL for entry to a function. The function
+;; entry i responsible for setting up the stack frame, initializing the frame
+;; pointer register, saving callee saved registers, etc.
+;;=============================================================================
+(define_expand "prologue"
+  [(clobber (const_int 0))]
+  ""
+  "
+  avr32_expand_prologue();
+  DONE;
+  "
+  )
+
+;;=============================================================================
+;; eh_return
+;;-----------------------------------------------------------------------------
+;; This pattern, if defined, affects the way __builtin_eh_return, and
+;; thence the call frame exception handling library routines, are
+;; built. It is intended to handle non-trivial actions needed along
+;; the abnormal return path.
+;;
+;; The address of the exception handler to which the function should
+;; return is passed as operand to this pattern. It will normally need
+;; to copied by the pattern to some special register or memory
+;; location. If the pattern needs to determine the location of the
+;; target call frame in order to do so, it may use
+;; EH_RETURN_STACKADJ_RTX, if defined; it will have already been
+;; assigned.
+;;
+;; If this pattern is not defined, the default action will be to
+;; simply copy the return address to EH_RETURN_HANDLER_RTX. Either
+;; that macro or this pattern needs to be defined if call frame
+;; exception handling is to be used.
+
+;; We can't expand this before we know where the link register is stored.
+(define_insn_and_split "eh_return"
+  [(unspec_volatile [(match_operand:SI 0 "register_operand" "r")]
+		    VUNSPEC_EH_RETURN)
+   (clobber (match_scratch:SI 1 "=&r"))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "
+  {
+    avr32_set_return_address (operands[0], operands[1]);
+    DONE;
+  }"
+  )
+
+
+;;=============================================================================
+;; ffssi2
+;;-----------------------------------------------------------------------------
+(define_insn "ffssi2"
+  [ (set (match_operand:SI 0 "register_operand" "=r")
+         (ffs:SI (match_operand:SI 1 "register_operand" "r"))) ]
+  ""
+  "mov    %0, %1
+   brev   %0
+   clz    %0, %0
+   sub    %0, -1
+   cp     %0, 33
+   moveq  %0, 0"
+  [(set_attr "length" "18")
+   (set_attr "cc" "clobber")]
+  )
+
+
+
+;;=============================================================================
+;; swap_h
+;;-----------------------------------------------------------------------------
+(define_insn "*swap_h"
+  [ (set (match_operand:SI 0 "register_operand" "=r")
+         (ior:SI (ashift:SI (match_dup 0) (const_int 16))
+                 (lshiftrt:SI (match_dup 0) (const_int 16))))]
+  ""
+  "swap.h    %0"
+  [(set_attr "length" "2")]
+  )
+
+(define_insn_and_split "bswap_16"
+  [ (set (match_operand:HI 0 "avr32_bswap_operand" "=r,RKs13,r")
+         (ior:HI (and:HI (lshiftrt:HI (match_operand:HI 1 "avr32_bswap_operand" "r,r,RKs13")
+                                      (const_int 8))
+                         (const_int 255))
+                 (ashift:HI (and:HI (match_dup 1)
+                                    (const_int 255))
+                            (const_int 8))))]
+  ""
+  {
+   switch ( which_alternative ){
+     case 0:
+       if ( REGNO(operands[0]) == REGNO(operands[1]))
+         return "swap.bh\t%0";
+       else
+         return "mov\t%0, %1\;swap.bh\t%0";
+     case 1:
+       return "stswp.h\t%0, %1";
+     case 2:
+       return "ldswp.sh\t%0, %1";
+     default:
+       abort();
+     }
+  }
+
+  "(reload_completed &&
+     REG_P(operands[0]) && REG_P(operands[1])
+     && (REGNO(operands[0]) != REGNO(operands[1])))"
+  [(set (match_dup 0) (match_dup 1))
+   (set (match_dup 0)
+        (ior:HI (and:HI (lshiftrt:HI (match_dup 0)
+                                     (const_int 8))
+                        (const_int 255))
+                (ashift:HI (and:HI (match_dup 0)
+                                   (const_int 255))
+                           (const_int 8))))]
+  ""
+
+  [(set_attr "length" "4,4,4")
+   (set_attr "type" "alu,store,load_rm")]
+  )
+
+(define_insn_and_split "bswap_32"
+  [ (set (match_operand:SI 0 "avr32_bswap_operand" "=r,RKs14,r")
+         (ior:SI (ior:SI (lshiftrt:SI (and:SI (match_operand:SI 1 "avr32_bswap_operand" "r,r,RKs14")
+                                              (const_int -16777216))
+                                      (const_int 24))
+                         (lshiftrt:SI (and:SI (match_dup 1)
+                                              (const_int 16711680))
+                                      (const_int 8)))
+                 (ior:SI (ashift:SI (and:SI (match_dup 1)
+                                            (const_int 65280))
+                                    (const_int 8))
+                         (ashift:SI (and:SI (match_dup 1)
+                                            (const_int 255))
+                                    (const_int 24)))))]
+  ""
+  {
+    switch ( which_alternative ){
+     case 0:
+       if ( REGNO(operands[0]) == REGNO(operands[1]))
+         return "swap.b\t%0";
+       else
+         return "#";
+     case 1:
+       return "stswp.w\t%0, %1";
+     case 2:
+       return "ldswp.w\t%0, %1";
+     default:
+       abort();
+    }
+  }
+  "(reload_completed &&
+    REG_P(operands[0]) && REG_P(operands[1])
+    && (REGNO(operands[0]) != REGNO(operands[1])))"
+  [(set (match_dup 0) (match_dup 1))
+   (set (match_dup 0)
+        (ior:SI (ior:SI (lshiftrt:SI (and:SI (match_dup 0)
+                                             (const_int -16777216))
+                                     (const_int 24))
+                        (lshiftrt:SI (and:SI (match_dup 0)
+                                             (const_int 16711680))
+                                     (const_int 8)))
+                (ior:SI (ashift:SI (and:SI (match_dup 0)
+                                           (const_int 65280))
+                                   (const_int 8))
+                        (ashift:SI (and:SI (match_dup 0)
+                                           (const_int 255))
+                                   (const_int 24)))))]
+  ""
+
+  [(set_attr "length" "4,4,4")
+   (set_attr "type" "alu,store,load_rm")]
+  )
+
+
+;;=============================================================================
+;; blockage
+;;-----------------------------------------------------------------------------
+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and
+;; all of memory.  This blocks insns from being moved across this point.
+
+(define_insn "blockage"
+  [(unspec_volatile [(const_int 0)] VUNSPEC_BLOCKAGE)]
+  ""
+  ""
+  [(set_attr "length" "0")]
+)
+
+;;=============================================================================
+;; clzsi2
+;;-----------------------------------------------------------------------------
+(define_insn "clzsi2"
+  [ (set (match_operand:SI 0 "register_operand" "=r")
+         (clz:SI (match_operand:SI 1 "register_operand" "r"))) ]
+  ""
+  "clz    %0, %1"
+  [(set_attr "length" "4")
+   (set_attr "cc" "set_z")]
+  )
+
+;;=============================================================================
+;; ctzsi2
+;;-----------------------------------------------------------------------------
+(define_insn "ctzsi2"
+  [ (set (match_operand:SI 0 "register_operand" "=r,r")
+         (ctz:SI (match_operand:SI 1 "register_operand" "0,r"))) ]
+  ""
+  "@
+   brev\t%0\;clz\t%0, %0
+   mov\t%0, %1\;brev\t%0\;clz\t%0, %0"
+  [(set_attr "length" "8")
+   (set_attr "cc" "set_z")]
+  )
+
+;;=============================================================================
+;; cache instructions
+;;-----------------------------------------------------------------------------
+(define_insn "cache"
+  [ (unspec_volatile [(match_operand:SI 0 "avr32_ks11_address_operand" "p")
+                      (match_operand:SI 1 "immediate_operand" "Ku05")] VUNSPEC_CACHE)]
+  ""
+  "cache    %0, %1"
+  [(set_attr "length" "4")]
+  )
+
+(define_insn "sync"
+  [ (unspec_volatile [(match_operand:SI 0 "immediate_operand" "Ku08")] VUNSPEC_SYNC)]
+  ""
+  "sync    %0"
+  [(set_attr "length" "4")]
+  )
+
+;;=============================================================================
+;; TLB instructions
+;;-----------------------------------------------------------------------------
+(define_insn "tlbr"
+  [ (unspec_volatile [(const_int 0)] VUNSPEC_TLBR)]
+  ""
+  "tlbr"
+  [(set_attr "length" "2")]
+  )
+
+(define_insn "tlbw"
+  [ (unspec_volatile [(const_int 0)] VUNSPEC_TLBW)]
+  ""
+  "tlbw"
+  [(set_attr "length" "2")]
+  )
+
+(define_insn "tlbs"
+  [ (unspec_volatile [(const_int 0)] VUNSPEC_TLBS)]
+  ""
+  "tlbs"
+  [(set_attr "length" "2")]
+  )
+
+;;=============================================================================
+;; Breakpoint instruction
+;;-----------------------------------------------------------------------------
+(define_insn "breakpoint"
+  [ (unspec_volatile [(const_int 0)] VUNSPEC_BREAKPOINT)]
+  ""
+  "breakpoint"
+  [(set_attr "length" "2")]
+  )
+
+
+;;=============================================================================
+;; mtsr/mfsr instruction
+;;-----------------------------------------------------------------------------
+(define_insn "mtsr"
+  [ (unspec_volatile [(match_operand 0 "immediate_operand" "i")
+                      (match_operand:SI 1 "register_operand" "r")] VUNSPEC_MTSR)]
+  ""
+  "mtsr\t%0, %1"
+  [(set_attr "length" "4")]
+  )
+
+(define_insn "mfsr"
+  [ (set (match_operand:SI 0 "register_operand" "=r")
+         (unspec_volatile:SI [(match_operand 1 "immediate_operand" "i")] VUNSPEC_MFSR)) ]
+  ""
+  "mfsr\t%0, %1"
+  [(set_attr "length" "4")]
+  )
+
+;;=============================================================================
+;; mtdr/mfdr instruction
+;;-----------------------------------------------------------------------------
+(define_insn "mtdr"
+  [ (unspec_volatile [(match_operand 0 "immediate_operand" "i")
+                      (match_operand:SI 1 "register_operand" "r")] VUNSPEC_MTDR)]
+  ""
+  "mtdr\t%0, %1"
+  [(set_attr "length" "4")]
+  )
+
+(define_insn "mfdr"
+  [ (set (match_operand:SI 0 "register_operand" "=r")
+         (unspec_volatile:SI [(match_operand 1 "immediate_operand" "i")] VUNSPEC_MFDR)) ]
+  ""
+  "mfdr\t%0, %1"
+  [(set_attr "length" "4")]
+  )
+
+;;=============================================================================
+;; musfr
+;;-----------------------------------------------------------------------------
+(define_insn "musfr"
+  [ (unspec_volatile [(match_operand:SI 0 "register_operand" "r")] VUNSPEC_MUSFR)]
+  ""
+  "musfr\t%0"
+  [(set_attr "length" "2")
+   (set_attr "cc" "clobber")]
+  )
+
+(define_insn "mustr"
+  [ (set (match_operand:SI 0 "register_operand" "=r")
+         (unspec_volatile:SI [(const_int 0)] VUNSPEC_MUSTR)) ]
+  ""
+  "mustr\t%0"
+  [(set_attr "length" "2")]
+  )
+
+(define_insn "ssrf"
+  [ (unspec_volatile [(match_operand:SI 0 "immediate_operand" "Ku05")] VUNSPEC_SSRF)]
+  ""
+  "ssrf    %0"
+  [(set_attr "length" "2")
+   (set_attr "cc" "clobber")]
+  )
+
+(define_insn "csrf"
+  [ (unspec_volatile [(match_operand:SI 0 "immediate_operand" "Ku05")] VUNSPEC_CSRF)]
+  ""
+  "csrf    %0"
+  [(set_attr "length" "2")
+   (set_attr "cc" "clobber")]
+  )
+
+;;=============================================================================
+;; Flush Return Stack instruction
+;;-----------------------------------------------------------------------------
+(define_insn "frs"
+  [ (unspec_volatile [(const_int 0)] VUNSPEC_FRS)]
+  ""
+  "frs"
+  [(set_attr "length" "2")
+   (set_attr "cc" "none")]
+  )
+
+
+;;=============================================================================
+;; Saturation Round Scale instruction
+;;-----------------------------------------------------------------------------
+(define_insn "sats"
+  [ (set (match_operand:SI 0 "register_operand" "+r")
+         (unspec:SI [(match_dup 0)
+                     (match_operand 1 "immediate_operand" "Ku05")
+                     (match_operand 2 "immediate_operand" "Ku05")]
+                    UNSPEC_SATS)) ]
+  "TARGET_DSP"
+  "sats\t%0 >> %1, %2"
+  [(set_attr "type" "alu_sat")
+   (set_attr "length" "4")]
+  )
+
+(define_insn "satu"
+  [ (set (match_operand:SI 0 "register_operand" "+r")
+         (unspec:SI [(match_dup 0)
+                     (match_operand 1 "immediate_operand" "Ku05")
+                     (match_operand 2 "immediate_operand" "Ku05")]
+                    UNSPEC_SATU)) ]
+  "TARGET_DSP"
+  "satu\t%0 >> %1, %2"
+  [(set_attr "type" "alu_sat")
+   (set_attr "length" "4")]
+  )
+
+(define_insn "satrnds"
+  [ (set (match_operand:SI 0 "register_operand" "+r")
+         (unspec:SI [(match_dup 0)
+                     (match_operand 1 "immediate_operand" "Ku05")
+                     (match_operand 2 "immediate_operand" "Ku05")]
+                    UNSPEC_SATRNDS)) ]
+  "TARGET_DSP"
+  "satrnds\t%0 >> %1, %2"
+  [(set_attr "type" "alu_sat")
+   (set_attr "length" "4")]
+  )
+
+(define_insn "satrndu"
+  [ (set (match_operand:SI 0 "register_operand" "+r")
+         (unspec:SI [(match_dup 0)
+                     (match_operand 1 "immediate_operand" "Ku05")
+                     (match_operand 2 "immediate_operand" "Ku05")]
+                    UNSPEC_SATRNDU)) ]
+  "TARGET_DSP"
+  "sats\t%0 >> %1, %2"
+  [(set_attr "type" "alu_sat")
+   (set_attr "length" "4")]
+  )
+
+(define_insn "sleep"
+  [(unspec_volatile [(const_int 0)] VUNSPEC_SLEEP)
+  (match_operand:SI 0 "const_int_operand" "")]
+  ""
+  "sleep	%0"
+  [(set_attr "length" "1")
+   (set_attr "cc"  "none")
+  ])
+
+(define_expand "delay_cycles"
+  [(unspec_volatile [(match_operand:SI 0 "const_int_operand" "i")]
+                    VUNSPEC_DELAY_CYCLES)]
+  ""
+  "
+  unsigned int cycles = UINTVAL (operands[0]);
+  if (IN_RANGE(cycles,0x10000 ,0xFFFFFFFF))
+   {
+     unsigned int msb = (cycles & 0xFFFF0000);
+     unsigned int shift = 16;
+     msb = (msb >> shift);
+     unsigned int cycles_used = (msb*0x10000);
+     emit_insn (gen_delay_cycles_2 (gen_int_mode (msb, SImode)));
+     cycles -= cycles_used;
+   }
+  if (IN_RANGE(cycles, 4, 0xFFFF))
+   {
+     unsigned int loop_count = (cycles/ 4);
+     unsigned int cycles_used = (loop_count*4);
+     emit_insn (gen_delay_cycles_1 (gen_int_mode (loop_count, SImode)));
+     cycles -= cycles_used;
+   }
+  while (cycles >= 3)
+    {
+      emit_insn (gen_nop3 ());
+      cycles -= 3;
+    }
+  if (cycles == 1 || cycles == 2)
+    {
+      while (cycles--)
+        emit_insn (gen_nop ());
+    }
+  DONE;
+  ")
+
+(define_insn "delay_cycles_1"
+[(unspec_volatile [(const_int 0)] VUNSPEC_DELAY_CYCLES_1)
+  (match_operand:SI 0 "immediate_operand" "")
+  (clobber (match_scratch:SI 1 "=&r"))]
+  ""
+  "mov\t%1, %0
+    1:  sub\t%1, 1
+        brne\t1b
+        nop"
+)
+
+(define_insn "delay_cycles_2"
+[(unspec_volatile [(const_int 0)] VUNSPEC_DELAY_CYCLES_2)
+  (match_operand:SI 0 "immediate_operand" "")
+  (clobber (match_scratch:SI 1 "=&r"))
+  (clobber (match_scratch:SI 2 "=&r"))]
+  ""
+  "mov\t%1, %0
+    1:  mov\t%2, 16383 
+    2:  sub\t%2, 1	
+        brne\t2b
+        nop
+        sub\t%1, 1
+        brne\t1b
+        nop"
+)
+
+;; CPU instructions
+
+;;=============================================================================
+;; nop
+;;-----------------------------------------------------------------------------
+;; No-op instruction.
+;;=============================================================================
+(define_insn "nop"
+  [(unspec_volatile [(const_int 0)] VUNSPEC_NOP)]
+  ""
+  "nop"
+  [(set_attr "length" "1")
+   (set_attr "type" "alu")
+  (set_attr "cc" "none")])
+
+;; NOP3
+(define_insn "nop3"
+  [(unspec_volatile [(const_int 0)] VUNSPEC_NOP3)]
+  ""
+  "rjmp\t2"
+  [(set_attr "length" "3")
+   (set_attr "type" "alu")
+  (set_attr "cc" "none")])
+
+;; Special patterns for dealing with the constant pool
+
+(define_insn "align_4"
+  [(unspec_volatile [(const_int 0)] VUNSPEC_ALIGN)]
+  ""
+  {
+   assemble_align (32);
+   return "";
+  }
+  [(set_attr "length" "2")]
+)
+
+
+(define_insn "consttable_start"
+  [(unspec_volatile [(const_int 0)] VUNSPEC_POOL_START)]
+  ""
+  {
+   return ".cpool";
+  }
+  [(set_attr "length" "0")]
+  )
+
+(define_insn "consttable_end"
+  [(unspec_volatile [(const_int 0)] VUNSPEC_POOL_END)]
+  ""
+  {
+   making_const_table = FALSE;
+   return "";
+  }
+  [(set_attr "length" "0")]
+)
+
+
+(define_insn "consttable_4"
+  [(unspec_volatile [(match_operand 0 "" "")] VUNSPEC_POOL_4)]
+  ""
+  {
+    making_const_table = TRUE;
+    switch (GET_MODE_CLASS (GET_MODE (operands[0])))
+      {
+      case MODE_FLOAT:
+      {
+        REAL_VALUE_TYPE r;
+        char real_string[1024];
+        REAL_VALUE_FROM_CONST_DOUBLE (r, operands[0]);
+        real_to_decimal(real_string, &r, 1024, 0, 1);
+        asm_fprintf (asm_out_file, "\t.float\t%s\n", real_string);
+        break;
+      }
+      default:
+        assemble_integer (operands[0], 4, 0, 1);
+        break;
+      }
+    return "";
+  }
+  [(set_attr "length" "4")]
+)
+
+(define_insn "consttable_8"
+  [(unspec_volatile [(match_operand 0 "" "")] VUNSPEC_POOL_8)]
+  ""
+  {
+    making_const_table = TRUE;
+    switch (GET_MODE_CLASS (GET_MODE (operands[0])))
+      {
+       case MODE_FLOAT:
+        {
+         REAL_VALUE_TYPE r; 
+         char real_string[1024];
+         REAL_VALUE_FROM_CONST_DOUBLE (r, operands[0]);
+         real_to_decimal(real_string, &r, 1024, 0, 1);
+         asm_fprintf (asm_out_file, "\t.double\t%s\n", real_string);
+         break;
+        }
+       default:
+         assemble_integer(operands[0], 8, 0, 1);
+        break;
+     }
+    return "";
+  }
+  [(set_attr "length" "8")]
+)
+
+(define_insn "consttable_16"
+  [(unspec_volatile [(match_operand 0 "" "")] VUNSPEC_POOL_16)]
+  ""
+  {
+    making_const_table = TRUE;
+    assemble_integer(operands[0], 16, 0, 1);
+    return "";
+  }
+  [(set_attr "length" "16")]
+)
+
+;;=============================================================================
+;; coprocessor instructions
+;;-----------------------------------------------------------------------------
+(define_insn "cop"
+  [ (unspec_volatile [(match_operand 0 "immediate_operand" "Ku03")
+                      (match_operand 1 "immediate_operand" "Ku04")
+                      (match_operand 2 "immediate_operand" "Ku04")
+                      (match_operand 3 "immediate_operand" "Ku04")
+                      (match_operand 4 "immediate_operand" "Ku07")] VUNSPEC_COP)]
+  ""
+  "cop\tcp%0, cr%1, cr%2, cr%3, %4"
+  [(set_attr "length" "4")]
+  )
+
+(define_insn "mvcrsi"
+  [ (set (match_operand:SI 0 "avr32_cop_move_operand" "=r,<,Z")
+         (unspec_volatile:SI [(match_operand 1 "immediate_operand" "Ku03,Ku03,Ku03")
+                              (match_operand 2 "immediate_operand" "Ku04,Ku04,Ku04")]
+                             VUNSPEC_MVCR)) ]
+  ""
+  "@
+   mvcr.w\tcp%1, %0, cr%2
+   stcm.w\tcp%1, %0, cr%2
+   stc.w\tcp%1, %0, cr%2"
+  [(set_attr "length" "4")]
+  )
+
+(define_insn "mvcrdi"
+  [ (set (match_operand:DI 0 "avr32_cop_move_operand" "=r,<,Z")
+         (unspec_volatile:DI [(match_operand 1 "immediate_operand" "Ku03,Ku03,Ku03")
+                              (match_operand 2 "immediate_operand" "Ku04,Ku04,Ku04")]
+                             VUNSPEC_MVCR)) ]
+  ""
+  "@
+   mvcr.d\tcp%1, %0, cr%2
+   stcm.d\tcp%1, %0, cr%2-cr%i2
+   stc.d\tcp%1, %0, cr%2"
+  [(set_attr "length" "4")]
+  )
+
+(define_insn "mvrcsi"
+  [ (unspec_volatile:SI [(match_operand 0 "immediate_operand" "Ku03,Ku03,Ku03")
+                         (match_operand 1 "immediate_operand" "Ku04,Ku04,Ku04")
+                         (match_operand:SI 2 "avr32_cop_move_operand" "r,>,Z")]
+                        VUNSPEC_MVRC)]
+  ""
+  {
+   switch (which_alternative){
+    case 0:
+      return "mvrc.w\tcp%0, cr%1, %2";
+    case 1:
+      return "ldcm.w\tcp%0, %2, cr%1";
+    case 2:
+      return "ldc.w\tcp%0, cr%1, %2";
+    default:
+      abort();
+   }
+  }
+  [(set_attr "length" "4")]
+  )
+
+(define_insn "mvrcdi"
+  [ (unspec_volatile:DI [(match_operand 0 "immediate_operand" "Ku03,Ku03,Ku03")
+                         (match_operand 1 "immediate_operand" "Ku04,Ku04,Ku04")
+                         (match_operand:DI 2 "avr32_cop_move_operand" "r,>,Z")]
+                        VUNSPEC_MVRC)]
+  ""
+  {
+   switch (which_alternative){
+    case 0:
+      return "mvrc.d\tcp%0, cr%1, %2";
+    case 1:
+      return "ldcm.d\tcp%0, %2, cr%1-cr%i1";
+    case 2:
+      return "ldc.d\tcp%0, cr%1, %2";
+    default:
+      abort();
+   }
+  }
+  [(set_attr "length" "4")]
+  )
+
+;;=============================================================================
+;; epilogue
+;;-----------------------------------------------------------------------------
+;; This pattern emits RTL for exit from a function. The function exit is
+;; responsible for deallocating the stack frame, restoring callee saved
+;; registers and emitting the return instruction.
+;; ToDo: using TARGET_ASM_FUNCTION_PROLOGUE instead.
+;;=============================================================================
+(define_expand "epilogue"
+  [(unspec_volatile [(return)] VUNSPEC_EPILOGUE)]
+  ""
+  "
+  if (USE_RETURN_INSN (FALSE)){
+      emit_jump_insn (gen_return ());
+      DONE;
+  }
+  emit_jump_insn (gen_rtx_UNSPEC_VOLATILE (VOIDmode,
+	gen_rtvec (1,
+		gen_rtx_RETURN (VOIDmode)),
+	VUNSPEC_EPILOGUE));
+  DONE;
+  "
+  )
+
+(define_insn "*epilogue_insns"
+  [(unspec_volatile [(return)] VUNSPEC_EPILOGUE)]
+  ""
+  {
+    avr32_output_return_instruction (FALSE, FALSE, NULL, NULL);
+    return "";
+  }
+  ; Length is absolute worst case
+  [(set_attr "type" "branch")
+   (set_attr "length" "12")]
+  )
+
+(define_insn "*epilogue_insns_ret_imm"
+  [(parallel [(set (reg RETVAL_REGNUM) (match_operand 0 "immediate_operand" "i"))
+              (use (reg RETVAL_REGNUM))
+              (unspec_volatile [(return)] VUNSPEC_EPILOGUE)])]
+  "((INTVAL(operands[0]) == -1) || (INTVAL(operands[0]) == 0) || (INTVAL(operands[0]) == 1))"
+  {
+    avr32_output_return_instruction (FALSE, FALSE, NULL, operands[0]);
+    return "";
+  }
+  ; Length is absolute worst case
+  [(set_attr "type" "branch")
+   (set_attr "length" "12")]
+  )
+
+(define_insn "sibcall_epilogue"
+  [(unspec_volatile [(const_int 0)] VUNSPEC_EPILOGUE)]
+  ""
+  {
+   avr32_output_return_instruction (FALSE, FALSE,  NULL, NULL);
+   return "";
+  }
+;; Length is absolute worst case
+  [(set_attr "type" "branch")
+   (set_attr "length" "12")]
+  )
+
+(define_insn "*sibcall_epilogue_insns_ret_imm"
+  [(parallel [(set (reg RETVAL_REGNUM) (match_operand 0 "immediate_operand" "i"))
+              (use (reg RETVAL_REGNUM))
+              (unspec_volatile [(const_int 0)] VUNSPEC_EPILOGUE)])]
+  "((INTVAL(operands[0]) == -1) || (INTVAL(operands[0]) == 0) || (INTVAL(operands[0]) == 1))"
+  {
+    avr32_output_return_instruction (FALSE, FALSE, NULL, operands[0]);
+    return "";
+  }
+  ; Length is absolute worst case
+  [(set_attr "type" "branch")
+   (set_attr "length" "12")]
+  )
+
+(define_insn "ldxi"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(mem:SI (plus:SI
+                 (match_operand:SI 1 "register_operand" "r")
+                 (mult:SI (zero_extract:SI (match_operand:SI 2 "register_operand" "r")
+                                           (const_int 8)
+                                           (match_operand:SI 3 "immediate_operand" "Ku05"))
+                          (const_int 4)))))]
+  "(INTVAL(operands[3]) == 24 || INTVAL(operands[3]) == 16 || INTVAL(operands[3]) == 8
+   || INTVAL(operands[3]) == 0)"
+  {
+   switch ( INTVAL(operands[3]) ){
+    case 0:
+         return "ld.w    %0, %1[%2:b << 2]";
+    case 8:
+         return "ld.w    %0, %1[%2:l << 2]";
+    case 16:
+         return "ld.w    %0, %1[%2:u << 2]";
+    case 24:
+         return "ld.w    %0, %1[%2:t << 2]";
+    default:
+         internal_error("illegal operand for ldxi");
+   }
+  }
+  [(set_attr "type" "load")
+   (set_attr "length" "4")
+   (set_attr "cc" "none")])
+
+
+
+
+
+
+;;=============================================================================
+;; Peephole optimizing
+;;-----------------------------------------------------------------------------
+;; Changing
+;;   sub     r8, r7, 8
+;;   st.w    r8[0x0], r12
+;; to
+;;   sub     r8, r7, 8
+;;   st.w    r7[-0x8], r12
+;;=============================================================================
+; (set (reg:SI 9 r8)
+;      (plus:SI (reg/f:SI 6 r7)
+;               (const_int ...)))
+; (set (mem:SI (reg:SI 9 r8))
+;      (reg:SI 12 r12))
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(plus:SI (match_operand:SI 1 "register_operand" "")
+		 (match_operand:SI 2 "immediate_operand" "")))
+   (set (mem:SI (match_dup 0))
+	(match_operand:SI 3 "register_operand" ""))]
+  "REGNO(operands[0]) != REGNO(operands[1]) && avr32_const_ok_for_constraint_p(INTVAL(operands[2]), 'K', \"Ks16\")"
+  [(set (match_dup 0)
+	(plus:SI (match_dup 1)
+		 (match_dup 2)))
+   (set (mem:SI (plus:SI (match_dup 1)
+			 (match_dup 2)))
+	(match_dup 3))]
+  "")
+
+;;=============================================================================
+;; Peephole optimizing
+;;-----------------------------------------------------------------------------
+;; Changing
+;;   sub     r6, r7, 4
+;;   ld.w    r6, r6[0x0]
+;; to
+;;   sub     r6, r7, 4
+;;   ld.w    r6, r7[-0x4]
+;;=============================================================================
+; (set (reg:SI 7 r6)
+;      (plus:SI (reg/f:SI 6 r7)
+;               (const_int -4 [0xfffffffc])))
+; (set (reg:SI 7 r6)
+;      (mem:SI (reg:SI 7 r6)))
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(plus:SI (match_operand:SI 1 "register_operand" "")
+		 (match_operand:SI 2 "immediate_operand" "")))
+   (set (match_operand:SI 3 "register_operand" "")
+	(mem:SI (match_dup 0)))]
+  "REGNO(operands[0]) != REGNO(operands[1]) && avr32_const_ok_for_constraint_p(INTVAL(operands[2]), 'K', \"Ks16\")"
+  [(set (match_dup 0)
+	(plus:SI (match_dup 1)
+		 (match_dup 2)))
+   (set (match_dup 3)
+	(mem:SI (plus:SI (match_dup 1)
+			 (match_dup 2))))]
+  "")
+
+;;=============================================================================
+;; Peephole optimizing
+;;-----------------------------------------------------------------------------
+;; Changing
+;;   ld.sb   r0, r7[-0x6]
+;;   cashs.b r0
+;; to
+;;   ld.sb   r0, r7[-0x6]
+;;=============================================================================
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "")
+	(match_operand:QI 1 "load_sb_memory_operand" ""))
+   (set (match_operand:SI 2 "register_operand" "")
+	(sign_extend:SI (match_dup 0)))]
+  "(REGNO(operands[0]) == REGNO(operands[2]) || peep2_reg_dead_p(2, operands[0]))"
+  [(set (match_dup 2)
+	(sign_extend:SI (match_dup 1)))]
+  "")
+
+;;=============================================================================
+;; Peephole optimizing
+;;-----------------------------------------------------------------------------
+;; Changing
+;;   ld.ub   r0, r7[-0x6]
+;;   cashu.b r0
+;; to
+;;   ld.ub   r0, r7[-0x6]
+;;=============================================================================
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "")
+	(match_operand:QI 1 "memory_operand" ""))
+   (set (match_operand:SI 2 "register_operand" "")
+	(zero_extend:SI (match_dup 0)))]
+  "(REGNO(operands[0]) == REGNO(operands[2])) || peep2_reg_dead_p(2, operands[0])"
+  [(set (match_dup 2)
+	(zero_extend:SI (match_dup 1)))]
+  "")
+
+;;=============================================================================
+;; Peephole optimizing
+;;-----------------------------------------------------------------------------
+;; Changing
+;;   ld.sh   r0, r7[-0x6]
+;;   casts.h r0
+;; to
+;;   ld.sh   r0, r7[-0x6]
+;;=============================================================================
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+	(match_operand:HI 1 "memory_operand" ""))
+   (set (match_operand:SI 2 "register_operand" "")
+	(sign_extend:SI (match_dup 0)))]
+  "(REGNO(operands[0]) == REGNO(operands[2])) || peep2_reg_dead_p(2, operands[0])"
+  [(set (match_dup 2)
+	(sign_extend:SI (match_dup 1)))]
+  "")
+
+;;=============================================================================
+;; Peephole optimizing
+;;-----------------------------------------------------------------------------
+;; Changing
+;;   ld.uh   r0, r7[-0x6]
+;;   castu.h r0
+;; to
+;;   ld.uh   r0, r7[-0x6]
+;;=============================================================================
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+	(match_operand:HI 1 "memory_operand" ""))
+   (set (match_operand:SI 2 "register_operand" "")
+	(zero_extend:SI (match_dup 0)))]
+  "(REGNO(operands[0]) == REGNO(operands[2])) || peep2_reg_dead_p(2, operands[0])"
+  [(set (match_dup 2)
+	(zero_extend:SI (match_dup 1)))]
+  "")
+
+;;=============================================================================
+;; Peephole optimizing
+;;-----------------------------------------------------------------------------
+;; Changing
+;;   mul     rd, rx, ry
+;;   add     rd2, rd  
+;; or
+;;   add     rd2, rd, rd2  
+;; to
+;;   mac     rd2, rx, ry
+;;=============================================================================
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (mult:SI (match_operand:SI 1 "register_operand" "")
+                (match_operand:SI 2 "register_operand" "")))
+   (set (match_operand:SI 3 "register_operand" "")
+        (plus:SI (match_dup 3)
+                 (match_dup 0)))]
+  "peep2_reg_dead_p(2, operands[0])"
+  [(set (match_dup 3)
+	(plus:SI (mult:SI (match_dup 1)
+			  (match_dup 2))
+		 (match_dup 3)))]
+  "")
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (mult:SI (match_operand:SI 1 "register_operand" "")
+                (match_operand:SI 2 "register_operand" "")))
+   (set (match_operand:SI 3 "register_operand" "")
+        (plus:SI (match_dup 0)
+                 (match_dup 3)))]
+  "peep2_reg_dead_p(2, operands[0])"
+  [(set (match_dup 3)
+	(plus:SI (mult:SI (match_dup 1)
+			  (match_dup 2))
+		 (match_dup 3)))]
+  "")
+
+
+;;=============================================================================
+;; Peephole optimizing
+;;-----------------------------------------------------------------------------
+;; Changing
+;;   bfextu  rd, rs, k5, 1 or and(h/l) rd, one_bit_set_mask
+;; to
+;;   bld     rs, k5
+;;
+;; If rd is dead after the operation.
+;;=============================================================================
+(define_peephole2
+  [ (set (match_operand:SI 0 "register_operand" "")
+         (zero_extract:SI (match_operand:SI 1 "register_operand" "")
+                          (const_int 1)
+                          (match_operand:SI 2 "immediate_operand" "")))
+    (set (cc0)
+         (match_dup 0))]
+  "peep2_reg_dead_p(2, operands[0])"
+  [(set (cc0)
+        (and:SI (match_dup 1)
+                (match_dup 2)))]
+  "operands[2] = GEN_INT(1 << INTVAL(operands[2]));")
+
+(define_peephole2
+  [ (set (match_operand:SI 0 "register_operand" "")
+         (and:SI (match_operand:SI 1 "register_operand" "")
+                 (match_operand:SI 2 "one_bit_set_operand" "")))
+    (set (cc0)
+         (match_dup 0))]
+  "peep2_reg_dead_p(2, operands[0])"
+  [(set (cc0)
+        (and:SI (match_dup 1)
+                (match_dup 2)))]
+  "")
+
+;;=============================================================================
+;; Peephole optimizing
+;;-----------------------------------------------------------------------------
+;; Load with extracted index: ld.w  Rd, Rb[Ri:{t/u/b/l} << 2]
+;;
+;;=============================================================================
+
+
+(define_peephole
+  [(set (match_operand:SI 0 "register_operand" "")
+        (zero_extract:SI (match_operand:SI 1 "register_operand" "")
+                         (const_int 8)
+                         (match_operand:SI 2 "avr32_extract_shift_operand" "")))
+   (set (match_operand:SI 3 "register_operand" "")
+        (mem:SI (plus:SI (mult:SI (match_dup 0) (const_int 4))
+                         (match_operand:SI 4 "register_operand" ""))))]
+
+  "(dead_or_set_p(insn, operands[0]))"
+  {
+   switch ( INTVAL(operands[2]) ){
+    case 0:
+         return "ld.w    %3, %4[%1:b << 2]";
+    case 8:
+         return "ld.w    %3, %4[%1:l << 2]";
+    case 16:
+         return "ld.w    %3, %4[%1:u << 2]";
+    case 24:
+         return "ld.w    %3, %4[%1:t << 2]";
+    default:
+         internal_error("illegal operand for ldxi");
+   }
+  }
+  [(set_attr "type" "load")
+   (set_attr "length" "4")
+   (set_attr "cc" "clobber")]
+  )
+
+
+
+(define_peephole
+  [(set (match_operand:SI 0 "register_operand" "")
+        (and:SI (match_operand:SI 1 "register_operand" "") (const_int 255)))
+   (set (match_operand:SI 2 "register_operand" "")
+        (mem:SI (plus:SI (mult:SI (match_dup 0) (const_int 4))
+                         (match_operand:SI 3 "register_operand" ""))))]
+
+  "(dead_or_set_p(insn, operands[0]))"
+
+  "ld.w    %2, %3[%1:b << 2]"
+  [(set_attr "type" "load")
+   (set_attr "length" "4")
+   (set_attr "cc" "clobber")]
+  )
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (zero_extract:SI (match_operand:SI 1 "register_operand" "")
+                         (const_int 8)
+                         (match_operand:SI 2 "avr32_extract_shift_operand" "")))
+   (set (match_operand:SI 3 "register_operand" "")
+        (mem:SI (plus:SI (mult:SI (match_dup 0) (const_int 4))
+                         (match_operand:SI 4 "register_operand" ""))))]
+
+  "(peep2_reg_dead_p(2, operands[0]))
+   || (REGNO(operands[0]) == REGNO(operands[3]))"
+  [(set (match_dup 3)
+	(mem:SI (plus:SI
+                 (match_dup 4)
+                 (mult:SI (zero_extract:SI (match_dup 1)
+                                           (const_int 8)
+                                           (match_dup 2))
+                          (const_int 4)))))]
+  )
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (zero_extend:SI (match_operand:QI 1 "register_operand" "")))
+   (set (match_operand:SI 2 "register_operand" "")
+        (mem:SI (plus:SI (mult:SI (match_dup 0) (const_int 4))
+                         (match_operand:SI 3 "register_operand" ""))))]
+
+  "(peep2_reg_dead_p(2, operands[0]))
+   || (REGNO(operands[0]) == REGNO(operands[2]))"
+  [(set (match_dup 2)
+	(mem:SI (plus:SI
+                 (match_dup 3)
+                 (mult:SI (zero_extract:SI (match_dup 1)
+                                           (const_int 8)
+                                           (const_int 0))
+                          (const_int 4)))))]
+  "operands[1] = gen_rtx_REG(SImode, REGNO(operands[1]));"
+  )
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (and:SI (match_operand:SI 1 "register_operand" "")
+                (const_int 255)))
+   (set (match_operand:SI 2 "register_operand" "")
+        (mem:SI (plus:SI (mult:SI (match_dup 0) (const_int 4))
+                         (match_operand:SI 3 "register_operand" ""))))]
+
+  "(peep2_reg_dead_p(2, operands[0]))
+   || (REGNO(operands[0]) == REGNO(operands[2]))"
+  [(set (match_dup 2)
+	(mem:SI (plus:SI
+                 (match_dup 3)
+                 (mult:SI (zero_extract:SI (match_dup 1)
+                                           (const_int 8)
+                                           (const_int 0))
+                          (const_int 4)))))]
+  ""
+  )
+
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (lshiftrt:SI (match_operand:SI 1 "register_operand" "")
+                     (const_int 24)))
+   (set (match_operand:SI 2 "register_operand" "")
+        (mem:SI (plus:SI (mult:SI (match_dup 0) (const_int 4))
+                         (match_operand:SI 3 "register_operand" ""))))]
+
+  "(peep2_reg_dead_p(2, operands[0]))
+   || (REGNO(operands[0]) == REGNO(operands[2]))"
+  [(set (match_dup 2)
+	(mem:SI (plus:SI
+                 (match_dup 3)
+                 (mult:SI (zero_extract:SI (match_dup 1)
+                                           (const_int 8)
+                                           (const_int 24))
+                          (const_int 4)))))]
+  ""
+  )
+
+
+;;************************************************
+;; ANDN
+;;
+;;************************************************
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (not:SI (match_operand:SI 1 "register_operand" "")))
+   (set (match_operand:SI 2 "register_operand" "")
+        (and:SI (match_dup 2)
+                (match_dup 0)))]
+  "peep2_reg_dead_p(2, operands[0])"
+
+  [(set (match_dup 2)
+        (and:SI  (match_dup 2)
+                 (not:SI (match_dup 1))
+                 ))]
+  ""
+)
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (not:SI (match_operand:SI 1 "register_operand" "")))
+   (set (match_operand:SI 2 "register_operand" "")
+        (and:SI (match_dup 0)
+                (match_dup 2)
+                ))]
+  "peep2_reg_dead_p(2, operands[0])"
+
+  [(set (match_dup 2)
+        (and:SI  (match_dup 2)
+                 (not:SI (match_dup 1))
+                 ))]
+
+  ""
+)
+
+
+;;=================================================================
+;; Addabs peephole
+;;=================================================================
+
+(define_peephole
+  [(set (match_operand:SI 2 "register_operand" "=r")
+ 	(abs:SI (match_operand:SI 1 "register_operand" "r")))
+   (set (match_operand:SI 0 "register_operand" "=r")
+ 	(plus:SI (match_operand:SI 3 "register_operand" "r")
+ 		 (match_dup 2)))]
+  "dead_or_set_p(insn, operands[2])"
+  "addabs  %0, %3, %1"
+  [(set_attr "length" "4")
+   (set_attr "cc" "set_z")])
+
+(define_peephole
+  [(set (match_operand:SI 2 "register_operand" "=r")
+ 	(abs:SI (match_operand:SI 1 "register_operand" "r")))
+   (set (match_operand:SI 0 "register_operand" "=r")
+ 	(plus:SI (match_dup 2)
+                 (match_operand:SI 3 "register_operand" "r")))]
+  "dead_or_set_p(insn, operands[2])"
+  "addabs  %0, %3, %1"
+  [(set_attr "length" "4")
+   (set_attr "cc" "set_z")])
+
+
+;;=================================================================
+;; Detect roundings
+;;=================================================================
+
+(define_insn "*round"
+  [(set (match_operand:SI 0 "register_operand" "+r")
+        (ashiftrt:SI (plus:SI (match_dup 0)
+                              (match_operand:SI 1 "immediate_operand" "i"))
+                     (match_operand:SI 2 "immediate_operand" "i")))]
+  "avr32_rnd_operands(operands[1], operands[2])"
+
+  "satrnds    %0 >> %2, 31"
+
+  [(set_attr "type" "alu_sat")
+   (set_attr "length" "4")]
+
+  )
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(plus:SI (match_dup 0)
+                 (match_operand:SI 1 "immediate_operand" "")))
+   (set (match_dup 0)
+	(ashiftrt:SI (match_dup 0)
+                     (match_operand:SI 2 "immediate_operand" "")))]
+  "avr32_rnd_operands(operands[1], operands[2])"
+
+  [(set (match_dup 0)
+        (ashiftrt:SI (plus:SI (match_dup 0)
+                              (match_dup 1))
+                     (match_dup 2)))]
+  )
+
+(define_peephole
+  [(set (match_operand:SI 0 "register_operand" "r")
+	(plus:SI (match_dup 0)
+                 (match_operand:SI 1 "immediate_operand" "i")))
+   (set (match_dup 0)
+	(ashiftrt:SI (match_dup 0)
+                     (match_operand:SI 2 "immediate_operand" "i")))]
+  "avr32_rnd_operands(operands[1], operands[2])"
+
+  "satrnds    %0 >> %2, 31"
+
+  [(set_attr "type" "alu_sat")
+   (set_attr "length" "4")
+   (set_attr "cc" "clobber")]
+
+  )
+
+
+;;=================================================================
+;; mcall
+;;=================================================================
+(define_peephole
+  [(set (match_operand:SI 0 "register_operand"        "")
+	(match_operand 1 "avr32_const_pool_ref_operand"  ""))
+   (parallel [(call (mem:SI (match_dup 0))
+                    (match_operand 2 "" ""))
+              (clobber (reg:SI LR_REGNUM))])]
+  "dead_or_set_p(insn, operands[0])"
+  "mcall    %1"
+  [(set_attr "type" "call")
+   (set_attr "length" "4")
+   (set_attr "cc" "clobber")]
+)
+
+(define_peephole
+  [(set (match_operand:SI 2 "register_operand"        "")
+	(match_operand 1 "avr32_const_pool_ref_operand"  ""))
+   (parallel [(set (match_operand 0 "register_operand" "")
+                   (call (mem:SI (match_dup 2))
+                         (match_operand 3 "" "")))
+              (clobber (reg:SI LR_REGNUM))])]
+  "dead_or_set_p(insn, operands[2])"
+  "mcall    %1"
+  [(set_attr "type" "call")
+   (set_attr "length" "4")
+   (set_attr "cc" "call_set")]
+)
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand"    "")
+	(match_operand 1 "avr32_const_pool_ref_operand"  ""))
+   (parallel [(call (mem:SI (match_dup 0))
+                    (match_operand 2 "" ""))
+              (clobber (reg:SI LR_REGNUM))])]
+  "peep2_reg_dead_p(2, operands[0])"
+  [(parallel [(call (mem:SI (match_dup 1))
+                    (match_dup 2))
+              (clobber (reg:SI LR_REGNUM))])]
+  ""
+)
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand"        "")
+	(match_operand 1 "avr32_const_pool_ref_operand"  ""))
+   (parallel [(set (match_operand 2 "register_operand" "")
+                   (call (mem:SI (match_dup 0))
+                         (match_operand 3 "" "")))
+              (clobber (reg:SI LR_REGNUM))])]
+  "(peep2_reg_dead_p(2, operands[0]) || (REGNO(operands[2]) == REGNO(operands[0])))"
+  [(parallel [(set (match_dup 2)
+                   (call (mem:SI (match_dup 1))
+                         (match_dup 3)))
+              (clobber (reg:SI LR_REGNUM))])]
+  ""
+)
+
+;;=================================================================
+;; Returning a value
+;;=================================================================
+
+
+(define_peephole
+  [(set (match_operand 0 "register_operand" "")
+        (match_operand 1 "register_operand" ""))
+   (return)]
+  "USE_RETURN_INSN (TRUE) && (REGNO(operands[0]) == RETVAL_REGNUM)
+   && (REGNO(operands[1]) != LR_REGNUM)
+   && (REGNO_REG_CLASS(REGNO(operands[1])) == GENERAL_REGS)"
+  "retal    %1"
+  [(set_attr "type" "call")
+   (set_attr "length" "2")]
+  )
+
+
+(define_peephole
+  [(set (match_operand 0 "register_operand" "r")
+        (match_operand 1 "immediate_operand" "i"))
+   (return)]
+  "(USE_RETURN_INSN (FALSE) && (REGNO(operands[0]) == RETVAL_REGNUM) &&
+   ((INTVAL(operands[1]) == -1) || (INTVAL(operands[1]) == 0) || (INTVAL(operands[1]) == 1)))"
+  {
+    avr32_output_return_instruction (TRUE, FALSE, NULL, operands[1]);
+    return "";
+  }
+  [(set_attr "type" "call")
+   (set_attr "length" "4")]
+  )
+
+(define_peephole
+  [(set (match_operand 0 "register_operand" "r")
+        (match_operand 1 "immediate_operand" "i"))
+   (unspec_volatile [(return)] VUNSPEC_EPILOGUE)]
+  "(REGNO(operands[0]) == RETVAL_REGNUM) &&
+   ((INTVAL(operands[1]) == -1) || (INTVAL(operands[1]) == 0) || (INTVAL(operands[1]) == 1))"
+  {
+    avr32_output_return_instruction (FALSE, FALSE, NULL, operands[1]);
+    return "";
+  }
+  ; Length is absolute worst case
+  [(set_attr "type" "branch")
+   (set_attr "length" "12")]
+  )
+
+(define_peephole
+  [(set (match_operand 0 "register_operand" "=r")
+        (if_then_else (match_operator 1 "avr32_comparison_operator"
+                                      [(match_operand 4 "register_operand" "r")
+                                       (match_operand 5 "register_immediate_operand" "rKs21")])
+                      (match_operand 2 "avr32_cond_register_immediate_operand" "rKs08")
+                      (match_operand 3 "avr32_cond_register_immediate_operand" "rKs08")))
+   (return)]
+  "USE_RETURN_INSN (TRUE) && (REGNO(operands[0]) == RETVAL_REGNUM)"
+  {
+   operands[1] = avr32_output_cmp(operands[1], GET_MODE(operands[4]), operands[4], operands[5]);
+
+   if ( GET_CODE(operands[2]) == REG
+        && GET_CODE(operands[3]) == REG
+        && REGNO(operands[2]) != LR_REGNUM
+        && REGNO(operands[3]) != LR_REGNUM ){
+      return "ret%1    %2\;ret%i1    %3";
+   } else if ( GET_CODE(operands[2]) == REG
+               && GET_CODE(operands[3]) == CONST_INT ){
+      if ( INTVAL(operands[3]) == -1
+           || INTVAL(operands[3]) == 0
+           || INTVAL(operands[3]) == 1 ){
+        return "ret%1    %2\;ret%i1    %d3";
+      } else {
+        return "mov%1    r12, %2\;mov%i1    r12, %3\;retal    r12";
+      }
+   } else if ( GET_CODE(operands[2]) == CONST_INT
+               && GET_CODE(operands[3]) == REG ){
+      if ( INTVAL(operands[2]) == -1
+           || INTVAL(operands[2]) == 0
+           || INTVAL(operands[2]) == 1 ){
+        return "ret%1    %d2\;ret%i1    %3";
+      } else {
+        return "mov%1    r12, %2\;mov%i1    r12, %3\;retal    r12";
+      }
+   } else {
+      if ( (INTVAL(operands[2]) == -1
+            || INTVAL(operands[2]) == 0
+            || INTVAL(operands[2]) == 1 )
+           && (INTVAL(operands[3]) == -1
+               || INTVAL(operands[3]) == 0
+               || INTVAL(operands[3]) == 1 )){
+        return "ret%1    %d2\;ret%i1    %d3";
+      } else {
+        return "mov%1    r12, %2\;mov%i1    r12, %3\;retal    r12";
+      }
+   }
+  }
+
+  [(set_attr "length" "10")
+   (set_attr "cc" "none")
+   (set_attr "type" "call")])
+  
+
+
+;;=================================================================
+;; mulnhh.w
+;;=================================================================
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+        (neg:HI (match_operand:HI 1 "register_operand" "")))
+   (set (match_operand:SI 2 "register_operand" "")
+        (mult:SI
+         (sign_extend:SI (match_dup 0))
+         (sign_extend:SI (match_operand:HI 3 "register_operand" ""))))]
+  "(peep2_reg_dead_p(2, operands[0])) || (REGNO(operands[2]) == REGNO(operands[0]))"
+  [ (set (match_dup 2)
+         (mult:SI
+          (sign_extend:SI (neg:HI (match_dup 1)))
+          (sign_extend:SI (match_dup 3))))]
+  ""
+  )
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+        (neg:HI (match_operand:HI 1 "register_operand" "")))
+   (set (match_operand:SI 2 "register_operand" "")
+        (mult:SI
+         (sign_extend:SI (match_operand:HI 3 "register_operand" ""))
+         (sign_extend:SI (match_dup 0))))]
+  "(peep2_reg_dead_p(2, operands[0])) || (REGNO(operands[2]) == REGNO(operands[0]))"
+  [ (set (match_dup 2)
+         (mult:SI
+          (sign_extend:SI (neg:HI (match_dup 1)))
+          (sign_extend:SI (match_dup 3))))]
+  ""
+  )
+
+
+
+;;=================================================================
+;; Vector set and extract operations
+;;=================================================================
+(define_insn "vec_setv2hi_hi"
+  [(set (match_operand:V2HI 0 "register_operand" "=r")
+        (vec_merge:V2HI
+         (match_dup 0)
+         (vec_duplicate:V2HI
+          (match_operand:HI 1 "register_operand" "r"))
+         (const_int 1)))]
+  ""
+  "bfins\t%0, %1, 16, 16"
+  [(set_attr "type" "alu")
+   (set_attr "length" "4")
+   (set_attr "cc" "clobber")])
+
+(define_insn "vec_setv2hi_lo"
+  [(set (match_operand:V2HI 0 "register_operand" "+r")
+        (vec_merge:V2HI
+         (match_dup 0)
+         (vec_duplicate:V2HI
+          (match_operand:HI 1 "register_operand" "r"))
+         (const_int 2)))]
+  ""
+  "bfins\t%0, %1, 0, 16"
+  [(set_attr "type" "alu")
+   (set_attr "length" "4")
+   (set_attr "cc" "clobber")])
+
+(define_expand "vec_setv2hi"
+  [(set (match_operand:V2HI 0 "register_operand" "")
+        (vec_merge:V2HI
+         (match_dup 0)
+         (vec_duplicate:V2HI
+          (match_operand:HI 1 "register_operand" ""))
+         (match_operand 2 "immediate_operand" "")))]
+  ""
+  { operands[2] = GEN_INT(INTVAL(operands[2]) + 1); }
+  )
+
+(define_insn "vec_extractv2hi"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (vec_select:HI
+         (match_operand:V2HI 1 "register_operand" "r")
+         (parallel [(match_operand:SI 2 "immediate_operand" "i")])))]
+  ""
+  {
+   if ( INTVAL(operands[2]) == 0 )
+      return "bfextu\t%0, %1, 16, 16";
+   else
+      return "bfextu\t%0, %1, 0, 16";
+  }
+  [(set_attr "type" "alu")
+   (set_attr "length" "4")
+   (set_attr "cc" "clobber")])
+
+(define_insn "vec_extractv4qi"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (vec_select:QI
+         (match_operand:V4QI 1 "register_operand" "r")
+         (parallel [(match_operand:SI 2 "immediate_operand" "i")])))]
+  ""
+  {
+   switch ( INTVAL(operands[2]) ){
+     case 0:
+       return "bfextu\t%0, %1, 24, 8";
+     case 1:
+       return "bfextu\t%0, %1, 16, 8";
+     case 2:
+       return "bfextu\t%0, %1, 8, 8";
+     case 3:
+       return "bfextu\t%0, %1, 0, 8";
+     default:
+       abort();
+   }
+  }
+  [(set_attr "type" "alu")
+   (set_attr "length" "4")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "concatv2hi"
+  [(set (match_operand:V2HI 0 "register_operand" "=r, r, r")
+        (vec_concat:V2HI
+         (match_operand:HI 1 "register_operand" "r, r, 0")
+         (match_operand:HI 2 "register_operand" "r, 0, r")))]
+  ""
+  "@
+   mov\t%0, %1\;bfins\t%0, %2, 0, 16
+   bfins\t%0, %2, 0, 16
+   bfins\t%0, %1, 16, 16"
+  [(set_attr "length" "6, 4, 4")
+   (set_attr "type" "alu")])
+
+
+;; Load the atomic operation description
+(include "sync.md")
+
+;; Load the SIMD description
+(include "simd.md")
+
+;; Include the FPU for uc3
+(include "uc3fpu.md")
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/avr32-modes.def gcc-4.4.6/gcc/config/avr32/avr32-modes.def
--- gcc-4.4.6.orig/gcc/config/avr32/avr32-modes.def	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/avr32-modes.def	2011-08-27 19:45:42.837990082 +0200
@@ -0,0 +1 @@
+VECTOR_MODES (INT, 4);        /*            V4QI V2HI */
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/avr32.opt gcc-4.4.6/gcc/config/avr32/avr32.opt
--- gcc-4.4.6.orig/gcc/config/avr32/avr32.opt	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/avr32.opt	2011-08-27 19:45:42.877990476 +0200
@@ -0,0 +1,93 @@
+; Options for the ATMEL AVR32 port of the compiler.
+
+; Copyright 2007 Atmel Corporation.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 2, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING.  If not, write to the Free
+; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
+; 02110-1301, USA.
+
+muse-rodata-section
+Target Report Mask(USE_RODATA_SECTION)
+Use section .rodata for read-only data instead of .text.
+
+mhard-float
+Target Report Mask(HARD_FLOAT)
+Use FPU instructions instead of floating point emulation.
+
+msoft-float
+Target Report InverseMask(HARD_FLOAT, SOFT_FLOAT)
+Use floating point emulation for floating point operations.
+
+mforce-double-align
+Target Report RejectNegative Mask(FORCE_DOUBLE_ALIGN)
+Force double-word alignment for double-word memory accesses.
+
+mno-init-got
+Target Report RejectNegative Mask(NO_INIT_GOT)
+Do not initialize GOT register before using it when compiling PIC code.
+
+mrelax
+Target Report Mask(RELAX)
+Let invoked assembler and linker do relaxing (Enabled by default when optimization level is >1).
+
+mmd-reorg-opt
+Target Report Undocumented Mask(MD_REORG_OPTIMIZATION)
+Perform machine dependent optimizations in reorg stage.
+
+masm-addr-pseudos
+Target Report Mask(HAS_ASM_ADDR_PSEUDOS) 
+Use assembler pseudo-instructions lda.w and call for handling direct addresses. (Enabled by default)
+
+mpart=
+Target Report RejectNegative Joined Var(avr32_part_name)
+Specify the AVR32 part name
+
+mcpu=
+Target Report RejectNegative Joined Undocumented Var(avr32_part_name)
+Specify the AVR32 part name (deprecated)
+
+march=
+Target Report RejectNegative Joined Var(avr32_arch_name)
+Specify the AVR32 architecture name
+
+mfast-float
+Target Report Mask(FAST_FLOAT)
+Enable fast floating-point library. Enabled by default if the -funsafe-math-optimizations switch is specified.
+
+mimm-in-const-pool
+Target Report Var(avr32_imm_in_const_pool) Init(-1)
+Put large immediates in constant pool. This is enabled by default for archs with insn-cache.
+
+mno-pic
+Target Report RejectNegative Mask(NO_PIC)
+Do not generate position-independent code. (deprecated, use -fno-pic instead)
+
+mcond-exec-before-reload
+Target Report Undocumented Mask(COND_EXEC_BEFORE_RELOAD) 
+Enable experimental conditional execution preparation before the reload stage. 
+
+mrmw-addressable-data
+Target Report Mask(RMW_ADDRESSABLE_DATA)
+Signal that all data is in range for the Atomic Read-Modify-Write memory instructions, and that
+gcc can safely generate these whenever possible. 
+
+mflashvault
+Target Var(TARGET_FLASHVAULT)
+Generate code for flashvault
+
+mlist-devices
+Target RejectNegative Var(avr32_list_supported_parts)
+Print the list of parts supported while printing --target-help.
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/avr32-protos.h gcc-4.4.6/gcc/config/avr32/avr32-protos.h
--- gcc-4.4.6.orig/gcc/config/avr32/avr32-protos.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/avr32-protos.h	2011-08-27 19:45:42.937990414 +0200
@@ -0,0 +1,196 @@
+/*
+   Prototypes for exported functions defined in avr32.c
+   Copyright 2003,2004,2005,2006,2007,2008,2009 Atmel Corporation.
+
+   This file is part of GCC.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
+
+
+#ifndef AVR32_PROTOS_H
+#define AVR32_PROTOS_H
+
+extern const int swap_reg[];
+
+extern int avr32_valid_macmac_bypass (rtx, rtx);
+extern int avr32_valid_mulmac_bypass (rtx, rtx);
+
+extern int avr32_decode_lcomm_symbol_offset (rtx, int *);
+extern void avr32_encode_lcomm_symbol_offset (tree, char *, int);
+
+extern const char *avr32_strip_name_encoding (const char *);
+
+extern rtx avr32_get_note_reg_equiv (rtx insn);
+
+extern int avr32_use_return_insn (int iscond);
+
+extern void avr32_make_reglist16 (int reglist16_vect, char *reglist16_string);
+
+extern void avr32_make_reglist8 (int reglist8_vect, char *reglist8_string);
+extern void avr32_make_fp_reglist_w (int reglist_mask, char *reglist_string);
+extern void avr32_make_fp_reglist_d (int reglist_mask, char *reglist_string);
+
+extern void avr32_output_return_instruction (int single_ret_inst,
+					     int iscond, rtx cond,
+					     rtx r12_imm);
+extern void avr32_expand_prologue (void);
+extern void avr32_set_return_address (rtx source, rtx scratch);
+
+extern int avr32_hard_regno_mode_ok (int regno, enum machine_mode mode);
+extern int avr32_extra_constraint_s (rtx value, const int strict);
+extern int avr32_eh_return_data_regno (const int n);
+extern int avr32_initial_elimination_offset (const int from, const int to);
+extern rtx avr32_function_arg (CUMULATIVE_ARGS * cum, enum machine_mode mode,
+			       tree type, int named);
+extern void avr32_init_cumulative_args (CUMULATIVE_ARGS * cum, tree fntype,
+					rtx libname, tree fndecl);
+extern void avr32_function_arg_advance (CUMULATIVE_ARGS * cum,
+					enum machine_mode mode,
+					tree type, int named);
+#ifdef ARGS_SIZE_RTX
+/* expr.h defines ARGS_SIZE_RTX and `enum direction'.  */
+extern enum direction avr32_function_arg_padding (enum machine_mode mode,
+						  tree type);
+#endif /* ARGS_SIZE_RTX */
+extern rtx avr32_function_value (tree valtype, tree func, bool outgoing);
+extern rtx avr32_libcall_value (enum machine_mode mode);
+extern int avr32_sched_use_dfa_pipeline_interface (void);
+extern bool avr32_return_in_memory (tree type, tree fntype);
+extern void avr32_regs_to_save (char *operand);
+extern void avr32_target_asm_function_prologue (FILE * file,
+						HOST_WIDE_INT size);
+extern void avr32_target_asm_function_epilogue (FILE * file,
+						HOST_WIDE_INT size);
+extern void avr32_trampoline_template (FILE * file);
+extern void avr32_initialize_trampoline (rtx addr, rtx fnaddr,
+					 rtx static_chain);
+extern int avr32_legitimate_address (enum machine_mode mode, rtx x,
+				     int strict);
+extern int avr32_legitimate_constant_p (rtx x);
+
+extern int avr32_legitimate_pic_operand_p (rtx x);
+
+extern rtx avr32_find_symbol (rtx x);
+extern void avr32_select_section (rtx exp, int reloc, int align);
+extern void avr32_encode_section_info (tree decl, rtx rtl, int first);
+extern void avr32_asm_file_end (FILE * stream);
+extern void avr32_asm_output_ascii (FILE * stream, char *ptr, int len);
+extern void avr32_asm_output_common (FILE * stream, const char *name,
+				     int size, int rounded);
+extern void avr32_asm_output_label (FILE * stream, const char *name);
+extern void avr32_asm_declare_object_name (FILE * stream, char *name,
+					   tree decl);
+extern void avr32_asm_globalize_label (FILE * stream, const char *name);
+extern void avr32_asm_weaken_label (FILE * stream, const char *name);
+extern void avr32_asm_output_external (FILE * stream, tree decl,
+				       const char *name);
+extern void avr32_asm_output_external_libcall (FILE * stream, rtx symref);
+extern void avr32_asm_output_labelref (FILE * stream, const char *name);
+extern void avr32_notice_update_cc (rtx exp, rtx insn);
+extern void avr32_print_operand (FILE * stream, rtx x, int code);
+extern void avr32_print_operand_address (FILE * stream, rtx x);
+
+extern int avr32_symbol (rtx x);
+
+extern void avr32_select_rtx_section (enum machine_mode mode, rtx x,
+				      unsigned HOST_WIDE_INT align);
+
+extern int avr32_load_multiple_operation (rtx op, enum machine_mode mode);
+extern int avr32_store_multiple_operation (rtx op, enum machine_mode mode);
+
+extern int avr32_const_ok_for_constraint_p (HOST_WIDE_INT value, char c,
+					    const char *str);
+
+extern bool avr32_cannot_force_const_mem (rtx x);
+
+extern void avr32_init_builtins (void);
+
+extern rtx avr32_expand_builtin (tree exp, rtx target, rtx subtarget,
+				 enum machine_mode mode, int ignore);
+
+extern bool avr32_must_pass_in_stack (enum machine_mode mode, tree type);
+
+extern bool avr32_strict_argument_naming (CUMULATIVE_ARGS * ca);
+
+extern bool avr32_pass_by_reference (CUMULATIVE_ARGS * cum,
+				     enum machine_mode mode,
+				     tree type, bool named);
+
+extern rtx avr32_gen_load_multiple (rtx * regs, int count, rtx from,
+				    int write_back, int in_struct_p,
+				    int scalar_p);
+extern rtx avr32_gen_store_multiple (rtx * regs, int count, rtx to,
+				     int in_struct_p, int scalar_p);
+extern int avr32_gen_movmemsi (rtx * operands);
+
+extern int avr32_rnd_operands (rtx add, rtx shift);
+extern int avr32_adjust_insn_length (rtx insn, int length);
+
+extern int symbol_mentioned_p (rtx x);
+extern int label_mentioned_p (rtx x);
+extern rtx legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg);
+extern int avr32_address_register_rtx_p (rtx x, int strict_p);
+extern int avr32_legitimate_index_p (enum machine_mode mode, rtx index,
+				     int strict_p);
+
+extern int avr32_const_double_immediate (rtx value);
+extern void avr32_init_expanders (void);
+extern rtx avr32_return_addr (int count, rtx frame);
+extern bool avr32_got_mentioned_p (rtx addr);
+
+extern void avr32_final_prescan_insn (rtx insn, rtx * opvec, int noperands);
+
+extern int avr32_expand_movcc (enum machine_mode mode, rtx operands[]);
+extern int avr32_expand_addcc (enum machine_mode mode, rtx operands[]);
+#ifdef RTX_CODE
+extern int avr32_expand_scc (RTX_CODE cond, rtx * operands);
+#endif
+
+extern int avr32_store_bypass (rtx insn_out, rtx insn_in);
+extern int avr32_mul_waw_bypass (rtx insn_out, rtx insn_in);
+extern int avr32_valid_load_double_bypass (rtx insn_out, rtx insn_in);
+extern int avr32_valid_load_quad_bypass (rtx insn_out, rtx insn_in);
+extern rtx avr32_output_cmp (rtx cond, enum machine_mode mode,
+			     rtx op0, rtx op1);
+
+rtx get_next_insn_cond (rtx cur_insn);
+int set_next_insn_cond (rtx cur_insn, rtx cond);
+rtx next_insn_emits_cmp (rtx cur_insn);
+void avr32_override_options (void);
+void avr32_load_pic_register (void);
+#ifdef GCC_BASIC_BLOCK_H
+rtx avr32_ifcvt_modify_insn (ce_if_block_t *ce_info, rtx pattern, rtx insn, 
+                             int *num_true_changes);
+rtx avr32_ifcvt_modify_test (ce_if_block_t *ce_info, rtx test );
+void avr32_ifcvt_modify_cancel ( ce_if_block_t *ce_info, int *num_true_changes);
+#endif
+void avr32_optimization_options (int level, int size);
+int avr32_const_ok_for_move (HOST_WIDE_INT c);
+
+void avr32_split_const_expr (enum machine_mode mode,
+                             enum machine_mode new_mode,
+                             rtx expr, 
+                             rtx *split_expr);
+void avr32_get_intval (enum machine_mode mode,
+                       rtx const_expr, 
+                       HOST_WIDE_INT *val);
+
+int avr32_cond_imm_clobber_splittable (rtx insn, 
+                                       rtx operands[]);
+
+bool avr32_flashvault_call(tree decl);
+extern void avr32_emit_swdivsf (rtx, rtx, rtx);
+
+#endif /* AVR32_PROTOS_H */
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/crti.asm gcc-4.4.6/gcc/config/avr32/crti.asm
--- gcc-4.4.6.orig/gcc/config/avr32/crti.asm	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/crti.asm	2011-08-27 19:45:42.977989352 +0200
@@ -0,0 +1,64 @@
+/*
+   Init/fini stuff for AVR32.
+   Copyright 2003-2006 Atmel Corporation.
+
+   Written by Ronny Pedersen, Atmel Norway, <rpedersen@atmel.com>
+
+   This file is part of GCC.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
+
+	
+/* The code in sections .init and .fini is supposed to be a single
+   regular function.  The function in .init is called directly from
+   start in crt1.asm.  The function in .fini is atexit()ed in crt1.asm
+   too.
+
+   crti.asm contributes the prologue of a function to these sections,
+   and crtn.asm comes up the epilogue.  STARTFILE_SPEC should list
+   crti.o before any other object files that might add code to .init
+   or .fini sections, and ENDFILE_SPEC should list crtn.o after any
+   such object files.  */
+		
+	.file		"crti.asm"
+
+	.section	".init"
+/* Just load the GOT */
+	.align 2
+	.global	_init
+_init:
+	stm	--sp, r6, lr
+	lddpc	r6, 1f		
+0:	
+	rsub	r6, pc
+	rjmp	2f
+	.align	2
+1:	.long	0b - _GLOBAL_OFFSET_TABLE_		
+2:	
+				
+	.section	".fini"
+/* Just load the GOT */
+	.align	2
+	.global	_fini
+_fini:
+	stm	--sp, r6, lr
+	lddpc	r6, 1f		
+0:	
+	rsub	r6, pc
+	rjmp	2f
+	.align	2
+1:	.long	0b - _GLOBAL_OFFSET_TABLE_		
+2:	
+
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/crtn.asm gcc-4.4.6/gcc/config/avr32/crtn.asm
--- gcc-4.4.6.orig/gcc/config/avr32/crtn.asm	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/crtn.asm	2011-08-27 19:45:43.020480077 +0200
@@ -0,0 +1,44 @@
+/*   Copyright (C) 2001 Free Software Foundation, Inc.
+    Written By Nick Clifton
+
+  This file is free software; you can redistribute it and/or modify it
+  under the terms of the GNU General Public License as published by the
+  Free Software Foundation; either version 2, or (at your option) any
+  later version.
+
+  In addition to the permissions in the GNU General Public License, the
+  Free Software Foundation gives you unlimited permission to link the
+  compiled version of this file with other programs, and to distribute
+  those programs without any restriction coming from the use of this
+  file.  (The General Public License restrictions do apply in other
+  respects; for example, they cover modification of the file, and
+  distribution when not linked into another program.)
+
+  This file is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; see the file COPYING.  If not, write to
+  the Free Software Foundation, 59 Temple Place - Suite 330,
+  Boston, MA 02111-1307, USA.
+
+     As a special exception, if you link this library with files
+     compiled with GCC to produce an executable, this does not cause
+     the resulting executable to be covered by the GNU General Public License.
+     This exception does not however invalidate any other reasons why
+     the executable file might be covered by the GNU General Public License.
+*/
+
+
+
+	
+	.file		"crtn.asm"
+
+	.section	".init"
+	ldm	sp++, r6, pc
+			
+	.section	".fini"
+	ldm	sp++, r6, pc
+		
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/lib1funcs.S gcc-4.4.6/gcc/config/avr32/lib1funcs.S
--- gcc-4.4.6.orig/gcc/config/avr32/lib1funcs.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/lib1funcs.S	2011-08-27 19:46:04.347990802 +0200
@@ -0,0 +1,2902 @@
+/* Macro for moving immediate value to register. */	
+.macro mov_imm	reg, imm
+.if	(((\imm & 0xfffff) == \imm) || ((\imm | 0xfff00000) == \imm))
+	mov	\reg, \imm
+#if __AVR32_UC__ >= 2
+.elseif	((\imm & 0xffff) == 0)
+	movh	\reg, hi(\imm)
+
+#endif
+.else
+	mov	\reg, lo(\imm)
+	orh	\reg, hi(\imm)
+.endif
+.endm
+	
+	
+	 
+/* Adjust the unpacked double number if it is a subnormal number.
+   The exponent and mantissa pair are stored
+   in [mant_hi,mant_lo] and [exp]. A register with the correct sign bit in
+   the MSB is passed in [sign]. Needs two scratch
+   registers [scratch1] and [scratch2]. An adjusted and packed double float
+   is present in [mant_hi,mant_lo] after macro has executed */
+.macro  adjust_subnormal_df     exp, mant_lo, mant_hi, sign, scratch1, scratch2 
+        /* We have an exponent which is <=0 indicating a subnormal number
+           As it should be stored as if the exponent was 1 (although the
+           exponent field is all zeros to indicate a subnormal number)
+           we have to shift down the mantissa to its correct position. */
+        neg     \exp
+        sub     \exp,-1                   /* amount to shift down */
+        cp.w    \exp,54
+        brlo    50f                     /* if more than 53 shift steps, the
+                                           entire mantissa will disappear
+                                           without any rounding to occur */
+        mov     \mant_hi, 0
+        mov     \mant_lo, 0
+        rjmp    52f
+50:     
+        sub     \exp,-10                /* do the shift to position the
+                                           mantissa at the same time
+                                           note! this does not include the
+                                           final 1 step shift to add the sign */
+ 
+        /* when shifting, save all shifted out bits in [scratch2]. we may need to
+           look at them to make correct rounding. */
+ 
+        rsub    \scratch1,\exp,32       /* get inverted shift count */
+        cp.w    \exp,32                 /* handle shifts >= 32 separately */
+        brhs    51f
+ 
+        /* small (<32) shift amount, both words are part of the shift */
+        lsl     \scratch2,\mant_lo,\scratch1               /* save bits to shift out from lsw*/
+        lsl     \scratch1,\mant_hi,\scratch1               /* get bits from msw destined for lsw*/
+        lsr     \mant_lo,\mant_lo,\exp                     /* shift down lsw */
+        lsr     \mant_hi,\mant_hi,\exp                     /* shift down msw */
+        or      \mant_hi,\scratch1                         /* add bits from msw with prepared lsw */
+        rjmp    50f
+ 
+        /* large (>=32) shift amount, only lsw will have bits left after shift.
+           note that shift operations will use ((shift count) mod 32) so
+           we do not need to subtract 32 from shift count. */
+51:
+        lsl     \scratch2,\mant_hi,\scratch1               /* save bits to shift out from msw */
+        or      \scratch2,\mant_lo                         /* also save all bits from lsw */
+        mov     \mant_lo,\mant_hi                          /* msw -> lsw (i.e. "shift 32 first") */
+        mov     \mant_hi,0                                 /* clear msw */
+        lsr     \mant_lo,\mant_lo,\exp                     /* make rest of shift inside lsw */
+ 
+50:
+        /* result is almost ready to return, except that least significant bit
+           and the part we already shifted out may cause the result to be
+           rounded */
+        bld     \mant_lo,0                   /* get bit to be shifted out */
+        brcc    51f                          /* if bit was 0, no rounding */
+ 
+        /* msb of part to remove is 1, so rounding depends on rest of bits */
+        tst     \scratch2,\scratch2                   /* get shifted out tail */
+        brne    50f     /* if rest > 0, do round */
+        bld     \mant_lo,1                   /* we have to look at lsb in result */
+        brcc    51f   /* if lsb is 0, don't round */
+ 
+50:
+        /* subnormal result requires rounding
+           rounding may cause subnormal to become smallest normal number
+           luckily, smallest normal number has exactly the representation
+           we got by rippling a one bit up from mantissa into exponent field. */
+        sub     \mant_lo,-1
+        subcc   \mant_hi,-1
+ 
+51:
+        /* shift and return packed double with correct sign */
+        rol     \sign
+        ror     \mant_hi
+        ror     \mant_lo        
+52:     
+.endm
+ 
+ 
+/* Adjust subnormal single float number with exponent [exp]
+   and mantissa [mant] and round.    */
+.macro  adjust_subnormal_sf     sf, exp, mant, sign, scratch
+        /* subnormal number */
+        rsub    \exp,\exp, 1            /* shift amount */
+        cp.w    \exp, 25
+        movhs   \mant, 0                
+        brhs    90f                     /* Return zero */
+        rsub    \scratch, \exp, 32
+        lsl     \scratch, \mant,\scratch/* Check if there are any bits set
+                                           in the bits discarded in the mantissa */
+        srne    \scratch                /* If so set the lsb of the shifted mantissa */ 
+        lsr     \mant,\mant,\exp        /* Shift the mantissa */
+        or      \mant, \scratch         /* Round lsb if any bits were shifted out  */
+        /* Rounding :   For explaination, see round_sf. */
+        mov     \scratch, 0x7f          /* Set rounding constant */
+        bld     \mant, 8                
+        subeq   \scratch, -1            /* For odd numbers use rounding constant 0x80 */
+        add     \mant, \scratch         /* Add rounding constant to mantissa */
+        /* We can't overflow because mantissa is at least shifted one position
+           to the right so the implicit bit is zero. We can however get the implicit
+           bit set after rounding which means that we have the lowest normal number
+           but this is ok since this bit has the same position as the LSB of the
+           exponent */
+        lsr     \sf, \mant, 7
+        /* Rotate in sign */
+        lsl     \sign, 1
+        ror     \sf
+90:     
+.endm
+ 
+ 
+/* Round the unpacked df number with exponent [exp] and
+   mantissa [mant_hi, mant_lo]. Uses scratch register
+   [scratch] */
+.macro  round_df        exp, mant_lo, mant_hi, scratch
+        mov     \scratch, 0x3ff         /* Rounding constant */
+        bld     \mant_lo,11             /* Check if lsb in the final result is  
+                                           set */
+        subeq   \scratch, -1            /* Adjust rounding constant to 0x400
+                                           if rounding 0.5 upwards */   
+        add     \mant_lo, \scratch      /* Round */
+        acr     \mant_hi                /* If overflowing we know that
+                                           we have all zeros in the bits not
+                                           scaled out so we can leave them
+                                           but we must increase the exponent with
+                                           two since we had an implicit bit
+                                           which is lost + the extra overflow bit */
+        subcs   \exp, -2                /* Update exponent */
+.endm           
+ 
+/* Round single float number stored in [mant] and [exp] */
+.macro  round_sf        exp, mant, scratch
+        /* Round:       
+                For 0.5 we round to nearest even integer
+                for all other cases we round to nearest integer.
+                This means that if the digit left of the "point" (.)
+                is 1 we can add 0x80 to the mantissa since the
+                corner case 0x180 will round up to 0x200. If the
+                digit left of the "point" is 0 we will have to
+                add 0x7f since this will give 0xff and hence a
+                truncation/rounding downwards for the corner
+                case when the 9 lowest bits are 0x080 */
+        mov     \scratch, 0x7f  /* Set rounding constant */
+        /* Check if the mantissa is even or odd */
+        bld     \mant, 8
+        subeq   \scratch, -1    /* Rounding constant should be 0x80 */
+        add     \mant, \scratch
+        subcs   \exp, -2        /* Adjust exponent if we overflowed */          
+.endm
+ 
+                 
+ 
+/* Pack a single float number stored in [mant] and [exp]
+   into a single float number in [sf]  */
+.macro  pack_sf sf, exp, mant
+        bld     \mant,31                  /* implicit bit to z */
+        subne   \exp,1                   /* if subnormal (implicit bit 0)
+                                          adjust exponent to storage format */
+        
+        lsr     \sf, \mant, 7
+        bfins   \sf, \exp, 24, 8
+.endm   
+ 
+/* Pack exponent [exp] and mantissa [mant_hi, mant_lo]
+   into [df_hi, df_lo].  [df_hi] is shifted
+   one bit up so the sign bit can be shifted into it */
+        
+.macro  pack_df         exp, mant_lo, mant_hi, df_lo, df_hi
+        bld     \mant_hi,31                  /* implicit bit to z */
+        subne   \exp,1                   /* if subnormal (implicit bit 0)
+                                          adjust exponent to storage format */
+ 
+        lsr     \mant_lo,11                  /* shift back lsw */
+        or      \df_lo,\mant_lo,\mant_hi<<21          /* combine with low bits from msw */
+        lsl     \mant_hi,1                   /* get rid of implicit bit */
+        lsr     \mant_hi,11                  /* shift back msw except for one step*/
+        or      \df_hi,\mant_hi,\exp<<21          /* combine msw with exponent */
+.endm
+ 
+/* Normalize single float number stored in [mant] and [exp]
+   using scratch register [scratch] */
+.macro  normalize_sf    exp, mant, scratch
+        /* Adjust exponent and mantissa */
+        clz     \scratch, \mant
+        sub     \exp, \scratch
+        lsl     \mant, \mant, \scratch
+.endm
+ 
+/* Normalize the exponent and mantissa pair stored
+   in [mant_hi,mant_lo] and [exp]. Needs two scratch
+   registers [scratch1] and [scratch2]. */
+.macro  normalize_df            exp, mant_lo, mant_hi, scratch1, scratch2
+        clz     \scratch1,\mant_hi     /* Check if we have zeros in high bits */
+        breq    80f                     /* No need for scaling if no zeros in high bits */
+        brcs    81f                     /* Check for all zeros */           
+ 
+        /* shift amount is smaller than 32, and involves both msw and lsw*/
+        rsub    \scratch2,\scratch1,32  /* shift mantissa */
+        lsl     \mant_hi,\mant_hi,\scratch1
+        lsr     \scratch2,\mant_lo,\scratch2
+        or      \mant_hi,\scratch2
+        lsl     \mant_lo,\mant_lo,\scratch1
+        sub     \exp,\scratch1          /* adjust exponent */
+        rjmp    80f                     /* Finished */  
+81:
+        /* shift amount is greater than 32 */
+        clz     \scratch1,\mant_lo      /* shift mantissa */
+        movcs   \scratch1, 0
+        subcc   \scratch1,-32
+        lsl     \mant_hi,\mant_lo,\scratch1
+        mov     \mant_lo,0
+        sub     \exp,\scratch1          /* adjust exponent */
+80:     
+.endm
+        
+ 
+/* Fast but approximate multiply of two 64-bit numbers to give a 64 bit result.
+   The multiplication of [al]x[bl] is discarded.
+   Operands in [ah], [al], [bh], [bl].
+   Scratch registers in [sh], [sl].
+   Returns results in registers [rh], [rl].*/
+.macro  mul_approx_df   ah, al, bh, bl, rh, rl, sh, sl
+        mulu.d  \sl, \ah, \bl
+        macu.d  \sl, \al, \bh
+        mulu.d  \rl, \ah, \bh
+        add     \rl, \sh
+        acr     \rh
+.endm           
+ 
+ 
+        
+#if defined(L_avr32_f64_mul) || defined(L_avr32_f64_mul_fast)
+        .align  2
+#if defined(L_avr32_f64_mul)
+        .global __avr32_f64_mul
+        .type  __avr32_f64_mul,@function
+__avr32_f64_mul:
+#else 
+        .global __avr32_f64_mul_fast
+        .type  __avr32_f64_mul_fast,@function
+__avr32_f64_mul_fast:
+#endif                
+        or      r12, r10, r11 << 1 
+        breq   __avr32_f64_mul_op1_zero        
+
+#if defined(L_avr32_f64_mul)
+	pushm	r4-r7, lr
+#else
+        stm     --sp, r5,r6,r7,lr       
+#endif
+
+#define AVR32_F64_MUL_OP1_INT_BITS 1
+#define AVR32_F64_MUL_OP2_INT_BITS 10
+#define AVR32_F64_MUL_RES_INT_BITS 11
+	
+        /* op1 in {r11,r10}*/
+        /* op2 in {r9,r8}*/
+        eor     lr, r11, r9             /* MSB(lr) = Sign(op1) ^ Sign(op2) */
+ 
+        /* Unpack op1 to 1.63 format*/        
+        /* exp: r7 */
+        /* sf:  r11, r10 */
+	bfextu	r7, r11, 20, 11 /* Extract exponent */
+
+	mov	r5, 1
+
+        /* Check if normalization is needed */
+        breq    __avr32_f64_mul_op1_subnormal /*If number is subnormal, normalize it */ 
+
+        lsl     r11, (12-AVR32_F64_MUL_OP1_INT_BITS-1) /* Extract mantissa, leave room for implicit bit */ 
+        or      r11, r11, r10>>(32-(12-AVR32_F64_MUL_OP1_INT_BITS-1))
+        lsl     r10, (12-AVR32_F64_MUL_OP1_INT_BITS-1)
+	bfins	r11, r5, 32 - (1 + AVR32_F64_MUL_OP1_INT_BITS), 1 + AVR32_F64_MUL_OP1_INT_BITS /* Insert implicit bit */
+
+
+22:     
+        /* Unpack op2 to 10.54 format */
+        /* exp: r6 */
+        /* sf:  r9, r8 */
+	bfextu	r6, r9, 20, 11 /* Extract exponent */
+
+        /* Check if normalization is needed */
+        breq    __avr32_f64_mul_op2_subnormal /*If number is subnormal, normalize it */ 
+
+	lsl	r8, 1 /* Extract mantissa, leave room for implicit bit */
+	rol	r9	
+	bfins	r9, r5, 32 - (1 + AVR32_F64_MUL_OP2_INT_BITS), 1 + AVR32_F64_MUL_OP2_INT_BITS /* Insert implicit bit */
+
+23:     
+ 
+        /* Check if any operands are NaN or INF */
+        cp      r7, 0x7ff
+        breq    __avr32_f64_mul_op_nan_or_inf /* Check op1 for NaN or Inf */
+        cp      r6, 0x7ff
+        breq    __avr32_f64_mul_op_nan_or_inf  /* Check op2 for NaN or Inf */
+ 
+ 
+        /* Calculate new exponent in r12*/
+        add     r12, r7, r6
+        sub     r12, (1023-1)
+ 
+#if defined(L_avr32_f64_mul)
+	/* Do the multiplication.
+           Place result in [r11, r10, r7, r6]. The result is in 11.117 format.  */
+        mulu.d  r4, r11, r8
+        macu.d  r4, r10, r9
+        mulu.d  r6, r10, r8
+        mulu.d  r10, r11, r9
+	add	r7, r4
+	adc	r10, r10, r5	
+	acr	r11
+#else
+	/* Do the multiplication using approximate calculation. discard the al x bl
+	   calculation.
+           Place result in [r11, r10, r7]. The result is in 11.85 format.  */
+
+        /* Do the multiplication using approximate calculation.
+         Place result in r11, r10. Use r7, r6 as scratch registers */
+        mulu.d  r6, r11, r8
+        macu.d  r6, r10, r9
+        mulu.d  r10, r11, r9
+        add     r10, r7
+        acr     r11
+#endif 
+        /* Adjust exponent and mantissa */
+        /* [r12]:exp, [r11, r10]:mant [r7, r6]:sticky bits */
+        /* Mantissa may be of the format 00000000000.0xxx or 00000000000.1xxx. */
+        /* In the first case, shift one pos to left.*/
+        bld     r11, 32-AVR32_F64_MUL_RES_INT_BITS-1
+	breq	0f	
+	lsl	r7, 1
+	rol	r10
+	rol	r11
+	sub	r12, 1
+0:	
+        cp      r12, 0  
+        brle    __avr32_f64_mul_res_subnormal /*Result was subnormal.*/
+ 
+        /* Check for Inf. */
+        cp.w    r12, 0x7ff
+        brge    __avr32_f64_mul_res_inf
+
+	/* Insert exponent. */
+	bfins	r11, r12, 20, 11  
+
+        /* Result was not subnormal. Perform rounding. */
+        /* For the fast version we discard the sticky bits and always round
+	   the halfwaycase up. */
+24:	
+#if defined(L_avr32_f64_mul)
+	or	r6, r6, r10 << 31 /* Or in parity bit into stickybits */
+	or	r7, r7, r6 >> 1   /* Or together sticky and still make the msb 
+				     of r7 represent the halfway bit. */
+	eorh	r7, 0x8000	  /* Toggle halfway bit. */
+	/* We should now round up by adding one for the following cases:
+
+		halfway   sticky|parity  round-up
+		   0            x           no
+		   1            0           no
+	           1            1           yes
+
+	   Since we have inverted the halfway bit we can use the satu instruction
+           by saturating to 1 bit to implement this. 
+	*/ 
+	satu	r7 >> 0, 1
+#else
+	lsr	r7, 31
+#endif	
+	add	r10, r7
+	acr	r11	
+        
+        /* Insert sign bit*/
+        bld     lr, 31
+        bst     r11, 31
+        
+        /* Return result in [r11,r10] */
+#if defined(L_avr32_f64_mul)
+	popm	r4-r7, pc
+#else
+        ldm     sp++, r5, r6, r7,pc
+#endif
+ 
+ 
+__avr32_f64_mul_op1_subnormal:
+	andh	r11, 0x000f /* Remove sign bit and exponent */
+        clz     r12, r10    /* Count leading zeros in lsw */
+        clz     r6, r11     /* Count leading zeros in msw */
+        subcs	r12, -32 + AVR32_F64_MUL_OP1_INT_BITS 
+	movcs	r6, r12
+	subcc	r6, AVR32_F64_MUL_OP1_INT_BITS
+	cp.w	r6, 32
+	brge	0f
+		
+        /* shifting involves both msw and lsw*/
+        rsub    r12, r6, 32  /* shift mantissa */
+        lsl     r11, r11, r6
+        lsr     r12, r10, r12
+        or      r11, r12
+        lsl     r10, r10, r6
+	sub	r6, 12-AVR32_F64_MUL_OP1_INT_BITS
+        sub     r7, r6          /* adjust exponent */
+        rjmp    22b             /* Finished */  
+0:
+        /* msw is zero so only need to consider lsw */
+        lsl     r11, r10, r6
+	breq	__avr32_f64_mul_res_zero
+        mov     r10, 0
+	sub	r6, 12-AVR32_F64_MUL_OP1_INT_BITS
+        sub     r7, r6            /* adjust exponent */
+        rjmp    22b
+
+ 
+__avr32_f64_mul_op2_subnormal:
+	andh	r9, 0x000f  /* Remove sign bit and exponent */
+        clz     r12, r8    /* Count leading zeros in lsw */
+        clz     r5, r9     /* Count leading zeros in msw */
+        subcs	r12, -32 + AVR32_F64_MUL_OP2_INT_BITS 
+	movcs	r5, r12
+	subcc	r5, AVR32_F64_MUL_OP2_INT_BITS
+	cp.w	r5, 32
+	brge	0f
+		
+        /* shifting involves both msw and lsw*/
+        rsub    r12, r5, 32  /* shift mantissa */
+        lsl     r9, r9, r5
+        lsr     r12, r8, r12
+        or      r9, r12
+        lsl     r8, r8, r5
+	sub	r5, 12 - AVR32_F64_MUL_OP2_INT_BITS
+        sub     r6, r5          /* adjust exponent */
+        rjmp    23b             /* Finished */  
+0:
+        /* msw is zero so only need to consider lsw */
+        lsl     r9, r8, r5
+	breq	__avr32_f64_mul_res_zero
+        mov     r8, 0
+	sub	r5, 12 - AVR32_F64_MUL_OP2_INT_BITS
+        sub     r6, r5            /* adjust exponent */
+        rjmp    23b
+                
+ 
+__avr32_f64_mul_op_nan_or_inf:
+        /* Same code for OP1 and OP2*/
+        /* Since we are here, at least one of the OPs were NaN or INF*/
+	andh	r9, 0x000f  /* Remove sign bit and exponent */
+	andh	r11, 0x000f  /* Remove sign bit and exponent */
+        /* Merge the regs in each operand to check for zero*/
+        or      r11, r10 /* op1 */
+        or      r9, r8 /* op2 */
+        /* Check if op1 is NaN or INF */
+        cp      r7, 0x7ff
+        brne    __avr32_f64_mul_op1_not_naninf
+        /* op1 was NaN or INF.*/
+        cp      r11, 0
+        brne    __avr32_f64_mul_res_nan /* op1 was NaN. Result will be NaN*/
+        /*op1 was INF. check if op2 is NaN or INF*/
+        cp      r6, 0x7ff
+        brne    __avr32_f64_mul_res_inf /*op1 was INF, op2 was neither NaN nor INF*/
+        /* op1 is INF, op2 is either NaN or INF*/
+        cp      r9, 0
+        breq    __avr32_f64_mul_res_inf /*op2 was also INF*/
+        rjmp    __avr32_f64_mul_res_nan /*op2 was NaN*/
+ 
+__avr32_f64_mul_op1_not_naninf:
+        /* op1 was not NaN nor INF. Then op2 must be NaN or INF*/
+        cp      r9, 0
+        breq    __avr32_f64_mul_res_inf /*op2 was INF, return INF*/
+        rjmp   __avr32_f64_mul_res_nan /*else return NaN*/
+        
+__avr32_f64_mul_res_subnormal:/* Multiply result was subnormal. */
+#if defined(L_avr32_f64_mul)
+	/* Check how much we must scale down the mantissa. */
+	neg	r12
+	sub	r12, -1     /* We do no longer have an implicit bit. */
+	satu	r12 >> 0, 6 /* Saturate shift amount to max 63. */
+	cp.w	r12, 32
+	brge	0f
+	/* Shift amount <32 */
+	rsub	r8, r12, 32
+	or	r6, r7 
+	lsr	r7, r7, r12
+	lsl	r9, r10, r8
+	or	r7, r9
+	lsr	r10, r10, r12
+	lsl	r9, r11, r8
+	or	r10, r9
+	lsr	r11, r11, r12
+	rjmp	24b
+0:
+	/* Shift amount >=32 */
+	rsub	r8, r12, 32
+	moveq	r9, 0
+	breq	0f
+	lsl	r9, r11, r8
+0:	
+	or	r6, r7
+	or	r6, r6, r10 << 1 
+	lsr	r10, r10, r12
+	or	r7, r9, r10
+	lsr	r10, r11, r12
+	mov	r11, 0	
+	rjmp	24b				
+#else
+	/* Flush to zero for the fast version. */
+        mov     r11, lr /*Get correct sign*/
+        andh    r11, 0x8000, COH
+        mov     r10, 0
+        ldm     sp++, r5, r6, r7,pc
+#endif
+
+__avr32_f64_mul_res_zero:/* Multiply result is zero. */
+        mov     r11, lr /*Get correct sign*/
+        andh    r11, 0x8000, COH
+        mov     r10, 0
+#if defined(L_avr32_f64_mul)
+	popm	r4-r7, pc
+#else
+        ldm     sp++, r5, r6, r7,pc
+#endif
+ 
+__avr32_f64_mul_res_nan:        /* Return NaN. */
+        mov     r11, -1
+        mov     r10, -1
+#if defined(L_avr32_f64_mul)
+	popm	r4-r7, pc
+#else
+        ldm     sp++, r5, r6, r7,pc
+#endif
+        
+__avr32_f64_mul_res_inf:        /* Return INF. */
+	mov	r11, 0xfff00000
+        bld     lr, 31
+        bst     r11, 31
+        mov     r10, 0
+#if defined(L_avr32_f64_mul)
+	popm	r4-r7, pc
+#else
+        ldm     sp++, r5, r6, r7,pc
+#endif
+
+__avr32_f64_mul_op1_zero:
+        /* Get sign */
+        eor     r11, r11, r9
+        andh    r11, 0x8000, COH  
+        /* Check if op2 is Inf or NaN. */
+        bfextu  r12, r9, 20, 11
+        cp.w    r12, 0x7ff
+        retne   r12     /* Return 0.0 */
+        /* Return NaN */
+        mov     r10, -1
+        mov     r11, -1
+        ret     r12
+         
+
+ 
+#endif
+                
+ 
+#if  defined(L_avr32_f64_addsub) || defined(L_avr32_f64_addsub_fast)
+        .align  2
+
+__avr32_f64_sub_from_add:
+        /* Switch sign on op2 */
+        eorh    r9, 0x8000
+
+#if  defined(L_avr32_f64_addsub_fast)
+        .global __avr32_f64_sub_fast
+        .type  __avr32_f64_sub_fast,@function
+__avr32_f64_sub_fast:
+#else	
+        .global __avr32_f64_sub
+        .type  __avr32_f64_sub,@function
+__avr32_f64_sub:
+#endif
+        
+        /* op1 in {r11,r10}*/
+        /* op2 in {r9,r8}*/
+
+#if  defined(L_avr32_f64_addsub_fast)
+        /* If op2 is zero just return op1 */
+        or      r12, r8, r9 << 1
+        reteq   r12 
+#endif
+ 
+        /* Check signs */
+        eor     r12, r11, r9
+        /* Different signs, use addition. */
+        brmi    __avr32_f64_add_from_sub
+ 
+        stm     --sp, r5, r6, r7, lr
+ 
+        /* Get sign of op1 into r12 */
+        mov     r12, r11
+        andh    r12, 0x8000, COH                
+ 
+        /* Remove sign from operands */
+        cbr     r11, 31
+        cbr     r9, 31
+ 
+        /* Put the largest number in [r11, r10]
+           and the smallest number in [r9, r8] */
+        cp      r10, r8
+        cpc     r11, r9
+        brhs    1f /* Skip swap if operands already correctly ordered*/
+        /* Operands were not correctly ordered, swap them*/
+        mov     r7, r11
+        mov     r11, r9
+        mov     r9, r7
+        mov     r7, r10
+        mov     r10, r8
+        mov     r8, r7
+        eorh    r12, 0x8000 /* Invert sign in r12*/
+1:      
+        /* Unpack largest operand - opH */      
+        /* exp: r7 */
+        /* sf:  r11, r10 */
+        lsr     r7, r11, 20 /* Extract exponent */
+        lsl     r11, 11 /* Extract mantissa, leave room for implicit bit */ 
+        or      r11, r11, r10>>21
+        lsl     r10, 11
+        sbr     r11, 31 /* Insert implicit bit */
+ 
+        
+        /* Unpack smallest operand - opL */
+        /* exp: r6 */
+        /* sf:  r9, r8 */
+        lsr     r6, r9, 20 /* Extract exponent */
+        breq    __avr32_f64_sub_opL_subnormal /* If either zero or subnormal */
+        lsl     r9, 11 /* Extract mantissa, leave room for implicit bit */ 
+        or      r9, r9, r8>>21
+        lsl     r8, 11
+        sbr     r9, 31 /* Insert implicit bit */
+ 
+
+__avr32_f64_sub_opL_subnormal_done:     
+        /* opH is NaN or Inf. */
+        cp.w    r7, 0x7ff
+        breq    __avr32_f64_sub_opH_nan_or_inf
+
+        /* Get shift amount to scale mantissa of op2. */
+        rsub    r6, r7
+        breq    __avr32_f64_sub_shift_done /* No need to shift, exponents are equal*/
+ 
+        /* Scale mantissa [r9, r8] with amount [r6].
+        Uses scratch registers [r5] and [lr].
+        In IEEE mode:Must not forget the sticky bits we intend to shift out. */
+ 
+        rsub    r5,r6,32 /* get (32 - shift count)
+                            (if shift count > 32 we get a
+                            negative value, but that will
+                            work as well in the code below.) */
+ 
+        cp.w    r6,32       /* handle shifts >= 32 separately */
+        brhs    __avr32_f64_sub_longshift
+ 
+        /* small (<32) shift amount, both words are part of the shift
+           first remember whether part that is lost contains any 1 bits ... */
+        lsl     lr,r8,r5  /* shift away bits that are part of
+                             final mantissa. only part that goes
+                             to lr are bits that will be lost */
+ 
+        /* ... and now to the actual shift */
+        lsl     r5,r9,r5  /* get bits from msw destined for lsw*/
+        lsr     r8,r8,r6  /* shift down lsw of mantissa */
+        lsr     r9,r9,r6  /* shift down msw of mantissa */
+        or      r8,r5     /* combine these bits with prepared lsw*/
+#if  defined(L_avr32_f64_addsub)
+        cp.w    lr,0      /* if any '1' bit in part we lost ...*/
+        srne    lr
+        or      r8, lr     /* ... we need to set sticky bit*/
+#endif
+        
+__avr32_f64_sub_shift_done:     
+        /* Now subtract the mantissas. */
+        sub     r10, r8
+        sbc     r11, r11, r9
+ 
+        /* Normalize the exponent and mantissa pair stored in
+        [r11,r10] and exponent in [r7]. Needs two scratch registers [r6] and [lr]. */
+        clz     r6,r11     /* Check if we have zeros in high bits */
+        breq    __avr32_f64_sub_longnormalize_done  /* No need for scaling if no zeros in high bits */
+        brcs    __avr32_f64_sub_longnormalize
+ 
+	
+        /* shift amount is smaller than 32, and involves both msw and lsw*/
+        rsub    lr,r6,32  /* shift mantissa */
+        lsl     r11,r11,r6
+        lsr     lr,r10,lr
+        or      r11,lr
+        lsl     r10,r10,r6
+ 
+        sub     r7,r6    /* adjust exponent */
+        brle    __avr32_f64_sub_subnormal_result
+__avr32_f64_sub_longnormalize_done:     
+        
+#if defined(L_avr32_f64_addsub)
+        /* Insert the bits we will remove from the mantissa r9[31:21] */
+        lsl     r9, r10, (32 - 11)
+#else
+        /* Keep the last bit shifted out. */
+        bfextu  r9, r10, 10, 1
+#endif
+ 
+        /* Pack final result*/
+        /* Input: [r7]:exp, [r11, r10]:mant, [r12]:sign in MSB */
+        /* Result in [r11,r10] */
+        /* Insert mantissa */
+        lsr     r10, 11
+        or      r10, r10, r11<<21
+        lsr     r11, 11
+        /* Insert exponent and sign bit*/
+	bfins	r11, r7, 20, 11
+        or      r11, r12
+        
+        /* Round */     
+__avr32_f64_sub_round:
+#if defined(L_avr32_f64_addsub)
+	mov_imm	r7, 0x80000000
+        bld     r10, 0
+        subne   r7, -1  
+ 
+        cp.w    r9, r7
+        srhs    r9
+#endif
+        add     r10, r9
+        acr     r11
+        
+        /* Return result in [r11,r10] */
+        ldm     sp++, r5, r6, r7,pc
+ 
+ 
+ 
+__avr32_f64_sub_opL_subnormal:
+        /* Extract the of mantissa */
+        lsl     r9, 11 /* Extract mantissa, leave room for implicit bit */ 
+        or      r9, r9, r8>>21
+        lsl     r8, 11
+ 
+        /* Set exponent to 1 if we do not have a zero. */
+        or      lr, r9, r8
+        movne   r6,1
+	
+        /* Check if opH is also subnormal. If so, clear implicit bit in r11*/
+        rsub    lr, r7, 0
+        moveq   r7,1
+        bst     r11, 31
+	
+        /* Check if op1 is zero, if so set exponent to 0. */
+        or      lr, r11, r10
+        moveq   r7,0
+	                 
+        rjmp    __avr32_f64_sub_opL_subnormal_done
+ 
+__avr32_f64_sub_opH_nan_or_inf: 
+        /* Check if opH is NaN, if so return NaN */
+        cbr     r11, 31
+        or      lr, r11, r10
+        brne    __avr32_f64_sub_return_nan
+ 
+        /* opH is Inf. */
+        /* Check if opL is Inf. or NaN */
+        cp.w    r6, 0x7ff
+        breq    __avr32_f64_sub_return_nan
+	/* Return infinity with correct sign. */	
+	or      r11, r12, r7 << 20
+        ldm     sp++, r5, r6, r7, pc/* opL not Inf or NaN, return opH */
+__avr32_f64_sub_return_nan:     
+        mov     r10, -1 /* Generate NaN in r11, r10 */
+        mov     r11, -1
+        ldm     sp++, r5, r6, r7, pc/* opL Inf or NaN, return NaN */
+ 
+ 
+__avr32_f64_sub_subnormal_result:
+#if defined(L_avr32_f64_addsub)
+	/* Check how much we must scale down the mantissa. */
+	neg	r7
+	sub	r7, -1     /* We do no longer have an implicit bit. */
+	satu	r7 >> 0, 6 /* Saturate shift amount to max 63. */
+	cp.w	r7, 32
+	brge	0f
+	/* Shift amount <32 */
+	rsub	r8, r7, 32
+	lsl	r9, r10, r8
+	srne	r6
+	lsr	r10, r10, r7
+	or	r10, r6		/* Sticky bit from the
+				   part that was shifted out. */
+	lsl	r9, r11, r8
+	or	r10, r10, r9
+	lsr	r11, r10, r7
+	/* Set exponent */
+	mov	r7, 0
+	rjmp	__avr32_f64_sub_longnormalize_done
+0:
+	/* Shift amount >=32 */
+	rsub	r8, r7, 64
+	lsl	r9, r11, r8
+	or	r9, r10
+	srne	r6
+	lsr	r10, r11, r7
+	or	r10, r6		/* Sticky bit from the
+				   part that was shifted out. */
+	mov	r11, 0
+	/* Set exponent */
+	mov	r7, 0
+	rjmp	__avr32_f64_sub_longnormalize_done
+#else
+        /* Just flush subnormals to zero. */
+        mov     r10, 0
+        mov     r11, 0
+#endif
+        ldm     sp++, r5, r6, r7, pc
+ 
+__avr32_f64_sub_longshift:
+        /* large (>=32) shift amount, only lsw will have bits left after shift.
+           note that shift operations will use ((shift count=r6) mod 32) so
+           we do not need to subtract 32 from shift count. */
+        /* Saturate the shift amount to 63. If the amount
+           is any larger op2 is insignificant. */
+        satu    r6 >> 0, 6
+	
+#if defined(L_avr32_f64_addsub)
+        /* first remember whether part that is lost contains any 1 bits ... */
+	moveq	lr, r8	   /* If shift amount is 32, no bits from msw are lost. */
+	breq	0f
+        lsl     lr,r9,r5   /* save all lost bits from msw */
+        or      lr,r8      /* also save lost bits (all) from lsw
+                              now lr != 0 if we lose any bits */
+#endif  
+0:	
+        /* ... and now to the actual shift */
+        lsr     r8,r9,r6   /* Move msw to lsw and shift. */
+        mov     r9,0       /* clear msw */
+#if defined(L_avr32_f64_addsub)
+        cp.w    lr,0       /* if any '1' bit in part we lost ...*/
+        srne    lr
+        or      r8, lr      /* ... we need to set sticky bit*/
+#endif
+        rjmp    __avr32_f64_sub_shift_done
+ 
+__avr32_f64_sub_longnormalize:
+        /* shift amount is greater than 32 */
+        clz     r6,r10      /* shift mantissa */
+        /* If the resulting mantissa is zero the result is 
+           zero so force exponent to zero. */
+        movcs   r7, 0
+        movcs   r6, 0
+        movcs   r12, 0  /* Also clear sign bit. A zero result from subtraction
+			   always is +0.0 */
+        subcc   r6,-32
+        lsl     r11,r10,r6
+        mov     r10,0
+        sub     r7,r6          /* adjust exponent */
+        brle    __avr32_f64_sub_subnormal_result
+        rjmp    __avr32_f64_sub_longnormalize_done
+        
+ 
+        
+	 .align  2
+__avr32_f64_add_from_sub:
+        /* Switch sign on op2 */
+        eorh    r9, 0x8000
+
+#if defined(L_avr32_f64_addsub_fast)
+        .global __avr32_f64_add_fast
+        .type  __avr32_f64_add_fast,@function
+__avr32_f64_add_fast:
+#else	
+        .global __avr32_f64_add
+        .type  __avr32_f64_add,@function
+__avr32_f64_add:
+#endif
+        
+        /* op1 in {r11,r10}*/
+        /* op2 in {r9,r8}*/
+ 
+#if defined(L_avr32_f64_addsub_fast)
+        /* If op2 is zero just return op1 */
+        or      r12, r8, r9 << 1
+        reteq   r12 
+#endif
+
+        /* Check signs */
+        eor     r12, r11, r9
+        /* Different signs, use subtraction. */
+        brmi    __avr32_f64_sub_from_add
+ 
+        stm     --sp, r5, r6, r7, lr
+ 
+        /* Get sign of op1 into r12 */
+        mov     r12, r11
+        andh    r12, 0x8000, COH                
+ 
+        /* Remove sign from operands */
+        cbr     r11, 31
+        cbr     r9, 31
+ 
+        /* Put the number with the largest exponent in [r11, r10]
+           and the number with the smallest exponent in [r9, r8] */
+        cp      r11, r9
+        brhs    1f /* Skip swap if operands already correctly ordered */
+        /* Operands were not correctly ordered, swap them */
+        mov     r7, r11
+        mov     r11, r9
+        mov     r9, r7
+        mov     r7, r10
+        mov     r10, r8
+        mov     r8, r7
+1:      
+	mov	lr, 0 /* Set sticky bits to zero */
+        /* Unpack largest operand - opH */      
+        /* exp: r7 */
+        /* sf:  r11, r10 */
+	bfextu	R7, R11, 20, 11 /* Extract exponent */
+	bfextu	r11, r11, 0, 20 /* Extract mantissa */
+        sbr     r11, 20 /* Insert implicit bit */
+ 
+        /* Unpack smallest operand - opL */
+        /* exp: r6 */
+        /* sf:  r9, r8 */
+	bfextu	R6, R9, 20, 11	/* Extract exponent */
+	breq	__avr32_f64_add_op2_subnormal
+	bfextu	r9, r9, 0, 20   /* Extract mantissa */
+        sbr     r9, 20		/* Insert implicit bit */
+
+2:		 
+        /* opH is NaN or Inf. */
+        cp.w    r7, 0x7ff
+        breq    __avr32_f64_add_opH_nan_or_inf
+
+        /* Get shift amount to scale mantissa of op2. */
+        rsub    r6, r7
+        breq    __avr32_f64_add_shift_done /* No need to shift, exponents are equal*/
+ 
+        /* Scale mantissa [r9, r8] with amount [r6].
+        Uses scratch registers [r5] and [lr].
+        In IEEE mode:Must not forget the sticky bits we intend to shift out. */
+        rsub    r5,r6,32 /* get (32 - shift count)
+                            (if shift count > 32 we get a
+                            negative value, but that will
+                            work as well in the code below.) */
+ 
+        cp.w    r6,32       /* handle shifts >= 32 separately */
+        brhs    __avr32_f64_add_longshift
+ 
+        /* small (<32) shift amount, both words are part of the shift
+           first remember whether part that is lost contains any 1 bits ... */
+        lsl     lr,r8,r5  /* shift away bits that are part of
+                             final mantissa. only part that goes
+                             to lr are bits that will be lost */
+ 
+        /* ... and now to the actual shift */
+        lsl     r5,r9,r5  /* get bits from msw destined for lsw*/
+        lsr     r8,r8,r6  /* shift down lsw of mantissa */
+        lsr     r9,r9,r6  /* shift down msw of mantissa */
+        or      r8,r5     /* combine these bits with prepared lsw*/
+        
+__avr32_f64_add_shift_done:     
+        /* Now add the mantissas. */
+        add     r10, r8
+        adc     r11, r11, r9
+
+        /* Check if we overflowed. */
+	bld	r11, 21 
+        breq	__avr32_f64_add_res_of:
+
+__avr32_f64_add_res_of_done:    
+        
+        /* Pack final result*/
+        /* Input: [r7]:exp, [r11, r10]:mant, [r12]:sign in MSB */
+        /* Result in [r11,r10] */
+        /* Insert exponent and sign bit*/
+	bfins	r11, r7, 20, 11
+	or	r11, r12
+        
+        /* Round */     
+__avr32_f64_add_round:
+#if defined(L_avr32_f64_addsub)
+	bfextu	r12, r10, 0, 1 /* Extract parity bit.*/
+	or	lr, r12	       /* or it together with the sticky bits. */	
+	eorh	lr, 0x8000     /* Toggle round bit. */	
+	/* We should now round up by adding one for the following cases:
+
+		halfway   sticky|parity  round-up
+		   0            x           no
+		   1            0           no
+	           1            1           yes
+
+	   Since we have inverted the halfway bit we can use the satu instruction
+           by saturating to 1 bit to implement this. 
+	*/ 
+	satu	lr >> 0, 1
+#else
+	lsr	lr, 31
+#endif
+        add     r10, lr
+        acr     r11
+        
+        /* Return result in [r11,r10] */
+        ldm     sp++, r5, r6, r7,pc
+ 
+  
+__avr32_f64_add_opH_nan_or_inf: 
+        /* Check if opH is NaN, if so return NaN */
+        cbr     r11, 20
+        or      lr, r11, r10
+        brne    __avr32_f64_add_return_nan
+ 
+        /* opH is Inf. */
+        /* Check if opL is Inf. or NaN */
+        cp.w    r6, 0x7ff
+        breq    __avr32_f64_add_opL_nan_or_inf
+        ldm     sp++, r5, r6, r7, pc/* opL not Inf or NaN, return opH */
+__avr32_f64_add_opL_nan_or_inf:
+        cbr     r9, 20
+        or      lr, r9, r8
+        brne    __avr32_f64_add_return_nan
+        mov     r10, 0  /* Generate Inf in r11, r10 */
+	mov_imm r11, 0x7ff00000
+        or      r11, r12 /* Put sign bit back */
+        ldm     sp++, r5, r6, r7, pc/* opL Inf, return Inf */
+__avr32_f64_add_return_nan:     
+        mov     r10, -1 /* Generate NaN in r11, r10 */
+        mov     r11, -1
+        ldm     sp++, r5, r6, r7, pc/* opL Inf or NaN, return NaN */
+ 
+ 
+__avr32_f64_add_longshift:
+        /* large (>=32) shift amount, only lsw will have bits left after shift.
+           note that shift operations will use ((shift count=r6) mod 32) so
+           we do not need to subtract 32 from shift count. */
+        /* Saturate the shift amount to 63. If the amount
+           is any larger op2 is insignificant. */
+        satu    r6 >> 0, 6
+	/* If shift amount is 32 there are no bits from the msw that are lost. */
+	moveq	lr, r8
+	breq	0f	
+        /* first remember whether part that is lost contains any 1 bits ... */
+        lsl     lr,r9,r5   /* save all lost bits from msw */
+#if defined(L_avr32_f64_addsub)
+	cp.w	r8, 0
+	srne	r8	
+        or      lr,r8      /* also save lost bits (all) from lsw
+                              now lr != 0 if we lose any bits */
+#endif  
+0:	
+        /* ... and now to the actual shift */
+        lsr     r8,r9,r6   /* msw -> lsw and make rest of shift inside lsw*/
+        mov     r9,0       /* clear msw */
+        rjmp    __avr32_f64_add_shift_done
+ 
+__avr32_f64_add_res_of:
+	/* We overflowed. Scale down mantissa by shifting right one position. */
+	or	lr, lr, lr << 1 /* Remember stickybits*/
+	lsr	r11, 1
+	ror	r10
+	ror	lr
+	sub	r7, -1	/* Increment exponent */
+ 
+        /* Clear mantissa to set result to Inf if the exponent is 255. */
+        cp.w    r7, 0x7ff
+        moveq   r10, 0
+        moveq   r11, 0
+        moveq   lr, 0
+        rjmp    __avr32_f64_add_res_of_done
+        
+__avr32_f64_add_op2_subnormal:	
+	/* Set epxponent to 1 */
+	mov	r6, 1
+
+	/* Check if op2 is also subnormal. */
+	cp.w	r7, 0
+	brne	2b
+
+	cbr	r11, 20
+	/* Both operands are subnormal. Just addd the mantissas
+	   and the exponent will automatically be set to 1 if
+	   we overflow into a normal number. */
+	add	r10, r8
+	adc	r11, r11, r9
+
+	/* Add sign bit */
+	or	r11, r12
+	
+        /* Return result in [r11,r10] */
+        ldm     sp++, r5, r6, r7,pc
+	
+			
+	 
+#endif
+ 
+#ifdef L_avr32_f64_to_u32
+        /* This goes into L_fixdfsi */
+#endif
+        
+ 
+#ifdef L_avr32_f64_to_s32
+        .global __avr32_f64_to_u32
+        .type  __avr32_f64_to_u32,@function
+__avr32_f64_to_u32:
+        cp.w    r11, 0
+        retmi   0       /* Negative returns 0 */
+ 
+        /* Fallthrough to df to signed si conversion */ 
+        .global __avr32_f64_to_s32
+        .type  __avr32_f64_to_s32,@function
+__avr32_f64_to_s32:
+        lsl     r12,r11,1
+        lsr     r12,21                  /* extract exponent*/
+        sub     r12,1023                /* convert to unbiased exponent.*/
+        retlo   0                       /* too small exponent implies zero. */
+ 
+1:      
+        rsub    r12,r12,31              /* shift count = 31 - exponent */
+        mov     r9,r11                  /* save sign for later...*/
+        lsl     r11,11                  /* remove exponent and sign*/
+        sbr     r11,31                  /* add implicit bit*/
+        or      r11,r11,r10>>21         /* get rest of bits from lsw of double */
+        lsr     r11,r11,r12             /* shift down mantissa to final place */
+        lsl     r9,1                    /* sign -> carry */
+        retcc   r11                     /* if positive, we are done */
+        neg     r11                     /* if negative float, negate result */
+        ret     r11
+ 
+#endif  /* L_fixdfsi*/
+ 
+#ifdef L_avr32_f64_to_u64
+        /* Actual function is in L_fixdfdi */
+#endif
+        
+#ifdef L_avr32_f64_to_s64
+        .global __avr32_f64_to_u64
+        .type  __avr32_f64_to_u64,@function
+__avr32_f64_to_u64:
+        cp.w    r11,0
+        /* Negative numbers return zero */
+        movmi   r10, 0
+        movmi   r11, 0
+        retmi   r11
+ 
+        
+ 
+        /* Fallthrough */
+        .global __avr32_f64_to_s64
+        .type  __avr32_f64_to_s64,@function
+__avr32_f64_to_s64:
+        lsl     r9,r11,1
+        lsr     r9,21                   /* get exponent*/
+        sub     r9,1023                 /* convert to correct range*/
+        /* Return zero if exponent to small */
+        movlo   r10, 0
+        movlo   r11, 0
+        retlo   r11
+ 
+        mov     r8,r11                  /* save sign for later...*/
+1:      
+        lsl     r11,11                  /* remove exponent */
+        sbr     r11,31                  /* add implicit bit*/
+        or      r11,r11,r10>>21         /* get rest of bits from lsw of double*/
+        lsl     r10,11                  /* align lsw correctly as well */
+        rsub    r9,r9,63                /* shift count = 63 - exponent */
+        breq    1f
+ 
+        cp.w    r9,32                   /* is shift count more than one reg? */
+        brhs    0f
+ 
+        mov     r12,r11                 /* save msw */
+        lsr     r10,r10,r9              /* small shift count, shift down lsw */
+        lsr     r11,r11,r9              /* small shift count, shift down msw */
+        rsub    r9,r9,32                /* get 32-size of shifted out tail */
+        lsl     r12,r12,r9              /* align part to move from msw to lsw */
+        or      r10,r12                 /* combine to get new lsw */
+        rjmp    1f
+ 
+0:
+        lsr     r10,r11,r9              /* large shift count,only lsw get bits
+                                           note that shift count is modulo 32*/
+        mov     r11,0                   /* msw will be 0 */
+ 
+1:
+        lsl     r8,1                    /* sign -> carry */
+        retcc   r11                     /* if positive, we are done */
+ 
+        neg     r11                     /* if negative float, negate result */
+        neg     r10
+        scr     r11
+        ret     r11 
+ 
+#endif
+ 
+#ifdef L_avr32_u32_to_f64
+        /* Code located in L_floatsidf */
+#endif
+        
+#ifdef L_avr32_s32_to_f64
+        .global __avr32_u32_to_f64
+        .type  __avr32_u32_to_f64,@function
+__avr32_u32_to_f64:
+        sub     r11, r12, 0 /* Move to r11 and force Z flag to be updated */
+        mov     r12, 0      /* always positive */
+        rjmp    0f          /* Jump to common code for floatsidf */
+        
+        .global __avr32_s32_to_f64
+        .type  __avr32_s32_to_f64,@function
+__avr32_s32_to_f64:
+        mov     r11, r12        /* Keep original value in r12 for sign */
+        abs     r11             /* Absolute value if r12 */
+0:      
+        mov     r10,0           /* let remaining bits be zero */
+        reteq   r11             /* zero long will return zero float */
+ 
+        pushm   lr
+        mov     r9,31+1023              /* set exponent */
+                
+        normalize_df    r9 /*exp*/, r10, r11 /* mantissa */, r8, lr /* scratch */
+ 
+        /* Check if a subnormal result was created */
+        cp.w    r9, 0
+        brgt    0f
+        
+        adjust_subnormal_df     r9 /* exp */, r10, r11 /* Mantissa */, r12 /*sign*/, r8, lr /* scratch */
+        popm    pc
+0:
+        
+        /* Round result */
+        round_df        r9 /*exp*/, r10, r11 /* Mantissa */, r8 /*scratch*/
+        cp.w    r9,0x7ff
+        brlt    0f
+        /*Return infinity */
+        mov     r10, 0
+	mov_imm	r11, 0xffe00000
+        rjmp    __floatsidf_return_op1
+        
+0:
+ 
+        /* Pack */
+        pack_df r9 /*exp*/, r10, r11 /* mantissa */, r10, r11 /* Output df number*/
+__floatsidf_return_op1: 
+        lsl     r12,1                  /* shift in sign bit */
+        ror     r11
+ 
+        popm    pc
+#endif
+ 
+ 
+#ifdef L_avr32_f32_cmp_eq
+        .global __avr32_f32_cmp_eq
+        .type  __avr32_f32_cmp_eq,@function
+__avr32_f32_cmp_eq:     
+        cp.w    r12, r11
+        breq    0f      
+        /* If not equal check for +/-0 */
+        /* Or together the two values and shift out the sign bit.
+           If the result is zero, then the two values are both zero. */
+        or      r12, r11
+        lsl     r12, 1
+        reteq   1
+        ret     0
+0:                      
+        /* Numbers were equal. Check for NaN or Inf */
+	mov_imm	r11, 0xff000000
+        lsl     r12, 1
+        cp.w    r12, r11
+        retls   1     /* 0 if NaN, 1 otherwise */
+        ret     0     
+#endif
+        
+#if defined(L_avr32_f32_cmp_ge) || defined(L_avr32_f32_cmp_lt)
+#ifdef L_avr32_f32_cmp_ge
+        .global __avr32_f32_cmp_ge
+        .type  __avr32_f32_cmp_ge,@function
+__avr32_f32_cmp_ge:
+#endif  
+#ifdef L_avr32_f32_cmp_lt
+        .global __avr32_f32_cmp_lt
+        .type  __avr32_f32_cmp_lt,@function
+__avr32_f32_cmp_lt:
+#endif  
+        lsl     r10, r12, 1     /* Remove sign bits */
+        lsl     r9, r11, 1
+	subfeq	r10, 0
+#ifdef L_avr32_f32_cmp_ge
+	reteq	1		/* Both number are zero. Return true. */
+#endif	
+#ifdef L_avr32_f32_cmp_lt
+	reteq	0		/* Both number are zero. Return false. */
+#endif	
+	mov_imm	r8, 0xff000000
+        cp.w    r10, r8
+        rethi   0               /* Op0 is NaN */                
+        cp.w    r9, r8
+        rethi   0               /* Op1 is Nan */
+ 
+        eor     r8, r11, r12
+        bld     r12, 31
+#ifdef L_avr32_f32_cmp_ge
+        srcc    r8      /* Set result to true if op0 is positive*/
+#endif
+#ifdef L_avr32_f32_cmp_lt
+        srcs    r8      /* Set result to true if op0 is negative*/
+#endif
+        retmi   r8      /* Return if signs are different */
+        brcs    0f      /* Both signs negative? */
+ 
+        /* Both signs positive */
+        cp.w    r12, r11
+#ifdef L_avr32_f32_cmp_ge
+        reths    1
+        retlo    0
+#endif
+#ifdef L_avr32_f32_cmp_lt
+        reths    0
+        retlo    1
+#endif
+0:
+        /* Both signs negative */
+        cp.w    r11, r12
+#ifdef L_avr32_f32_cmp_ge
+        reths    1
+        retlo    0
+#endif
+#ifdef L_avr32_f32_cmp_lt
+        reths    0
+        retlo    1
+#endif
+#endif
+        
+ 
+#ifdef L_avr32_f64_cmp_eq
+        .global __avr32_f64_cmp_eq
+        .type  __avr32_f64_cmp_eq,@function
+__avr32_f64_cmp_eq:     
+        cp.w    r10,r8
+        cpc     r11,r9
+        breq    0f
+        
+        /* Args were not equal*/
+        /* Both args could be zero with different sign bits */
+        lsl     r11,1                   /* get rid of sign bits */
+        lsl     r9,1
+        or      r11,r10                 /* Check if all bits are zero */
+        or      r11,r9
+        or      r11,r8
+        reteq   1                       /* If all zeros the arguments are equal
+                                           so return 1 else return 0 */
+        ret     0
+0:      
+        /* check for NaN */
+        lsl     r11,1
+	mov_imm	r12, 0xffe00000
+        cp.w    r10,0
+        cpc     r11,r12                 /* check if nan or inf */
+        retls   1                       /* If Arg is NaN return 0 else 1*/
+        ret     0                       /* Return  */
+ 
+#endif
+ 
+ 
+#if   defined(L_avr32_f64_cmp_ge) || defined(L_avr32_f64_cmp_lt)
+ 
+#ifdef L_avr32_f64_cmp_ge
+        .global __avr32_f64_cmp_ge
+        .type  __avr32_f64_cmp_ge,@function
+__avr32_f64_cmp_ge:
+#endif  
+#ifdef L_avr32_f64_cmp_lt
+        .global __avr32_f64_cmp_lt
+        .type  __avr32_f64_cmp_lt,@function
+__avr32_f64_cmp_lt:
+#endif  
+ 
+        /* compare magnitude of op1 and op2 */
+        st.w    --sp, lr
+        st.w    --sp, r7
+        lsl     r11,1                   /* Remove sign bit of op1 */
+        srcs    r12                     /* Sign op1 to lsb of r12*/
+        lsl     r9,1                    /* Remove sign bit of op2 */
+        srcs    r7
+        rol     r12                     /* Sign op2 to lsb of lr, sign bit op1 bit 1 of r12*/
+	
+ 
+        /* Check for Nan */
+        mov_imm lr, 0xffe00000
+        cp.w    r10,0
+        cpc     r11,lr
+        brhi    0f      /* We have NaN */
+        cp.w    r8,0
+        cpc     r9,lr
+        brhi    0f      /* We have NaN */
+
+        cp.w    r11, 0
+        subfeq  r10, 0
+        breq    3f			/* op1 zero */
+        ld.w    r7, sp++
+        ld.w    lr, sp++
+
+        cp.w    r12,3                   /* both operands negative ?*/    
+        breq    1f
+ 
+        cp.w    r12,1                   /* both operands positive? */
+        brlo    2f
+ 
+        /* Different signs. If sign of op1 is negative the difference
+           between op1 and op2 will always be negative, and if op1 is
+           positive the difference will always be positive */           
+#ifdef L_avr32_f64_cmp_ge
+	reteq	1
+	retne	0
+#endif
+#ifdef L_avr32_f64_cmp_lt
+	reteq	0
+	retne	1
+#endif
+  
+2:
+        /* Both operands positive. Just compute the difference */
+        cp.w    r10,r8
+        cpc     r11,r9
+#ifdef L_avr32_f64_cmp_ge
+	reths	1
+	retlo	0
+#endif
+#ifdef L_avr32_f64_cmp_lt
+	reths	0
+	retlo	1
+#endif
+                
+1:
+        /* Both operands negative. Compute the difference with operands switched */
+        cp     r8,r10
+        cpc    r9,r11
+#ifdef L_avr32_f64_cmp_ge
+	reths	1
+	retlo	0
+#endif
+#ifdef L_avr32_f64_cmp_lt
+	reths	0
+	retlo	1
+#endif
+
+0:      
+        ld.w    r7, sp++
+        popm    pc, r12=0
+ 
+3:
+        cp.w    r7, 1          /* Check sign bit from r9 */
+#ifdef L_avr32_f64_cmp_ge
+        sreq    r12		       /* If op2 is negative then op1 >= op2. */	
+#endif
+#ifdef L_avr32_f64_cmp_lt
+        srne    r12		       /* If op2 is positve then op1 <= op2. */
+#endif
+        cp.w    r9, 0
+        subfeq  r8, 0
+        ld.w    r7, sp++
+        ld.w    lr, sp++
+#ifdef L_avr32_f64_cmp_ge
+	reteq	1		       /* Both operands are zero. Return true. */
+#endif
+#ifdef L_avr32_f64_cmp_lt
+	reteq	0		       /* Both operands are zero. Return false. */
+#endif
+	ret	r12
+#endif
+			        
+#if defined(L_avr32_f64_div) || defined(L_avr32_f64_div_fast)
+        .align  2
+
+#if defined(L_avr32_f64_div_fast)
+        .global __avr32_f64_div_fast
+        .type  __avr32_f64_div_fast,@function
+__avr32_f64_div_fast:
+#else
+        .global __avr32_f64_div
+        .type  __avr32_f64_div,@function
+__avr32_f64_div:
+#endif
+        stm     --sp, r0, r1, r2, r3, r4, r5, r6, r7,lr 
+        /* op1 in {r11,r10}*/
+        /* op2 in {r9,r8}*/
+        eor     lr, r11, r9             /* MSB(lr) = Sign(op1) ^ Sign(op2) */
+ 
+        
+        /* Unpack op1 to 2.62 format*/  
+        /* exp: r7 */
+        /* sf:  r11, r10 */
+        lsr     r7, r11, 20 /* Extract exponent */
+                
+        lsl     r11, 9 /* Extract mantissa, leave room for implicit bit */ 
+        or      r11, r11, r10>>23
+        lsl     r10, 9
+        sbr     r11, 29 /* Insert implicit bit */
+        andh    r11, 0x3fff /*Mask last part of exponent since we use 2.62 format*/
+ 
+        cbr     r7, 11       /* Clear sign bit */
+        /* Check if normalization is needed */
+        breq    11f /*If number is subnormal, normalize it */
+22:     
+        cp      r7, 0x7ff
+        brge    2f  /* Check op1 for NaN or Inf */
+
+        /* Unpack op2 to 2.62 format*/
+        /* exp: r6 */
+        /* sf:  r9, r8 */
+        lsr     r6, r9, 20 /* Extract exponent */
+                
+        lsl     r9, 9 /* Extract mantissa, leave room for implicit bit */ 
+        or      r9, r9, r8>>23
+        lsl     r8, 9
+        sbr     r9, 29 /* Insert implicit bit */
+        andh    r9, 0x3fff /*Mask last part of exponent since we use 2.62 format*/
+ 
+        cbr     r6, 11       /* Clear sign bit */
+        /* Check if normalization is needed */
+        breq    13f /*If number is subnormal, normalize it */
+23:             
+        cp      r6, 0x7ff
+        brge    3f  /* Check op2 for NaN or Inf */
+
+        /* Calculate new exponent */
+        sub     r7, r6
+        sub     r7,-1023
+ 
+        /* Divide */
+        /* Approximating 1/d with the following recurrence: */
+        /* R[j+1] = R[j]*(2-R[j]*d) */
+        /* Using 2.62 format */
+        /* TWO:  r12 */
+        /* d = op2 = divisor (2.62 format): r9,r8 */
+        /* Multiply result :     r5, r4 */
+        /* Initial guess :       r3, r2 */
+        /* New approximations :  r3, r2 */
+        /* op1 = Dividend (2.62 format) : r11, r10 */
+ 
+	mov_imm	r12, 0x80000000
+         
+        /* Load initial guess, using look-up table */
+        /* Initial guess is of format 01.XY, where XY is constructed as follows: */
+        /* Let d be of following format: 00.1xy....., then XY=~xy */
+        /* For d=00.100 = 0,5   -> initial guess=01.11 = 1,75 */
+        /* For d=00.101 = 0,625 -> initial guess=01.11 = 1,5  */
+        /* For d=00.110 = 0,75  -> initial guess=01.11 = 1,25 */
+        /* For d=00.111 = 0,875 -> initial guess=01.11 = 1,0  */
+        /* r2 is also part of the reg pair forming initial guess, but it*/
+        /* is kept uninitialized to save one cycle since it has so low significance*/
+ 
+        lsr     r3, r12, 1
+        bfextu  r4, r9, 27, 2
+        com     r4
+        bfins   r3, r4, 28, 2
+ 
+        /* First approximation */
+        /* Approximating to 32 bits */
+        /* r5 = R[j]*d */
+        mulu.d  r4, r3, r9
+        /* r5 = 2-R[j]*d */
+        sub    r5, r12, r5<<2
+        /* r3 = R[j]*(2-R[j]*d) */
+        mulu.d  r4, r3, r5
+        lsl     r3, r5, 2
+         
+        /* Second approximation */
+        /* Approximating to 32 bits */
+        /* r5 = R[j]*d */
+        mulu.d  r4, r3, r9
+        /* r5 = 2-R[j]*d */
+        sub    r5, r12, r5<<2
+        /* r3 = R[j]*(2-R[j]*d) */
+        mulu.d  r4, r3, r5
+        lsl     r3, r5, 2
+         
+        /* Third approximation */
+        /* Approximating to 32 bits */
+        /* r5 = R[j]*d */
+        mulu.d  r4, r3, r9
+        /* r5 = 2-R[j]*d */
+        sub    r5, r12, r5<<2
+        /* r3 = R[j]*(2-R[j]*d) */
+        mulu.d  r4, r3, r5
+        lsl     r3, r5, 2
+ 
+        /* Fourth approximation */
+        /* Approximating to 64 bits */
+        /* r5,r4 = R[j]*d */
+        mul_approx_df        r3 /*ah*/, r2 /*al*/, r9 /*bh*/, r8 /*bl*/, r5 /*rh*/, r4 /*rl*/, r1 /*sh*/, r0 /*sl*/
+        lsl    r5, 2
+        or     r5, r5, r4>>30
+        lsl    r4, 2
+        /* r5,r4 = 2-R[j]*d */
+        neg    r4
+        sbc    r5, r12, r5
+        /* r3,r2 = R[j]*(2-R[j]*d) */
+        mul_approx_df        r3 /*ah*/, r2 /*al*/, r5 /*bh*/, r4 /*bl*/, r5 /*rh*/, r4 /*rl*/, r1 /*sh*/, r0 /*sl*/
+        lsl    r3, r5, 2
+        or     r3, r3, r4>>30
+        lsl    r2, r4, 2
+ 
+ 
+        /* Fifth approximation */
+        /* Approximating to 64 bits */
+        /* r5,r4 = R[j]*d */
+        mul_approx_df        r3 /*ah*/, r2 /*al*/, r9 /*bh*/, r8 /*bl*/, r5 /*rh*/, r4 /*rl*/, r1 /*sh*/, r0 /*sl*/
+        lsl    r5, 2
+        or     r5, r5, r4>>30
+        lsl    r4, 2
+        /* r5,r4 = 2-R[j]*d */
+        neg    r4
+        sbc    r5, r12, r5
+        /* r3,r2 = R[j]*(2-R[j]*d) */
+        mul_approx_df        r3 /*ah*/, r2 /*al*/, r5 /*bh*/, r4 /*bl*/, r5 /*rh*/, r4 /*rl*/, r1 /*sh*/, r0 /*sl*/
+        lsl    r3, r5, 2
+        or     r3, r3, r4>>30
+        lsl    r2, r4, 2
+ 
+ 
+        /* Multiply with dividend to get quotient */
+        mul_approx_df        r3 /*ah*/, r2 /*al*/, r11 /*bh*/, r10 /*bl*/, r3 /*rh*/, r2 /*rl*/, r1 /*sh*/, r0 /*sl*/
+ 
+ 
+        /* To increase speed, this result is not corrected before final rounding.*/
+        /* This may give a difference to IEEE compliant code of 1 ULP.*/
+		
+ 
+        /* Adjust exponent and mantissa */
+        /* r7:exp, [r3, r2]:mant, [r5, r4]:scratch*/
+        /* Mantissa may be of the format 0.xxxx or 1.xxxx. */
+        /* In the first case, shift one pos to left.*/
+        bld     r3, 31-3
+	breq	0f
+	lsl	r2, 1
+	rol	r3
+	sub	r7, 1
+#if defined(L_avr32_f64_div)
+	/* We must scale down the dividend to 5.59 format. */
+	lsr	r10, 3
+	or	r10, r10, r11 << 29
+	lsr	r11, 3
+	rjmp    1f
+#endif	
+0:	
+#if defined(L_avr32_f64_div)
+	/* We must scale down the dividend to 6.58 format. */
+	lsr	r10, 4
+	or	r10, r10, r11 << 28
+	lsr	r11, 4
+1:	
+#endif
+        cp      r7, 0   
+        brle    __avr32_f64_div_res_subnormal /* Result was subnormal. */
+ 
+ 
+#if defined(L_avr32_f64_div)
+	/* In order to round correctly we calculate the remainder:	
+	   Remainder = dividend[11:r10] - divisor[r9:r8]*quotient[r3:r2] 
+	   for the case when the quotient is halfway between the round-up
+	   value and the round down value. If the remainder then is negative
+	   it means that the quotient was to big and that it should not be
+           rounded up, if the remainder is positive the quotient was to small
+	   and we need to round up. If the remainder is zero it means that the
+	   quotient is exact but since we need to remove the guard bit we should
+	   round to even. */
+
+	/* Truncate and add guard bit. */
+	andl	r2, 0xff00
+	orl	r2, 0x0080	
+	
+
+	/* Now do the multiplication. The quotient has the format 4.60
+	   while the divisor has the format 2.62 which gives a result
+	   of 6.58 */
+        mulu.d  r0, r3, r8
+        macu.d  r0, r2, r9
+        mulu.d  r4, r2, r8
+        mulu.d  r8, r3, r9
+	add	r5, r0
+	adc	r8, r8, r1	
+	acr	r9
+
+
+	/* Check if remainder is positive, negative or equal. */
+	bfextu	r12, r2, 8, 1  /* Get parity bit into bit 0 of r0 */ 
+	cp	r4, 0
+	cpc	r5
+__avr32_f64_div_round_subnormal:	
+	cpc	r8, r10
+	cpc	r9, r11
+	srlo	r6	/* Remainder positive:	 we need to round up.*/
+	moveq	r6, r12  /* Remainder zero:	 round up if mantissa odd. */
+#else
+	bfextu	r6, r2, 7, 1  /* Get guard bit */ 	
+#endif
+	/* Final packing, scale down mantissa. */
+	lsr	r10, r2, 8
+        or      r10, r10, r3<<24
+        lsr     r11, r3, 8
+	/* Insert exponent and sign bit*/
+	bfins	r11, r7, 20, 11
+        bld     lr, 31
+        bst     r11, 31
+
+	/* Final rounding */
+	add	r10, r6
+	acr	r11		
+	        
+        /* Return result in [r11,r10] */
+        ldm     sp++, r0, r1, r2, r3, r4, r5, r6, r7,pc
+ 
+                
+2:
+        /* Op1 is NaN or inf */
+        andh    r11, 0x000f /* Extract mantissa */
+        or      r11, r10
+        brne    16f     /* Return NaN if op1 is NaN */
+        /* Op1 is inf check op2 */
+        lsr     r6, r9, 20 /* Extract exponent */
+        cbr     r6, 11      /* Clear sign bit */
+        cp      r6, 0x7ff
+        brne    17f     /* Inf/number gives inf, return inf */
+        rjmp    16f     /* The rest gives NaN*/
+        
+3:      
+        /* Op1 is a valid number. Op 2 is NaN or inf */
+        andh    r9, 0x000f /* Extract mantissa */
+        or      r9, r8
+        brne    16f     /* Return NaN if op2 is NaN */
+        rjmp    15f     /* Op2 was inf, return zero*/
+                
+11:     /* Op1 was denormal. Fix it. */
+        lsl     r11, 3
+        or      r11, r11, r10 >> 29
+        lsl     r10, 3
+        /* Check if op1 is zero. */
+        or      r4, r10, r11
+        breq    __avr32_f64_div_op1_zero
+        normalize_df    r7 /*exp*/, r10, r11 /*Mantissa*/, r4, r5 /*scratch*/
+        lsr     r10, 2
+        or      r10, r10, r11 << 30
+        lsr     r11, 2
+        rjmp    22b
+ 
+ 
+13:     /* Op2 was denormal. Fix it */
+        lsl     r9, 3
+        or      r9, r9, r8 >> 29
+        lsl     r8, 3
+        /* Check if op2 is zero. */
+        or      r4, r9, r8
+        breq    17f     /* Divisor is zero -> return Inf */
+        normalize_df    r6 /*exp*/, r8, r9 /*Mantissa*/, r4, r5 /*scratch*/     
+        lsr     r8, 2
+        or      r8, r8, r9 << 30
+        lsr     r9, 2
+        rjmp    23b
+        
+ 
+__avr32_f64_div_res_subnormal:/* Divide result was subnormal. */
+#if defined(L_avr32_f64_div)
+	/* Check how much we must scale down the mantissa. */
+	neg	r7
+	sub	r7, -1     /* We do no longer have an implicit bit. */
+	satu	r7 >> 0, 6 /* Saturate shift amount to max 63. */
+	cp.w	r7, 32
+	brge	0f
+	/* Shift amount <32 */
+	/* Scale down quotient */
+	rsub	r6, r7, 32
+	lsr	r2, r2, r7
+	lsl	r12, r3, r6
+	or	r2, r12
+	lsr	r3, r3, r7
+	/* Scale down the dividend to match the scaling of the quotient. */
+	lsl	r1, r10, r6
+	lsr	r10, r10, r7
+	lsl	r12, r11, r6
+	or	r10, r12
+	lsr	r11, r11, r7
+	mov	r0, 0
+	rjmp	1f
+0:
+	/* Shift amount >=32 */
+	rsub	r6, r7, 32
+	moveq	r0, 0
+	moveq	r12, 0
+	breq	0f
+	lsl	r0, r10, r6
+	lsl	r12, r11, r6
+0:	
+	lsr	r2, r3, r7
+	mov	r3, 0
+	/* Scale down the dividend to match the scaling of the quotient. */
+	lsr	r1, r10, r7
+	or	r1, r12
+	lsr	r10, r11, r7
+	mov	r11, 0
+1:	
+	/* Start performing the same rounding as done for normal numbers
+	   but this time we have scaled the quotient and dividend and hence
+	   need a little different comparison. */
+	/* Truncate and add guard bit. */
+	andl	r2, 0xff00
+	orl	r2, 0x0080	
+	
+	/* Now do the multiplication. */
+        mulu.d  r6, r3, r8
+        macu.d  r6, r2, r9
+        mulu.d  r4, r2, r8
+        mulu.d  r8, r3, r9
+	add	r5, r6
+	adc	r8, r8, r7	
+	acr	r9
+
+	/* Set exponent to 0 */
+	mov	r7, 0	
+
+	/* Check if remainder is positive, negative or equal. */
+	bfextu	r12, r2, 8, 1  /* Get parity bit into bit 0 of r0 */ 
+	cp	r4, r0
+	cpc	r5, r1
+	/* Now the rest of the rounding is the same as for normals. */
+	rjmp	__avr32_f64_div_round_subnormal
+	
+#endif
+15:	
+	/* Flush to zero for the fast version. */
+        mov     r11, lr /*Get correct sign*/
+        andh    r11, 0x8000, COH
+        mov     r10, 0
+        ldm     sp++, r0, r1, r2, r3, r4, r5, r6, r7,pc
+	 
+16:     /* Return NaN. */
+        mov     r11, -1
+        mov     r10, 0
+        ldm     sp++, r0, r1, r2, r3, r4, r5, r6, r7,pc
+        
+17:     
+        /* Check if op1 is zero. */
+        or      r4, r10, r11
+        breq    __avr32_f64_div_op1_zero
+        /* Return INF. */
+        mov     r11, lr /*Get correct sign*/
+        andh    r11, 0x8000, COH
+        orh     r11, 0x7ff0
+        mov     r10, 0
+        ldm     sp++, r0, r1, r2, r3, r4, r5, r6, r7,pc
+
+__avr32_f64_div_op1_zero:
+        or      r5, r8, r9 << 1
+        breq    16b             /* 0.0/0.0 -> NaN */
+        bfextu  r4, r9, 20, 11
+        cp      r4, 0x7ff
+        brne    15b             /* Return zero */
+        /* Check if divisor is Inf or NaN */
+        or      r5, r8, r9 << 12
+        breq    15b             /* Divisor is inf -> return zero */
+        rjmp    16b             /* Return NaN */                
+        
+        
+        
+
+#endif  
+                
+#if defined(L_avr32_f32_addsub) || defined(L_avr32_f32_addsub_fast)
+
+        .align  2
+__avr32_f32_sub_from_add:
+        /* Switch sign on op2 */
+        eorh    r11, 0x8000
+
+#if defined(L_avr32_f32_addsub_fast)
+        .global __avr32_f32_sub_fast
+        .type  __avr32_f32_sub_fast,@function
+__avr32_f32_sub_fast:
+#else
+        .global __avr32_f32_sub
+        .type  __avr32_f32_sub,@function
+__avr32_f32_sub:
+#endif 
+ 
+        /* Check signs */
+        eor     r8, r11, r12
+        /* Different signs, use subtraction. */
+        brmi    __avr32_f32_add_from_sub
+ 
+        /* Get sign of op1 */
+        mov     r8, r12
+        andh    r12, 0x8000, COH                
+ 
+        /* Remove sign from operands */
+        cbr     r11, 31
+#if defined(L_avr32_f32_addsub_fast)
+        reteq   r8      /* If op2 is zero return op1 */
+#endif
+        cbr     r8, 31
+ 
+        /* Put the number with the largest exponent in r10
+           and the number with the smallest exponent in r9 */
+        max     r10, r8, r11
+        min     r9, r8, r11
+        cp      r10, r8 /*If largest operand (in R10) is not equal to op1*/
+        subne   r12, 1 /* Subtract 1 from sign, which will invert MSB of r12*/
+        andh    r12, 0x8000, COH /*Mask all but MSB*/
+ 
+        /* Unpack exponent and mantissa of op1 */
+        lsl     r8, r10, 8
+        sbr     r8, 31  /* Set implicit bit. */
+        lsr     r10, 23 
+                
+        /* op1 is NaN or Inf. */
+        cp.w    r10, 0xff
+        breq    __avr32_f32_sub_op1_nan_or_inf
+        
+        /* Unpack exponent and mantissa of op2 */
+        lsl     r11, r9, 8
+        sbr     r11, 31  /* Set implicit bit. */
+        lsr     r9, 23  
+ 
+#if defined(L_avr32_f32_addsub)
+        /* Keep sticky bit for correct IEEE rounding */
+        st.w    --sp, r12
+ 
+        /* op2 is either zero or subnormal. */
+        breq    __avr32_f32_sub_op2_subnormal
+0:      
+        /* Get shift amount to scale mantissa of op2. */
+        sub     r12, r10, r9                 
+
+	breq	__avr32_f32_sub_shift_done
+ 
+        /* Saturate the shift amount to 31. If the amount
+           is any larger op2 is insignificant. */
+        satu    r12 >> 0, 5      
+
+        /* Put the remaining bits into r9.*/
+        rsub    r9, r12, 32
+        lsl     r9, r11, r9
+	
+	/* If the remaining bits are non-zero then we must subtract one
+	   more from opL.  */
+	subne	r8, 1
+	srne	r9	/* LSB of r9 represents sticky bits. */
+
+        /* Shift mantissa of op2 to same decimal point as the mantissa
+           of op1. */
+        lsr     r11, r11, r12
+ 
+
+__avr32_f32_sub_shift_done:	
+        /* Now subtract the mantissas. */
+        sub     r8, r11
+ 
+        ld.w    r12, sp++
+ 
+        /* Normalize resulting mantissa. */
+        clz     r11, r8
+
+	retcs	0
+        lsl     r8, r8, r11
+        sub     r10, r11
+        brle    __avr32_f32_sub_subnormal_result
+
+        /* Insert the bits we will remove from the mantissa into r9[31:24] */
+	or	r9, r9, r8 << 24
+#else
+        /* Ignore sticky bit to simplify and speed up rounding */
+        /* op2 is either zero or subnormal. */
+        breq    __avr32_f32_sub_op2_subnormal
+0:      
+        /* Get shift amount to scale mantissa of op2. */
+        rsub    r9, r10                 
+ 
+        /* Saturate the shift amount to 31. If the amount
+           is any larger op2 is insignificant. */
+        satu    r9 >> 0, 5      
+ 
+        /* Shift mantissa of op2 to same decimal point as the mantissa
+           of op1. */
+        lsr     r11, r11, r9
+ 
+        /* Now subtract the mantissas. */
+        sub     r8, r11
+ 
+        /* Normalize resulting mantissa. */
+        clz     r9, r8
+	retcs	0
+        lsl     r8, r8, r9
+        sub     r10, r9
+        brle    __avr32_f32_sub_subnormal_result        
+#endif
+        
+        /* Pack result. */
+        or      r12, r12, r8 >> 8
+        bfins   r12, r10, 23, 8         
+ 
+        /* Round */     
+__avr32_f32_sub_round:
+#if defined(L_avr32_f32_addsub)
+	mov_imm	r10, 0x80000000
+        bld     r12, 0
+        subne   r10, -1 
+        cp.w    r9, r10
+        subhs   r12, -1
+#else
+        bld     r8, 7 
+        acr     r12
+#endif  
+        
+        ret     r12     
+ 
+ 
+__avr32_f32_sub_op2_subnormal:
+        /* Fix implicit bit and adjust exponent of subnormals. */
+        cbr     r11, 31
+        /* Set exponent to 1 if we do not have a zero. */
+        movne   r9,1
+ 
+        /* Check if op1 is also subnormal. */
+        cp.w    r10, 0
+        brne    0b
+ 
+        cbr     r8, 31
+         /* If op1 is not zero set exponent to 1. */
+        movne   r10,1
+                
+        rjmp    0b
+ 
+__avr32_f32_sub_op1_nan_or_inf: 
+        /* Check if op1 is NaN, if so return NaN */
+        lsl     r11, r8, 1
+        retne   -1
+ 
+        /* op1 is Inf. */
+        bfins   r12, r10, 23, 8 /* Generate Inf in r12 */
+ 
+        /* Check if op2 is Inf. or NaN */
+        lsr     r11, r9, 23
+        cp.w    r11, 0xff
+        retne   r12             /* op2 not Inf or NaN, return op1 */
+ 
+        ret     -1              /* op2 Inf or NaN, return NaN */
+ 
+__avr32_f32_sub_subnormal_result:
+        /* Check if the number is so small that
+           it will be represented with zero. */
+        rsub    r10, r10, 9
+        rsub    r11, r10, 32
+        retcs   0
+ 
+        /* Shift the mantissa into the correct position.*/
+        lsr     r10, r8, r10
+        /* Add sign bit. */
+        or      r12, r10
+
+        /* Put the shifted out bits in the most significant part
+           of r8. */
+        lsl     r8, r8, r11
+ 
+#if defined(L_avr32_f32_addsub)
+        /* Add all the remainder bits used for rounding into r9 */
+        or      r9, r8
+#else
+        lsr     r8, 24 
+#endif
+        rjmp    __avr32_f32_sub_round
+ 
+                                
+        .align  2
+
+__avr32_f32_add_from_sub:
+        /* Switch sign on op2 */
+        eorh    r11, 0x8000
+
+#if defined(L_avr32_f32_addsub_fast)
+        .global __avr32_f32_add_fast
+        .type  __avr32_f32_add_fast,@function
+__avr32_f32_add_fast:
+#else
+        .global __avr32_f32_add
+        .type  __avr32_f32_add,@function
+__avr32_f32_add:
+#endif 
+	
+        /* Check signs */
+        eor     r8, r11, r12
+        /* Different signs, use subtraction. */
+        brmi    __avr32_f32_sub_from_add
+ 
+        /* Get sign of op1 */
+        mov     r8, r12
+        andh    r12, 0x8000, COH                
+ 
+        /* Remove sign from operands */
+        cbr     r11, 31
+#if defined(L_avr32_f32_addsub_fast)
+        reteq   r8      /* If op2 is zero return op1 */
+#endif
+        cbr     r8, 31
+ 
+        /* Put the number with the largest exponent in r10
+           and the number with the smallest exponent in r9 */
+        max     r10, r8, r11
+        min     r9, r8, r11
+ 
+        /* Unpack exponent and mantissa of op1 */
+        lsl     r8, r10, 8
+        sbr     r8, 31  /* Set implicit bit. */
+        lsr     r10, 23 
+                
+        /* op1 is NaN or Inf. */
+        cp.w    r10, 0xff
+        breq    __avr32_f32_add_op1_nan_or_inf
+        
+        /* Unpack exponent and mantissa of op2 */
+        lsl     r11, r9, 8
+        sbr     r11, 31  /* Set implicit bit. */
+        lsr     r9, 23  
+ 
+#if defined(L_avr32_f32_addsub)
+        /* op2 is either zero or subnormal. */
+        breq    __avr32_f32_add_op2_subnormal
+0:      
+        /* Keep sticky bit for correct IEEE rounding */
+        st.w    --sp, r12
+ 
+        /* Get shift amount to scale mantissa of op2. */
+        rsub    r9, r10                 
+ 
+        /* Saturate the shift amount to 31. If the amount
+           is any larger op2 is insignificant. */
+        satu    r9 >> 0, 5      
+ 
+        /* Shift mantissa of op2 to same decimal point as the mantissa
+           of op1. */
+        lsr     r12, r11, r9
+ 
+        /* Put the remainding bits into r11[23:..].*/
+        rsub    r9, r9, (32-8)
+        lsl     r11, r11, r9
+        /* Insert the bits we will remove from the mantissa into r11[31:24] */
+        bfins   r11, r12, 24, 8
+ 
+        /* Now add the mantissas. */
+        add     r8, r12
+ 
+        ld.w    r12, sp++
+#else
+        /* Ignore sticky bit to simplify and speed up rounding */
+        /* op2 is either zero or subnormal. */
+        breq    __avr32_f32_add_op2_subnormal
+0:      
+        /* Get shift amount to scale mantissa of op2. */
+        rsub    r9, r10                 
+ 
+        /* Saturate the shift amount to 31. If the amount
+           is any larger op2 is insignificant. */
+        satu    r9 >> 0, 5      
+ 
+        /* Shift mantissa of op2 to same decimal point as the mantissa
+           of op1. */
+        lsr     r11, r11, r9
+ 
+        /* Now add the mantissas. */
+        add     r8, r11
+        
+#endif
+        /* Check if we overflowed. */
+        brcs    __avr32_f32_add_res_of
+1:      
+        /* Pack result. */
+        or      r12, r12, r8 >> 8
+        bfins   r12, r10, 23, 8         
+ 
+        /* Round */     
+#if defined(L_avr32_f32_addsub)
+	mov_imm	r10, 0x80000000
+        bld     r12, 0
+        subne   r10, -1 
+        cp.w    r11, r10
+        subhs   r12, -1
+#else
+        bld     r8, 7 
+        acr     r12
+#endif  
+
+        ret     r12     
+ 
+__avr32_f32_add_op2_subnormal:
+        /* Fix implicit bit and adjust exponent of subnormals. */
+        cbr     r11, 31
+        /* Set exponent to 1 if we do not have a zero. */
+        movne   r9,1
+ 
+        /* Check if op1 is also subnormal. */
+        cp.w    r10, 0
+        brne    0b
+	/* Both operands subnormal, just add the mantissas and 
+	   pack. If the addition of the subnormal numbers results
+	   in a normal number then the exponent will automatically
+	   be set to 1 by the addition. */
+        cbr     r8, 31
+	add	r11, r8
+	or	r12, r12, r11 >> 8
+	ret	r12
+ 
+__avr32_f32_add_op1_nan_or_inf: 
+        /* Check if op1 is NaN, if so return NaN */
+        lsl     r11, r8, 1
+        retne   -1
+ 
+        /* op1 is Inf. */
+        bfins   r12, r10, 23, 8 /* Generate Inf in r12 */
+ 
+        /* Check if op2 is Inf. or NaN */
+        lsr     r11, r9, 23
+        cp.w    r11, 0xff
+        retne   r12             /* op2 not Inf or NaN, return op1 */
+ 
+        lsl     r9, 9
+        reteq   r12             /* op2 Inf return op1 */
+        ret     -1              /* op2 is NaN, return NaN */ 
+ 
+__avr32_f32_add_res_of:
+        /* We overflowed. Increase exponent and shift mantissa.*/
+        lsr     r8, 1
+        sub     r10, -1
+ 
+        /* Clear mantissa to set result to Inf if the exponent is 255. */
+        cp.w    r10, 255
+        moveq   r8, 0
+        moveq   r11, 0
+        rjmp    1b      
+        
+        
+#endif
+
+	
+#if defined(L_avr32_f32_div) || defined(L_avr32_f32_div_fast)
+	.align	2
+
+#if defined(L_avr32_f32_div_fast)
+        .global __avr32_f32_div_fast
+        .type  __avr32_f32_div_fast,@function
+__avr32_f32_div_fast:
+#else
+        .global __avr32_f32_div
+        .type  __avr32_f32_div,@function
+__avr32_f32_div:
+#endif
+	 
+        eor     r8, r11, r12            /* MSB(r8) = Sign(op1) ^ Sign(op2) */
+ 
+        /* Unpack */
+        lsl     r12,1
+        lsl     r11,1
+        breq    4f                      /* Check op2 for zero */
+
+        tst     r12, r12
+        moveq   r9, 0
+        breq    12f
+
+        /* Unpack op1*/ 
+        /* exp: r9 */
+        /* sf:  r12 */
+        lsr     r9, r12, 24
+        breq    11f /*If number is subnormal*/
+        cp      r9, 0xff
+        brhs    2f  /* Check op1 for NaN or Inf */      
+        lsl     r12, 7
+        sbr     r12, 31 /*Implicit bit*/
+12:                     
+ 
+        /* Unpack op2*/
+        /* exp: r10 */
+        /* sf:  r11 */
+        lsr     r10, r11, 24
+        breq    13f /*If number is subnormal*/
+        cp      r10, 0xff
+        brhs    3f  /* Check op2 for NaN or Inf */      
+        lsl     r11,7
+        sbr     r11, 31 /*Implicit bit*/
+
+        cp.w    r9, 0
+        subfeq  r12, 0
+        reteq   0                       /* op1 is zero and op2 is not zero */
+                                        /* or NaN so return zero */
+
+14:     
+ 
+        /* For UC3, store with predecrement is faster than stm */
+        st.w    --sp, r5
+        st.d    --sp, r6
+ 
+        /* Calculate new exponent */
+        sub     r9, r10
+        sub     r9,-127
+ 
+        /* Divide */
+        /* Approximating 1/d with the following recurrence: */
+        /* R[j+1] = R[j]*(2-R[j]*d) */
+        /* Using 2.30 format */
+        /* TWO:  r10 */
+        /* d:    r5 */
+        /* Multiply result :     r6, r7 */
+        /* Initial guess :       r11 */
+        /* New approximations :  r11 */
+        /* Dividend :            r12 */
+
+	/* Load TWO */
+	mov_imm	r10, 0x80000000 
+         
+        lsr     r12, 2     /* Get significand of Op1 in 2.30 format */
+        lsr     r5, r11, 2 /* Get significand of Op2 (=d) in 2.30 format */
+ 
+        /* Load initial guess, using look-up table */
+        /* Initial guess is of format 01.XY, where XY is constructed as follows: */
+        /* Let d be of following format: 00.1xy....., then XY=~xy */
+        /* For d=00.100 = 0,5   -> initial guess=01.11 = 1,75 */
+        /* For d=00.101 = 0,625 -> initial guess=01.11 = 1,5  */
+        /* For d=00.110 = 0,75  -> initial guess=01.11 = 1,25 */
+        /* For d=00.111 = 0,875 -> initial guess=01.11 = 1,0  */
+ 
+        lsr     r11, r10, 1
+        bfextu  r6, r5, 27, 2
+        com     r6
+        bfins   r11, r6, 28, 2
+ 
+        /* First approximation */
+        /* r7 = R[j]*d */
+        mulu.d  r6, r11, r5
+        /* r7 = 2-R[j]*d */
+        sub    r7, r10, r7<<2
+        /* r11 = R[j]*(2-R[j]*d) */
+        mulu.d  r6, r11, r7
+        lsl     r11, r7, 2
+         
+        /* Second approximation */
+        /* r7 = R[j]*d */
+        mulu.d  r6, r11, r5
+        /* r7 = 2-R[j]*d */
+        sub    r7, r10, r7<<2
+        /* r11 = R[j]*(2-R[j]*d) */
+        mulu.d  r6, r11, r7
+        lsl     r11, r7, 2
+         
+        /* Third approximation */
+        /* r7 = R[j]*d */
+        mulu.d  r6, r11, r5
+        /* r7 = 2-R[j]*d */
+        sub    r7, r10, r7<<2
+        /* r11 = R[j]*(2-R[j]*d) */
+        mulu.d  r6, r11, r7
+        lsl     r11, r7, 2
+ 
+        /* Fourth approximation */
+        /* r7 = R[j]*d */
+        mulu.d  r6, r11, r5
+        /* r7 = 2-R[j]*d */
+        sub    r7, r10, r7<<2
+        /* r11 = R[j]*(2-R[j]*d) */
+        mulu.d  r6, r11, r7
+        lsl     r11, r7, 2
+ 
+ 
+        /* Multiply with dividend to get quotient, r7 = sf(op1)/sf(op2) */
+        mulu.d  r6, r11, r12
+ 
+        /* Shift by 3 to get result in 1.31 format, as required by the exponent. */
+        /* Note that 1.31 format is already used by the exponent in r9, since */
+        /* a bias of 127 was added to the result exponent, even though the implicit */
+        /* bit was inserted. This gives the exponent an additional bias of 1, which */
+        /* supports 1.31 format. */
+	//lsl     r10, r7, 3
+
+	/* Adjust exponent and mantissa in case the result is of format
+	   0000.1xxx to 0001.xxx*/	
+#if defined(L_avr32_f32_div)
+	lsr	r12, 4	/* Scale dividend to 6.26 format to match the
+			   result of the multiplication of the divisor and 
+			   quotient to get the remainder. */
+#endif
+	bld	r7, 31-3
+	breq	0f
+	lsl	r7, 1	
+	sub	r9, 1
+#if defined(L_avr32_f32_div)
+	lsl	r12, 1	/* Scale dividend to 5.27 format to match the
+			   result of the multiplication of the divisor and 
+			   quotient to get the remainder. */
+#endif
+0:		
+        cp      r9, 0   
+        brle    __avr32_f32_div_res_subnormal /* Result was subnormal. */
+
+		
+#if defined(L_avr32_f32_div)
+	/* In order to round correctly we calculate the remainder:	
+	   Remainder = dividend[r12] - divisor[r5]*quotient[r7] 
+	   for the case when the quotient is halfway between the round-up
+	   value and the round down value. If the remainder then is negative
+	   it means that the quotient was to big and that it should not be
+           rounded up, if the remainder is positive the quotient was to small
+	   and we need to round up. If the remainder is zero it means that the
+	   quotient is exact but since we need to remove the guard bit we should
+	   round to even. */
+	andl	r7, 0xffe0
+	orl	r7, 0x0010
+
+	/* Now do the multiplication. The quotient has the format 4.28
+	   while the divisor has the format 2.30 which gives a result
+	   of 6.26 */
+	mulu.d	r10, r5, r7
+
+	/* Check if remainder is positive, negative or equal. */
+	bfextu	r5, r7, 5, 1  /* Get parity bit into bit 0 of r5 */ 
+	cp	r10, 0
+__avr32_f32_div_round_subnormal:	
+	cpc	r11, r12
+	srlo	r11	/* Remainder positive:	 we need to round up.*/
+	moveq	r11, r5  /* Remainder zero:	 round up if mantissa odd. */
+#else
+	bfextu	r11, r7, 4, 1  /* Get guard bit */ 	
+#endif
+                               
+        /* Pack final result*/
+        lsr     r12, r7, 5
+        bfins   r12, r9, 23, 8
+        /* For UC3, load with postincrement is faster than ldm */
+        ld.d    r6, sp++
+        ld.w    r5, sp++
+        bld     r8, 31
+        bst     r12, 31
+	/* Rounding add. */
+	add	r12, r11
+        ret     r12
+
+__divsf_return_op1:     
+        lsl     r8, 1
+        ror     r12
+        ret     r12
+ 
+ 
+2:
+        /* Op1 is NaN or inf */
+        retne   -1      /* Return NaN if op1 is NaN */
+        /* Op1 is inf check op2 */
+	mov_imm	r9, 0xff000000
+        cp      r11, r9
+        brlo    __divsf_return_op1 /* inf/number gives inf */
+        ret     -1      /* The rest gives NaN*/
+3:      
+        /* Op2 is NaN or inf */
+        reteq   0       /* Return zero if number/inf*/
+        ret     -1      /* Return NaN*/
+4:
+        /* Op1 is zero ? */
+        tst     r12,r12
+        reteq   -1      /* 0.0/0.0 is NaN */
+        /* Op1 is Nan? */
+        lsr     r9, r12, 24
+        breq    11f /*If number is subnormal*/
+        cp      r9, 0xff
+        brhs    2b  /* Check op1 for NaN or Inf */
+        /* Nonzero/0.0 is Inf. Sign bit will be shifted in before returning*/
+	mov_imm	r12, 0xff000000
+        rjmp    __divsf_return_op1
+                
+11:     /* Op1 was denormal. Fix it. */
+        lsl     r12,7
+        clz     r9,r12
+        lsl     r12,r12,r9
+        rsub    r9,r9,1
+        rjmp    12b
+ 
+13:     /* Op2 was denormal. Fix it. */ 
+        lsl     r11,7
+        clz     r10,r11
+        lsl     r11,r11,r10
+        rsub    r10,r10,1
+        rjmp    14b
+        
+ 
+__avr32_f32_div_res_subnormal:     /* Divide result was subnormal */
+#if defined(L_avr32_f32_div)
+	/* Check how much we must scale down the mantissa. */
+	neg	r9
+	sub	r9, -1     /* We do no longer have an implicit bit. */
+	satu	r9 >> 0, 5 /* Saturate shift amount to max 32. */
+	/* Scale down quotient */
+	rsub	r10, r9, 32
+	lsr	r7, r7, r9
+	/* Scale down the dividend to match the scaling of the quotient. */
+	lsl	r6, r12, r10	/* Make the divident 64-bit and put the lsw in r6 */
+	lsr	r12, r12, r9
+
+	/* Start performing the same rounding as done for normal numbers
+	   but this time we have scaled the quotient and dividend and hence
+	   need a little different comparison. */
+	andl	r7, 0xffe0
+	orl	r7, 0x0010
+
+	/* Now do the multiplication. The quotient has the format 4.28
+	   while the divisor has the format 2.30 which gives a result
+	   of 6.26 */
+	mulu.d	r10, r5, r7
+
+	/* Set exponent to 0 */
+	mov	r9, 0	
+
+	/* Check if remainder is positive, negative or equal. */
+	bfextu	r5, r7, 5, 1  /* Get parity bit into bit 0 of r5 */ 
+	cp	r10, r6
+	rjmp	__avr32_f32_div_round_subnormal
+
+#else
+        ld.d    r6, sp++
+        ld.w    r5, sp++
+        /*Flush to zero*/
+	ret	0
+#endif
+#endif
+ 
+#ifdef L_avr32_f32_mul
+        .global __avr32_f32_mul
+        .type  __avr32_f32_mul,@function
+ 
+                
+__avr32_f32_mul:
+        mov     r8, r12
+        eor     r12, r11                /* MSB(r8) = Sign(op1) ^ Sign(op2) */
+        andh    r12, 0x8000, COH
+        
+        /* arrange operands so that that op1 >= op2 */
+        cbr     r8, 31
+        breq    __avr32_f32_mul_op1_zero
+        cbr     r11, 31
+ 
+        /* Put the number with the largest exponent in r10
+           and the number with the smallest exponent in r9 */
+        max     r10, r8, r11
+        min     r9, r8, r11
+ 
+        /* Unpack exponent and mantissa of op1 */
+        lsl     r8, r10, 8
+        sbr     r8, 31  /* Set implicit bit. */
+        lsr     r10, 23 
+                
+        /* op1 is NaN or Inf. */
+        cp.w    r10, 0xff
+        breq    __avr32_f32_mul_op1_nan_or_inf
+        
+        /* Unpack exponent and mantissa of op2 */
+        lsl     r11, r9, 8
+        sbr     r11, 31  /* Set implicit bit. */
+        lsr     r9, 23  
+ 
+        /* op2 is either zero or subnormal. */
+        breq    __avr32_f32_mul_op2_subnormal
+0:      
+        /* Calculate new exponent */
+        add     r9,r10
+ 
+        /* Do the multiplication */
+        mulu.d  r10,r8,r11
+ 
+        /* We might need to scale up by two if the MSB of the result is
+           zero. */
+        lsl     r8, r11, 1
+        movcc   r11, r8
+        subcc   r9, 1
+ 
+        /* Put the shifted out bits of the mantissa into r10 */
+        lsr     r10, 8
+        bfins   r10, r11, 24, 8
+                
+        sub     r9,(127-1)              /* remove extra exponent bias */
+        brle    __avr32_f32_mul_res_subnormal
+ 
+        /* Check for Inf. */
+        cp.w    r9, 0xff
+        brge    1f
+ 
+        /* Pack result. */
+        or      r12, r12, r11 >> 8
+        bfins   r12, r9, 23, 8          
+ 
+        /* Round */     
+__avr32_f32_mul_round:
+	mov_imm	r8, 0x80000000
+        bld     r12, 0
+        subne   r8, -1  
+ 
+        cp.w    r10, r8
+        subhs   r12, -1
+        
+        ret     r12     
+ 
+1:      
+        /* Return Inf */        
+        orh     r12, 0x7f80
+        ret     r12
+ 
+__avr32_f32_mul_op2_subnormal:
+        cbr     r11, 31
+        clz     r9, r11
+        retcs   0       /* op2 is zero. Return 0 */
+        sub     r9, 8
+        lsl     r11, r11, r9
+        rsub    r9, r9, 1
+                
+        /* Check if op2 is subnormal. */
+        tst     r10, r10
+        brne    0b
+ 
+        /* op2 is subnormal */  
+        cbr     r8, 31
+        clz     r10, r11
+        retcs   0       /* op1 is zero. Return 0 */
+        lsl     r8, r8, r10
+        rsub    r10, r10, 1
+                        
+        rjmp    0b
+                
+ 
+__avr32_f32_mul_op1_nan_or_inf:
+        /* Check if op1 is NaN, if so return NaN */
+        lsl     r11, r8, 1
+        retne   -1
+ 
+        /* op1 is Inf. */
+        tst     r9, r9
+        reteq   -1      /* Inf * 0 -> NaN */
+ 
+        bfins   r12, r10, 23, 8 /* Generate Inf in r12 */
+ 
+        /* Check if op2 is Inf. or NaN */
+        lsr     r11, r9, 23
+        cp.w    r11, 0xff
+        retne   r12             /* op2 not Inf or NaN, return Info */
+ 
+        lsl     r9, 9
+        reteq   r12             /* op2 Inf return Inf */
+        ret     -1              /* op2 is NaN, return NaN */ 
+        
+__avr32_f32_mul_res_subnormal:
+        /* Check if the number is so small that
+           it will be represented with zero. */
+        rsub    r9, r9, 9
+        rsub    r8, r9, 32
+        retcs   0
+ 
+        /* Shift the mantissa into the correct position.*/
+        lsr     r9, r11, r9
+        /* Add sign bit. */
+        or      r12, r9
+        /* Put the shifted out bits in the most significant part
+           of r8. */
+        lsl     r11, r11, r8
+ 
+        /* Add all the remainder bits used for rounding into r11 */
+        andh    r10, 0x00FF     
+        or      r10, r11
+        rjmp    __avr32_f32_mul_round
+
+__avr32_f32_mul_op1_zero:
+        bfextu  r10, r11, 23, 8
+        cp.w    r10, 0xff
+        retne   r12
+        reteq   -1        
+ 
+#endif  
+ 
+        
+#ifdef L_avr32_s32_to_f32
+        .global __avr32_s32_to_f32
+        .type  __avr32_s32_to_f32,@function
+__avr32_s32_to_f32:
+        cp      r12, 0
+        reteq   r12     /* If zero then return zero float */
+        mov     r11, r12 /* Keep the sign */
+        abs     r12     /* Compute the absolute value */
+        mov     r10, 31 + 127   /* Set the correct exponent */
+        
+        /* Normalize */
+        normalize_sf    r10 /*exp*/, r12 /*mant*/, r9 /*scratch*/       
+ 
+        /* Check for subnormal result */
+        cp.w    r10, 0
+        brle    __avr32_s32_to_f32_subnormal
+ 
+        round_sf        r10 /*exp*/, r12 /*mant*/, r9 /*scratch*/       
+        pack_sf         r12 /*sf*/, r10 /*exp*/, r12 /*mant*/
+        lsl     r11, 1
+        ror     r12
+        ret     r12             
+ 
+__avr32_s32_to_f32_subnormal:
+        /* Adjust a subnormal result */
+        adjust_subnormal_sf     r12/*sf*/, r10 /*exp*/, r12 /*mant*/, r11/*sign*/, r9 /*scratch*/
+        ret     r12
+        
+#endif
+ 
+#ifdef L_avr32_u32_to_f32
+        .global __avr32_u32_to_f32
+        .type  __avr32_u32_to_f32,@function
+__avr32_u32_to_f32:
+        cp      r12, 0
+        reteq   r12     /* If zero then return zero float */
+        mov     r10, 31 + 127   /* Set the correct exponent */
+        
+        /* Normalize */
+        normalize_sf    r10 /*exp*/, r12 /*mant*/, r9 /*scratch*/       
+ 
+        /* Check for subnormal result */
+        cp.w    r10, 0
+        brle    __avr32_u32_to_f32_subnormal
+ 
+        round_sf        r10 /*exp*/, r12 /*mant*/, r9 /*scratch*/       
+        pack_sf         r12 /*sf*/, r10 /*exp*/, r12 /*mant*/
+        lsr     r12,1   /* Sign bit is 0 for unsigned int */
+        ret     r12             
+ 
+__avr32_u32_to_f32_subnormal:
+        /* Adjust a subnormal result */
+        mov     r8, 0
+        adjust_subnormal_sf     r12/*sf*/,r10 /*exp*/, r12 /*mant*/,r8/*sign*/, r9 /*scratch*/
+        ret     r12
+        
+        
+#endif
+        
+ 
+#ifdef L_avr32_f32_to_s32
+        .global __avr32_f32_to_s32
+        .type  __avr32_f32_to_s32,@function
+__avr32_f32_to_s32:
+        bfextu  r11, r12, 23, 8
+        sub     r11,127                 /* Fix bias */
+        retlo   0                       /* Negative exponent yields zero integer */
+ 
+        /* Shift mantissa into correct position */
+        rsub    r11,r11,31      /* Shift amount */
+        lsl     r10,r12,8       /* Get mantissa */
+        sbr     r10,31          /* Add implicit bit */
+        lsr     r10,r10,r11     /* Perform shift */
+        lsl     r12,1           /* Check sign */
+        retcc   r10             /* if positive, we are done */
+        neg     r10             /* if negative float, negate result */
+        ret     r10
+ 
+#endif  
+        
+#ifdef L_avr32_f32_to_u32
+        .global __avr32_f32_to_u32
+        .type  __avr32_f32_to_u32,@function
+__avr32_f32_to_u32:
+        cp      r12,0
+        retmi   0                       /* Negative numbers gives 0 */
+        bfextu  r11, r12, 23, 8         /* Extract exponent */
+        sub     r11,127                 /* Fix bias */
+        retlo   0                       /* Negative exponent yields zero integer */
+ 
+        /* Shift mantissa into correct position */
+        rsub    r11,r11,31      /* Shift amount */
+        lsl     r12,8           /* Get mantissa */
+        sbr     r12,31          /* Add implicit bit */
+        lsr     r12,r12,r11     /* Perform shift */
+        ret     r12
+ 
+#endif  
+ 
+#ifdef L_avr32_f32_to_f64
+        .global __avr32_f32_to_f64
+        .type  __avr32_f32_to_f64,@function
+ 
+__avr32_f32_to_f64:
+        lsl     r11,r12,1               /* Remove sign bit, keep original value in r12*/
+        moveq   r10, 0
+        reteq   r11                     /* Return zero if input is zero */
+ 
+        bfextu  r9,r11,24,8              /* Get exponent */
+        cp.w    r9,0xff                 /* check for NaN or inf */
+        breq    0f
+ 
+        lsl     r11,7                   /* Convert sf mantissa to df format */
+        mov     r10,0
+ 
+        /* Check if implicit bit should be set */
+        cp.w    r9, 0
+        subeq   r9,-1                    /* Adjust exponent if it was 0 */
+        srne    r8
+        or      r11, r11, r8 << 31      /* Set implicit bit if needed */
+        sub     r9,(127-0x3ff)          /* Convert exponent to df format exponent */
+ 
+        /*We know that low register of mantissa is 0, and will be unaffected by normalization.*/
+        /*We can therefore use the faster normalize_sf function instead of normalize_df.*/
+        normalize_sf    r9 /*exp*/, r11 /*mantissa*/, r8 /*scratch*/
+        pack_df         r9 /*exp*/, r10, r11 /*mantissa*/, r10, r11 /*df*/
+ 
+__extendsfdf_return_op1:        
+        /* Rotate in sign bit */
+        lsl     r12, 1
+        ror     r11
+        ret     r11
+                        
+0:
+        /* Inf or NaN*/
+	mov_imm	r10, 0xffe00000
+        lsl     r11,8                   /* check mantissa */
+        movne   r11, -1                 /* Return NaN */
+        moveq   r11, r10                /* Return inf */
+        mov     r10, 0
+        rjmp    __extendsfdf_return_op1
+#endif                  
+ 
+ 
+#ifdef L_avr32_f64_to_f32
+        .global __avr32_f64_to_f32
+        .type  __avr32_f64_to_f32,@function
+ 
+__avr32_f64_to_f32:
+        /* Unpack */
+        lsl     r9,r11,1                /* Unpack exponent */
+        lsr     r9,21
+ 
+        reteq   0                       /* If exponent is 0 the number is so small
+                                           that the conversion to single float gives
+                                           zero */
+ 
+        lsl     r8,r11,10                  /* Adjust mantissa */
+        or      r12,r8,r10>>22
+ 
+        lsl     r10,10                  /* Check if there are any remaining bits
+                                           in the low part of the mantissa.*/
+        neg     r10
+        rol     r12                     /* If there were remaining bits then set lsb
+                                           of mantissa to 1 */
+ 
+        cp      r9,0x7ff
+        breq    2f                      /* Check for NaN or inf */
+ 
+        sub     r9,(0x3ff-127)          /* Adjust bias of exponent */
+        sbr     r12,31                  /* set the implicit bit.*/
+ 
+        cp.w    r9, 0                   /* Check for subnormal number */
+        brle    3f
+ 
+        round_sf        r9 /*exp*/, r12 /*mant*/, r10 /*scratch*/       
+        pack_sf         r12 /*sf*/, r9 /*exp*/, r12 /*mant*/
+__truncdfsf_return_op1: 
+        /* Rotate in sign bit */
+        lsl     r11, 1
+        ror     r12
+        ret     r12             
+        
+2:
+        /* NaN or inf */
+        cbr     r12,31                  /* clear implicit bit */
+        retne   -1                      /* Return NaN if mantissa not zero */
+	mov_imm	r12, 0x7f800000
+        ret     r12                     /* Return inf */
+ 
+3:      /* Result is subnormal. Adjust it.*/
+        adjust_subnormal_sf     r12/*sf*/,r9 /*exp*/, r12 /*mant*/, r11/*sign*/, r10 /*scratch*/
+        ret     r12
+        
+                
+#endif
+ 
+#if defined(L_mulsi3) && defined(__AVR32_NO_MUL__)
+	.global __mulsi3
+	.type __mulsi3,@function
+
+__mulsi3:
+	mov r9, 0
+0:
+	lsr r11, 1
+	addcs r9, r9, r12
+	breq 1f
+	lsl r12, 1
+	rjmp 0b
+1:
+	ret r9
+#endif
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/lib2funcs.S gcc-4.4.6/gcc/config/avr32/lib2funcs.S
--- gcc-4.4.6.orig/gcc/config/avr32/lib2funcs.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/lib2funcs.S	2011-08-27 19:45:43.100490428 +0200
@@ -0,0 +1,21 @@
+	.align	4
+	.global __nonlocal_goto
+	.type  __nonlocal_goto,@function
+
+/* __nonlocal_goto:	This function handles nonlocal_goto's in gcc.
+
+	parameter 0 (r12) = New Frame Pointer
+	parameter 1 (r11) = Address to goto
+	parameter 2 (r10) = New Stack Pointer
+
+	This function invalidates the return stack, since it returns from a
+	function without using a return instruction.
+*/
+__nonlocal_goto:
+	mov	r7, r12
+	mov	sp, r10
+	frs			# Flush return stack
+	mov	pc, r11
+
+
+		
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/linux-elf.h gcc-4.4.6/gcc/config/avr32/linux-elf.h
--- gcc-4.4.6.orig/gcc/config/avr32/linux-elf.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/linux-elf.h	2011-08-27 19:45:43.160490580 +0200
@@ -0,0 +1,151 @@
+/*
+   Linux/Elf specific definitions.
+   Copyright 2003-2006 Atmel Corporation.
+
+   Written by Ronny Pedersen, Atmel Norway, <rpedersen@atmel.com>
+   and H�vard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of GCC.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
+
+
+
+/* elfos.h should have already been included.  Now just override
+   any conflicting definitions and add any extras.  */
+
+/* Run-time Target Specification.  */
+#undef  TARGET_VERSION
+#define TARGET_VERSION  fputs (" (AVR32 GNU/Linux with ELF)", stderr);
+
+/* Do not assume anything about header files.  */
+#define NO_IMPLICIT_EXTERN_C
+
+/* The GNU C++ standard library requires that these macros be defined.  */
+#undef CPLUSPLUS_CPP_SPEC
+#define CPLUSPLUS_CPP_SPEC "-D_GNU_SOURCE %(cpp)"
+
+/* Now we define the strings used to build the spec file.  */
+#undef  LIB_SPEC
+#define LIB_SPEC \
+  "%{pthread:-lpthread} \
+   %{shared:-lc} \
+   %{!shared:%{profile:-lc_p}%{!profile:-lc}}"
+
+/* Provide a STARTFILE_SPEC appropriate for GNU/Linux.  Here we add
+   the GNU/Linux magical crtbegin.o file (see crtstuff.c) which
+   provides part of the support for getting C++ file-scope static
+   object constructed before entering `main'.  */
+
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC \
+  "%{!shared: \
+     %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} \
+		       %{!p:%{profile:gcrt1.o%s} \
+			 %{!profile:crt1.o%s}}}} \
+   crti.o%s %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}"
+
+/* Provide a ENDFILE_SPEC appropriate for GNU/Linux.  Here we tack on
+   the GNU/Linux magical crtend.o file (see crtstuff.c) which
+   provides part of the support for getting C++ file-scope static
+   object constructed before entering `main', followed by a normal
+   GNU/Linux "finalizer" file, `crtn.o'.  */
+
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC \
+  "%{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s"
+
+#undef ASM_SPEC
+#define ASM_SPEC "%{!mno-pic:%{!fno-pic:--pic}} %{mrelax|O*:%{mno-relax|O0|O1: ;:--linkrelax}} %{mcpu=*:-mcpu=%*}"
+ 
+#undef  LINK_SPEC
+#define LINK_SPEC "%{version:-v} \
+   %{static:-Bstatic} \
+   %{shared:-shared} \
+   %{symbolic:-Bsymbolic} \
+   %{rdynamic:-export-dynamic} \
+   %{!dynamic-linker:-dynamic-linker /lib/ld-uClibc.so.0} \
+   %{mrelax|O*:%{mno-relax|O0|O1: ;:--relax}}"
+
+#define TARGET_OS_CPP_BUILTINS() LINUX_TARGET_OS_CPP_BUILTINS()
+
+/* This is how we tell the assembler that two symbols have the same value.  */
+#define ASM_OUTPUT_DEF(FILE, NAME1, NAME2) \
+  do					   \
+    {					   \
+      assemble_name (FILE, NAME1); 	   \
+      fputs (" = ", FILE);		   \
+      assemble_name (FILE, NAME2);	   \
+      fputc ('\n', FILE);		   \
+    }					   \
+  while (0)
+
+
+
+#undef  CC1_SPEC
+#define CC1_SPEC "%{profile:-p}"
+
+/* Target CPU builtins.  */
+#define TARGET_CPU_CPP_BUILTINS()				\
+  do								\
+    {								\
+      builtin_define ("__avr32__");				\
+      builtin_define ("__AVR32__");				\
+      builtin_define ("__AVR32_LINUX__");			\
+      builtin_define (avr32_part->macro);			\
+      builtin_define (avr32_arch->macro);			\
+      if (avr32_arch->uarch_type == UARCH_TYPE_AVR32A)		\
+	builtin_define ("__AVR32_AVR32A__");			\
+      else							\
+	builtin_define ("__AVR32_AVR32B__");			\
+      if (TARGET_UNALIGNED_WORD)				\
+	builtin_define ("__AVR32_HAS_UNALIGNED_WORD__");	\
+      if (TARGET_SIMD)						\
+	builtin_define ("__AVR32_HAS_SIMD__");			\
+      if (TARGET_DSP)						\
+	builtin_define ("__AVR32_HAS_DSP__");			\
+      if (TARGET_RMW)						\
+	builtin_define ("__AVR32_HAS_RMW__");			\
+      if (TARGET_BRANCH_PRED)					\
+	builtin_define ("__AVR32_HAS_BRANCH_PRED__");		\
+      if (TARGET_FAST_FLOAT)                                    \
+        builtin_define ("__AVR32_FAST_FLOAT__");                \
+    }								\
+  while (0)
+
+
+
+/* Call the function profiler with a given profile label.  */
+#undef  FUNCTION_PROFILER
+#define FUNCTION_PROFILER(STREAM, LABELNO)				\
+  do									\
+    {									\
+      fprintf (STREAM, "\tmov\tlr, lo(mcount)\n\torh\tlr, hi(mcount)\n"); \
+      fprintf (STREAM, "\ticall lr\n");					\
+    }									\
+  while (0)
+
+#define NO_PROFILE_COUNTERS 1
+
+/* For dynamic libraries to work */
+/* #define PLT_REG_CALL_CLOBBERED 1 */
+#define AVR32_ALWAYS_PIC 1
+
+/* uclibc does not implement sinf, cosf etc. */
+#undef TARGET_C99_FUNCTIONS
+#define TARGET_C99_FUNCTIONS 0
+
+#define LINK_GCC_C_SEQUENCE_SPEC \
+  "%{static:--start-group} %G %L %{static:--end-group}%{!static:%G}"
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/predicates.md gcc-4.4.6/gcc/config/avr32/predicates.md
--- gcc-4.4.6.orig/gcc/config/avr32/predicates.md	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/predicates.md	2011-08-27 19:45:43.200490072 +0200
@@ -0,0 +1,422 @@
+;;   AVR32 predicates file.
+;;   Copyright 2003-2006 Atmel Corporation.
+;;
+;;   Written by Ronny Pedersen, Atmel Norway, <rpedersen@atmel.com>
+;;
+;;   This file is part of GCC.
+;;
+;;   This program is free software; you can redistribute it and/or modify
+;;   it under the terms of the GNU General Public License as published by
+;;   the Free Software Foundation; either version 2 of the License, or
+;;   (at your option) any later version.
+;;
+;;   This program is distributed in the hope that it will be useful,
+;;   but WITHOUT ANY WARRANTY; without even the implied warranty of
+;;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;;   GNU General Public License for more details.
+;;
+;;   You should have received a copy of the GNU General Public License
+;;   along with this program; if not, write to the Free Software
+;;   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+
+;; True if the operand is a memory reference which contains an
+;; Address consisting of a single pointer register
+(define_predicate "avr32_indirect_register_operand"
+  (and (match_code "mem")
+       (match_test "register_operand(XEXP(op, 0), SImode)")))
+
+
+
+;; Address expression with a base pointer offset with
+;; a register displacement
+(define_predicate "avr32_indexed_memory_operand"
+  (and (match_code "mem")
+       (match_test "GET_CODE(XEXP(op, 0)) == PLUS"))
+  {
+
+   rtx op0 = XEXP(XEXP(op, 0), 0);
+   rtx op1 = XEXP(XEXP(op, 0), 1);
+
+   return ((avr32_address_register_rtx_p (op0, 0)
+            && avr32_legitimate_index_p (GET_MODE(op), op1, 0))
+	   || (avr32_address_register_rtx_p (op1, 0)
+            && avr32_legitimate_index_p (GET_MODE(op), op0, 0)));
+
+ })
+
+;; Operand suitable for the ld.sb instruction
+(define_predicate "load_sb_memory_operand"
+  (ior (match_operand 0 "avr32_indirect_register_operand")
+       (match_operand 0 "avr32_indexed_memory_operand")))
+
+
+;; Operand suitable as operand to insns sign extending QI values
+(define_predicate "extendqi_operand"
+  (ior (match_operand 0 "load_sb_memory_operand")
+       (match_operand 0 "register_operand")))
+
+(define_predicate "post_inc_memory_operand"
+  (and (match_code "mem")
+       (match_test "(GET_CODE(XEXP(op, 0)) == POST_INC)
+                     && REG_P(XEXP(XEXP(op, 0), 0))")))
+
+(define_predicate "pre_dec_memory_operand"
+  (and (match_code "mem")
+       (match_test "(GET_CODE(XEXP(op, 0)) == PRE_DEC)
+                     && REG_P(XEXP(XEXP(op, 0), 0))")))
+
+;; Operand suitable for add instructions
+(define_predicate "avr32_add_operand"
+  (ior (match_operand 0 "register_operand")
+       (and (match_operand 0 "immediate_operand")
+            (match_test "CONST_OK_FOR_CONSTRAINT_P(INTVAL(op), 'I', \"Is21\")"))))
+
+;; Operand is a power of two immediate
+(define_predicate "power_of_two_operand"
+  (match_code "const_int")
+{
+  HOST_WIDE_INT value = INTVAL (op);
+
+  return value != 0 && (value & (value - 1)) == 0;
+})
+
+;; Operand is a multiple of 8 immediate
+(define_predicate "multiple_of_8_operand"
+  (match_code "const_int")
+{
+  HOST_WIDE_INT value = INTVAL (op);
+
+  return (value & 0x7) == 0 ;
+})
+
+;; Operand is a multiple of 16 immediate
+(define_predicate "multiple_of_16_operand"
+  (match_code "const_int")
+{
+  HOST_WIDE_INT value = INTVAL (op);
+
+  return (value & 0xf) == 0 ;
+})
+
+;; Operand is a mask used for masking away upper bits of a reg
+(define_predicate "avr32_mask_upper_bits_operand"
+  (match_code "const_int")
+{
+  HOST_WIDE_INT value = INTVAL (op) + 1;
+
+  return value != 1 && value != 0 && (value & (value - 1)) == 0;
+})
+
+
+;; Operand suitable for mul instructions
+(define_predicate "avr32_mul_operand"
+  (ior (match_operand 0 "register_operand")
+       (and (match_operand 0 "immediate_operand")
+            (match_test "CONST_OK_FOR_CONSTRAINT_P(INTVAL(op), 'K', \"Ks08\")"))))
+
+;; True for logical binary operators.
+(define_predicate "logical_binary_operator"
+  (match_code "ior,xor,and"))
+
+;; True for logical shift operators
+(define_predicate "logical_shift_operator"
+  (match_code "ashift,lshiftrt"))
+
+;; True for shift operand for logical and, or and eor insns
+(define_predicate "avr32_logical_shift_operand"
+  (and (match_code "ashift,lshiftrt")
+       (ior (and (match_test "GET_CODE(XEXP(op, 1)) == CONST_INT")
+                 (match_test "register_operand(XEXP(op, 0), GET_MODE(XEXP(op, 0)))"))
+            (and (match_test "GET_CODE(XEXP(op, 0)) == CONST_INT")
+                 (match_test "register_operand(XEXP(op, 1), GET_MODE(XEXP(op, 1)))"))))
+  )
+
+
+;; Predicate for second operand to and, ior and xor insn patterns
+(define_predicate "avr32_logical_insn_operand"
+  (ior (match_operand 0 "register_operand")
+       (match_operand 0 "avr32_logical_shift_operand"))
+)
+
+
+;; True for avr32 comparison operators
+(define_predicate "avr32_comparison_operator"
+  (ior (match_code "eq, ne, gt, ge, lt, le, gtu, geu, ltu, leu")
+       (and (match_code "unspec")
+            (match_test "(XINT(op, 1) == UNSPEC_COND_MI)
+                         || (XINT(op, 1) == UNSPEC_COND_PL)"))))
+
+(define_predicate "avr32_cond3_comparison_operator"
+  (ior (match_code "eq, ne, ge, lt, geu, ltu")
+       (and (match_code "unspec")
+            (match_test "(XINT(op, 1) == UNSPEC_COND_MI)
+                         || (XINT(op, 1) == UNSPEC_COND_PL)"))))
+
+;; True for avr32 comparison operand
+(define_predicate "avr32_comparison_operand"
+  (ior (and (match_code "eq, ne, gt, ge, lt, le, gtu, geu, ltu, leu")
+            (match_test "(CC0_P (XEXP(op,0)) && rtx_equal_p (XEXP(op,1), const0_rtx))"))
+       (and (match_code "unspec")
+            (match_test "(XINT(op, 1) == UNSPEC_COND_MI)
+                         || (XINT(op, 1) == UNSPEC_COND_PL)"))))
+
+;; True if this is a const_int with one bit set
+(define_predicate "one_bit_set_operand"
+  (match_code "const_int")
+  {
+   int i;
+   int value;
+   int ones = 0;
+
+   value = INTVAL(op);
+   for ( i = 0 ; i < 32; i++ ){
+     if ( value & ( 1 << i ) ){
+        ones++;
+      }
+   }
+
+   return ( ones == 1 );
+  })
+
+
+;; True if this is a const_int with one bit cleared
+(define_predicate "one_bit_cleared_operand"
+  (match_code "const_int")
+  {
+   int i;
+   int value;
+   int zeroes = 0;
+
+   value = INTVAL(op);
+   for ( i = 0 ; i < 32; i++ ){
+     if ( !(value & ( 1 << i )) ){
+        zeroes++;
+      }
+   }
+
+   return ( zeroes == 1 );
+  })
+
+
+;; Immediate all the low 16-bits cleared
+(define_predicate "avr32_hi16_immediate_operand"
+  (match_code "const_int")
+  {
+   /* If the low 16-bits are zero then this
+      is a hi16 immediate. */
+   return ((INTVAL(op) & 0xffff) == 0);
+   }
+)
+
+;; True if this is a register or immediate operand
+(define_predicate "register_immediate_operand"
+  (ior (match_operand 0 "register_operand")
+       (match_operand 0 "immediate_operand")))
+
+;; True if this is a register or const_int operand
+(define_predicate "register_const_int_operand"
+  (ior (match_operand 0 "register_operand")
+       (and (match_operand 0 "const_int_operand")
+            (match_operand 0 "immediate_operand"))))
+
+;; True if this is a register or const_double operand
+(define_predicate "register_const_double_operand"
+  (ior (match_operand 0 "register_operand")
+       (match_operand 0 "const_double_operand")))
+
+;; True if this is an operand containing a label_ref.
+(define_predicate "avr32_label_ref_operand"
+  (and (match_code "mem")
+       (match_test "avr32_find_symbol(op)
+                    && (GET_CODE(avr32_find_symbol(op)) == LABEL_REF)")))
+
+;; True if this is a valid symbol pointing to the constant pool.
+(define_predicate "avr32_const_pool_operand"
+  (and (match_code "symbol_ref")
+       (match_test "CONSTANT_POOL_ADDRESS_P(op)"))
+  {
+        return (flag_pic ? (!(symbol_mentioned_p (get_pool_constant (op))
+                        || label_mentioned_p (get_pool_constant (op)))
+                       || avr32_got_mentioned_p(get_pool_constant (op)))
+                    : true);
+  }
+)
+
+;; True if this is a memory reference to the constant or mini pool.
+(define_predicate "avr32_const_pool_ref_operand"
+  (ior (match_operand 0 "avr32_label_ref_operand")
+       (and (match_code "mem")
+            (match_test "avr32_const_pool_operand(XEXP(op,0), GET_MODE(XEXP(op,0)))"))))
+
+
+;; Legal source operand for movti insns
+(define_predicate "avr32_movti_src_operand"
+  (ior (match_operand 0 "avr32_const_pool_ref_operand")
+       (ior (ior (match_operand 0 "register_immediate_operand")
+                 (match_operand 0 "avr32_indirect_register_operand"))
+            (match_operand 0 "post_inc_memory_operand"))))
+  
+;; Legal destination operand for movti insns
+(define_predicate "avr32_movti_dst_operand"
+  (ior (ior (match_operand 0 "register_operand")
+            (match_operand 0 "avr32_indirect_register_operand"))
+       (match_operand 0 "pre_dec_memory_operand")))
+
+
+;; True if this is a k12 offseted memory operand.
+(define_predicate "avr32_k12_memory_operand"
+  (and (match_code "mem")
+       (ior (match_test "REG_P(XEXP(op, 0))")
+            (match_test "GET_CODE(XEXP(op, 0)) == PLUS
+                         && REG_P(XEXP(XEXP(op, 0), 0))
+                         && (GET_CODE(XEXP(XEXP(op, 0), 1)) == CONST_INT)
+                         && (CONST_OK_FOR_CONSTRAINT_P(INTVAL(XEXP(XEXP(op, 0), 0)),
+                                'K', (mode == SImode) ? \"Ks14\" : ((mode == HImode) ? \"Ks13\" : \"Ks12\")))"))))
+
+;; True if this is a memory operand with an immediate displacement.
+(define_predicate "avr32_imm_disp_memory_operand"
+  (and (match_code "mem")
+       (match_test "GET_CODE(XEXP(op, 0)) == PLUS
+                    && REG_P(XEXP(XEXP(op, 0), 0))
+                    && (GET_CODE(XEXP(XEXP(op, 0), 1)) == CONST_INT)")))
+
+;; True if this is a bswap operand.
+(define_predicate "avr32_bswap_operand"
+  (ior (match_operand 0 "avr32_k12_memory_operand")
+       (match_operand 0 "register_operand")))
+
+;; True if this is a valid coprocessor insn memory operand.
+(define_predicate "avr32_cop_memory_operand"
+  (and (match_operand 0 "memory_operand")
+       (not (match_test "GET_CODE(XEXP(op, 0)) == PLUS
+                         && REG_P(XEXP(XEXP(op, 0), 0))
+                         && (GET_CODE(XEXP(XEXP(op, 0), 1)) == CONST_INT)
+                         && !(CONST_OK_FOR_CONSTRAINT_P(INTVAL(XEXP(XEXP(op, 0), 0)), 'K', \"Ku10\"))"))))
+
+;; True if this is a valid source/destination operand.
+;; for moving values to/from a coprocessor
+(define_predicate "avr32_cop_move_operand"
+  (ior (match_operand 0 "register_operand")
+       (match_operand 0 "avr32_cop_memory_operand")))
+
+
+;; True if this is a valid extract byte offset for use in
+;; load extracted index insns.
+(define_predicate "avr32_extract_shift_operand"
+  (and (match_operand 0 "const_int_operand")
+       (match_test "(INTVAL(op) == 0) || (INTVAL(op) == 8)
+                    || (INTVAL(op) == 16) || (INTVAL(op) == 24)")))
+
+;; True if this is a valid avr32 symbol operand.
+(define_predicate "avr32_symbol_operand"
+   (and (match_code "label_ref, symbol_ref, const")
+        (match_test "avr32_find_symbol(op)")))
+
+;; True if this is a valid operand for the lda.w and call pseudo insns.
+(define_predicate "avr32_address_operand"
+   (and (and (match_code "label_ref, symbol_ref")
+             (match_test "avr32_find_symbol(op)"))
+       (ior (match_test "TARGET_HAS_ASM_ADDR_PSEUDOS")
+            (match_test "flag_pic")) ))
+
+;; An immediate k16 address operand
+(define_predicate "avr32_ks16_address_operand"
+  (and (match_operand 0 "address_operand")
+       (ior (match_test "REG_P(op)")
+            (match_test "GET_CODE(op) == PLUS
+                         && ((GET_CODE(XEXP(op,0)) == CONST_INT)
+                             || (GET_CODE(XEXP(op,1)) == CONST_INT))")) ))
+
+;; An offset k16 memory operand
+(define_predicate "avr32_ks16_memory_operand"
+  (and (match_code "mem")
+       (match_test "avr32_ks16_address_operand (XEXP (op, 0), GET_MODE (XEXP (op, 0)))")))
+
+;; An immediate k11 address operand
+(define_predicate "avr32_ks11_address_operand"
+  (and (match_operand 0 "address_operand")
+       (ior (match_test "REG_P(op)")
+            (match_test "GET_CODE(op) == PLUS
+                         && (((GET_CODE(XEXP(op,0)) == CONST_INT)
+                              && avr32_const_ok_for_constraint_p(INTVAL(XEXP(op,0)), 'K', \"Ks11\"))
+                             || ((GET_CODE(XEXP(op,1)) == CONST_INT)
+                                 && avr32_const_ok_for_constraint_p(INTVAL(XEXP(op,1)), 'K', \"Ks11\")))")) ))
+
+;; True if this is a avr32 call operand
+(define_predicate "avr32_call_operand"
+  (ior (ior (match_operand 0 "register_operand")
+            (ior (match_operand 0 "avr32_const_pool_ref_operand")
+                 (match_operand 0 "avr32_address_operand")))
+       (match_test "SYMBOL_REF_RCALL_FUNCTION_P(op)")))
+
+;; Return true for operators performing ALU operations
+
+(define_predicate "alu_operator"
+  (match_code "ior, xor, and, plus, minus, ashift, lshiftrt, ashiftrt"))
+
+(define_predicate "avr32_add_shift_immediate_operand"
+  (and (match_operand 0 "immediate_operand")
+       (match_test "CONST_OK_FOR_CONSTRAINT_P(INTVAL(op), 'K', \"Ku02\")")))
+
+(define_predicate "avr32_cond_register_immediate_operand"
+  (ior (match_operand 0 "register_operand")
+       (and (match_operand 0 "immediate_operand")
+            (match_test "CONST_OK_FOR_CONSTRAINT_P(INTVAL(op), 'K', \"Ks08\")"))))
+
+(define_predicate "avr32_cond_immediate_operand"
+  (and (match_operand 0 "immediate_operand")
+       (match_test "CONST_OK_FOR_CONSTRAINT_P(INTVAL(op), 'I', \"Is08\")")))
+
+
+(define_predicate "avr32_cond_move_operand"
+  (ior (ior (match_operand 0 "register_operand")
+            (and (match_operand 0 "immediate_operand")
+                 (match_test "CONST_OK_FOR_CONSTRAINT_P(INTVAL(op), 'K', \"Ks08\")")))
+       (and (match_test "TARGET_V2_INSNS")
+            (match_operand 0 "memory_operand"))))
+
+(define_predicate "avr32_mov_immediate_operand"
+  (and (match_operand 0 "immediate_operand")
+       (match_test "avr32_const_ok_for_move(INTVAL(op))")))
+
+
+(define_predicate "avr32_rmw_address_operand"
+  (ior (and (match_code "symbol_ref") 
+            (match_test "({rtx symbol = avr32_find_symbol(op); \
+                               symbol && (GET_CODE (symbol) == SYMBOL_REF) && SYMBOL_REF_RMW_ADDR(symbol);})"))
+       (and (match_operand 0 "immediate_operand")
+            (match_test "CONST_OK_FOR_CONSTRAINT_P(INTVAL(op), 'K', \"Ks17\")")))
+  {
+     return TARGET_RMW && !flag_pic;
+  }
+)
+ 
+(define_predicate "avr32_rmw_memory_operand"
+  (and (match_code "mem") 
+       (match_test "!volatile_refs_p(op) && (GET_MODE(op) == SImode) && 
+                    avr32_rmw_address_operand(XEXP(op, 0), GET_MODE(XEXP(op, 0)))")))
+
+(define_predicate "avr32_rmw_memory_or_register_operand"
+  (ior (match_operand 0 "avr32_rmw_memory_operand")
+       (match_operand 0 "register_operand")))
+
+(define_predicate "avr32_non_rmw_memory_operand"
+  (and (not (match_operand 0 "avr32_rmw_memory_operand"))
+       (match_operand 0 "memory_operand")))
+
+(define_predicate "avr32_non_rmw_general_operand"
+  (and (not (match_operand 0 "avr32_rmw_memory_operand"))
+       (match_operand 0 "general_operand")))
+
+(define_predicate "avr32_non_rmw_nonimmediate_operand"
+  (and (not (match_operand 0 "avr32_rmw_memory_operand"))
+       (match_operand 0 "nonimmediate_operand")))
+
+;; Return true if the operand is the 1.0f constant.
+
+(define_predicate "const_1f_operand"
+  (match_code "const_int,const_double")
+{
+  return (op == CONST1_RTX (SFmode));
+})
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/simd.md gcc-4.4.6/gcc/config/avr32/simd.md
--- gcc-4.4.6.orig/gcc/config/avr32/simd.md	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/simd.md	2011-08-27 19:45:43.237989394 +0200
@@ -0,0 +1,145 @@
+;;   AVR32 machine description file for SIMD instructions.
+;;   Copyright 2003-2006 Atmel Corporation.
+;;
+;;   Written by Ronny Pedersen, Atmel Norway, <rpedersen@atmel.com>
+;;
+;;   This file is part of GCC.
+;;
+;;   This program is free software; you can redistribute it and/or modify
+;;   it under the terms of the GNU General Public License as published by
+;;   the Free Software Foundation; either version 2 of the License, or
+;;   (at your option) any later version.
+;;
+;;   This program is distributed in the hope that it will be useful,
+;;   but WITHOUT ANY WARRANTY; without even the implied warranty of
+;;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;;   GNU General Public License for more details.
+;;
+;;   You should have received a copy of the GNU General Public License
+;;   along with this program; if not, write to the Free Software
+;;   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+;; -*- Mode: Scheme -*-
+
+
+;; Vector modes
+(define_mode_iterator VECM [V2HI V4QI])
+(define_mode_attr  size [(V2HI "h") (V4QI "b")])
+
+(define_insn "add<mode>3"
+  [(set (match_operand:VECM 0 "register_operand" "=r")
+	(plus:VECM (match_operand:VECM 1 "register_operand" "r")
+                   (match_operand:VECM 2 "register_operand" "r")))]
+  "TARGET_SIMD"
+  "padd.<size>\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "alu")])
+
+
+(define_insn "sub<mode>3"
+  [(set (match_operand:VECM 0 "register_operand" "=r")
+	(minus:VECM (match_operand:VECM 1 "register_operand" "r")
+                    (match_operand:VECM 2 "register_operand" "r")))]
+  "TARGET_SIMD"
+  "psub.<size>\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "alu")])
+
+
+(define_insn "abs<mode>2"
+  [(set (match_operand:VECM 0 "register_operand" "=r")
+	(abs:VECM (match_operand:VECM 1 "register_operand" "r")))]
+  "TARGET_SIMD"
+  "pabs.s<size>\t%0, %1"
+  [(set_attr "length" "4")
+   (set_attr "type" "alu")])
+
+(define_insn "ashl<mode>3"
+  [(set (match_operand:VECM 0 "register_operand"           "=r")
+	(ashift:VECM (match_operand:VECM 1 "register_operand" "r")
+                     (match_operand:SI 2 "immediate_operand" "Ku04")))]
+  "TARGET_SIMD"
+  "plsl.<size>\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "alu")])
+
+(define_insn "ashr<mode>3"
+  [(set (match_operand:VECM 0 "register_operand"           "=r")
+	(ashiftrt:VECM (match_operand:VECM 1 "register_operand" "r")
+                       (match_operand:SI 2 "immediate_operand" "Ku04")))]
+  "TARGET_SIMD"
+  "pasr.<size>\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "alu")])
+
+(define_insn "lshr<mode>3"
+  [(set (match_operand:VECM 0 "register_operand"           "=r")
+	(lshiftrt:VECM (match_operand:VECM 1 "register_operand" "r")
+                       (match_operand:SI 2 "immediate_operand" "Ku04")))]
+  "TARGET_SIMD"
+  "plsr.<size>\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "alu")])
+
+(define_insn "smaxv2hi3"
+  [(set (match_operand:V2HI 0 "register_operand" "=r")
+	(smax:V2HI (match_operand:V2HI 1 "register_operand" "r")
+                        (match_operand:V2HI 2 "register_operand" "r")))]
+
+  "TARGET_SIMD"
+  "pmax.sh\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "alu")])
+
+(define_insn "sminv2hi3"
+  [(set (match_operand:V2HI 0 "register_operand" "=r")
+	(smin:V2HI (match_operand:V2HI 1 "register_operand" "r")
+                        (match_operand:V2HI 2 "register_operand" "r")))]
+
+  "TARGET_SIMD"
+  "pmin.sh\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "alu")])
+
+(define_insn "umaxv4qi3"
+  [(set (match_operand:V4QI 0 "register_operand" "=r")
+	(umax:V4QI (match_operand:V4QI 1 "register_operand" "r")
+                   (match_operand:V4QI 2 "register_operand" "r")))]
+
+  "TARGET_SIMD"
+  "pmax.ub\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "alu")])
+
+(define_insn "uminv4qi3"
+  [(set (match_operand:V4QI 0 "register_operand" "=r")
+	(umin:V4QI (match_operand:V4QI 1 "register_operand" "r")
+                   (match_operand:V4QI 2 "register_operand" "r")))]
+
+  "TARGET_SIMD"
+  "pmin.ub\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "alu")])
+
+
+(define_insn "addsubv2hi"
+  [(set (match_operand:V2HI 0 "register_operand" "=r")
+        (vec_concat:V2HI
+         (plus:HI (match_operand:HI 1 "register_operand" "r")
+                  (match_operand:HI 2 "register_operand" "r"))
+         (minus:HI (match_dup 1) (match_dup 2))))]
+  "TARGET_SIMD"
+  "paddsub.h\t%0, %1:b, %2:b"
+  [(set_attr "length" "4")
+   (set_attr "type" "alu")])
+
+(define_insn "subaddv2hi"
+  [(set (match_operand:V2HI 0 "register_operand" "=r")
+        (vec_concat:V2HI
+         (minus:HI (match_operand:HI 1 "register_operand" "r")
+                  (match_operand:HI 2 "register_operand" "r"))
+         (plus:HI (match_dup 1) (match_dup 2))))]
+  "TARGET_SIMD"
+  "psubadd.h\t%0, %1:b, %2:b"
+  [(set_attr "length" "4")
+   (set_attr "type" "alu")])
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/sync.md gcc-4.4.6/gcc/config/avr32/sync.md
--- gcc-4.4.6.orig/gcc/config/avr32/sync.md	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/sync.md	2011-08-27 19:45:43.280490475 +0200
@@ -0,0 +1,244 @@
+;;=================================================================
+;; Atomic operations
+;;=================================================================
+
+
+(define_insn "sync_compare_and_swapsi"
+  [(set (match_operand:SI 0 "register_operand" "=&r,&r")
+	(match_operand:SI 1 "memory_operand" "+RKs16,+RKs16"))
+   (set (match_dup 1)
+	(unspec_volatile:SI
+	  [(match_dup 1)
+	   (match_operand:SI 2 "register_immediate_operand" "r,Ks21")
+	   (match_operand:SI 3 "register_operand" "r,r")]
+	  VUNSPEC_SYNC_CMPXCHG))   ]
+  ""
+  "0:
+   ssrf\t5
+   ld.w\t%0,%1
+   cp.w\t%0,%2
+   brne\t0f
+   stcond\t%1, %3
+   brne\t0b
+   0:
+  "
+  [(set_attr "length" "16,18")
+   (set_attr "cc" "clobber")]
+  )
+ 
+
+(define_code_iterator atomic_op [plus minus and ior xor])
+(define_code_attr  atomic_asm_insn [(plus "add") (minus "sub") (and "and") (ior "or") (xor "eor")])
+(define_code_attr  atomic_insn [(plus "add") (minus "sub") (and "and") (ior "ior") (xor "xor")])
+
+(define_insn "sync_loadsi"
+  ; NB! Put an early clobber on the destination operand to 
+  ; avoid gcc using the same register in the source and 
+  ; destination. This is done in order to avoid gcc to 
+  ; clobber the source operand since these instructions
+  ; are actually inside a "loop".
+  [(set (match_operand:SI 0 "register_operand" "=&r")
+	(unspec_volatile:SI
+         [(match_operand:SI 1 "avr32_ks16_memory_operand" "RKs16")
+          (label_ref (match_operand 2 "" ""))]
+         VUNSPEC_SYNC_SET_LOCK_AND_LOAD) )]
+  ""
+  "%2:
+   ssrf\t5
+   ld.w\t%0,%1"
+  [(set_attr "length" "6")
+   (set_attr "cc" "clobber")]
+  )
+  
+(define_insn "sync_store_if_lock"
+  [(set (match_operand:SI 0 "avr32_ks16_memory_operand" "=RKs16")
+        (unspec_volatile:SI
+         [(match_operand:SI 1 "register_operand" "r")
+          (label_ref (match_operand 2 "" ""))]
+         VUNSPEC_SYNC_STORE_IF_LOCK) )]
+  ""
+  "stcond\t%0, %1
+   brne\t%2"
+  [(set_attr "length" "6")
+   (set_attr "cc" "clobber")]
+  )
+
+
+(define_expand "sync_<atomic_insn>si"
+  [(set (match_dup 2)
+	(unspec_volatile:SI
+         [(match_operand:SI 0 "avr32_ks16_memory_operand" "")
+          (match_dup 3)]
+         VUNSPEC_SYNC_SET_LOCK_AND_LOAD))
+   (set (match_dup 2) 
+        (atomic_op:SI (match_dup 2)
+                      (match_operand:SI 1 "register_immediate_operand" "")))
+   (set (match_dup 0)
+        (unspec_volatile:SI
+         [(match_dup 2)
+          (match_dup 3)]
+         VUNSPEC_SYNC_STORE_IF_LOCK) )
+   (use (match_dup 1))
+   (use (match_dup 4))]
+  ""
+  {
+   rtx *mem_expr = &operands[0];
+   rtx ptr_reg;
+   if ( !avr32_ks16_memory_operand (*mem_expr, GET_MODE (*mem_expr)) )
+    {
+      ptr_reg = force_reg (Pmode, XEXP (*mem_expr, 0));
+      XEXP (*mem_expr, 0) = ptr_reg;
+    } 
+   else 
+    {
+      rtx address = XEXP (*mem_expr, 0);
+      if ( REG_P (address) )
+         ptr_reg = address;
+      else if ( REG_P (XEXP (address, 0)) ) 
+         ptr_reg = XEXP (address, 0);
+      else 
+         ptr_reg = XEXP (address, 1);
+    }
+
+   operands[2] = gen_reg_rtx (SImode);
+   operands[3] = gen_rtx_LABEL_REF(Pmode, gen_label_rtx ());
+   operands[4] = ptr_reg;   
+
+  }
+  )
+
+
+
+(define_expand "sync_old_<atomic_insn>si"
+  [(set (match_operand:SI 0 "register_operand" "")
+	(unspec_volatile:SI
+         [(match_operand:SI 1 "avr32_ks16_memory_operand" "")
+          (match_dup 4)]
+         VUNSPEC_SYNC_SET_LOCK_AND_LOAD))
+   (set (match_dup 3) 
+        (atomic_op:SI (match_dup 0)
+                      (match_operand:SI 2 "register_immediate_operand" "")))
+   (set (match_dup 1)
+        (unspec_volatile:SI
+         [(match_dup 3)
+          (match_dup 4)]
+         VUNSPEC_SYNC_STORE_IF_LOCK) )
+   (use (match_dup 2))
+   (use (match_dup 5))]
+  ""
+  {
+   rtx *mem_expr = &operands[1];
+   rtx ptr_reg;
+   if ( !avr32_ks16_memory_operand (*mem_expr, GET_MODE (*mem_expr)) )
+    {
+      ptr_reg = force_reg (Pmode, XEXP (*mem_expr, 0));
+      XEXP (*mem_expr, 0) = ptr_reg;
+    } 
+   else 
+    {
+      rtx address = XEXP (*mem_expr, 0);
+      if ( REG_P (address) )
+         ptr_reg = address;
+      else if ( REG_P (XEXP (address, 0)) ) 
+         ptr_reg = XEXP (address, 0);
+      else 
+         ptr_reg = XEXP (address, 1);
+    }
+
+   operands[3] = gen_reg_rtx (SImode);
+   operands[4] = gen_rtx_LABEL_REF(Pmode, gen_label_rtx ());
+   operands[5] = ptr_reg;
+  }
+  )
+
+(define_expand "sync_new_<atomic_insn>si"
+  [(set (match_operand:SI 0 "register_operand" "")
+	(unspec_volatile:SI
+         [(match_operand:SI 1 "avr32_ks16_memory_operand" "")
+          (match_dup 3)]
+         VUNSPEC_SYNC_SET_LOCK_AND_LOAD))
+   (set (match_dup 0) 
+        (atomic_op:SI (match_dup 0)
+                      (match_operand:SI 2 "register_immediate_operand" "")))
+   (set (match_dup 1)
+        (unspec_volatile:SI
+         [(match_dup 0)
+          (match_dup 3)]
+         VUNSPEC_SYNC_STORE_IF_LOCK) )
+   (use (match_dup 2))
+   (use (match_dup 4))]
+  ""
+  {
+   rtx *mem_expr = &operands[1];
+   rtx ptr_reg;
+   if ( !avr32_ks16_memory_operand (*mem_expr, GET_MODE (*mem_expr)) )
+    {
+      ptr_reg = force_reg (Pmode, XEXP (*mem_expr, 0));
+      XEXP (*mem_expr, 0) = ptr_reg;
+    } 
+   else 
+    {
+      rtx address = XEXP (*mem_expr, 0);
+      if ( REG_P (address) )
+         ptr_reg = address;
+      else if ( REG_P (XEXP (address, 0)) ) 
+         ptr_reg = XEXP (address, 0);
+      else 
+         ptr_reg = XEXP (address, 1);
+    }
+
+   operands[3] = gen_rtx_LABEL_REF(Pmode, gen_label_rtx ());
+   operands[4] = ptr_reg;
+  }
+  )
+
+
+;(define_insn "sync_<atomic_insn>si"
+;  [(set (match_operand:SI 0 "memory_operand" "+RKs16")
+;	(unspec_volatile:SI
+;         [(atomic_op:SI (match_dup 0)
+;                        (match_operand:SI 1 "register_operand" "r"))]
+;         VUNSPEC_SYNC_CMPXCHG))
+;   (clobber (match_scratch:SI 2 "=&r"))]
+;  ""
+;  "0:
+;   ssrf\t5
+;   ld.w\t%2,%0
+;   <atomic_asm_insn>\t%2,%1
+;   stcond\t%0, %2
+;   brne\t0b
+;  "
+;  [(set_attr "length" "14")
+;   (set_attr "cc" "clobber")]
+;  )
+;
+;(define_insn "sync_new_<atomic_insn>si"
+;  [(set (match_operand:SI 1 "memory_operand" "+RKs16")
+;	(unspec_volatile:SI
+;         [(atomic_op:SI (match_dup 1)
+;                        (match_operand:SI 2 "register_operand" "r"))]
+;         VUNSPEC_SYNC_CMPXCHG))
+;   (set (match_operand:SI 0 "register_operand" "=&r")
+;	(atomic_op:SI (match_dup 1)
+;                      (match_dup 2)))]
+;  ""
+;  "0:
+;   ssrf\t5
+;   ld.w\t%0,%1
+;   <atomic_asm_insn>\t%0,%2
+;   stcond\t%1, %0
+;   brne\t0b
+;  "
+;  [(set_attr "length" "14")
+;   (set_attr "cc" "clobber")]
+;  )
+
+(define_insn "sync_lock_test_and_setsi"
+  [ (set (match_operand:SI 0 "register_operand" "=&r")
+         (match_operand:SI 1 "memory_operand" "+RKu00"))
+    (set (match_dup 1)
+         (match_operand:SI 2 "register_operand" "r")) ]
+  ""
+  "xchg\t%0, %p1, %2"
+  [(set_attr "length" "4")]
+  )
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/t-avr32 gcc-4.4.6/gcc/config/avr32/t-avr32
--- gcc-4.4.6.orig/gcc/config/avr32/t-avr32	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/t-avr32	2011-08-27 19:45:43.327990411 +0200
@@ -0,0 +1,118 @@
+
+MD_INCLUDES= 	$(srcdir)/config/avr32/avr32.md \
+		$(srcdir)/config/avr32/sync.md \
+		$(srcdir)/config/avr32/simd.md \
+        $(srcdir)/config/avr32/predicates.md
+
+s-config s-conditions s-flags s-codes s-constants s-emit s-recog s-preds \
+	s-opinit s-extract s-peep s-attr s-attrtab s-output: $(MD_INCLUDES)
+
+# We want fine grained libraries, so use the new code
+# to build the floating point emulation libraries.
+FPBIT = fp-bit.c
+DPBIT = dp-bit.c
+
+LIB1ASMSRC = avr32/lib1funcs.S
+LIB1ASMFUNCS =  _avr32_f64_mul _avr32_f64_mul_fast _avr32_f64_addsub _avr32_f64_addsub_fast  _avr32_f64_to_u32 \
+                _avr32_f64_to_s32 _avr32_f64_to_u64 _avr32_f64_to_s64 _avr32_u32_to_f64 \
+                _avr32_s32_to_f64 _avr32_f64_cmp_eq _avr32_f64_cmp_ge _avr32_f64_cmp_lt \
+                _avr32_f32_cmp_eq _avr32_f32_cmp_ge _avr32_f32_cmp_lt _avr32_f64_div _avr32_f64_div_fast \
+                _avr32_f32_div _avr32_f32_div_fast _avr32_f32_addsub _avr32_f32_addsub_fast \
+                _avr32_f32_mul _avr32_s32_to_f32 _avr32_u32_to_f32 _avr32_f32_to_s32 \
+                _avr32_f32_to_u32 _avr32_f32_to_f64 _avr32_f64_to_f32 _mulsi3
+
+#LIB2FUNCS_EXTRA += $(srcdir)/config/avr32/lib2funcs.S
+
+MULTILIB_OPTIONS     = march=ap/march=ucr1/march=ucr2/march=ucr2nomul/march=ucr3/march=ucr3fp
+MULTILIB_DIRNAMES    = ap ucr1 ucr2 ucr2nomul ucr3 ucr3fp
+MULTILIB_EXCEPTIONS  =
+MULTILIB_MATCHES     += march?ap=mpart?ap7000
+MULTILIB_MATCHES     += march?ap=mpart?ap7001
+MULTILIB_MATCHES     += march?ap=mpart?ap7002
+MULTILIB_MATCHES     += march?ap=mpart?ap7200
+MULTILIB_MATCHES     += march?ucr1=march?uc
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3a0512es
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a0128
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a0256
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a0512
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a1128
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a1256
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3a1512es
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a1512
+MULTILIB_MATCHES     += march?ucr2nomul=mpart?uc3a3revd
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a364
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a364s
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a3128
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a3128s
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a3256
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a3256s
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a464
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a464s
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a4128
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a4128s
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a4256
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a4256s
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3b064
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3b0128
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3b0256es
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3b0256
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3b0512
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3b0512revc
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3b164
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3b1128
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3b1256es
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3b1256
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3b1512
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3b1512revc
+MULTILIB_MATCHES     += march?ucr3=mpart?uc64d3
+MULTILIB_MATCHES     += march?ucr3=mpart?uc128d3
+MULTILIB_MATCHES     += march?ucr3=mpart?uc64d4
+MULTILIB_MATCHES     += march?ucr3=mpart?uc128d4
+MULTILIB_MATCHES     += march?ucr3=mpart?uc3c0512crevc
+MULTILIB_MATCHES     += march?ucr3=mpart?uc3c1512crevc
+MULTILIB_MATCHES     += march?ucr3=mpart?uc3c2512crevc
+MULTILIB_MATCHES     += march?ucr3=mpart?uc3l0256
+MULTILIB_MATCHES     += march?ucr3=mpart?uc3l0128
+MULTILIB_MATCHES     += march?ucr3=mpart?uc3l064
+MULTILIB_MATCHES     += march?ucr3=mpart?uc3l032
+MULTILIB_MATCHES     += march?ucr3=mpart?uc3l016
+MULTILIB_MATCHES     += march?ucr3=mpart?uc3l064revb
+MULTILIB_MATCHES     += march?ucr3=mpart?uc64l3u
+MULTILIB_MATCHES     += march?ucr3=mpart?uc128l3u
+MULTILIB_MATCHES     += march?ucr3=mpart?uc256l3u
+MULTILIB_MATCHES     += march?ucr3=mpart?uc64l4u
+MULTILIB_MATCHES     += march?ucr3=mpart?uc128l4u
+MULTILIB_MATCHES     += march?ucr3=mpart?uc256l4u
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c064c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c0128c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c0256c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c0512c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c164c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c1128c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c1256c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c1512c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c264c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c2128c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c2256c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c2512c
+MULTILIB_MATCHES     += march?ucr3=mpart?mxt768e
+
+
+EXTRA_MULTILIB_PARTS = crtbegin.o crtbeginS.o crtend.o crtendS.o crti.o crtn.o
+
+CRTSTUFF_T_CFLAGS = -mrelax
+CRTSTUFF_T_CFLAGS_S = -mrelax -fPIC
+TARGET_LIBGCC2_CFLAGS += -mrelax
+
+LIBGCC = stmp-multilib
+INSTALL_LIBGCC = install-multilib
+
+fp-bit.c: $(srcdir)/config/fp-bit.c
+	echo '#define FLOAT' > fp-bit.c
+	cat $(srcdir)/config/fp-bit.c >> fp-bit.c
+
+dp-bit.c: $(srcdir)/config/fp-bit.c
+	cat $(srcdir)/config/fp-bit.c > dp-bit.c
+
+
+
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/t-avr32-linux gcc-4.4.6/gcc/config/avr32/t-avr32-linux
--- gcc-4.4.6.orig/gcc/config/avr32/t-avr32-linux	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/t-avr32-linux	2011-08-27 19:45:43.367991180 +0200
@@ -0,0 +1,118 @@
+
+MD_INCLUDES= 	$(srcdir)/config/avr32/avr32.md \
+		$(srcdir)/config/avr32/sync.md \
+		$(srcdir)/config/avr32/simd.md \
+		$(srcdir)/config/avr32/predicates.md
+
+s-config s-conditions s-flags s-codes s-constants s-emit s-recog s-preds \
+	s-opinit s-extract s-peep s-attr s-attrtab s-output: $(MD_INCLUDES)
+
+# We want fine grained libraries, so use the new code
+# to build the floating point emulation libraries.
+FPBIT = fp-bit.c
+DPBIT = dp-bit.c
+
+LIB1ASMSRC = avr32/lib1funcs.S
+LIB1ASMFUNCS =  _avr32_f64_mul _avr32_f64_mul_fast _avr32_f64_addsub _avr32_f64_addsub_fast  _avr32_f64_to_u32 \
+                _avr32_f64_to_s32 _avr32_f64_to_u64 _avr32_f64_to_s64 _avr32_u32_to_f64 \
+                _avr32_s32_to_f64 _avr32_f64_cmp_eq _avr32_f64_cmp_ge _avr32_f64_cmp_lt \
+                _avr32_f32_cmp_eq _avr32_f32_cmp_ge _avr32_f32_cmp_lt _avr32_f64_div _avr32_f64_div_fast \
+                _avr32_f32_div _avr32_f32_div_fast _avr32_f32_addsub _avr32_f32_addsub_fast \
+                _avr32_f32_mul _avr32_s32_to_f32 _avr32_u32_to_f32 _avr32_f32_to_s32 \
+                _avr32_f32_to_u32 _avr32_f32_to_f64 _avr32_f64_to_f32 _mulsi3
+
+#LIB2FUNCS_EXTRA += $(srcdir)/config/avr32/lib2funcs.S
+
+MULTILIB_OPTIONS     = march=ap/march=ucr1/march=ucr2/march=ucr2nomul/march=ucr3/march=ucr3fp
+MULTILIB_DIRNAMES    = ap ucr1 ucr2 ucr2nomul ucr3 ucr3fp
+MULTILIB_EXCEPTIONS  =
+MULTILIB_MATCHES     += march?ap=mpart?ap7000
+MULTILIB_MATCHES     += march?ap=mpart?ap7001
+MULTILIB_MATCHES     += march?ap=mpart?ap7002
+MULTILIB_MATCHES     += march?ap=mpart?ap7200
+MULTILIB_MATCHES     += march?ucr1=march?uc
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3a0512es
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a0128
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a0256
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a0512
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a1128
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a1256
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3a1512es
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a1512
+MULTILIB_MATCHES     += march?ucr2nomul=mpart?uc3a3revd
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a364
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a364s
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a3128
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a3128s
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a3256
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a3256s
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a464
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a464s
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a4128
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a4128s
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a4256
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3a4256s
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3b064
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3b0128
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3b0256es
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3b0256
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3b0512
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3b0512revc
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3b164
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3b1128
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3b1256es
+MULTILIB_MATCHES     += march?ucr1=mpart?uc3b1256
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3b1512
+MULTILIB_MATCHES     += march?ucr2=mpart?uc3b1512revc
+MULTILIB_MATCHES     += march?ucr3=mpart?uc64d3
+MULTILIB_MATCHES     += march?ucr3=mpart?uc128d3
+MULTILIB_MATCHES     += march?ucr3=mpart?uc64d4
+MULTILIB_MATCHES     += march?ucr3=mpart?uc128d4
+MULTILIB_MATCHES     += march?ucr3=mpart?uc3c0512crevc
+MULTILIB_MATCHES     += march?ucr3=mpart?uc3c1512crevc
+MULTILIB_MATCHES     += march?ucr3=mpart?uc3c2512crevc
+MULTILIB_MATCHES     += march?ucr3=mpart?uc3l0256
+MULTILIB_MATCHES     += march?ucr3=mpart?uc3l0128
+MULTILIB_MATCHES     += march?ucr3=mpart?uc3l064
+MULTILIB_MATCHES     += march?ucr3=mpart?uc3l032
+MULTILIB_MATCHES     += march?ucr3=mpart?uc3l016
+MULTILIB_MATCHES     += march?ucr3=mpart?uc3l064revb
+MULTILIB_MATCHES     += march?ucr3=mpart?uc64l3u
+MULTILIB_MATCHES     += march?ucr3=mpart?uc128l3u
+MULTILIB_MATCHES     += march?ucr3=mpart?uc256l3u
+MULTILIB_MATCHES     += march?ucr3=mpart?uc64l4u
+MULTILIB_MATCHES     += march?ucr3=mpart?uc128l4u
+MULTILIB_MATCHES     += march?ucr3=mpart?uc256l4u
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c064c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c0128c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c0256c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c0512c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c164c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c1128c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c1256c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c1512c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c264c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c2128c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c2256c
+MULTILIB_MATCHES     += march?ucr3fp=mpart?uc3c2512c
+MULTILIB_MATCHES     += march?ucr3=mpart?mxt768e
+
+
+EXTRA_MULTILIB_PARTS = crtbegin.o crtbeginS.o crtend.o crtendS.o
+
+CRTSTUFF_T_CFLAGS = -mrelax
+CRTSTUFF_T_CFLAGS_S = -mrelax -fPIC
+TARGET_LIBGCC2_CFLAGS += -mrelax
+
+LIBGCC = stmp-multilib
+INSTALL_LIBGCC = install-multilib
+
+fp-bit.c: $(srcdir)/config/fp-bit.c
+	echo '#define FLOAT' > fp-bit.c
+	cat $(srcdir)/config/fp-bit.c >> fp-bit.c
+
+dp-bit.c: $(srcdir)/config/fp-bit.c
+	cat $(srcdir)/config/fp-bit.c > dp-bit.c
+
+
+
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/t-elf gcc-4.4.6/gcc/config/avr32/t-elf
--- gcc-4.4.6.orig/gcc/config/avr32/t-elf	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/t-elf	2011-08-27 19:45:43.427991160 +0200
@@ -0,0 +1,16 @@
+
+# Assemble startup files.
+$(T)crti.o: $(srcdir)/config/avr32/crti.asm $(GCC_PASSES)
+	$(GCC_FOR_TARGET) $(CRTSTUFF_CFLAGS) $(CRTSTUFF_T_CFLAGS) $(INCLUDES) \
+	-c -o $(T)crti.o -x assembler-with-cpp $(srcdir)/config/avr32/crti.asm
+
+$(T)crtn.o: $(srcdir)/config/avr32/crtn.asm $(GCC_PASSES)
+	$(GCC_FOR_TARGET) $(CRTSTUFF_CFLAGS) $(CRTSTUFF_T_CFLAGS) $(INCLUDES) \
+	-c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/avr32/crtn.asm
+
+
+# Build the libraries for both hard and soft floating point
+EXTRA_MULTILIB_PARTS = crtbegin.o crtbeginS.o crtend.o crtendS.o crti.o crtn.o
+
+LIBGCC = stmp-multilib
+INSTALL_LIBGCC = install-multilib
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/uc3fpu.md gcc-4.4.6/gcc/config/avr32/uc3fpu.md
--- gcc-4.4.6.orig/gcc/config/avr32/uc3fpu.md	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/uc3fpu.md	2011-08-27 19:45:43.470489984 +0200
@@ -0,0 +1,199 @@
+;;   AVR32 machine description file for Floating-Point instructions.
+;;   Copyright 2003-2006 Atmel Corporation.
+;;
+;;
+;;   This file is part of GCC.
+;;
+;;   This program is free software; you can redistribute it and/or modify
+;;   it under the terms of the GNU General Public License as published by
+;;   the Free Software Foundation; either version 2 of the License, or
+;;   (at your option) any later version.
+;;
+;;   This program is distributed in the hope that it will be useful,
+;;   but WITHOUT ANY WARRANTY; without even the implied warranty of
+;;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;;   GNU General Public License for more details.
+;;
+;;   You should have received a copy of the GNU General Public License
+;;   along with this program; if not, write to the Free Software
+;;   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+(define_insn "*movsf_uc3fp"
+  [(set (match_operand:SF 0 "nonimmediate_operand"     "=r,r,r,m")
+	(match_operand:SF 1 "general_operand"          "r,G,m,r"))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "@
+   mov\t%0, %1
+   mov\t%0, %1
+   ld.w\t%0, %1
+   st.w\t%0, %1"
+  [(set_attr "length" "2,4,4,4")
+   (set_attr "type" "alu,alu,load,store")])
+
+(define_insn "mulsf3"
+  [(set (match_operand:SF          0 "register_operand" "=r")
+	(mult:SF (match_operand:SF 1 "register_operand" "r")
+		 (match_operand:SF 2 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fmul.s\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmul")])
+
+(define_insn "nmulsf3"
+  [(set (match_operand:SF          0 "register_operand" "=r")
+	(neg:SF (mult:SF (match_operand:SF 1 "register_operand" "%r")
+                         (match_operand:SF 2 "register_operand" "r"))))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fnmul.s\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmul")])
+
+(define_insn "macsf3"
+  [(set (match_operand:SF          0 "register_operand" "=r")
+	(plus:SF (mult:SF (match_operand:SF 1 "register_operand" "r")
+                          (match_operand:SF 2 "register_operand" "r"))
+                 (match_operand:SF 3 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fmac.s\t%0, %3, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmul")])
+
+;(define_insn "nmacsf3"
+;  [(set (match_operand:SF          0 "register_operand" "=r")
+;	(plus:SF  (neg:SF (match_operand:SF 1 "register_operand" "r"))
+;                            (mult:SF(match_operand:SF 2 "register_operand" "r")
+;                                    (match_operand:SF 3 "register_operand" "r"))))]
+;  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+;  "fnmac.s\t%0, %1, %2, %3"
+;  [(set_attr "length" "4")
+;   (set_attr "type" "fmul")])
+
+(define_insn "nmacsf3"
+  [(set (match_operand:SF          0 "register_operand" "=r")
+	(minus:SF  (mult:SF (match_operand:SF 2 "register_operand" "r")
+                        (match_operand:SF 3 "register_operand" "r"))
+	                    (match_operand:SF 1 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fnmac.s\t%0, %1, %2, %3"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmul")])
+
+(define_insn "msubacsf3"
+  [(set (match_operand:SF          0 "register_operand" "=r")
+	(minus:SF (match_operand:SF 3 "register_operand" "r")
+	          (mult:SF (match_operand:SF 1 "register_operand" "r")
+                       (match_operand:SF 2 "register_operand" "r"))))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fmsc.s\t%0, %3, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmul")])
+
+(define_insn "nmsubacsf3"
+  [(set (match_operand:SF          0 "register_operand" "=r")
+	(minus:SF  (neg:SF (mult:SF (match_operand:SF 1 "register_operand" "r")
+                                    (match_operand:SF 2 "register_operand" "r")))
+                   (match_operand:SF 3 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fnmsc.s\t%0, %3, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmul")])
+
+(define_insn "addsf3"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+	(plus:SF (match_operand:SF 1 "register_operand" "%r")
+                   (match_operand:SF 2 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fadd.s\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmul")])
+
+(define_insn "subsf3"
+  [(set (match_operand:SF          0 "register_operand" "=r")
+	(minus:SF (match_operand:SF 1 "register_operand" "r")
+                  (match_operand:SF 2 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fsub.s\t%0, %1, %2"
+  [(set_attr "length" "4")
+   (set_attr "type" "fmul")])
+
+(define_insn "fixuns_truncsfsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unsigned_fix:SI (match_operand:SF 1 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fcastrs.uw\t%0, %1"
+  [(set_attr "length" "4")])
+
+(define_insn "fix_truncsfsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(fix:SI (match_operand:SF 1 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fcastrs.sw\t%0, %1"
+  [(set_attr "length" "4")])
+
+(define_insn "floatunssisf2"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+        (unsigned_float:SF (match_operand:SI 1 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fcastuw.s\t%0, %1"
+  [(set_attr "length" "4")])
+
+(define_insn "floatsisf2"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+        (float:SF (match_operand:SI 1 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "fcastsw.s\t%0, %1"
+  [(set_attr "length" "4")])
+
+(define_insn "cmpsf_internal_uc3fp"
+  [(set (cc0)
+        (compare:CC
+         (match_operand:SF 0 "register_operand" "r")
+         (match_operand:SF 1 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  {
+        avr32_branch_type = CMP_SF;
+   if (!rtx_equal_p(cc_prev_status.mdep.value, SET_SRC(PATTERN (insn))) )
+      return "fcmp.s\t%0, %1";
+   return "";
+  }
+  [(set_attr "length" "4")
+   (set_attr "cc" "compare")])
+
+(define_expand "divsf3"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+	(div:SF (match_operand:SF 1 "register_operand" "r")
+		 (match_operand:SF 2 "register_operand" "r")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT && flag_unsafe_math_optimizations"
+  "{
+    emit_insn(gen_frcpa_internal(operands[0],operands[2]));
+    emit_insn(gen_mulsf3(operands[0],operands[0],operands[1]));
+    DONE;
+  }"  
+)
+
+(define_insn "frcpa_internal"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+	(unspec:SF [(match_operand:SF 1 "register_operand" "r")] UNSPEC_FRCPA))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "frcpa.s %0,%1"
+  [(set_attr "length" "4")])
+
+(define_expand "sqrtsf2"
+  [(set (match_operand:SF 0 "register_operand" "")
+	(sqrt:SF (match_operand:SF 1 "register_operand" "")))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT && flag_unsafe_math_optimizations"
+  "
+{
+  rtx scratch = gen_reg_rtx (SFmode);
+  emit_insn (gen_rsqrtsf2 (scratch, operands[1], CONST1_RTX (SFmode)));
+  emit_insn (gen_divsf3(operands[0], force_reg (SFmode, CONST1_RTX (SFmode)),
+			 scratch));
+  DONE;
+}")
+
+(define_insn "rsqrtsf2"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+	(div:SF (match_operand:SF 2 "const_1f_operand" "F")
+		(sqrt:SF (match_operand:SF 1 "register_operand" "?r"))))]
+  "TARGET_ARCH_FPU && TARGET_HARD_FLOAT"
+  "frsqrta.s %1, %0")
diff -Nur gcc-4.4.6.orig/gcc/config/avr32/uclinux-elf.h gcc-4.4.6/gcc/config/avr32/uclinux-elf.h
--- gcc-4.4.6.orig/gcc/config/avr32/uclinux-elf.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config/avr32/uclinux-elf.h	2011-08-27 19:45:43.510490479 +0200
@@ -0,0 +1,20 @@
+
+/* Run-time Target Specification.  */
+#undef  TARGET_VERSION
+#define TARGET_VERSION  fputs (" (AVR32 uClinux with ELF)", stderr)
+
+/* We don't want a .jcr section on uClinux. As if this makes a difference... */
+#define TARGET_USE_JCR_SECTION 0
+
+/* Here we go. Drop the crtbegin/crtend stuff completely. */
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC							\
+  "%{!shared: %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s}"			\
+  " %{!p:%{profile:gcrt1.o%s}"						\
+  " %{!profile:crt1.o%s}}}} crti.o%s"
+
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC "crtn.o%s"
+
+#undef TARGET_DEFAULT
+#define TARGET_DEFAULT (AVR32_FLAG_NO_INIT_GOT)
diff -Nur gcc-4.4.6.orig/gcc/config/host-linux.c gcc-4.4.6/gcc/config/host-linux.c
--- gcc-4.4.6.orig/gcc/config/host-linux.c	2009-02-20 16:20:38.000000000 +0100
+++ gcc-4.4.6/gcc/config/host-linux.c	2011-08-27 19:45:43.560490932 +0200
@@ -25,6 +25,9 @@
 #include "hosthooks.h"
 #include "hosthooks-def.h"
 
+#ifndef SSIZE_MAX
+#define SSIZE_MAX LONG_MAX
+#endif
 
 /* Linux has a feature called exec-shield-randomize that perturbs the
    address of non-fixed mapped segments by a (relatively) small amount.
diff -Nur gcc-4.4.6.orig/gcc/config.gcc gcc-4.4.6/gcc/config.gcc
--- gcc-4.4.6.orig/gcc/config.gcc	2011-02-18 22:39:51.000000000 +0100
+++ gcc-4.4.6/gcc/config.gcc	2011-08-27 19:45:43.637990448 +0200
@@ -810,6 +810,24 @@
 avr-*-*)
 	tm_file="avr/avr.h dbxelf.h"
 	;;
+avr32*-*-linux*)
+	tm_file="dbxelf.h elfos.h linux.h avr32/linux-elf.h avr32/avr32.h "
+	tmake_file="t-linux avr32/t-avr32-linux"
+	extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
+	extra_modes=avr32/avr32-modes.def
+	gnu_ld=yes
+	;;
+avr32*-*-uclinux*)
+	tm_file="dbxelf.h elfos.h linux.h avr32/linux-elf.h avr32/uclinux-elf.h avr32/avr32.h"
+	tmake_file="t-linux avr32/t-avr32-linux"
+	extra_modes=avr32/avr32-modes.def
+	gnu_ld=yes
+	;;
+avr32-*-*)
+	tm_file="dbxelf.h elfos.h avr32/avr32.h avr32/avr32-elf.h"
+	tmake_file="avr32/t-avr32 avr32/t-elf"
+	extra_modes=avr32/avr32-modes.def
+	;;
 bfin*-elf*)
 	tm_file="${tm_file} dbxelf.h elfos.h bfin/elf.h"
 	tmake_file=bfin/t-bfin-elf
@@ -2736,6 +2754,32 @@
 		fi
 		;;
 
+	avr32*-*-*)
+		supported_defaults="part arch"
+
+		case "$with_part" in
+		"" \
+		| "ap7000" | "ap7010" | "ap7020" | "uc3a0256" | "uc3a0512" | "uc3a1128" | "uc3a1256" | "uc3a1512" )
+			# OK
+			;;
+		*)
+			echo "Unknown part used in --with-part=$with_part" 1>&2
+			exit 1
+			;;
+		esac
+
+		case "$with_arch" in
+		"" \
+		| "ap" | "uc")
+			# OK
+			;;
+		*)
+			echo "Unknown arch used in --with-arch=$with_arch" 1>&2
+			exit 1
+			;;
+		esac
+                ;;
+
 	fr*-*-*linux*)
 		supported_defaults=cpu
 		case "$with_cpu" in
diff -Nur gcc-4.4.6.orig/gcc/config.gcc.orig gcc-4.4.6/gcc/config.gcc.orig
--- gcc-4.4.6.orig/gcc/config.gcc.orig	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/config.gcc.orig	2011-02-18 22:39:51.000000000 +0100
@@ -0,0 +1,3208 @@
+# GCC target-specific configuration file.
+# Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
+# 2008, 2009, 2010 Free Software Foundation, Inc.
+
+#This file is part of GCC.
+
+#GCC is free software; you can redistribute it and/or modify it under
+#the terms of the GNU General Public License as published by the Free
+#Software Foundation; either version 3, or (at your option) any later
+#version.
+
+#GCC is distributed in the hope that it will be useful, but WITHOUT
+#ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+#for more details.
+
+#You should have received a copy of the GNU General Public License
+#along with GCC; see the file COPYING3.  If not see
+#<http://www.gnu.org/licenses/>.
+
+# This is the GCC target-specific configuration file
+# where a configuration type is mapped to different system-specific
+# definitions and files.  This is invoked by the autoconf-generated
+# configure script.  Putting it in a separate shell file lets us skip
+# running autoconf when modifying target-specific information.
+
+# When you change the cases in the OS or target switches, consider
+# updating ../libgcc/config.host also.
+
+# This file switches on the shell variable ${target}, and also uses the
+# following shell variables:
+#
+#  with_*		Various variables as set by configure.
+#
+#  enable_threads	Either the name, yes or no depending on whether
+#			threads support was requested.
+#
+#  default_use_cxa_atexit
+#			  The default value for the $enable___cxa_atexit
+#			variable.  enable___cxa_atexit needs to be set to
+#			"yes" for the correct operation of C++ destructors
+#			but it relies upon the presence of a non-standard C
+#			library	function called	__cxa_atexit.
+#			  Since not all C libraries provide __cxa_atexit the
+#			default value of $default_use_cxa_atexit is set to
+#			"no" except for targets which are known to be OK.
+#
+#  gas_flag		Either yes or no depending on whether GNU as was
+#			requested.
+#
+#  gnu_ld_flag		Either yes or no depending on whether GNU ld was
+#			requested.
+
+# This file sets the following shell variables for use by the
+# autoconf-generated configure script:
+#
+#  cpu_type		The name of the cpu, if different from the first
+#			chunk of the canonical target name.
+#
+#  tm_defines		List of target macros to define for all compilations.
+#
+#  tm_file		A list of target macro files, if different from
+#			"$cpu_type/$cpu_type.h". Usually it's constructed
+#			per target in a way like this:
+#			tm_file="${tm_file} dbxelf.h elfos.h svr4.h ${cpu_type.h}/elf.h"
+#			Note that the preferred order is:
+#			- specific target header "${cpu_type}/${cpu_type.h}"
+#			- generic headers like dbxelf.h elfos.h, etc.
+#			- specializing target headers like ${cpu_type.h}/elf.h
+#			This helps to keep OS specific stuff out of the CPU
+#			defining header ${cpu_type}/${cpu_type.h}.
+#
+#			It is possible to include automatically-generated
+#			build-directory files by prefixing them with "./".
+#			All other files should relative to $srcdir/config.
+#
+#  tm_p_file		Location of file with declarations for functions
+#			in $out_file.
+#
+#  out_file		The name of the machine description C support
+#			file, if different from "$cpu_type/$cpu_type.c".
+#
+#  md_file		The name of the machine-description file, if
+#			different from "$cpu_type/$cpu_type.md".
+#
+#  tmake_file		A list of machine-description-specific
+#			makefile-fragments, if different from
+#			"$cpu_type/t-$cpu_type".
+#
+#  extra_modes          The name of the file containing a list of extra
+#                       machine modes, if necessary and different from
+#                       "$cpu_type/$cpu_type-modes.def".
+#
+#  extra_objs		List of extra objects that should be linked into
+#			the compiler proper (cc1, cc1obj, cc1plus)
+#			depending on target.
+#
+#  extra_gcc_objs	List of extra objects that should be linked into
+#			the compiler driver (gcc) depending on target.
+#
+#  extra_headers	List of used header files from the directory
+#			config/${cpu_type}.
+#
+#  use_gcc_tgmath	If set, add tgmath.h to the list of used header
+#			files.
+#
+#  extra_passes		List of extra executables compiled for this target
+#			machine, used for compiling from source to object.
+#
+#  extra_parts		List of extra object files that should be compiled
+#			for this target machine.
+#
+#  extra_programs	Like extra_passes, but these are used when linking.
+#
+#  extra_options	List of target-dependent .opt files.
+#
+#  c_target_objs	List of extra target-dependent objects that be
+#			linked into the C compiler only.
+#
+#  cxx_target_objs	List of extra target-dependent objects that be
+#			linked into the C++ compiler only.
+#
+#  fortran_target_objs	List of extra target-dependent objects that be
+#			linked into the fortran compiler only.
+#
+#  target_gtfiles       List of extra source files with type information.
+#
+#  xm_defines		List of macros to define when compiling for the
+#			target machine.
+#
+#  xm_file		List of files to include when compiling for the
+#			target machine.
+#
+#  use_collect2		Set to yes or no, depending on whether collect2
+#			will be used.
+#
+#  target_cpu_default	Set to override the default target model.
+#
+#  gdb_needs_out_file_path
+#			Set to yes if gdb needs a dir command with
+#			`dirname $out_file`.
+#
+#  thread_file		Set to control which thread package to use.
+#
+#  gas			Set to yes or no depending on whether the target
+#			system normally uses GNU as.
+#
+#  need_64bit_hwint	Set to yes if HOST_WIDE_INT must be 64 bits wide
+#			for this target.  This is true if this target
+#			supports "long" or "wchar_t" wider than 32 bits,
+#			or BITS_PER_WORD is wider than 32 bits.
+#			The setting made here must match the one made in
+#			other locations such as libcpp/configure.ac
+#
+#  configure_default_options
+#			Set to an initializer for configure_default_options
+#			in configargs.h, based on --with-cpu et cetera.
+#
+#  use_fixproto		Set to "yes" if fixproto should be run normally,
+#			"no" if fixproto should never be run.
+
+# The following variables are used in each case-construct to build up the
+# outgoing variables:
+#
+#  gnu_ld		Set to yes or no depending on whether the target
+#			system normally uses GNU ld.
+
+out_file=
+tmake_file=
+extra_headers=
+use_gcc_tgmath=yes
+extra_passes=
+extra_parts=
+extra_programs=
+extra_objs=
+extra_gcc_objs=
+extra_options=
+c_target_objs=
+cxx_target_objs=
+fortran_target_objs=
+tm_defines=
+xm_defines=
+# Set this to force installation and use of collect2.
+use_collect2=
+# Set this to override the default target model.
+target_cpu_default=
+# Set this if gdb needs a dir command with `dirname $out_file`
+gdb_needs_out_file_path=
+# Set this to control which thread package will be used.
+thread_file=
+# Reinitialize these from the flag values every loop pass, since some
+# configure entries modify them.
+gas="$gas_flag"
+gnu_ld="$gnu_ld_flag"
+default_use_cxa_atexit=no
+target_gtfiles=
+need_64bit_hwint=
+
+# Default to not using fixproto.  Targets which need fixproto should
+# specifically set this to 'yes'.
+use_fixproto=no
+
+# Don't carry these over build->host->target.  Please.
+xm_file=
+md_file=
+
+# Obsolete configurations.
+case ${target} in
+# Avoid generic cases below matching.
+   h8300-*-rtems* | h8300-*-elf* \
+ | sh-*-elf* | sh-*-symbianelf* | sh-*-linux* | sh-*-netbsdelf* \
+ | sh-*-rtems* | sh-wrs-vxworks) ;;
+   arm-*-coff*		\
+ | armel-*-coff*	\
+ | h8300-*-*		\
+ | i[34567]86-*-aout*	\
+ | i[34567]86-*-coff*	\
+ | m68k-*-aout*		\
+ | m68k-*-coff*		\
+ | sh-*-*		\
+ | pdp11-*-bsd		\
+ | rs6000-ibm-aix4.[12]* \
+ | powerpc-ibm-aix4.[12]* \
+ )
+    if test "x$enable_obsolete" != xyes; then
+      echo "*** Configuration ${target} is obsolete." >&2
+      echo "*** Specify --enable-obsolete to build it anyway." >&2
+      echo "*** Support will be REMOVED in the next major release of GCC," >&2
+      echo "*** unless a maintainer comes forward." >&2
+      exit 1
+    fi;;
+esac
+
+# Unsupported targets list.  Do not put an entry in this list unless
+# it would otherwise be caught by a more permissive pattern.  The list
+# should be in alphabetical order.
+case ${target} in
+   i[34567]86-go32-*			\
+ | i[34567]86-*-go32*			\
+ | mips64orion*-*-rtems*		\
+ | sparc-hal-solaris2*			\
+ | thumb-*-*				\
+ | *-*-linux*aout*			\
+ | *-*-linux*coff*			\
+ | *-*-linux*libc1*			\
+ | *-*-linux*oldld*			\
+ | *-*-rtemsaout*			\
+ | *-*-rtemscoff*			\
+ | *-*-solaris2.[0-6]			\
+ | *-*-solaris2.[0-6].*			\
+ | *-*-sysv*		\
+ | vax-*-vms*				\
+ )
+	echo "*** Configuration ${target} not supported" 1>&2
+	exit 1
+	;;
+esac
+
+# Set default cpu_type, tm_file, tm_p_file and xm_file so it can be
+# updated in each machine entry.  Also set default extra_headers for some
+# machines.
+tm_p_file=
+cpu_type=`echo ${target} | sed 's/-.*$//'`
+cpu_is_64bit=
+case ${target} in
+m32c*-*-*)
+        cpu_type=m32c
+	tmake_file=m32c/t-m32c
+        ;;
+alpha*-*-*)
+	cpu_type=alpha
+	need_64bit_hwint=yes
+	;;
+am33_2.0-*-linux*)
+	cpu_type=mn10300
+	;;
+arm*-*-*)
+	cpu_type=arm
+	extra_headers="mmintrin.h arm_neon.h"
+	c_target_objs="arm-c.o"
+	cxx_target_objs="arm-c.o"
+	;;
+bfin*-*)
+	cpu_type=bfin
+	;;
+crisv32-*)
+	cpu_type=cris
+	;;
+frv*)	cpu_type=frv
+	;;
+fido-*-*)
+	cpu_type=m68k
+	extra_headers=math-68881.h
+        ;;
+i[34567]86-*-*)
+	cpu_type=i386
+	c_target_objs="i386-c.o"
+	cxx_target_objs="i386-c.o"
+	extra_headers="cpuid.h mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h
+		       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h
+		       nmmintrin.h bmmintrin.h mmintrin-common.h
+		       wmmintrin.h immintrin.h x86intrin.h avxintrin.h 
+		       cross-stdarg.h"
+	;;
+x86_64-*-*)
+	cpu_type=i386
+	c_target_objs="i386-c.o"
+	cxx_target_objs="i386-c.o"
+	extra_headers="cpuid.h mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h
+		       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h
+		       nmmintrin.h bmmintrin.h mmintrin-common.h
+		       wmmintrin.h immintrin.h x86intrin.h avxintrin.h 
+		       cross-stdarg.h"
+	need_64bit_hwint=yes
+	;;
+ia64-*-*)
+	extra_headers=ia64intrin.h
+	need_64bit_hwint=yes
+	;;
+hppa*-*-*)
+	cpu_type=pa
+	;;
+m32r*-*-*)
+        cpu_type=m32r
+        ;;
+m68k-*-*)
+	extra_headers=math-68881.h
+	;;
+mips*-*-*)
+	cpu_type=mips
+	need_64bit_hwint=yes
+	extra_headers="loongson.h"
+	;;
+picochip-*-*)
+        cpu_type=picochip
+        ;;
+powerpc*-*-*)
+	cpu_type=rs6000
+	extra_headers="ppc-asm.h altivec.h spe.h ppu_intrinsics.h paired.h spu2vmx.h vec_types.h si2vmx.h"
+	need_64bit_hwint=yes
+	case x$with_cpu in
+	    xpowerpc64|xdefault64|x6[23]0|x970|xG5|xpower[34567]|xpower6x|xrs64a|xcell)
+		cpu_is_64bit=yes
+		;;
+	esac
+	;;
+rs6000*-*-*)
+	need_64bit_hwint=yes
+	;;
+score*-*-*)
+	cpu_type=score
+	;;
+sparc*-*-*)
+	cpu_type=sparc
+	need_64bit_hwint=yes
+	;;
+spu*-*-*)
+	cpu_type=spu
+	need_64bit_hwint=yes
+	;;
+s390*-*-*)
+	cpu_type=s390
+	need_64bit_hwint=yes
+	;;
+# Note the 'l'; we need to be able to match e.g. "shle" or "shl".
+sh[123456789lbe]*-*-* | sh-*-*)
+	cpu_type=sh
+	need_64bit_hwint=yes
+	;;
+esac
+
+tm_file=${cpu_type}/${cpu_type}.h
+if test -f ${srcdir}/config/${cpu_type}/${cpu_type}-protos.h
+then
+	tm_p_file=${cpu_type}/${cpu_type}-protos.h
+fi
+extra_modes=
+if test -f ${srcdir}/config/${cpu_type}/${cpu_type}-modes.def
+then
+	extra_modes=${cpu_type}/${cpu_type}-modes.def
+fi
+if test -f ${srcdir}/config/${cpu_type}/${cpu_type}.opt
+then
+	extra_options="${extra_options} ${cpu_type}/${cpu_type}.opt"
+fi
+
+case ${target} in
+i[34567]86-*-*)
+	if test "x$enable_cld" = xyes; then
+		tm_defines="${tm_defines} USE_IX86_CLD=1"
+	fi
+	;;
+x86_64-*-*)
+	tm_file="i386/biarch64.h ${tm_file}"
+	if test "x$enable_cld" = xyes; then
+		tm_defines="${tm_defines} USE_IX86_CLD=1"
+	fi
+	;;
+esac
+
+# On a.out targets, we need to use collect2.
+case ${target} in
+*-*-*aout*)
+	use_collect2=yes
+	;;
+esac
+
+# Common parts for widely ported systems.
+case ${target} in
+*-*-darwin*)
+  tm_file="${tm_file} darwin.h"
+  case ${target} in
+  *-*-darwin[912]*)
+    tm_file="${tm_file} darwin9.h"
+    ;;
+  esac
+  tm_file="${tm_file} ${cpu_type}/darwin.h"
+  tm_p_file="${tm_p_file} darwin-protos.h"
+  tmake_file="t-darwin ${cpu_type}/t-darwin t-slibgcc-darwin"
+  target_gtfiles="\$(srcdir)/config/darwin.c"
+  extra_options="${extra_options} darwin.opt"
+  c_target_objs="${c_target_objs} darwin-c.o"
+  cxx_target_objs="${cxx_target_objs} darwin-c.o"
+  fortran_target_objs="darwin-f.o"
+  extra_objs="darwin.o"
+  extra_gcc_objs="darwin-driver.o"
+  default_use_cxa_atexit=yes
+  case ${enable_threads} in
+    "" | yes | posix) thread_file='posix' ;;
+  esac
+  ;;
+*-*-freebsd[12] | *-*-freebsd[12].* | *-*-freebsd*aout*)
+  # This is the place-holder for the generic a.out configuration
+  # of FreeBSD.  No actual configuration resides here since
+  # there was only ever a bare-bones ix86 configuration for
+  # a.out and it exists solely in the machine-specific section.
+  # This place-holder must exist to avoid dropping into
+  # the generic ELF configuration of FreeBSD (i.e. it must be
+  # ordered before that section).
+  ;;
+*-*-freebsd*)
+  # This is the generic ELF configuration of FreeBSD.  Later
+  # machine-specific sections may refine and add to this
+  # configuration.
+  #
+  # Due to tm_file entry ordering issues that vary between cpu
+  # architectures, we only define fbsd_tm_file to allow the
+  # machine-specific section to dictate the final order of all
+  # entries of tm_file with the minor exception that components
+  # of the tm_file set here will always be of the form:
+  #
+  # freebsd<version_number>.h [freebsd-<conf_option>.h ...] freebsd-spec.h freebsd.h
+  #
+  # The machine-specific section should not tamper with this
+  # ordering but may order all other entries of tm_file as it
+  # pleases around the provided core setting.
+  gas=yes
+  gnu_ld=yes
+  extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o"
+  fbsd_major=`echo ${target} | sed -e 's/.*freebsd//g' | sed -e 's/\..*//g'`
+  tm_defines="${tm_defines} FBSD_MAJOR=${fbsd_major}"
+  tmake_file="t-slibgcc-elf-ver t-freebsd"
+  case ${enable_threads} in
+    no)
+      fbsd_tm_file="${fbsd_tm_file} freebsd-nthr.h"
+      ;;
+    "" | yes | posix)
+      thread_file='posix'
+      tmake_file="${tmake_file} t-freebsd-thread"
+      # Before 5.0, FreeBSD can't bind shared libraries to -lc
+      # when "optionally" threaded via weak pthread_* checks.
+      case ${target} in
+        *-*-freebsd[34] | *-*-freebsd[34].*)
+          tmake_file="${tmake_file} t-slibgcc-nolc-override"
+          ;;
+      esac
+      ;;
+    *)
+      echo 'Unknown thread configuration for FreeBSD'
+      exit 1
+      ;;
+  esac
+  fbsd_tm_file="${fbsd_tm_file} freebsd-spec.h freebsd.h"
+  case ${target} in
+    *-*-freebsd[345].*)
+      :;;
+    *)
+      default_use_cxa_atexit=yes;;
+  esac
+  ;;
+*-*-linux* | frv-*-*linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu | *-*-gnu* | *-*-kopensolaris*-gnu)
+  extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o"
+  gas=yes
+  gnu_ld=yes
+  case ${enable_threads} in
+    "" | yes | posix) thread_file='posix' ;;
+  esac
+  tmake_file="t-slibgcc-elf-ver t-linux"
+  case $target in
+    *-*-linux* | frv-*-*linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu | *-*-kopensolaris*-gnu)
+      :;;
+    *-*-gnu*)
+      tmake_file="$tmake_file t-gnu";;
+  esac
+  # glibc / uclibc switch.  uclibc isn't usable for GNU/Hurd and neither for
+  # GNU/k*BSD.
+  case $target in
+    *linux*)
+      extra_options="$extra_options linux.opt";;
+    *)
+      tm_defines="$tm_defines OPTION_GLIBC=1";;
+  esac
+  case ${target} in
+    *-*-*uclibc*)
+      tm_defines="${tm_defines} UCLIBC_DEFAULT=1"
+      ;;
+    *)
+      tm_defines="${tm_defines} UCLIBC_DEFAULT=0"
+      ;;
+  esac
+  # Assume that glibc or uClibc are being used and so __cxa_atexit is provided.
+  default_use_cxa_atexit=yes
+  use_gcc_tgmath=no
+  ;;
+*-*-netbsd*)
+  tmake_file="t-slibgcc-elf-ver t-libc-ok t-netbsd t-libgcc-pic"
+  gas=yes
+  gnu_ld=yes
+
+  # NetBSD 2.0 and later get POSIX threads enabled by default.
+  # Allow them to be explicitly enabled on any other version.
+  case ${enable_threads} in
+    "")
+      case ${target} in
+        *-*-netbsd[2-9]* | *-*-netbsdelf[2-9]*)
+          thread_file='posix'
+          tm_defines="${tm_defines} NETBSD_ENABLE_PTHREADS"
+          ;;
+      esac
+      ;;
+    yes | posix)
+      thread_file='posix'
+      tm_defines="${tm_defines} NETBSD_ENABLE_PTHREADS"
+      ;;
+  esac
+
+  # NetBSD 1.7 and later are set up to use GCC's crtstuff for
+  # ELF configurations.  We will clear extra_parts in the
+  # a.out configurations.
+  case ${target} in
+    *-*-netbsd*1.[7-9]* | *-*-netbsd[2-9]* | *-*-netbsdelf[2-9]*)
+      extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o"
+      ;;
+  esac
+
+  # NetBSD 2.0 and later provide __cxa_atexit(), which we use by
+  # default (unless overridden by --disable-__cxa_atexit).
+  case ${target} in
+    *-*-netbsd[2-9]* | *-*-netbsdelf[2-9]*)
+      default_use_cxa_atexit=yes
+      ;;
+  esac
+  ;;
+*-*-openbsd*)
+  tmake_file="t-libc-ok t-openbsd t-libgcc-pic"
+  case ${enable_threads} in
+    yes)
+      thread_file='posix'
+      tmake_file="${tmake_file} t-openbsd-thread"
+      ;;
+  esac
+  case ${target} in
+    *-*-openbsd2.*|*-*-openbsd3.[012])
+      tm_defines="${tm_defines} HAS_LIBC_R=1" ;;
+  esac
+  ;;
+*-*-rtems*)
+  case ${enable_threads} in
+    yes) thread_file='rtems' ;;
+  esac
+  ;;
+*-*-vxworks*)
+  tmake_file=t-vxworks
+  xm_defines=POSIX
+  extra_options="${extra_options} vxworks.opt"
+  extra_objs=vxworks.o
+  case ${enable_threads} in
+    no) ;;
+    "" | yes | vxworks) thread_file='vxworks' ;;
+    *) echo 'Unknown thread configuration for VxWorks'; exit 1 ;;
+  esac
+  ;;
+*-*-elf)
+  # Assume that newlib is being used and so __cxa_atexit is provided.
+  default_use_cxa_atexit=yes
+  ;;
+esac
+
+case ${target} in
+# Support site-specific machine types.
+*local*)
+	rest=`echo ${target} | sed -e "s/$cpu_type-//"`
+	tm_file=${cpu_type}/$rest.h
+	if test -f $srcdir/config/${cpu_type}/xm-$rest.h
+	then xm_file=${cpu_type}/xm-$rest.h
+	fi
+	if test -f $srcdir/config/${cpu_type}/t-$rest
+	then tmake_file=${cpu_type}/t-$rest
+	fi
+	;;
+alpha*-*-linux*)
+	tm_file="${tm_file} alpha/elf.h alpha/linux.h alpha/linux-elf.h"
+	target_cpu_default="MASK_GAS"
+	tmake_file="${tmake_file} alpha/t-crtfm alpha/t-alpha alpha/t-ieee alpha/t-linux"
+	;;
+alpha*-*-gnu*)
+	tm_file="$tm_file alpha/elf.h alpha/linux.h alpha/linux-elf.h gnu.h alpha/gnu.h"
+	target_cpu_default="MASK_GAS"
+	tmake_file="${tmake_file} alpha/t-crtfm alpha/t-alpha alpha/t-ieee"
+	;;
+alpha*-*-freebsd*)
+	tm_file="${tm_file} ${fbsd_tm_file} alpha/elf.h alpha/freebsd.h"
+	target_cpu_default="MASK_GAS"
+	tmake_file="${tmake_file} alpha/t-crtfm alpha/t-alpha alpha/t-ieee"
+	extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o"
+	;;
+alpha*-*-netbsd*)
+	tm_file="${tm_file} netbsd.h alpha/elf.h netbsd-elf.h alpha/netbsd.h"
+	target_cpu_default="MASK_GAS"
+	tmake_file="${tmake_file} alpha/t-alpha alpha/t-ieee"
+	;;
+alpha*-*-openbsd*)
+	tm_defines="${tm_defines} OBSD_NO_DYNAMIC_LIBRARIES OBSD_HAS_DECLARE_FUNCTION_NAME OBSD_HAS_DECLARE_FUNCTION_SIZE OBSD_HAS_DECLARE_OBJECT"
+	tm_file="alpha/alpha.h openbsd.h alpha/openbsd.h"
+	# default x-alpha is only appropriate for dec-osf.
+	target_cpu_default="MASK_GAS"
+	tmake_file="alpha/t-alpha alpha/t-ieee"
+	;;
+alpha*-dec-osf[45]*)
+	if test x$stabs = xyes
+	then
+		tm_file="${tm_file} dbx.h"
+	fi
+	if test x$gas != xyes
+	then
+		extra_passes="mips-tfile mips-tdump"
+	fi
+	use_collect2=yes
+	tmake_file="alpha/t-alpha alpha/t-ieee alpha/t-crtfm alpha/t-osf4"
+	tm_file="${tm_file} alpha/osf.h"
+	extra_headers=va_list.h
+	case ${target} in
+	  *-*-osf4*)
+	    # Define TARGET_SUPPORT_ARCH except on 4.0a.
+	    case ${target} in
+		*-*-osf4.0a) ;;
+		*) tm_defines="${tm_defines} TARGET_SUPPORT_ARCH=1"
+	    esac
+	    ;;
+	  *-*-osf5*)
+	    tm_file="${tm_file} alpha/osf5.h"
+	    tm_defines="${tm_defines} TARGET_SUPPORT_ARCH=1"
+	    ;;
+	esac
+	case ${enable_threads} in
+	  "" | yes | posix)
+	    thread_file='posix'
+	    tmake_file="${tmake_file} alpha/t-osf-pthread"
+	    ;;
+	esac
+	;;
+alpha64-dec-*vms*)
+	tm_file="${tm_file} alpha/vms.h alpha/vms64.h"
+	xm_file="alpha/xm-vms.h"
+	tmake_file="alpha/t-alpha alpha/t-vms alpha/t-vms64 alpha/t-ieee"
+	prefix=/gnu
+	local_prefix=/gnu
+	;;
+alpha*-dec-*vms*)
+	tm_file="${tm_file} alpha/vms.h"
+	xm_file=alpha/xm-vms.h
+	tmake_file="alpha/t-alpha alpha/t-vms alpha/t-ieee"
+	prefix=/gnu
+	local_prefix=/gnu
+	;;
+arc-*-elf*)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file}"
+	extra_parts="crtinit.o crtfini.o"
+	;;
+arm-*-coff* | armel-*-coff*)
+	tm_file="arm/semi.h arm/aout.h arm/arm.h arm/coff.h dbxcoff.h"
+	tmake_file="arm/t-arm arm/t-arm-coff"
+	;;
+arm-wrs-vxworks)
+	tm_file="elfos.h arm/elf.h arm/aout.h ${tm_file} vx-common.h vxworks.h arm/vxworks.h"
+	tmake_file="${tmake_file} arm/t-arm arm/t-vxworks"
+	;;
+arm*-*-freebsd*)
+	tm_file="dbxelf.h elfos.h ${fbsd_tm_file} arm/elf.h arm/aout.h arm/freebsd.h arm/arm.h"
+	tmake_file="${tmake_file} arm/t-arm arm/t-strongarm-elf"
+	;;
+arm*-*-netbsdelf*)
+	tm_file="dbxelf.h elfos.h netbsd.h netbsd-elf.h arm/elf.h arm/aout.h arm/arm.h arm/netbsd-elf.h"
+	tmake_file="${tmake_file} arm/t-arm arm/t-netbsd"
+	;;
+arm*-*-netbsd*)
+	tm_file="arm/aout.h arm/arm.h netbsd.h netbsd-aout.h arm/netbsd.h"
+	tmake_file="t-netbsd arm/t-arm arm/t-netbsd"
+	extra_parts=""
+	use_collect2=yes
+	;;
+arm*-*-linux*)			# ARM GNU/Linux with ELF
+	tm_file="dbxelf.h elfos.h linux.h arm/elf.h arm/linux-gas.h arm/linux-elf.h"
+	case $target in
+	arm*b-*)
+		tm_defines="${tm_defines} TARGET_BIG_ENDIAN_DEFAULT=1"
+		;;
+	esac
+	tmake_file="${tmake_file} t-linux arm/t-arm"
+	case ${target} in
+	arm*-*-linux-*eabi)
+	    tm_file="$tm_file arm/bpabi.h arm/linux-eabi.h"
+	    tmake_file="$tmake_file arm/t-arm-elf arm/t-bpabi arm/t-linux-eabi t-slibgcc-libgcc"
+  	    # The BPABI long long divmod functions return a 128-bit value in
+	    # registers r0-r3.  Correctly modeling that requires the use of
+	    # TImode.
+	    need_64bit_hwint=yes
+	    # The EABI requires the use of __cxa_atexit.
+	    default_use_cxa_atexit=yes
+	    ;;
+	*)
+	    tmake_file="$tmake_file arm/t-linux"
+	    ;;
+	esac
+	tm_file="$tm_file arm/aout.h arm/arm.h"
+	tmake_file="${tmake_file} arm/t-arm-softfp soft-fp/t-softfp"
+	;;
+arm*-*-uclinux*)		# ARM ucLinux
+	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/linux-gas.h arm/uclinux-elf.h"
+	tmake_file="arm/t-arm arm/t-arm-elf"
+	case ${target} in
+	arm*-*-uclinux*eabi)
+	    tm_file="$tm_file arm/bpabi.h arm/uclinux-eabi.h"
+	    tmake_file="$tmake_file arm/t-bpabi"
+  	    # The BPABI long long divmod functions return a 128-bit value in
+	    # registers r0-r3.  Correctly modeling that requires the use of
+	    # TImode.
+	    need_64bit_hwint=yes
+	    # The EABI requires the use of __cxa_atexit.
+	    default_use_cxa_atexit=yes
+	esac
+	tm_file="$tm_file arm/aout.h arm/arm.h"
+	tmake_file="${tmake_file} arm/t-arm-softfp soft-fp/t-softfp"
+	;;
+arm*-*-ecos-elf)
+	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h arm/ecos-elf.h"
+	tmake_file="arm/t-arm arm/t-arm-elf"
+	tmake_file="${tmake_file} arm/t-arm-softfp soft-fp/t-softfp"
+	;;
+arm*-*-eabi* | arm*-*-symbianelf* )
+	# The BPABI long long divmod functions return a 128-bit value in
+	# registers r0-r3.  Correctly modeling that requires the use of
+	# TImode.
+	need_64bit_hwint=yes
+	default_use_cxa_atexit=yes
+	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/bpabi.h"
+	tmake_file="arm/t-arm arm/t-arm-elf"
+	case ${target} in
+	arm*-*-eabi*)
+	  tm_file="$tm_file arm/eabi.h"
+	  tmake_file="${tmake_file} arm/t-bpabi"
+	  extra_options="${extra_options} arm/eabi.opt"
+	  ;;
+	arm*-*-symbianelf*)
+	  tm_file="${tm_file} arm/symbian.h"
+	  # We do not include t-bpabi for Symbian OS because the system
+	  # provides its own implementation of the BPABI functions.
+	  tmake_file="${tmake_file} arm/t-symbian"
+	  ;;
+	esac
+	tm_file="${tm_file} arm/aout.h arm/arm.h"
+	tmake_file="${tmake_file} arm/t-arm-softfp soft-fp/t-softfp"
+	;;
+arm*-*-rtems*)
+	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h arm/rtems-elf.h rtems.h"
+	tmake_file="arm/t-arm arm/t-arm-elf t-rtems arm/t-rtems"
+	tmake_file="${tmake_file} arm/t-arm-softfp soft-fp/t-softfp"
+	;;
+arm*-*-elf)
+	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h"
+	tmake_file="arm/t-arm arm/t-arm-elf"
+	tmake_file="${tmake_file} arm/t-arm-softfp soft-fp/t-softfp"
+	;;
+arm*-wince-pe*)
+	tm_file="arm/semi.h arm/aout.h arm/arm.h arm/coff.h dbxcoff.h arm/pe.h arm/wince-pe.h"
+	tmake_file="arm/t-arm arm/t-wince-pe"
+	extra_options="${extra_options} arm/pe.opt"
+	extra_objs="pe.o"
+	;;
+arm-*-pe*)
+	tm_file="arm/semi.h arm/aout.h arm/arm.h arm/coff.h dbxcoff.h arm/pe.h"
+	tmake_file="arm/t-arm arm/t-pe"
+	extra_options="${extra_options} arm/pe.opt"
+	extra_objs="pe.o"
+	;;
+avr-*-rtems*)
+	tm_file="avr/avr.h dbxelf.h avr/rtems.h rtems.h"
+	tmake_file="avr/t-avr t-rtems avr/t-rtems"
+	;;
+avr-*-*)
+	tm_file="avr/avr.h dbxelf.h"
+	;;
+bfin*-elf*)
+	tm_file="${tm_file} dbxelf.h elfos.h bfin/elf.h"
+	tmake_file=bfin/t-bfin-elf
+	use_collect2=no
+	;;
+bfin*-uclinux*)
+	tm_file="${tm_file} dbxelf.h elfos.h bfin/elf.h linux.h bfin/uclinux.h"
+	tmake_file=bfin/t-bfin-uclinux
+	tm_defines="${tm_defines} UCLIBC_DEFAULT=1"
+	extra_options="${extra_options} linux.opt"
+	use_collect2=no
+	;;
+bfin*-linux-uclibc*)
+	tm_file="${tm_file} dbxelf.h elfos.h bfin/elf.h linux.h bfin/linux.h ./linux-sysroot-suffix.h"
+	tmake_file="t-slibgcc-elf-ver bfin/t-bfin-linux"
+	extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
+	use_collect2=no
+	;;
+bfin*-rtems*)
+	tm_file="${tm_file} dbxelf.h elfos.h bfin/elf.h bfin/rtems.h rtems.h"
+	tmake_file="bfin/t-bfin t-rtems bfin/t-rtems"
+	;;
+bfin*-*)
+	tm_file="${tm_file} dbxelf.h elfos.h bfin/elf.h"
+	tmake_file=bfin/t-bfin
+	use_collect2=no
+	;;
+crisv32-*-elf | crisv32-*-none)
+	tm_file="dbxelf.h elfos.h ${tm_file}"
+	tmake_file="cris/t-cris"
+	target_cpu_default=32
+	gas=yes
+	extra_options="${extra_options} cris/elf.opt"
+	;;
+cris-*-elf | cris-*-none)
+	tm_file="dbxelf.h elfos.h ${tm_file}"
+	tmake_file="cris/t-cris cris/t-elfmulti"
+	gas=yes
+	extra_options="${extra_options} cris/elf.opt"
+	;;
+crisv32-*-linux* | cris-*-linux*)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file} linux.h cris/linux.h"
+	# We need to avoid using t-linux, so override default tmake_file
+	tmake_file="cris/t-cris t-slibgcc-elf-ver cris/t-linux"
+	extra_options="${extra_options} cris/linux.opt"
+	case $target in
+	  cris-*-*)
+		target_cpu_default=10
+		;;
+	  crisv32-*-*)
+		target_cpu_default=32
+		;;
+	esac
+	;;
+crx-*-elf)
+	tm_file="elfos.h ${tm_file}"
+	extra_parts="crtbegin.o crtend.o"
+	use_collect2=no
+	;;
+fr30-*-elf)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file}"
+	tmake_file=fr30/t-fr30
+	extra_parts="crti.o crtn.o crtbegin.o crtend.o"
+	;;
+frv-*-elf)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file} frv/frv-abi.h"
+	tmake_file=frv/t-frv
+	;;
+frv-*-*linux*)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file} \
+	         linux.h frv/linux.h frv/frv-abi.h"
+	tmake_file="${tmake_file} frv/t-frv frv/t-linux"
+	;;
+h8300-*-rtems*)
+	tmake_file="h8300/t-h8300 h8300/t-elf t-rtems h8300/t-rtems"
+	tm_file="h8300/h8300.h dbxelf.h elfos.h h8300/elf.h h8300/rtems.h rtems.h"
+	;;
+h8300-*-elf*)
+	tmake_file="h8300/t-h8300 h8300/t-elf"
+	tm_file="h8300/h8300.h dbxelf.h elfos.h h8300/elf.h"
+	;;
+h8300-*-*)
+	tm_file="h8300/h8300.h dbxcoff.h h8300/coff.h"
+	;;
+hppa*64*-*-linux*)
+	target_cpu_default="MASK_PA_11|MASK_PA_20"
+	tm_file="pa/pa64-start.h ${tm_file} dbxelf.h elfos.h svr4.h linux.h \
+		 pa/pa-linux.h pa/pa64-regs.h pa/pa-64.h pa/pa64-linux.h"
+	tmake_file="${tmake_file} pa/t-linux64"
+	gas=yes gnu_ld=yes
+	need_64bit_hwint=yes
+	;;
+hppa*-*-linux*)
+	target_cpu_default="MASK_PA_11|MASK_NO_SPACE_REGS"
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h linux.h pa/pa-linux.h \
+		 pa/pa32-regs.h pa/pa32-linux.h"
+	tmake_file="${tmake_file} pa/t-linux"
+	# Set the libgcc version number
+	if test x$sjlj = x1; then
+	    tmake_file="$tmake_file pa/t-slibgcc-sjlj-ver"
+	else
+	    tmake_file="$tmake_file pa/t-slibgcc-dwarf-ver"
+	fi
+	;;
+# port not yet contributed.
+#hppa*-*-openbsd*)
+#	target_cpu_default="MASK_PA_11"
+#	;;
+hppa[12]*-*-hpux10*)
+	case ${target} in
+	hppa1.1-*-* | hppa2*-*-*)
+		target_cpu_default="MASK_PA_11"
+		;;
+	esac
+	tm_file="${tm_file} pa/pa32-regs.h dbxelf.h pa/som.h \
+		 pa/pa-hpux.h pa/pa-hpux10.h"
+	extra_options="${extra_options} pa/pa-hpux.opt"
+	case ${target} in
+	*-*-hpux10.[1-9]*)
+		tm_file="${tm_file} pa/pa-hpux1010.h"
+		extra_options="${extra_options} pa/pa-hpux1010.opt"
+		;;
+	esac
+	tmake_file="pa/t-pa-hpux10 pa/t-pa-hpux pa/t-hpux-shlib"
+	case ${enable_threads} in
+	  "")
+	    if test x$have_pthread_h = xyes ; then
+	      tmake_file="${tmake_file} pa/t-dce-thr"
+	    fi
+	    ;;
+	  yes | dce)
+	    tmake_file="${tmake_file} pa/t-dce-thr"
+	    ;;
+	esac
+	# Set the libgcc version number
+	if test x$sjlj = x1; then
+	    tmake_file="$tmake_file pa/t-slibgcc-sjlj-ver"
+	else
+	    tmake_file="$tmake_file pa/t-slibgcc-dwarf-ver"
+	fi
+	use_collect2=yes
+	gas=yes
+	;;
+hppa*64*-*-hpux11*)
+	target_cpu_default="MASK_PA_11|MASK_PA_20"
+	if test x$gnu_ld = xyes
+	then
+		target_cpu_default="${target_cpu_default}|MASK_GNU_LD"
+	fi
+	tm_file="pa/pa64-start.h ${tm_file} dbxelf.h elfos.h \
+		 pa/pa64-regs.h pa/pa-hpux.h pa/pa-hpux1010.h \
+		 pa/pa-hpux11.h"
+	case ${target} in
+	*-*-hpux11.[1-9]*)
+		tm_file="${tm_file} pa/pa-hpux1111.h pa/pa-64.h pa/pa64-hpux.h"
+		extra_options="${extra_options} pa/pa-hpux1111.opt"
+		;;
+	*)
+		tm_file="${tm_file} pa/pa-64.h pa/pa64-hpux.h"
+		;;
+	esac
+	extra_options="${extra_options} pa/pa-hpux.opt \
+		       pa/pa-hpux1010.opt pa/pa64-hpux.opt"
+	need_64bit_hwint=yes
+	tmake_file="pa/t-pa64 pa/t-pa-hpux pa/t-hpux-shlib"
+	# Set the libgcc version number
+	if test x$sjlj = x1; then
+	    tmake_file="$tmake_file pa/t-slibgcc-sjlj-ver"
+	else
+	    tmake_file="$tmake_file pa/t-slibgcc-dwarf-ver"
+	fi
+	extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o \
+		     libgcc_stub.a"
+	case x${enable_threads} in
+	x | xyes | xposix )
+		thread_file=posix
+		;;
+	esac
+	gas=yes
+	;;
+hppa[12]*-*-hpux11*)
+	case ${target} in
+	hppa1.1-*-* | hppa2*-*-*)
+		target_cpu_default="MASK_PA_11"
+		;;
+	esac
+	tm_file="${tm_file} pa/pa32-regs.h dbxelf.h pa/som.h \
+		 pa/pa-hpux.h pa/pa-hpux1010.h pa/pa-hpux11.h"
+	extra_options="${extra_options} pa/pa-hpux.opt pa/pa-hpux1010.opt"
+	case ${target} in
+	*-*-hpux11.[1-9]*)
+		tm_file="${tm_file} pa/pa-hpux1111.h"
+		extra_options="${extra_options} pa/pa-hpux1111.opt"
+		;;
+	esac
+	tmake_file="pa/t-pa-hpux11 pa/t-pa-hpux pa/t-hpux-shlib"
+	# Set the libgcc version number
+	if test x$sjlj = x1; then
+	    tmake_file="$tmake_file pa/t-slibgcc-sjlj-ver"
+	else
+	    tmake_file="$tmake_file pa/t-slibgcc-dwarf-ver"
+	fi
+	extra_parts="libgcc_stub.a"
+	case x${enable_threads} in
+	x | xyes | xposix )
+		thread_file=posix
+		;;
+	esac
+	use_collect2=yes
+	gas=yes
+	;;
+i[34567]86-*-darwin*)
+	need_64bit_hwint=yes
+
+	# This is so that '.../configure && make' doesn't fail due to
+	# config.guess deciding that the configuration is i386-*-darwin* and
+	# then this file using that to set --with-cpu=i386 which has no -m64
+	# support.
+	with_cpu=${with_cpu:-generic}
+	tmake_file="${tmake_file} i386/t-crtpc i386/t-crtfm"
+	;;
+x86_64-*-darwin*)
+	with_cpu=${with_cpu:-generic}
+	tmake_file="${tmake_file} t-darwin ${cpu_type}/t-darwin64 t-slibgcc-darwin i386/t-crtpc i386/t-crtfm"
+	tm_file="${tm_file} ${cpu_type}/darwin64.h"
+	;;
+i[34567]86-*-elf*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h"
+	tmake_file="${tmake_file} i386/t-i386elf t-svr4"
+	;;
+x86_64-*-elf*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h i386/x86-64.h"
+	tmake_file="${tmake_file} i386/t-i386elf t-svr4"
+	;;
+i[34567]86-*-aout*)
+	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h i386/i386-aout.h"
+	;;
+i[34567]86-*-freebsd*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h ${fbsd_tm_file} i386/freebsd.h"
+	;;
+x86_64-*-freebsd*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h ${fbsd_tm_file} i386/x86-64.h i386/freebsd.h i386/freebsd64.h"
+	tmake_file="${tmake_file} i386/t-crtstuff"
+	;;
+i[34567]86-*-netbsdelf*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/netbsd-elf.h"
+	;;
+i[34567]86-*-netbsd*)
+	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h netbsd.h netbsd-aout.h i386/netbsd.h"
+	tmake_file="${tmake_file} t-netbsd"
+	extra_parts=""
+	use_collect2=yes
+	;;
+x86_64-*-netbsd*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/x86-64.h i386/netbsd64.h"
+	tmake_file="${tmake_file} i386/t-crtstuff"
+	;;
+i[34567]86-*-openbsd2.*|i[34567]86-*openbsd3.[0123])
+	tm_file="i386/i386.h i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h openbsd-oldgas.h openbsd.h i386/openbsd.h"
+	# needed to unconfuse gdb
+	tmake_file="${tmake_file} t-libc-ok t-openbsd i386/t-openbsd"
+	# we need collect2 until our bug is fixed...
+	use_collect2=yes
+	;;
+i[34567]86-*-openbsd*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h"
+	tm_file="${tm_file} openbsd.h i386/openbsdelf.h"
+	gas=yes
+	gnu_ld=yes
+	;;
+i[34567]86-*-coff*)
+	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/i386-coff.h"
+	;;
+i[34567]86-*-linux* | i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-knetbsd*-gnu | i[34567]86-*-gnu* | i[34567]86-*-kopensolaris*-gnu)
+			# Intel 80386's running GNU/*
+			# with ELF format using glibc 2
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h linux.h"
+	case ${target} in
+	i[34567]86-*-linux*)
+		if test x$enable_targets = xall; then
+			tm_file="${tm_file} i386/x86-64.h i386/linux64.h"
+			tm_defines="${tm_defines} TARGET_BI_ARCH=1"
+			tmake_file="${tmake_file} i386/t-linux64"
+			need_64bit_hwint=yes
+			case X"${with_cpu}" in
+			Xgeneric|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx|Xathlon64-sse3|Xk8-sse3|Xopteron-sse3)
+				;;
+			X)
+				if test x$with_cpu_64 = x; then
+					with_cpu_64=generic
+				fi
+				;;
+			*)
+				echo "Unsupported CPU used in --with-cpu=$with_cpu, supported values:" 1>&2
+				echo "generic core2 nocona x86-64 amdfam10 barcelona k8 opteron athlon64 athlon-fx athlon64-sse3 k8-sse3 opteron-sse3" 1>&2
+				exit 1
+				;;
+			esac
+		else
+			tm_file="${tm_file} i386/linux.h"
+		fi
+		;;
+	i[34567]86-*-knetbsd*-gnu) tm_file="${tm_file} i386/linux.h knetbsd-gnu.h i386/knetbsd-gnu.h" ;;
+	i[34567]86-*-kfreebsd*-gnu) tm_file="${tm_file} i386/linux.h kfreebsd-gnu.h i386/kfreebsd-gnu.h" ;;
+	i[34567]86-*-kopensolaris*-gnu) tm_file="${tm_file} i386/linux.h kopensolaris-gnu.h i386/kopensolaris-gnu.h" ;;
+	i[34567]86-*-gnu*) tm_file="$tm_file i386/linux.h gnu.h i386/gnu.h";;
+	esac
+	tmake_file="${tmake_file} i386/t-crtstuff i386/t-crtpc i386/t-crtfm t-dfprules"
+	;;
+x86_64-*-linux* | x86_64-*-kfreebsd*-gnu | x86_64-*-knetbsd*-gnu)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h linux.h \
+		 i386/x86-64.h i386/linux64.h"
+	case ${target} in
+	x86_64-*-kfreebsd*-gnu) tm_file="${tm_file} kfreebsd-gnu.h" ;;
+	x86_64-*-knetbsd*-gnu) tm_file="${tm_file} knetbsd-gnu.h" ;;
+	esac
+	tmake_file="${tmake_file} i386/t-linux64 i386/t-crtstuff i386/t-crtpc i386/t-crtfm t-dfprules"
+	;;
+i[34567]86-pc-msdosdjgpp*)
+	xm_file=i386/xm-djgpp.h
+	tm_file="dbxcoff.h ${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/djgpp.h"
+	tmake_file="${tmake_file} i386/t-djgpp"
+	extra_options="${extra_options} i386/djgpp.opt"
+	gnu_ld=yes
+	gas=yes
+	;;
+i[34567]86-*-lynxos*)
+	xm_defines=POSIX
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/lynx.h lynx.h"
+	tmake_file="${tmake_file} i386/t-crtstuff t-lynx"
+	extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
+	extra_options="${extra_options} lynx.opt"
+	thread_file=lynx
+	gnu_ld=yes
+	gas=yes
+	;;
+i[3456x]86-*-netware*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h tm-dwarf2.h i386/netware.h"
+ 	tmake_file="${tmake_file} i386/t-netware"
+	extra_objs=netware.o
+	case /${with_ld} in
+	*/nwld)
+		extra_objs="$extra_objs nwld.o"
+		tm_file="${tm_file} i386/nwld.h"
+	 	tmake_file="${tmake_file} i386/t-nwld"
+		extra_parts="crt0.o libgcc.def libc.def libcpre.def posixpre.def"
+		;;
+	esac
+	case x${enable_threads} in
+	x | xyes | xposix) thread_file='posix';;
+	xnks) thread_file='nks';;
+	xno) ;;
+	*) echo 'Unknown thread configuration for NetWare' >&2; exit 1;;
+	esac
+	;;
+i[34567]86-*-nto-qnx*)
+	tm_file="${tm_file} i386/att.h dbxelf.h tm-dwarf2.h elfos.h svr4.h i386/unix.h i386/nto.h"
+	tmake_file="${tmake_file} i386/t-nto"
+	gnu_ld=yes
+	gas=yes
+	;;
+i[34567]86-*-rtems*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h i386/rtemself.h rtems.h"
+	extra_parts="crtbegin.o crtend.o crti.o crtn.o"
+	tmake_file="${tmake_file} i386/t-rtems-i386 i386/t-crtstuff t-rtems"
+	;;
+i[34567]86-*-solaris2*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h sol2.h"
+	case ${target} in
+	*-*-solaris2.1[0-9]*)
+		tm_file="${tm_file} sol2-10.h"
+		;;
+	esac
+	tm_file="${tm_file} i386/sol2.h"
+	if test x$gnu_ld = xyes; then
+		tm_file="${tm_file} sol2-gld.h"
+	fi
+	if test x$gas = xyes; then
+		tm_file="${tm_file} i386/sol2-gas.h"
+	fi
+	tmake_file="${tmake_file} t-sol2 t-svr4"
+	c_target_objs="${c_target_objs} sol2-c.o"
+	cxx_target_objs="${cxx_target_objs} sol2-c.o"
+	extra_objs="sol2.o"
+	tm_p_file="${tm_p_file} sol2-protos.h"
+	if test x$gnu_ld = xyes; then
+		tmake_file="$tmake_file t-slibgcc-elf-ver"
+		tm_defines="${tm_defines} TARGET_GNU_LD=1"
+	else
+		tmake_file="$tmake_file t-slibgcc-sld"
+	fi
+	if test x$gas = xyes; then
+		tm_file="usegas.h ${tm_file}"
+	fi
+	tm_file="$tm_file tm-dwarf2.h"
+	case ${target} in
+	*-*-solaris2.1[0-9]*)
+		tm_file="${tm_file} i386/x86-64.h i386/sol2-10.h"
+		tm_defines="${tm_defines} TARGET_BI_ARCH=1"
+		tmake_file="$tmake_file i386/t-sol2-10"
+		# i386/t-crtstuff only affects libgcc.  Its inclusion
+		# depends on a runtime test and is thus performed in
+		# libgcc/configure.ac instead.
+		need_64bit_hwint=yes
+		case X"${with_cpu}" in
+		Xgeneric|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx|Xathlon64-sse3|Xk8-sse3|Xopteron-sse3)
+			;;
+		X)
+			if test x$with_cpu_64 = x; then
+				with_cpu_64=generic
+			fi
+			;;
+		*)
+			echo "Unsupported CPU used in --with-cpu=$with_cpu, supported values:" 1>&2
+			echo "generic core2 nocona x86-64 amdfam10 barcelona k8 opteron athlon64 athlon-fx athlon64-sse3 k8-sse3 opteron-sse3" 1>&2
+			exit 1
+			;;
+		esac
+		;;
+	esac
+	case ${enable_threads}:${have_pthread_h}:${have_thread_h} in
+	  "":yes:* | yes:yes:* )
+		thread_file=posix
+		;;
+	  "":*:yes | yes:*:yes )
+		thread_file=solaris
+		;;
+	esac
+	;;
+i[4567]86-wrs-vxworks|i[4567]86-wrs-vxworksae)
+	tm_file="${tm_file} i386/unix.h i386/att.h elfos.h svr4.h vx-common.h"
+	case ${target} in
+	  *-vxworksae*)
+	    tm_file="${tm_file} vxworksae.h i386/vx-common.h i386/vxworksae.h"
+	    tmake_file="${tmake_file} i386/t-vxworks i386/t-vxworksae"
+	    ;;
+	  *)
+	    tm_file="${tm_file} vxworks.h i386/vx-common.h i386/vxworks.h"
+	    tmake_file="${tmake_file} i386/t-vxworks"
+	    ;;
+	esac
+	;;
+i[34567]86-*-pe | i[34567]86-*-cygwin*)
+	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/cygming.h i386/cygwin.h"
+	xm_file=i386/xm-cygwin.h
+	# This has to match the logic for DWARF2_UNWIND_INFO in gcc/config/i386/cygming.h
+	if test x$sjlj = x0; then
+		tmake_eh_file="i386/t-dw2-eh"
+	else
+		tmake_eh_file="i386/t-sjlj-eh"
+	fi
+	tmake_file="${tmake_file} ${tmake_eh_file} i386/t-cygming i386/t-cygwin"
+	target_gtfiles="\$(srcdir)/config/i386/winnt.c"
+	extra_options="${extra_options} i386/cygming.opt"
+	extra_objs="winnt.o winnt-stubs.o"
+	c_target_objs="${c_target_objs} cygwin2.o msformat-c.o"
+	cxx_target_objs="${cxx_target_objs} cygwin2.o winnt-cxx.o msformat-c.o"
+	extra_gcc_objs=cygwin1.o
+	if test x$enable_threads = xyes; then
+		thread_file='posix'
+	fi
+	;;
+i[34567]86-*-mingw* | x86_64-*-mingw*)
+	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/cygming.h i386/mingw32.h"
+	xm_file=i386/xm-mingw32.h
+	case ${target} in
+		x86_64-*-*)
+			need_64bit_hwint=yes
+			;;
+		*)
+			;;
+	esac
+	# This has to match the logic for DWARF2_UNWIND_INFO in gcc/config/i386/cygming.h
+	if test x$sjlj = x0; then
+		tmake_eh_file="i386/t-dw2-eh"
+	else
+		tmake_eh_file="i386/t-sjlj-eh"
+	fi
+	tmake_file="${tmake_file} ${tmake_eh_file} i386/t-cygming i386/t-mingw32"
+	target_gtfiles="\$(srcdir)/config/i386/winnt.c"
+	extra_options="${extra_options} i386/cygming.opt i386/mingw.opt"
+	extra_objs="winnt.o winnt-stubs.o"
+	c_target_objs="${c_target_objs} msformat-c.o"
+	cxx_target_objs="${cxx_target_objs} winnt-cxx.o msformat-c.o"
+	default_use_cxa_atexit=yes
+	case ${enable_threads} in
+	  "" | yes | win32)
+	  thread_file='win32'
+	  tmake_file="${tmake_file} i386/t-gthr-win32"
+	  ;;
+	esac
+	case ${target} in
+		x86_64-*-mingw*)
+			tmake_file="${tmake_file} i386/t-crtfm"
+			;;
+		*)
+			;;
+	esac
+	case ${target} in
+ 		*mingw32crt*)
+ 			tm_file="${tm_file} i386/crtdll.h"
+ 			;;
+		*mingw32msv* | *mingw*)
+			;;
+	esac
+	;;
+i[34567]86-*-interix3*)
+	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/i386-interix.h i386/i386-interix3.h interix.h interix3.h"
+	tmake_file="${tmake_file} i386/t-interix"
+	extra_objs=winnt.o
+	target_gtfiles="\$(srcdir)/config/i386/winnt.c"
+	if test x$enable_threads = xyes ; then
+		thread_file='posix'
+	fi
+	if test x$stabs = xyes ; then
+		tm_file="${tm_file} dbxcoff.h"
+	fi
+	;;
+ia64*-*-elf*)
+	tm_file="${tm_file} dbxelf.h elfos.h ia64/sysv4.h ia64/elf.h"
+	tmake_file="ia64/t-ia64"
+	target_cpu_default="0"
+	if test x$gas = xyes
+	then
+		target_cpu_default="${target_cpu_default}|MASK_GNU_AS"
+	fi
+	if test x$gnu_ld = xyes
+	then
+		target_cpu_default="${target_cpu_default}|MASK_GNU_LD"
+	fi
+	extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtfastmath.o"
+	;;
+ia64*-*-freebsd*)
+	tm_file="${tm_file} dbxelf.h elfos.h ${fbsd_tm_file} ia64/sysv4.h ia64/freebsd.h"
+	target_cpu_default="MASK_GNU_AS|MASK_GNU_LD"
+	tmake_file="${tmake_file} ia64/t-ia64"
+	extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtfastmath.o"
+	;;
+ia64*-*-linux*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h linux.h ia64/sysv4.h ia64/linux.h"
+	tmake_file="${tmake_file} ia64/t-ia64 t-libunwind ia64/t-glibc"
+	if test x$with_system_libunwind != xyes ; then
+		tmake_file="${tmake_file} t-libunwind-elf ia64/t-glibc-libunwind"
+	fi
+	target_cpu_default="MASK_GNU_AS|MASK_GNU_LD"
+	extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtfastmath.o"
+	;;
+ia64*-*-hpux*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h ia64/sysv4.h ia64/hpux.h"
+	tmake_file="ia64/t-ia64 ia64/t-hpux"
+	target_cpu_default="MASK_GNU_AS"
+	case x$enable_threads in
+	x | xyes | xposix )
+		thread_file=posix
+		;;
+	esac
+	use_collect2=no
+	c_target_objs="ia64-c.o"
+	cxx_target_objs="ia64-c.o"
+	extra_options="${extra_options} ia64/ilp32.opt"
+	;;
+iq2000*-*-elf*)
+        tm_file="svr4.h elfos.h iq2000/iq2000.h"
+        tmake_file=iq2000/t-iq2000
+        out_file=iq2000/iq2000.c
+        md_file=iq2000/iq2000.md
+        ;;
+m32r-*-elf*)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file}"
+	extra_parts="crtinit.o crtfini.o"
+ 	;;
+m32rle-*-elf*)
+	tm_file="dbxelf.h elfos.h svr4.h m32r/little.h ${tm_file}"
+	extra_parts="crtinit.o crtfini.o m32rx/crtinit.o m32rx/crtfini.o"
+	;;
+m32r-*-rtems*)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file} m32r/rtems.h rtems.h"
+	tmake_file="m32r/t-m32r t-rtems"
+	extra_parts="crtinit.o crtfini.o"
+ 	;;
+m32r-*-linux*)
+	tm_file="dbxelf.h elfos.h svr4.h linux.h ${tm_file} m32r/linux.h"
+	# We override the tmake_file for linux -- why?
+	tmake_file="t-slibgcc-elf-ver m32r/t-linux"
+	gnu_ld=yes
+	if test x$enable_threads = xyes; then
+		thread_file='posix'
+	fi
+ 	;;
+m32rle-*-linux*)
+	tm_file="dbxelf.h elfos.h svr4.h linux.h m32r/little.h ${tm_file} m32r/linux.h"
+	# We override the tmake_file for linux -- why?
+	tmake_file="t-slibgcc-elf-ver m32r/t-linux"
+	gnu_ld=yes
+	if test x$enable_threads = xyes; then
+		thread_file='posix'
+	fi
+	;;
+# m68hc11 and m68hc12 share the same machine description.
+m68hc11-*-*|m6811-*-*)
+	tm_file="dbxelf.h elfos.h usegas.h m68hc11/m68hc11.h"
+	tm_p_file="m68hc11/m68hc11-protos.h"
+	md_file="m68hc11/m68hc11.md"
+	out_file="m68hc11/m68hc11.c"
+	tmake_file="m68hc11/t-m68hc11"
+        ;;
+m68hc12-*-*|m6812-*-*)
+	tm_file="m68hc11/m68hc12.h dbxelf.h elfos.h usegas.h m68hc11/m68hc11.h"
+	tm_p_file="m68hc11/m68hc11-protos.h"
+	md_file="m68hc11/m68hc11.md"
+	out_file="m68hc11/m68hc11.c"
+	tmake_file="m68hc11/t-m68hc11"
+	extra_options="${extra_options} m68hc11/m68hc11.opt"
+        ;;
+m68k-*-aout*)
+	default_m68k_cpu=68020
+	default_cf_cpu=5206
+	tmake_file="m68k/t-floatlib m68k/t-m68kbare m68k/t-mlibs"
+	tm_file="${tm_file} m68k/m68k-none.h m68k/m68kemb.h m68k/m68k-aout.h libgloss.h"
+	;;
+m68k-*-coff*)
+	default_m68k_cpu=68020
+	default_cf_cpu=5206
+	tmake_file="m68k/t-floatlib m68k/t-m68kbare m68k/t-mlibs"
+	tm_defines="${tm_defines} MOTOROLA=1"
+	tm_file="${tm_file} m68k/m68k-none.h m68k/m68kemb.h dbxcoff.h m68k/coff.h dbx.h"
+	;;
+m68k-*-elf* | fido-*-elf*)
+	case ${target} in
+	fido-*-elf*)
+		# Check that $with_cpu makes sense.
+		case $with_cpu in
+		"" | "fidoa")
+			;;
+		*)
+			echo "Cannot accept --with-cpu=$with_cpu"
+			exit 1
+			;;
+		esac
+		with_cpu=fidoa
+		;;
+	*)
+		default_m68k_cpu=68020
+		default_cf_cpu=5206
+		;;
+	esac
+	tm_file="${tm_file} m68k/m68k-none.h m68k/m68kelf.h dbxelf.h elfos.h m68k/m68kemb.h m68k/m68020-elf.h"
+	tm_defines="${tm_defines} MOTOROLA=1"
+	tmake_file="m68k/t-floatlib m68k/t-m68kbare m68k/t-m68kelf"
+	# Add multilibs for targets other than fido.
+	case ${target} in
+	fido-*-elf*)
+		;;
+	*)
+		tmake_file="$tmake_file m68k/t-mlibs"
+		;;
+	esac
+	extra_parts="crtbegin.o crtend.o"
+	;;
+m68k*-*-netbsdelf*)
+	default_m68k_cpu=68020
+	default_cf_cpu=5475
+	tm_file="${tm_file} dbxelf.h elfos.h netbsd.h netbsd-elf.h m68k/netbsd-elf.h"
+	tm_defines="${tm_defines} MOTOROLA=1"
+	;;
+m68k*-*-openbsd*)
+	default_m68k_cpu=68020
+	default_cf_cpu=5475
+	# needed to unconfuse gdb
+	tm_defines="${tm_defines} OBSD_OLD_GAS"
+	tm_file="${tm_file} openbsd.h m68k/openbsd.h"
+	tmake_file="t-libc-ok t-openbsd m68k/t-openbsd"
+	# we need collect2 until our bug is fixed...
+	use_collect2=yes
+	;;
+m68k-*-uclinuxoldabi*)		# Motorola m68k/ColdFire running uClinux
+				# with uClibc, using the original
+				# m68k-elf-based ABI
+	default_m68k_cpu=68020
+	default_cf_cpu=5206
+	tm_file="${tm_file} m68k/m68k-none.h m68k/m68kelf.h dbxelf.h elfos.h m68k/uclinux-oldabi.h"
+ 	tm_defines="${tm_defines} MOTOROLA=1"
+	tmake_file="m68k/t-floatlib m68k/t-uclinux"
+	;;
+m68k-*-uclinux*)		# Motorola m68k/ColdFire running uClinux
+				# with uClibc, using the new GNU/Linux-style
+				# ABI.
+	default_m68k_cpu=68020
+	default_cf_cpu=5206
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h linux.h flat.h m68k/linux.h m68k/uclinux.h ./sysroot-suffix.h"
+ 	tm_defines="${tm_defines} MOTOROLA=1 UCLIBC_DEFAULT=1"
+	extra_options="${extra_options} linux.opt"
+	tmake_file="m68k/t-floatlib m68k/t-uclinux m68k/t-mlibs"
+	;;
+m68k-*-linux*)		# Motorola m68k's running GNU/Linux
+				# with ELF format using glibc 2
+				# aka the GNU/Linux C library 6.
+	default_m68k_cpu=68020
+	default_cf_cpu=5475
+	with_arch=${with_arch:-m68k}
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h linux.h m68k/linux.h ./sysroot-suffix.h"
+	extra_options="${extra_options} m68k/ieee.opt"
+	tm_defines="${tm_defines} MOTOROLA=1"
+	tmake_file="${tmake_file} m68k/t-floatlib m68k/t-linux m68k/t-mlibs"
+	# if not configured with --enable-sjlj-exceptions, bump the
+	# libgcc version number
+	if test x$sjlj != x1; then
+	    tmake_file="$tmake_file m68k/t-slibgcc-elf-ver"
+	fi
+	;;
+m68k-*-rtems*)
+	default_m68k_cpu=68020
+	default_cf_cpu=5206
+	tmake_file="m68k/t-floatlib m68k/t-m68kbare m68k/t-crtstuff t-rtems m68k/t-rtems m68k/t-mlibs"
+	tm_file="${tm_file} m68k/m68k-none.h m68k/m68kelf.h dbxelf.h elfos.h m68k/m68kemb.h m68k/m68020-elf.h m68k/rtemself.h rtems.h"
+	tm_defines="${tm_defines} MOTOROLA=1"
+	extra_parts="crtbegin.o crtend.o"
+	;;
+mcore-*-elf)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file} mcore/mcore-elf.h"
+	tmake_file=mcore/t-mcore
+	inhibit_libc=true
+	;;
+mcore-*-pe*)
+	tm_file="svr3.h dbxcoff.h ${tm_file} mcore/mcore-pe.h"
+	tmake_file=mcore/t-mcore-pe
+	inhibit_libc=true
+	;;
+mips-sgi-irix[56]*)
+	tm_file="elfos.h ${tm_file} mips/iris.h"
+	tmake_file="mips/t-iris mips/t-slibgcc-irix"
+	target_cpu_default="MASK_ABICALLS"
+	case ${target} in
+	*-*-irix5*)
+		tm_file="${tm_file} mips/iris5.h"
+		;;
+
+	*-*-irix6*)
+		tm_file="${tm_file} mips/iris6.h"
+		tmake_file="${tmake_file} mips/t-iris6"
+		tm_defines="${tm_defines} MIPS_ISA_DEFAULT=3 MIPS_ABI_DEFAULT=ABI_N32"
+		;;
+	esac
+	if test "x$stabs" = xyes
+	then
+		tm_file="${tm_file} dbx.h mips/dbxmdebug.h"
+	fi
+	if test "x$gnu_ld" = xyes
+	then
+		tm_defines="${tm_defines} IRIX_USING_GNU_LD"
+	fi
+	case ${enable_threads}:${have_pthread_h} in
+	  "":yes | yes:yes ) thread_file=posix ;;
+	esac
+	;;
+mips*-*-netbsd*)			# NetBSD/mips, either endian.
+	target_cpu_default="MASK_ABICALLS"
+	tm_file="elfos.h ${tm_file} mips/elf.h netbsd.h netbsd-elf.h mips/netbsd.h"
+	;;
+mips64*-*-linux* | mipsisa64*-*-linux*)
+	tm_file="dbxelf.h elfos.h svr4.h linux.h ${tm_file} mips/linux.h mips/linux64.h"
+	tmake_file="${tmake_file} mips/t-linux64 mips/t-libgcc-mips16"
+	tm_defines="${tm_defines} MIPS_ABI_DEFAULT=ABI_N32"
+	case ${target} in
+		mips64el-st-linux-gnu)
+			tm_file="${tm_file} mips/st.h"
+			tmake_file="${tmake_file} mips/t-st"
+			;;
+		mips64octeon*-*-linux*)
+			tm_defines="${tm_defines} MIPS_CPU_STRING_DEFAULT=\\\"octeon\\\""
+			target_cpu_default=MASK_SOFT_FLOAT_ABI
+			;;
+		mipsisa64r2*-*-linux*)
+			tm_defines="${tm_defines} MIPS_ISA_DEFAULT=65"
+			;;
+	esac
+	gnu_ld=yes
+	gas=yes
+	test x$with_llsc != x || with_llsc=yes
+	;;
+mips*-*-linux*)				# Linux MIPS, either endian.
+        tm_file="dbxelf.h elfos.h svr4.h linux.h ${tm_file} mips/linux.h"
+	tmake_file="${tmake_file} mips/t-libgcc-mips16"
+	case ${target} in
+        mipsisa32r2*)
+		tm_defines="${tm_defines} MIPS_ISA_DEFAULT=33"
+                ;;
+        mipsisa32*)
+		tm_defines="${tm_defines} MIPS_ISA_DEFAULT=32"
+        esac
+	test x$with_llsc != x || with_llsc=yes
+	;;
+mips*-*-openbsd*)
+	tm_defines="${tm_defines} OBSD_HAS_DECLARE_FUNCTION_NAME OBSD_HAS_DECLARE_OBJECT OBSD_HAS_CORRECT_SPECS"
+	target_cpu_default="MASK_ABICALLS"
+	tm_file="mips/mips.h openbsd.h mips/openbsd.h mips/sdb.h"
+	case ${target} in
+	mips*el-*-openbsd*)
+	    tm_defines="${tm_defines} TARGET_ENDIAN_DEFAULT=0";;
+	*)  tm_defines="${tm_defines} TARGET_ENDIAN_DEFAULT=MASK_BIG_ENDIAN";;
+        esac
+	;;
+mips*-sde-elf*)
+	tm_file="elfos.h ${tm_file} mips/elf.h mips/sde.h"
+	tmake_file="mips/t-sde mips/t-libgcc-mips16"
+	case "${with_newlib}" in
+	  yes)
+	    # newlib / libgloss.
+	    ;;
+	  *)
+	    # MIPS toolkit libraries.
+	    tm_file="$tm_file mips/sdemtk.h"
+	    tmake_file="$tmake_file mips/t-sdemtk"
+	    extra_options="$extra_options mips/sdemtk.opt"
+	    case ${enable_threads} in
+	      "" | yes | mipssde)
+		thread_file='mipssde'
+		;;
+	    esac
+	    ;;
+	esac
+	case ${target} in
+	  mipsisa32r2*)
+	    tm_defines="MIPS_ISA_DEFAULT=33 MIPS_ABI_DEFAULT=ABI_32"
+	    ;;
+	  mipsisa32*)
+	    tm_defines="MIPS_ISA_DEFAULT=32 MIPS_ABI_DEFAULT=ABI_32"
+	    ;;
+	  mipsisa64r2*)
+	    tm_defines="MIPS_ISA_DEFAULT=65 MIPS_ABI_DEFAULT=ABI_N32"
+	    ;;
+	  mipsisa64*)
+	    tm_defines="MIPS_ISA_DEFAULT=64 MIPS_ABI_DEFAULT=ABI_N32"
+	    ;;
+	esac
+	;;
+mipsisa32-*-elf* | mipsisa32el-*-elf* | \
+mipsisa32r2-*-elf* | mipsisa32r2el-*-elf* | \
+mipsisa64-*-elf* | mipsisa64el-*-elf* | \
+mipsisa64r2-*-elf* | mipsisa64r2el-*-elf*)
+	tm_file="elfos.h ${tm_file} mips/elf.h"
+	tmake_file="mips/t-isa3264 mips/t-libgcc-mips16"
+	case ${target} in
+	  mipsisa32r2*)
+	    tm_defines="${tm_defines} MIPS_ISA_DEFAULT=33"
+	    ;;
+	  mipsisa32*)
+	    tm_defines="${tm_defines} MIPS_ISA_DEFAULT=32"
+	    ;;
+	  mipsisa64r2*)
+	    tm_defines="${tm_defines} MIPS_ISA_DEFAULT=65"
+	    ;;
+	  mipsisa64*)
+	    tm_defines="${tm_defines} MIPS_ISA_DEFAULT=64"
+	    ;;
+	esac
+	case ${target} in
+	  mipsisa32*-*-elfoabi*)
+	    tm_defines="${tm_defines} MIPS_ABI_DEFAULT=ABI_32"
+	    tm_file="${tm_file} mips/elfoabi.h"
+	    ;;
+	  mipsisa64*-*-elfoabi*)
+	    tm_defines="${tm_defines} MIPS_ABI_DEFAULT=ABI_O64"
+	    tm_file="${tm_file} mips/elfoabi.h"
+	    ;;
+	  *-*-elf*)
+	    tm_defines="${tm_defines} MIPS_ABI_DEFAULT=ABI_EABI"
+	    ;;
+	esac
+	;;
+mipsisa64sr71k-*-elf*)
+        tm_file="elfos.h ${tm_file} mips/elf.h"
+        tmake_file=mips/t-sr71k
+	target_cpu_default="MASK_64BIT|MASK_FLOAT64"
+	tm_defines="${tm_defines} MIPS_ISA_DEFAULT=64 MIPS_CPU_STRING_DEFAULT=\\\"sr71000\\\" MIPS_ABI_DEFAULT=ABI_EABI"
+        ;;
+mipsisa64sb1-*-elf* | mipsisa64sb1el-*-elf*)
+	tm_file="elfos.h ${tm_file} mips/elf.h"
+	tmake_file="mips/t-elf mips/t-libgcc-mips16 mips/t-sb1"
+	target_cpu_default="MASK_64BIT|MASK_FLOAT64"
+	tm_defines="${tm_defines} MIPS_ISA_DEFAULT=64 MIPS_CPU_STRING_DEFAULT=\\\"sb1\\\" MIPS_ABI_DEFAULT=ABI_O64"
+	;;
+mips-*-elf* | mipsel-*-elf*)
+	tm_file="elfos.h ${tm_file} mips/elf.h"
+	tmake_file="mips/t-elf mips/t-libgcc-mips16"
+	;;
+mips64-*-elf* | mips64el-*-elf*)
+	tm_file="elfos.h ${tm_file} mips/elf.h"
+	tmake_file="mips/t-elf mips/t-libgcc-mips16"
+	target_cpu_default="MASK_64BIT|MASK_FLOAT64"
+	tm_defines="${tm_defines} MIPS_ISA_DEFAULT=3 MIPS_ABI_DEFAULT=ABI_O64"
+	;;
+mips64vr-*-elf* | mips64vrel-*-elf*)
+        tm_file="elfos.h ${tm_file} mips/vr.h mips/elf.h"
+        tmake_file=mips/t-vr
+        ;;
+mips64orion-*-elf* | mips64orionel-*-elf*)
+	tm_file="elfos.h ${tm_file} mips/elforion.h mips/elf.h"
+	tmake_file="mips/t-elf mips/t-libgcc-mips16"
+	target_cpu_default="MASK_64BIT|MASK_FLOAT64"
+	tm_defines="${tm_defines} MIPS_ISA_DEFAULT=3 MIPS_ABI_DEFAULT=ABI_O64"
+	;;
+mips*-*-rtems*)
+	tm_file="elfos.h ${tm_file} mips/elf.h mips/rtems.h rtems.h"
+	tmake_file="mips/t-elf mips/t-libgcc-mips16 t-rtems mips/t-rtems"
+	;;
+mips-wrs-vxworks)
+	tm_file="elfos.h ${tm_file} svr4.h mips/elf.h vx-common.h vxworks.h mips/vxworks.h"
+	tmake_file="${tmake_file} mips/t-vxworks"
+	;;
+mipstx39-*-elf* | mipstx39el-*-elf*)
+	tm_file="elfos.h ${tm_file} mips/r3900.h mips/elf.h"
+	tmake_file="mips/t-r3900 mips/t-libgcc-mips16"
+	;;
+mmix-knuth-mmixware)
+	need_64bit_hwint=yes
+	;;
+mn10300-*-*)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file}"
+	if test x$stabs = xyes
+	then
+		tm_file="${tm_file} dbx.h"
+	fi
+	use_collect2=no
+	;;
+pdp11-*-bsd)
+	tm_file="${tm_file} pdp11/2bsd.h"
+	use_fixproto=yes
+        ;;
+pdp11-*-*)
+	;;
+picochip-*)
+        # Nothing special
+        ;;
+# port not yet contributed
+#powerpc-*-openbsd*)
+#	tmake_file="${tmake_file} rs6000/t-fprules rs6000/t-fprules-fpbit "
+#	extra_headers=
+#	;;
+powerpc64-*-linux*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h"
+	test x$with_cpu != x || cpu_is_64bit=yes
+	test x$cpu_is_64bit != xyes || tm_file="${tm_file} rs6000/default64.h"
+	tm_file="rs6000/biarch64.h ${tm_file} rs6000/linux64.h"
+	if test x${enable_secureplt} = xyes; then
+		tm_file="rs6000/secureplt.h ${tm_file}"
+	fi
+	extra_options="${extra_options} rs6000/sysv4.opt rs6000/linux64.opt"
+	tmake_file="t-dfprules rs6000/t-fprules ${tmake_file} rs6000/t-ppccomm rs6000/t-linux64 rs6000/t-fprules-softfp soft-fp/t-softfp"
+	;;
+powerpc64-*-gnu*)
+	tm_file="${cpu_type}/${cpu_type}.h elfos.h svr4.h freebsd-spec.h gnu.h rs6000/sysv4.h rs6000/linux64.h rs6000/gnu.h"
+	extra_options="${extra_options} rs6000/sysv4.opt rs6000/linux64.opt"
+	tmake_file="rs6000/t-fprules t-slibgcc-elf-ver t-gnu rs6000/t-linux64 rs6000/t-fprules-softfp soft-fp/t-softfp"
+	;;
+powerpc-*-darwin*)
+	extra_options="${extra_options} rs6000/darwin.opt"
+	extra_parts="crt2.o"
+	case ${target} in
+	  *-darwin1[0-9]* | *-darwin[8-9]*)
+	    tmake_file="${tmake_file} rs6000/t-darwin8"
+	    tm_file="${tm_file} rs6000/darwin8.h"
+	    ;;
+	  *-darwin7*)
+	    tm_file="${tm_file} rs6000/darwin7.h"
+	    ;;
+	  *-darwin[0-6]*)
+	    ;;
+	esac
+	extra_headers=altivec.h
+	;;
+powerpc64-*-darwin*)
+	tm_file="${tm_file} ${cpu_type}/darwin8.h ${cpu_type}/darwin64.h"
+	extra_options="${extra_options} ${cpu_type}/darwin.opt"
+	# We're omitting t-darwin8 to avoid building any multilibs
+	extra_headers=altivec.h
+	;;
+powerpc*-*-freebsd*)
+	tm_file="${tm_file} dbxelf.h elfos.h ${fbsd_tm_file} rs6000/sysv4.h rs6000/freebsd.h"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	;;
+powerpc-*-netbsd*)
+	tm_file="${tm_file} dbxelf.h elfos.h netbsd.h netbsd-elf.h freebsd-spec.h rs6000/sysv4.h rs6000/netbsd.h"
+	tmake_file="${tmake_file} rs6000/t-netbsd"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	;;
+powerpc-*-eabispe*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/e500.h rs6000/eabispe.h"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	tmake_file="rs6000/t-spe rs6000/t-ppccomm"
+	;;
+powerpc-*-eabisimaltivec*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/e500.h rs6000/eabisim.h rs6000/eabialtivec.h"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcendian rs6000/t-ppccomm"
+	;;
+powerpc-*-eabisim*)
+	tm_file="${tm_file} dbxelf.h elfos.h usegas.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/e500.h rs6000/eabisim.h"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm"
+	;;
+powerpc-*-elf*)
+	tm_file="${tm_file} dbxelf.h elfos.h usegas.h svr4.h freebsd-spec.h rs6000/sysv4.h"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm"
+	;;
+powerpc-*-eabialtivec*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/e500.h rs6000/eabialtivec.h"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcendian rs6000/t-ppccomm"
+	;;
+powerpc-xilinx-eabi*)
+	tm_file="${tm_file} dbxelf.h elfos.h usegas.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/singlefp.h"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm"
+	;;
+powerpc-*-eabi*)
+	tm_file="${tm_file} dbxelf.h elfos.h usegas.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/e500.h"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm"
+	;;
+powerpc-*-rtems*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/e500.h rs6000/rtems.h rtems.h"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-rtems t-rtems rs6000/t-ppccomm"
+	;;
+powerpc-*-linux*altivec*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/linux.h rs6000/linuxaltivec.h"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-softfp soft-fp/t-softfp rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm"
+	;;
+powerpc-*-linux*spe*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/linux.h rs6000/linuxspe.h rs6000/e500.h"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	tmake_file="t-dfprules rs6000/t-fprules rs6000/t-fprules-softfp soft-fp/t-softfp rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm"
+	;;
+powerpc-*-linux*paired*)
+        tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/linux.h rs6000/750cl.h"
+        extra_options="${extra_options} rs6000/sysv4.opt"
+        tmake_file="rs6000/t-fprules rs6000/t-fprules-softfp soft-fp/t-softfp rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm"
+        ;;
+powerpc-*-linux*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	tmake_file="t-dfprules rs6000/t-fprules rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm"
+	case ${enable_targets}:${cpu_is_64bit} in
+	    *powerpc64* | all:* | *:yes)
+		if test x$cpu_is_64bit = xyes; then
+		    tm_file="${tm_file} rs6000/default64.h"
+		fi
+		tm_file="rs6000/biarch64.h ${tm_file} rs6000/linux64.h"
+		tmake_file="$tmake_file rs6000/t-linux64"
+		extra_options="${extra_options} rs6000/linux64.opt"
+		;;
+	    *)
+		tm_file="${tm_file} rs6000/linux.h"
+		;;
+	esac
+	tmake_file="${tmake_file} rs6000/t-fprules-softfp soft-fp/t-softfp"
+	if test x${enable_secureplt} = xyes; then
+		tm_file="rs6000/secureplt.h ${tm_file}"
+	fi
+	;;
+powerpc-*-gnu-gnualtivec*)
+	tm_file="${cpu_type}/${cpu_type}.h elfos.h svr4.h freebsd-spec.h gnu.h rs6000/sysv4.h rs6000/linux.h rs6000/linuxaltivec.h rs6000/gnu.h"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcos t-slibgcc-elf-ver t-gnu rs6000/t-ppccomm"
+	if test x$enable_threads = xyes; then
+		thread_file='posix'
+	fi
+	;;
+powerpc-*-gnu*)
+	tm_file="${cpu_type}/${cpu_type}.h elfos.h svr4.h freebsd-spec.h gnu.h rs6000/sysv4.h rs6000/linux.h rs6000/gnu.h"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcos t-slibgcc-elf-ver t-gnu rs6000/t-ppccomm"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	if test x$enable_threads = xyes; then
+		thread_file='posix'
+	fi
+	;;
+powerpc-wrs-vxworks|powerpc-wrs-vxworksae)
+	tm_file="${tm_file} elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h"
+	tmake_file="${tmake_file} rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppccomm rs6000/t-vxworks"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	extra_headers=ppc-asm.h
+	case ${target} in
+	  *-vxworksae*)
+	    tm_file="${tm_file} vx-common.h vxworksae.h rs6000/vxworks.h rs6000/e500.h rs6000/vxworksae.h"
+	    tmake_file="${tmake_file} rs6000/t-vxworksae"
+	    ;;
+	  *-vxworks*)
+	    tm_file="${tm_file} vx-common.h vxworks.h rs6000/vxworks.h rs6000/e500.h"
+	    ;;
+	esac
+	;;
+powerpc-*-lynxos*)
+	xm_defines=POSIX
+	tm_file="${tm_file} dbxelf.h elfos.h rs6000/sysv4.h rs6000/lynx.h lynx.h"
+	tmake_file="t-lynx rs6000/t-lynx"
+	extra_options="${extra_options} rs6000/sysv4.opt lynx.opt"
+	extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
+	extra_options="${extra_options} lynx.opt"
+	thread_file=lynx
+	gnu_ld=yes
+	gas=yes
+	;;
+powerpcle-*-elf*)
+	tm_file="${tm_file} dbxelf.h elfos.h usegas.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/sysv4le.h"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	;;
+powerpcle-*-eabisim*)
+	tm_file="${tm_file} dbxelf.h elfos.h usegas.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/sysv4le.h rs6000/eabi.h rs6000/e500.h rs6000/eabisim.h"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	;;
+powerpcle-*-eabi*)
+	tm_file="${tm_file} dbxelf.h elfos.h usegas.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/sysv4le.h rs6000/eabi.h rs6000/e500.h"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm"
+	extra_options="${extra_options} rs6000/sysv4.opt"
+	;;
+powerpc-xilinx-eabi*)
+ 	tm_file="${tm_file} dbxelf.h elfos.h usegas.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/singlefp.h rs6000/xfpu.h"
+  	extra_options="${extra_options} rs6000/sysv4.opt"
+  	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm"
+  	;;
+rs6000-ibm-aix4.[12]* | powerpc-ibm-aix4.[12]*)
+	tm_file="${tm_file} rs6000/aix.h rs6000/aix41.h rs6000/xcoff.h"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-newas"
+	extra_options="${extra_options} rs6000/aix41.opt"
+	use_collect2=yes
+	extra_headers=
+	use_fixproto=yes
+	;;
+rs6000-ibm-aix4.[3456789]* | powerpc-ibm-aix4.[3456789]*)
+	tm_file="rs6000/biarch64.h ${tm_file} rs6000/aix.h rs6000/aix43.h rs6000/xcoff.h"
+	tmake_file=rs6000/t-aix43
+	extra_options="${extra_options} rs6000/aix64.opt"
+	use_collect2=yes
+	thread_file='aix'
+	extra_headers=
+	;;
+rs6000-ibm-aix5.1.* | powerpc-ibm-aix5.1.*)
+	tm_file="rs6000/biarch64.h ${tm_file} rs6000/aix.h rs6000/aix51.h rs6000/xcoff.h"
+	extra_options="${extra_options} rs6000/aix64.opt"
+	tmake_file=rs6000/t-aix43
+	use_collect2=yes
+	thread_file='aix'
+	extra_headers=
+	;;
+rs6000-ibm-aix5.2.* | powerpc-ibm-aix5.2.*)
+	tm_file="${tm_file} rs6000/aix.h rs6000/aix52.h rs6000/xcoff.h"
+	tmake_file=rs6000/t-aix52
+	extra_options="${extra_options} rs6000/aix64.opt"
+	use_collect2=yes
+	thread_file='aix'
+	extra_headers=
+	;;
+rs6000-ibm-aix5.3.* | powerpc-ibm-aix5.3.*)
+	tm_file="${tm_file} rs6000/aix.h rs6000/aix53.h rs6000/xcoff.h"
+	tmake_file=rs6000/t-aix52
+	extra_options="${extra_options} rs6000/aix64.opt"
+	use_collect2=yes
+	thread_file='aix'
+	extra_headers=altivec.h
+	;;
+rs6000-ibm-aix[6789].* | powerpc-ibm-aix[6789].*)
+	tm_file="${tm_file} rs6000/aix.h rs6000/aix61.h rs6000/xcoff.h"
+	tmake_file=rs6000/t-aix52
+	extra_options="${extra_options} rs6000/aix64.opt"
+	use_collect2=yes
+	thread_file='aix'
+	extra_headers=altivec.h
+	;;
+s390-*-linux*)
+	tm_file="s390/s390.h dbxelf.h elfos.h svr4.h linux.h s390/linux.h"
+	tmake_file="${tmake_file} t-dfprules s390/t-crtstuff s390/t-linux"
+	;;
+s390x-*-linux*)
+	tm_file="s390/s390x.h s390/s390.h dbxelf.h elfos.h svr4.h linux.h s390/linux.h"
+	tm_p_file=s390/s390-protos.h
+	md_file=s390/s390.md
+	extra_modes=s390/s390-modes.def
+	out_file=s390/s390.c
+	tmake_file="${tmake_file} t-dfprules s390/t-crtstuff s390/t-linux s390/t-linux64"
+	;;
+s390x-ibm-tpf*)
+        tm_file="s390/s390x.h s390/s390.h dbxelf.h elfos.h svr4.h s390/tpf.h"
+        tm_p_file=s390/s390-protos.h
+        md_file=s390/s390.md
+        extra_modes=s390/s390-modes.def
+        out_file=s390/s390.c
+        extra_parts="crtbeginS.o crtendS.o"
+        tmake_file="s390/t-crtstuff s390/t-tpf"
+        thread_file='tpf'
+	extra_options="${extra_options} s390/tpf.opt"
+	;;
+score-*-elf)
+        tm_file="dbxelf.h elfos.h score/elf.h score/score.h"
+        tmake_file=score/t-score-elf
+        extra_objs="score7.o score3.o"
+        ;;
+sh-*-elf* | sh[12346l]*-*-elf* | \
+sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \
+  sh-*-linux* | sh[2346lbe]*-*-linux* | \
+  sh-*-netbsdelf* | shl*-*-netbsdelf* | sh5-*-netbsd* | sh5l*-*-netbsd* | \
+   sh64-*-netbsd* | sh64l*-*-netbsd*)
+	tmake_file="${tmake_file} sh/t-sh sh/t-elf"
+	if test x${with_endian} = x; then
+		case ${target} in
+		sh[1234]*be-*-* | sh[1234]*eb-*-*) with_endian=big ;;
+		shbe-*-* | sheb-*-*)		   with_endian=big,little ;;
+		sh[1234]l* | sh[34]*-*-linux*)	   with_endian=little ;;
+		shl* | sh64l* | sh*-*-linux* | \
+		  sh5l* | sh-superh-elf)	   with_endian=little,big ;;
+		sh[1234]*-*-*)			   with_endian=big ;;
+		*)				   with_endian=big,little ;;
+		esac
+	fi
+	case ${with_endian} in
+	big|little)	tmake_file="${tmake_file} sh/t-1e" ;;
+	big,little|little,big) ;;
+	*)	echo "with_endian=${with_endian} not supported."; exit 1 ;;
+	esac
+	case ${with_endian} in
+	little*)	tm_file="sh/little.h ${tm_file}" ;;
+	esac
+	tm_file="${tm_file} dbxelf.h elfos.h"
+	case ${target} in
+	sh*-*-netbsd*)	;;
+	*)		tm_file="${tm_file} svr4.h" ;;
+	esac
+	tm_file="${tm_file} sh/elf.h"
+	case ${target} in
+	sh*-*-linux*)	tmake_file="${tmake_file} sh/t-linux"
+			tm_file="${tm_file} linux.h sh/linux.h" ;;
+	sh*-*-netbsd*)	tm_file="${tm_file} netbsd.h netbsd-elf.h sh/netbsd-elf.h" ;;
+	sh*-superh-elf)	if test x$with_libgloss != xno; then
+				with_libgloss=yes
+				tm_file="${tm_file} sh/newlib.h"
+			fi
+			tm_file="${tm_file} sh/embed-elf.h sh/superh.h"
+			tmake_file="${tmake_file} sh/t-superh"
+			extra_options="${extra_options} sh/superh.opt" ;;
+	*)		if test x$with_newlib = xyes \
+			   && test x$with_libgloss = xyes; then
+				tm_file="${tm_file} sh/newlib.h"
+			fi
+			tm_file="${tm_file} sh/embed-elf.h" ;;
+	esac
+	case ${target} in
+	sh5*-*-netbsd*)
+		# SHmedia, 32-bit ABI
+		tmake_file="${tmake_file} sh/t-sh64 sh/t-netbsd"
+		;;
+	sh64*-netbsd*)
+		# SHmedia, 64-bit ABI
+		tmake_file="${tmake_file} sh/t-sh64 sh/t-netbsd sh/t-netbsd-sh5-64"
+		;;
+	*-*-netbsd)
+                tmake_file="${tmake_file} sh/t-netbsd"
+		;;
+	sh64*-*-linux*)
+		tmake_file="${tmake_file} sh/t-sh64 sh/t-linux64"
+		tm_file="${tm_file} sh/sh64.h"
+		extra_headers="shmedia.h ushmedia.h sshmedia.h"
+		;;
+	sh64*)
+		tmake_file="${tmake_file} sh/t-sh64"
+		tm_file="${tm_file} sh/sh64.h"
+		extra_headers="shmedia.h ushmedia.h sshmedia.h"
+		;;
+	*-*-symbianelf*)
+		tmake_file="sh/t-symbian"
+		tm_file="sh/symbian-pre.h sh/little.h ${tm_file} sh/symbian-post.h"
+		extra_objs="symbian.o"
+		extra_parts="crt1.o crti.o crtn.o crtbegin.o crtend.o crtbeginS.o crtendS.o"
+		;;
+	esac
+	# sed el/eb endian suffixes away to avoid confusion with sh[23]e
+	case `echo ${target} | sed 's/e[lb]-/-/'` in
+	sh64*-*-netbsd*)	sh_cpu_target=sh5-64media ;;
+	sh64* | sh5*-*-netbsd*)	sh_cpu_target=sh5-32media ;;
+	sh4a_single_only*)	sh_cpu_target=sh4a-single-only ;;
+	sh4a_single*)		sh_cpu_target=sh4a-single ;;
+	sh4a_nofpu*)		sh_cpu_target=sh4a-nofpu ;;
+	sh4al)			sh_cpu_target=sh4al ;;
+	sh4a*)			sh_cpu_target=sh4a ;;
+	sh4_single_only*)	sh_cpu_target=sh4-single-only ;;
+	sh4_single*)		sh_cpu_target=sh4-single ;;
+	sh4_nofpu*)		sh_cpu_target=sh4-nofpu ;;
+	sh4* | sh-superh-*)	sh_cpu_target=sh4 ;;
+	sh3e*)			sh_cpu_target=sh3e ;;
+	sh*-*-netbsd* | sh3*)	sh_cpu_target=sh3 ;;
+	sh2a_single_only*)	sh_cpu_target=sh2a-single-only ;;
+	sh2a_single*)		sh_cpu_target=sh2a-single ;;
+	sh2a_nofpu*)		sh_cpu_target=sh2a-nofpu ;;
+	sh2a*)			sh_cpu_target=sh2a ;;
+	sh2e*)			sh_cpu_target=sh2e ;;
+	sh2*)			sh_cpu_target=sh2 ;;
+	*)			sh_cpu_target=sh1 ;;
+	esac
+	# did the user say --without-fp ?
+	if test x$with_fp = xno; then
+		case ${sh_cpu_target} in
+		sh5-*media)	sh_cpu_target=${sh_cpu_target}-nofpu ;;
+		sh4al | sh1)	;;
+		sh4a* )		sh_cpu_target=sh4a-nofpu ;;
+		sh4*)		sh_cpu_target=sh4-nofpu ;;
+		sh3*)		sh_cpu_target=sh3 ;;
+		sh2a*)		sh_cpu_target=sh2a-nofpu ;;
+		sh2*)		sh_cpu_target=sh2 ;;
+		*)	echo --without-fp not available for $target: ignored
+		esac
+		tm_defines="$tm_defines STRICT_NOFPU=1"
+	fi
+	sh_cpu_default="`echo $with_cpu|sed s/^m/sh/|tr A-Z_ a-z-`"
+	case $sh_cpu_default in
+	sh5-64media-nofpu | sh5-64media | \
+	  sh5-32media-nofpu | sh5-32media | sh5-compact-nofpu | sh5-compact | \
+	  sh2a-single-only | sh2a-single | sh2a-nofpu | sh2a | \
+	  sh4a-single-only | sh4a-single | sh4a-nofpu | sh4a | sh4al | \
+	  sh4-single-only | sh4-single | sh4-nofpu | sh4 | sh4-300 | \
+	  sh3e | sh3 | sh2e | sh2 | sh1) ;;
+	"")	sh_cpu_default=${sh_cpu_target} ;;
+	*)	echo "with_cpu=$with_cpu not supported"; exit 1 ;;
+	esac
+	sh_multilibs=${with_multilib_list}
+	if test x${sh_multilibs} = x ; then
+		case ${target} in
+		sh64-superh-linux* | \
+		sh[1234]*)	sh_multilibs=${sh_cpu_target} ;;
+		sh64* | sh5*)	sh_multilibs=m5-32media,m5-32media-nofpu,m5-compact,m5-compact-nofpu,m5-64media,m5-64media-nofpu ;;
+		sh-superh-*)	sh_multilibs=m4,m4-single,m4-single-only,m4-nofpu ;;
+		sh*-*-linux*)	sh_multilibs=m1,m3e,m4 ;;
+		sh*-*-netbsd*)	sh_multilibs=m3,m3e,m4 ;;
+		*) sh_multilibs=m1,m2,m2e,m4,m4-single,m4-single-only,m2a,m2a-single ;;
+		esac
+		if test x$with_fp = xno; then
+			sh_multilibs="`echo $sh_multilibs|sed -e s/m4/sh4-nofpu/ -e s/,m4-[^,]*//g -e s/,m[23]e// -e s/m2a,m2a-single/m2a-nofpu/ -e s/m5-..m....,//g`"
+		fi
+	fi
+	target_cpu_default=SELECT_`echo ${sh_cpu_default}|tr abcdefghijklmnopqrstuvwxyz- ABCDEFGHIJKLMNOPQRSTUVWXYZ_`
+	tm_defines=${tm_defines}' SH_MULTILIB_CPU_DEFAULT=\"'`echo $sh_cpu_default|sed s/sh/m/`'\"'
+	sh_multilibs=`echo $sh_multilibs,$sh_cpu_default | sed -e 's/[ 	,/][ 	,]*/ /g' -e 's/ $//' -e 's/^m/sh/' -e 's/ m/ sh/g' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ_ abcdefghijklmnopqrstuvwxyz-`
+	for sh_multilib in ${sh_multilibs}; do
+		case ${sh_multilib} in
+		sh1 | sh2 | sh2e | sh3 | sh3e | \
+		sh4 | sh4-single | sh4-single-only | sh4-nofpu | sh4-300 |\
+		sh4a | sh4a-single | sh4a-single-only | sh4a-nofpu | sh4al | \
+		sh2a | sh2a-single | sh2a-single-only | sh2a-nofpu | \
+		sh5-64media | sh5-64media-nofpu | \
+		sh5-32media | sh5-32media-nofpu | \
+		sh5-compact | sh5-compact-nofpu)
+			tmake_file="${tmake_file} sh/t-mlib-${sh_multilib}"
+			tm_defines="$tm_defines SUPPORT_`echo $sh_multilib|tr abcdefghijklmnopqrstuvwxyz- ABCDEFGHIJKLMNOPQRSTUVWXYZ_`=1"
+			;;
+		*)
+			echo "with_multilib_list=${sh_multilib} not supported."
+			exit 1
+			;;
+		esac
+	done
+	if test x${enable_incomplete_targets} = xyes ; then
+		tm_defines="$tm_defines SUPPORT_SH1=1 SUPPORT_SH2E=1 SUPPORT_SH4=1 SUPPORT_SH4_SINGLE=1 SUPPORT_SH2A=1 SUPPORT_SH2A_SINGLE=1 SUPPORT_SH5_32MEDIA=1 SUPPORT_SH5_32MEDIA_NOFPU=1 SUPPORT_SH5_64MEDIA=1 SUPPORT_SH5_64MEDIA_NOFPU=1"
+	fi
+	;;
+sh-*-rtems*)
+	tmake_file="sh/t-sh sh/t-elf t-rtems sh/t-rtems"
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sh/elf.h sh/embed-elf.h sh/rtemself.h rtems.h"
+	;;
+sh-wrs-vxworks)
+	tmake_file="$tmake_file sh/t-sh sh/t-elf sh/t-vxworks"
+	tm_file="${tm_file} elfos.h svr4.h sh/elf.h sh/embed-elf.h vx-common.h vxworks.h sh/vxworks.h"
+	;;
+sh-*-*)
+	tm_file="${tm_file} dbxcoff.h sh/coff.h"
+	;;
+sparc-*-netbsdelf*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h netbsd.h netbsd-elf.h sparc/netbsd-elf.h"
+	extra_options="${extra_options} sparc/long-double-switch.opt"
+	;;
+sparc64-*-openbsd*)
+	tm_file="sparc/openbsd1-64.h ${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/sp64-elf.h openbsd.h sparc/openbsd64.h"
+	extra_options="${extra_options} sparc/little-endian.opt"
+	gas=yes gnu_ld=yes
+	with_cpu=ultrasparc
+	;;
+sparc-*-elf*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/sp-elf.h"
+	tmake_file="sparc/t-elf sparc/t-crtfm"
+	extra_parts="crti.o crtn.o crtbegin.o crtend.o"
+	;;
+sparc-*-linux*)		# SPARC's running GNU/Linux, libc6
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/gas.h linux.h"
+	extra_options="${extra_options} sparc/long-double-switch.opt"
+	tmake_file="${tmake_file} sparc/t-linux"
+	if test x$enable_targets = xall; then
+		tm_file="sparc/biarch64.h ${tm_file} sparc/linux64.h"
+		tmake_file="${tmake_file} sparc/t-linux64"
+	else
+		tm_file="${tm_file} sparc/linux.h"
+	fi
+	tmake_file="${tmake_file} sparc/t-crtfm"
+	;;
+sparc-*-rtems*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/sp-elf.h sparc/rtemself.h rtems.h"
+	tmake_file="sparc/t-elf sparc/t-crtfm t-rtems"
+	extra_parts="crti.o crtn.o crtbegin.o crtend.o"
+	;;
+sparc64-*-solaris2* | sparcv9-*-solaris2*)
+	tm_file="sparc/biarch64.h ${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sol2.h"
+	case ${target} in
+	*-*-solaris2.1[0-9]*)
+		tm_file="${tm_file} sol2-10.h"
+		;;
+	esac
+	tm_file="${tm_file} sparc/sol2.h sparc/sol2-64.h sparc/sol2-bi.h"
+	if test x$gnu_ld = xyes; then
+		tm_file="${tm_file} sol2-gld.h sparc/sol2-gld-bi.h"
+	fi
+	if test x$gas = xyes; then
+		tm_file="${tm_file} sparc/sol2-gas.h sparc/sol2-gas-bi.h"
+	fi
+	tm_file="${tm_file} tm-dwarf2.h"
+	tmake_file="t-sol2 sparc/t-sol2 sparc/t-sol2-64 sparc/t-crtfm"
+	if test x$gnu_ld = xyes; then
+		tmake_file="$tmake_file t-slibgcc-elf-ver"
+	else
+		tmake_file="$tmake_file t-slibgcc-sld"
+	fi
+	if test x$gas = xyes; then
+		tm_file="usegas.h ${tm_file}"
+	fi
+	c_target_objs="sol2-c.o"
+	cxx_target_objs="sol2-c.o"
+	extra_objs="sol2.o"
+	tm_p_file="${tm_p_file} sol2-protos.h"
+	extra_parts="crt1.o crti.o crtn.o gcrt1.o crtbegin.o crtend.o"
+	case ${enable_threads}:${have_pthread_h}:${have_thread_h} in
+	  "":yes:* | yes:yes:* ) thread_file=posix ;;
+	  "":*:yes | yes:*:yes ) thread_file=solaris ;;
+	esac
+	;;
+sparc-*-solaris2*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sol2.h"
+	case ${target} in
+	*-*-solaris2.1[0-9]*)
+		tm_file="${tm_file} sol2-10.h"
+		;;
+	esac
+	tm_file="${tm_file} sparc/sol2.h"
+	if test x$gnu_ld = xyes; then
+		tm_file="${tm_file} sol2-gld.h"
+	fi
+	if test x$gas = xyes; then
+		tm_file="${tm_file} sparc/sol2-gas.h"
+	fi
+	tmake_file="t-sol2 sparc/t-sol2 sparc/t-crtfm"
+	if test x$gnu_ld = xyes; then
+		tmake_file="$tmake_file t-slibgcc-elf-ver"
+	else
+		tmake_file="$tmake_file t-slibgcc-sld"
+	fi
+	tm_file="sparc/biarch64.h ${tm_file} sparc/sol2-bi.h"
+	if test x$gnu_ld = xyes; then
+		tm_file="${tm_file} sparc/sol2-gld-bi.h"
+	fi
+	if test x$gas = xyes; then
+		tm_file="${tm_file} sparc/sol2-gas-bi.h"
+	fi
+	if test x$gas = xyes; then
+		tm_file="usegas.h ${tm_file}"
+	fi
+	tm_file="${tm_file} tm-dwarf2.h"
+	tmake_file="$tmake_file sparc/t-sol2-64"
+	test x$with_cpu != x || with_cpu=v9
+	c_target_objs="sol2-c.o"
+	cxx_target_objs="sol2-c.o"
+	extra_objs="sol2.o"
+	tm_p_file="${tm_p_file} sol2-protos.h"
+	extra_parts="crt1.o crti.o crtn.o gcrt1.o gmon.o crtbegin.o crtend.o"
+	case ${enable_threads}:${have_pthread_h}:${have_thread_h} in
+	  "":yes:* | yes:yes:* )
+		thread_file=posix
+		;;
+	  "":*:yes | yes:*:yes )
+		thread_file=solaris
+		;;
+	esac
+	;;
+sparc-wrs-vxworks)
+	tm_file="${tm_file} elfos.h svr4.h sparc/sysv4.h vx-common.h vxworks.h sparc/vxworks.h"
+	tmake_file="${tmake_file} sparc/t-vxworks"
+	;;
+sparc64-*-elf*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/sp64-elf.h"
+	extra_options="${extra_options} sparc/little-endian.opt"
+	tmake_file="${tmake_file} sparc/t-crtfm"
+	extra_parts="crtbegin.o crtend.o"
+	;;
+sparc64-*-freebsd*|ultrasparc-*-freebsd*)
+	tm_file="${tm_file} ${fbsd_tm_file} dbxelf.h elfos.h sparc/sysv4.h sparc/freebsd.h"
+	extra_options="${extra_options} sparc/long-double-switch.opt"
+	tmake_file="${tmake_file} sparc/t-crtfm"
+	case "x$with_cpu" in
+		xultrasparc) ;;
+		x) with_cpu=ultrasparc ;;
+		*) echo "$with_cpu not supported for freebsd target"; exit 1 ;;
+	esac
+	;;
+sparc64-*-linux*)		# 64-bit SPARC's running GNU/Linux
+	tm_file="sparc/biarch64.h ${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/gas.h linux.h sparc/linux64.h"
+	extra_options="${extra_options} sparc/long-double-switch.opt"
+	tmake_file="${tmake_file} sparc/t-linux sparc/t-linux64 sparc/t-crtfm"
+	;;
+sparc64-*-netbsd*)
+	tm_file="sparc/biarch64.h ${tm_file}"
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h netbsd.h netbsd-elf.h sparc/netbsd-elf.h"
+	extra_options="${extra_options} sparc/long-double-switch.opt"
+	tmake_file="${tmake_file} sparc/t-netbsd64"
+	;;
+spu-*-elf*)
+	tm_file="dbxelf.h elfos.h spu/spu-elf.h spu/spu.h"
+	tmake_file="spu/t-spu-elf"
+	extra_headers="spu_intrinsics.h spu_internals.h vmx2spu.h spu_mfcio.h vec_types.h"
+	extra_modes=spu/spu-modes.def
+	c_target_objs="${c_target_objs} spu-c.o"
+	cxx_target_objs="${cxx_target_objs} spu-c.o"
+	;;
+v850e1-*-*)
+	target_cpu_default="TARGET_CPU_v850e1"
+	tm_file="dbxelf.h elfos.h svr4.h v850/v850.h"
+	tm_p_file=v850/v850-protos.h
+	tmake_file=v850/t-v850e
+	md_file=v850/v850.md
+	out_file=v850/v850.c
+	extra_options="${extra_options} v850/v850.opt"
+	if test x$stabs = xyes
+	then
+		tm_file="${tm_file} dbx.h"
+	fi
+	use_collect2=no
+	c_target_objs="v850-c.o"
+	cxx_target_objs="v850-c.o"
+	;;
+v850e-*-*)
+	target_cpu_default="TARGET_CPU_v850e"
+	tm_file="dbxelf.h elfos.h svr4.h v850/v850.h"
+	tm_p_file=v850/v850-protos.h
+	tmake_file=v850/t-v850e
+	md_file=v850/v850.md
+	out_file=v850/v850.c
+	extra_options="${extra_options} v850/v850.opt"
+	if test x$stabs = xyes
+	then
+		tm_file="${tm_file} dbx.h"
+	fi
+	use_collect2=no
+	c_target_objs="v850-c.o"
+	cxx_target_objs="v850-c.o"
+	;;
+v850-*-*)
+	target_cpu_default="TARGET_CPU_generic"
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file}"
+	tmake_file=v850/t-v850
+	if test x$stabs = xyes
+	then
+		tm_file="${tm_file} dbx.h"
+	fi
+	use_collect2=no
+	c_target_objs="v850-c.o"
+	cxx_target_objs="v850-c.o"
+	;;
+vax-*-netbsdelf*)
+	tm_file="${tm_file} elfos.h netbsd.h netbsd-elf.h vax/elf.h vax/netbsd-elf.h"
+	;;
+vax-*-netbsd*)
+	tm_file="${tm_file} netbsd.h netbsd-aout.h vax/netbsd.h"
+	tmake_file=t-netbsd
+	extra_parts=""
+	use_collect2=yes
+	;;
+vax-*-openbsd*)
+	tm_file="vax/vax.h vax/openbsd1.h openbsd.h vax/openbsd.h"
+	use_collect2=yes
+	;;
+xstormy16-*-elf)
+	# For historical reasons, the target files omit the 'x'.
+	tm_file="dbxelf.h elfos.h svr4.h stormy16/stormy16.h"
+	tm_p_file=stormy16/stormy16-protos.h
+	md_file=stormy16/stormy16.md
+	out_file=stormy16/stormy16.c
+	extra_options=stormy16/stormy16.opt
+	tmake_file="stormy16/t-stormy16"
+	extra_parts="crtbegin.o crtend.o"
+	;;
+xtensa*-*-elf*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h xtensa/elf.h"
+	tmake_file="xtensa/t-xtensa xtensa/t-elf"
+	;;
+xtensa*-*-linux*)
+	tm_file="${tm_file} dbxelf.h elfos.h svr4.h linux.h xtensa/linux.h"
+	tmake_file="${tmake_file} xtensa/t-xtensa xtensa/t-linux"
+	;;
+am33_2.0-*-linux*)
+	tm_file="mn10300/mn10300.h dbxelf.h elfos.h linux.h mn10300/linux.h"
+	tmake_file="${tmake_file} mn10300/t-linux"
+	gas=yes gnu_ld=yes
+	extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o"
+	use_collect2=no
+	;;
+m32c-*-rtems*)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file} m32c/rtems.h rtems.h"
+	tmake_file="${tmake_file} t-rtems"
+	c_target_objs="m32c-pragma.o"
+	cxx_target_objs="m32c-pragma.o"
+ 	;;
+m32c-*-elf*)
+	tm_file="dbxelf.h elfos.h svr4.h ${tm_file}"
+	c_target_objs="m32c-pragma.o"
+	cxx_target_objs="m32c-pragma.o"
+ 	;;
+*)
+	echo "*** Configuration ${target} not supported" 1>&2
+	exit 1
+	;;
+esac
+
+case ${target} in
+i[34567]86-*-linux* | x86_64-*-linux*)
+	tmake_file="${tmake_file} i386/t-pmm_malloc i386/t-i386"
+	;;
+i[34567]86-*-* | x86_64-*-*)
+	tmake_file="${tmake_file} i386/t-gmm_malloc i386/t-i386"
+	;;
+esac
+
+# Support for --with-cpu and related options (and a few unrelated options,
+# too).
+case ${with_cpu} in
+  yes | no)
+    echo "--with-cpu must be passed a value" 1>&2
+    exit 1
+    ;;
+esac
+
+# If there is no $with_cpu option, try to infer one from ${target}.
+# This block sets nothing except for with_cpu.
+if test x$with_cpu = x ; then
+  case ${target} in
+    i386-*-*)
+      with_cpu=i386
+      ;;
+    i486-*-*)
+      with_cpu=i486
+      ;;
+    i586-*-*)
+      case ${target_noncanonical} in
+        k6_2-*)
+          with_cpu=k6-2
+          ;;
+        k6_3-*)
+          with_cpu=k6-3
+          ;;
+        k6-*)
+          with_cpu=k6
+          ;;
+        pentium_mmx-*|winchip_c6-*|winchip2-*|c3-*)
+          with_cpu=pentium-mmx
+          ;;
+        *)
+          with_cpu=pentium
+          ;;
+      esac
+      ;;
+    i686-*-* | i786-*-*)
+      case ${target_noncanonical} in
+        amdfam10-*|barcelona-*)
+          with_cpu=amdfam10
+          ;;
+        k8_sse3-*|opteron_sse3-*|athlon64_sse3-*)
+          with_cpu=k8-sse3
+          ;;
+        k8-*|opteron-*|athlon64-*|athlon_fx-*)
+          with_cpu=k8
+          ;;
+        athlon_xp-*|athlon_mp-*|athlon_4-*)
+          with_cpu=athlon-4
+          ;;
+        athlon_tbird-*|athlon-*)
+          with_cpu=athlon
+          ;;
+	geode-*)
+	  with_cpu=geode
+	  ;;
+        pentium2-*)
+          with_cpu=pentium2
+          ;;
+        pentium3-*|pentium3m-*)
+          with_cpu=pentium3
+          ;;
+        pentium4-*|pentium4m-*)
+          with_cpu=pentium4
+          ;;
+        prescott-*)
+          with_cpu=prescott
+          ;;
+        nocona-*)
+          with_cpu=nocona
+          ;;
+	core2-*)
+	  with_cpu=core2
+	  ;;
+        pentium_m-*)
+          with_cpu=pentium-m
+          ;;
+        pentiumpro-*)
+          with_cpu=pentiumpro
+          ;;
+        *)
+          with_cpu=generic
+          ;;
+      esac
+      ;;
+    x86_64-*-*)
+      case ${target_noncanonical} in
+        amdfam10-*|barcelona-*)
+          with_cpu=amdfam10
+          ;;
+        k8_sse3-*|opteron_sse3-*|athlon64_sse3-*)
+          with_cpu=k8-sse3
+          ;;
+        k8-*|opteron-*|athlon64-*|athlon_fx-*)
+          with_cpu=k8
+          ;;
+        nocona-*)
+          with_cpu=nocona
+          ;;
+	core2-*)
+	  with_cpu=core2
+	  ;;
+        *)
+          with_cpu=generic
+          ;;
+      esac
+      ;;
+    alphaev6[78]*-*-*)
+      with_cpu=ev67
+      ;;
+    alphaev6*-*-*)
+      with_cpu=ev6
+      ;;
+    alphapca56*-*-*)
+      with_cpu=pca56
+      ;;
+    alphaev56*-*-*)
+      with_cpu=ev56
+      ;;
+    alphaev5*-*-*)
+      with_cpu=ev5
+      ;;
+    frv-*-*linux* | frv400-*-*linux*)
+      with_cpu=fr400
+      ;;
+    frv550-*-*linux*)
+      with_cpu=fr550
+      ;;
+    m68k*-*-*)
+      case "$with_arch" in
+	"cf")
+	  with_cpu=${default_cf_cpu}
+	  ;;
+	"" | "m68k")
+	  with_cpu=m${default_m68k_cpu}
+	  ;;
+      esac
+      ;;
+    mips*-*-vxworks)
+      with_arch=mips2
+      ;;
+    sparc*-*-*)
+      with_cpu="`echo ${target} | sed 's/-.*$//'`"
+      ;;
+  esac
+
+  # Avoid overriding --with-cpu-32 and --with-cpu-64 values.
+  case ${target} in
+    i[34567]86-*-*|x86_64-*-*)
+      if test x$with_cpu != x; then
+        if test x$with_cpu_32 != x || test x$with_cpu_64 != x; then
+          if test x$with_cpu_32 = x; then
+            with_cpu_32=$with_cpu
+          fi
+          if test x$with_cpu_64 = x; then
+            with_cpu_64=$with_cpu
+          fi
+          with_cpu=
+        fi
+      fi
+      ;;
+  esac
+fi
+
+# Similarly for --with-schedule.
+if test x$with_schedule = x; then
+	case ${target} in
+	hppa1*)
+		# Override default PA8000 scheduling model.
+		with_schedule=7100LC
+		;;
+	esac
+fi
+
+# Validate and mark as valid any --with options supported
+# by this target.  In order to use a particular --with option
+# you must list it in supported_defaults; validating the value
+# is optional.  This case statement should set nothing besides
+# supported_defaults.
+
+supported_defaults=
+case "${target}" in
+	alpha*-*-*)
+		supported_defaults="cpu tune"
+		for which in cpu tune; do
+			eval "val=\$with_$which"
+			case "$val" in
+			"" \
+			| ev4 | ev45 | 21064 | ev5 | 21164 | ev56 | 21164a \
+			| pca56 | 21164PC | 21164pc | ev6 | 21264 | ev67 \
+			| 21264a)
+				;;
+			*)
+				echo "Unknown CPU used in --with-$which=$val" 1>&2
+				exit 1
+				;;
+			esac
+		done
+		;;
+
+	arm*-*-*)
+		supported_defaults="arch cpu float tune fpu abi mode"
+		for which in cpu tune; do
+			# See if it matches any of the entries in arm-cores.def
+			eval "val=\$with_$which"
+			if [ x"$val" = x ] \
+			    || grep "^ARM_CORE(\"$val\"," \
+				    ${srcdir}/config/arm/arm-cores.def \
+				    > /dev/null; then
+			  # Ok
+			  new_val=`grep "^ARM_CORE(\"$val\"," \
+				${srcdir}/config/arm/arm-cores.def | \
+				sed -e 's/^[^,]*,[ 	]*//' | \
+				sed -e 's/,.*$//'`
+			  eval "target_${which}_cname=$new_val"
+			echo "For $val real value is $new_val"
+			  true
+			else
+			  echo "Unknown CPU used in --with-$which=$val" 1>&2
+			  exit 1
+			fi
+		done
+
+		case "$with_arch" in
+		"" \
+		| armv[23456] | armv2a | armv3m | armv4t | armv5t \
+		| armv5te | armv6j |armv6k | armv6z | armv6zk | armv6-m \
+		| armv7 | armv7-a | armv7-r | armv7-m \
+		| iwmmxt | ep9312)
+			# OK
+			;;
+		*)
+			echo "Unknown arch used in --with-arch=$with_arch" 1>&2
+			exit 1
+			;;
+		esac
+
+		case "$with_float" in
+		"" \
+		| soft | hard | softfp)
+			# OK
+			;;
+		*)
+			echo "Unknown floating point type used in --with-float=$with_float" 1>&2
+			exit 1
+			;;
+		esac
+
+		case "$with_fpu" in
+		"" \
+		| fpa | fpe2 | fpe3 | maverick | vfp | vfp3 | vfpv3 | vfpv3-d16 | neon )
+			# OK
+			;;
+		*)
+			echo "Unknown fpu used in --with-fpu=$with_fpu" 2>&1
+			exit 1
+			;;
+		esac
+
+		case "$with_abi" in
+		"" \
+		| apcs-gnu | atpcs | aapcs | iwmmxt | aapcs-linux )
+			#OK
+			;;
+		*)
+			echo "Unknown ABI used in --with-abi=$with_abi"
+			exit 1
+			;;
+		esac
+
+		case "$with_mode" in
+		"" \
+		| arm | thumb )
+			#OK
+			;;
+		*)
+			echo "Unknown mode used in --with-mode=$with_mode"
+			exit 1
+			;;
+		esac
+
+		if test "x$with_arch" != x && test "x$with_cpu" != x; then
+			echo "Warning: --with-arch overrides --with-cpu=$with_cpu" 1>&2
+		fi
+		;;
+
+	fr*-*-*linux*)
+		supported_defaults=cpu
+		case "$with_cpu" in
+		fr400) ;;
+		fr550) ;;
+		*)
+			echo "Unknown cpu used in --with-cpu=$with_cpu" 1>&2
+			exit 1
+			;;
+		esac
+		;;
+
+	fido-*-* | m68k*-*-*)
+		supported_defaults="arch cpu"
+		case "$with_arch" in
+		"" | "m68k"| "cf")
+			m68k_arch_family="$with_arch"
+			;;
+		*)
+			echo "Invalid --with-arch=$with_arch" 1>&2
+			exit 1
+			;;
+		esac
+
+		# We always have a $with_cpu setting here.
+		case "$with_cpu" in
+		"m68000" | "m68010" | "m68020" | "m68030" | "m68040" | "m68060")
+			m68k_cpu_ident=$with_cpu
+			;;
+		"m68020-40")
+			m68k_cpu_ident=m68020
+			tm_defines="$tm_defines M68K_DEFAULT_TUNE=u68020_40"
+			;;
+		"m68020-60")
+			m68k_cpu_ident=m68020
+			tm_defines="$tm_defines M68K_DEFAULT_TUNE=u68020_60"
+			;;
+		*)
+			# We need the C identifier rather than the string.
+			m68k_cpu_ident=`awk -v arg="\"$with_cpu\"" \
+			   'BEGIN { FS="[ \t]*[,()][ \t]*" }; \
+			    $1 == "M68K_DEVICE" && $2 == arg { print $3 }' \
+				 ${srcdir}/config/m68k/m68k-devices.def`
+			if [ x"$m68k_cpu_ident" = x ] ; then
+				echo "Unknown CPU used in --with-cpu=$with_cpu" 1>&2
+				exit 1
+			fi
+			with_cpu="mcpu=$with_cpu"
+			;;
+		esac
+		;;
+
+	hppa*-*-*)
+		supported_defaults="arch schedule"
+
+		case "$with_arch" in
+		"" | 1.0 | 1.1 | 2.0)
+			# OK
+			;;
+		*)
+			echo "Unknown architecture used in --with-arch=$with_arch" 1>&2
+			exit 1
+			;;
+		esac
+
+		case "$with_schedule" in
+		"" | 700 | 7100 | 7100LC | 7200 | 7300 | 8000)
+			# OK
+			;;
+		*)
+			echo "Unknown processor used in --with-schedule=$with_schedule." 1>&2
+			exit 1
+			;;
+		esac
+		;;
+
+	i[34567]86-*-* | x86_64-*-*)
+		supported_defaults="arch arch_32 arch_64 cpu cpu_32 cpu_64 tune tune_32 tune_64"
+		for which in arch arch_32 arch_64 cpu cpu_32 cpu_64 tune tune_32 tune_64; do
+			eval "val=\$with_$which"
+			case ${val} in
+			i386 | i486 \
+			| i586 | pentium | pentium-mmx | winchip-c6 | winchip2 \
+			| c3 | c3-2 | i686 | pentiumpro | pentium2 | pentium3 \
+			| pentium4 | k6 | k6-2 | k6-3 | athlon | athlon-tbird \
+			| athlon-4 | athlon-xp | athlon-mp | geode \
+			| prescott | pentium-m | pentium4m | pentium3m)
+				case "${target}" in
+				  x86_64-*-*)
+				      case "x$which" in
+					*_32)
+						;;
+					*)
+						echo "CPU given in --with-$which=$val doesn't support 64bit mode." 1>&2
+						exit 1
+						;;
+				      esac
+				      ;;
+				esac
+				# OK
+				;;
+			"" | amdfam10 | barcelona | k8-sse3 | opteron-sse3 | athlon64-sse3 | k8 | opteron | athlon64 | athlon-fx | nocona | core2 | generic)
+				# OK
+				;;
+			*)
+				echo "Unknown CPU given in --with-$which=$val." 1>&2
+				exit 1
+				;;
+			esac
+		done
+		;;
+
+	mips*-*-*)
+		supported_defaults="abi arch float tune divide llsc mips-plt"
+
+		case ${with_float} in
+		"" | soft | hard)
+			# OK
+			;;
+		*)
+			echo "Unknown floating point type used in --with-float=$with_float" 1>&2
+			exit 1
+			;;
+		esac
+
+		case ${with_abi} in
+		"" | 32 | o64 | n32 | 64 | eabi)
+			# OK
+			;;
+		*)
+			echo "Unknown ABI used in --with-abi=$with_abi" 1>&2
+			exit 1
+			;;
+		esac
+
+		case ${with_divide} in
+		"" | breaks | traps)
+			# OK
+			;;
+		*)
+			echo "Unknown division check type use in --with-divide=$with_divide" 1>&2
+			exit 1
+			;;
+		esac
+
+		case ${with_llsc} in
+		yes)
+			with_llsc=llsc
+			;;
+		no)
+			with_llsc="no-llsc"
+			;;
+		"")
+			# OK
+			;;
+		*)
+			echo "Unknown llsc type used in --with-llsc" 1>&2
+			exit 1
+			;;
+		esac
+
+		case ${with_mips_plt} in
+		yes)
+			with_mips_plt=plt
+			;;
+		no)
+			with_mips_plt=no-plt
+			;;
+		"")
+			;;
+		*)
+			echo "Unknown --with-mips-plt argument: $with_mips_plt" 1>&2
+			exit 1
+			;;
+		esac
+		;;
+
+	powerpc*-*-* | rs6000-*-*)
+		supported_defaults="cpu float tune"
+
+		for which in cpu tune; do
+			eval "val=\$with_$which"
+			case ${val} in
+			default32 | default64)
+				with_which="with_$which"
+				eval $with_which=
+				;;
+			405cr)
+				tm_defines="${tm_defines} CONFIG_PPC405CR"
+				eval "with_$which=405"
+				;;
+			"" | common \
+			| power | power[234567] | power6x | powerpc | powerpc64 \
+			| rios | rios1 | rios2 | rsc | rsc1 | rs64a \
+			| 401 | 403 | 405 | 405fp | 440 | 440fp | 464 | 464fp \
+			| 505 | 601 | 602 | 603 | 603e | ec603e | 604 \
+			| 604e | 620 | 630 | 740 | 750 | 7400 | 7450 \
+			| e300c[23] | 854[08] | e500mc \
+			| 801 | 821 | 823 | 860 | 970 | G3 | G4 | G5 | cell)
+				# OK
+				;;
+			*)
+				echo "Unknown cpu used in --with-$which=$val." 1>&2
+				exit 1
+				;;
+			esac
+		done
+		;;
+
+	s390*-*-*)
+		supported_defaults="arch mode tune"
+
+		for which in arch tune; do
+			eval "val=\$with_$which"
+			case ${val} in
+			"" | g5 | g6 | z900 | z990 | z9-109 | z9-ec | z10)
+				# OK
+				;;
+			*)
+				echo "Unknown cpu used in --with-$which=$val." 1>&2
+				exit 1
+				;;
+			esac
+		done
+
+		case ${with_mode} in
+		"" | esa | zarch)
+			# OK
+			;;
+		*)
+			echo "Unknown architecture mode used in --with-mode=$with_mode." 1>&2
+			exit 1
+			;;
+		esac
+		;;
+
+	sh[123456ble]-*-* | sh-*-*)
+		supported_defaults="cpu"
+		case "`echo $with_cpu | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ_ abcdefghijklmnopqrstuvwxyz- | sed s/sh/m/`" in
+		"" | m1 | m2 | m2e | m3 | m3e | m4 | m4-single | m4-single-only | m4-nofpu )
+			# OK
+			;;
+		m2a | m2a-single | m2a-single-only | m2a-nofpu)
+			;;
+		m4a | m4a-single | m4a-single-only | m4a-nofpu | m4al)
+		        ;;
+		*)
+			echo "Unknown CPU used in --with-cpu=$with_cpu, known values:"  1>&2
+			echo "m1 m2 m2e m3 m3e m4 m4-single m4-single-only m4-nofpu" 1>&2
+			echo "m4a m4a-single m4a-single-only m4a-nofpu m4al" 1>&2
+			echo "m2a m2a-single m2a-single-only m2a-nofpu" 1>&2
+			exit 1
+			;;
+		esac
+		;;
+	sparc*-*-*)
+		supported_defaults="cpu float tune"
+
+		for which in cpu tune; do
+			eval "val=\$with_$which"
+			case ${val} in
+			"" | sparc | sparcv9 | sparc64 | sparc86x \
+			| v7 | cypress | v8 | supersparc | sparclite | f930 \
+			| f934 | hypersparc | sparclite86x | sparclet | tsc701 \
+			| v9 | ultrasparc | ultrasparc3 | niagara | niagara2)
+				# OK
+				;;
+			*)
+				echo "Unknown cpu used in --with-$which=$val" 1>&2
+				exit 1
+				;;
+			esac
+		done
+
+		case ${with_float} in
+		"" | soft | hard)
+			# OK
+			;;
+		*)
+			echo "Unknown floating point type used in --with-float=$with_float" 1>&2
+			exit 1
+			;;
+		esac
+		;;
+
+	spu-*-*)
+		supported_defaults="arch tune"
+
+		for which in arch tune; do
+			eval "val=\$with_$which"
+			case ${val} in
+			"" | cell | celledp)
+				# OK
+				;;
+			*)
+				echo "Unknown cpu used in --with-$which=$val." 1>&2
+				exit 1
+				;;
+			esac
+		done
+		;;
+
+	v850*-*-*)
+		supported_defaults=cpu
+		case ${with_cpu} in
+		"" | v850e | v850e1)
+			# OK
+			;;
+		*)
+			echo "Unknown cpu used in --with-cpu=$with_cpu" 1>&2
+			exit 1
+			;;
+		esac
+		;;
+esac
+
+# Set some miscellaneous flags for particular targets.
+target_cpu_default2=
+case ${target} in
+	alpha*-*-*)
+		if test x$gas = xyes
+		then
+			target_cpu_default2="MASK_GAS"
+		fi
+		;;
+
+	arm*-*-*)
+		if test x$target_cpu_cname = x
+		then
+			target_cpu_default2=TARGET_CPU_generic
+		else
+			target_cpu_default2=TARGET_CPU_$target_cpu_cname
+		fi
+		;;
+
+	hppa*-*-*)
+		target_cpu_default2="MASK_BIG_SWITCH"
+		if test x$gas = xyes
+		then
+			target_cpu_default2="${target_cpu_default2}|MASK_GAS|MASK_JUMP_IN_DELAY"
+		fi
+		;;
+
+	fido*-*-* | m68k*-*-*)
+		target_cpu_default2=$m68k_cpu_ident
+		if [ x"$m68k_arch_family" != x ]; then
+		        tmake_file="m68k/t-$m68k_arch_family $tmake_file"
+		fi
+		;;
+
+	i[34567]86-*-darwin* | x86_64-*-darwin*)
+		tmake_file="${tmake_file} i386/t-fprules-softfp soft-fp/t-softfp"
+		;;
+	i[34567]86-*-linux* | x86_64-*-linux* | i[34567]86-*-kfreebsd*-gnu | x86_64-*-kfreebsd*-gnu)
+		tmake_file="${tmake_file} i386/t-fprules-softfp soft-fp/t-softfp i386/t-linux"
+		;;
+	ia64*-*-linux*)
+		tmake_file="${tmake_file} ia64/t-fprules-softfp soft-fp/t-softfp"
+		;;
+
+	mips*-*-*)
+		if test x$gnu_ld = xyes
+		then
+			target_cpu_default2="MASK_SPLIT_ADDRESSES"
+		fi
+		case ${target} in
+			mips*el-*-*)
+				tm_defines="TARGET_ENDIAN_DEFAULT=0 $tm_defines"
+				;;
+		esac
+		if test "x$enable_gofast" = xyes
+		then
+			tm_defines="US_SOFTWARE_GOFAST $tm_defines"
+			tmake_file="mips/t-gofast $tmake_file"
+		else
+			tmake_file="mips/t-mips $tmake_file"
+		fi
+		;;
+
+	powerpc*-*-* | rs6000-*-*)
+		# FIXME: The PowerPC port uses the value set at compile time,
+		# although it's only cosmetic.
+		if test "x$with_cpu" != x
+		then
+			target_cpu_default2="\\\"$with_cpu\\\""
+		fi
+		out_file=rs6000/rs6000.c
+		c_target_objs="${c_target_objs} rs6000-c.o"
+		cxx_target_objs="${cxx_target_objs} rs6000-c.o"
+		tmake_file="rs6000/t-rs6000 ${tmake_file}"
+
+                if test x$enable_e500_double = xyes
+                then
+                        tm_file="$tm_file rs6000/e500-double.h"
+                fi
+		;;
+
+	sh[123456ble]*-*-* | sh-*-*)
+		c_target_objs="${c_target_objs} sh-c.o"
+		cxx_target_objs="${cxx_target_objs} sh-c.o"
+		;;
+
+	sparc*-*-*)
+		# Some standard aliases.
+		case x$with_cpu in
+		xsparc)
+			with_cpu=v7
+			;;
+		xsparcv9 | xsparc64)
+			with_cpu=v9
+			;;
+		esac
+
+		# The SPARC port checks this value at compile-time.
+		target_cpu_default2="TARGET_CPU_$with_cpu"
+		;;
+	v850*-*-*)
+		# FIXME: The v850 is "special" in that it does not support
+		# runtime CPU selection, only --with-cpu.
+		case "x$with_cpu" in
+		x)
+			;;
+		xv850e)
+			target_cpu_default2="TARGET_CPU_$with_cpu"
+			;;
+		esac
+		;;
+esac
+
+t=
+all_defaults="abi cpu cpu_32 cpu_64 arch arch_32 arch_64 tune tune_32 tune_64 schedule float mode fpu divide llsc mips-plt"
+for option in $all_defaults
+do
+	eval "val=\$with_"`echo $option | sed s/-/_/g`
+	if test -n "$val"; then
+		case " $supported_defaults " in
+		*" $option "*)
+			;;
+		*)
+			echo "This target does not support --with-$option." 2>&1
+			echo "Valid --with options are: $supported_defaults" 2>&1
+			exit 1
+			;;
+		esac
+
+		if test "x$t" = x
+		then
+			t="{ \"$option\", \"$val\" }"
+		else
+			t="${t}, { \"$option\", \"$val\" }"
+		fi
+	fi
+done
+
+if test "x$t" = x
+then
+	configure_default_options="{ { NULL, NULL} }"
+else
+	configure_default_options="{ ${t} }"
+fi
+
+if test "$target_cpu_default2" != ""
+then
+	if test "$target_cpu_default" != ""
+	then
+		target_cpu_default="(${target_cpu_default}|${target_cpu_default2})"
+	else
+		target_cpu_default=$target_cpu_default2
+	fi
+fi
diff -Nur gcc-4.4.6.orig/gcc/configure.ac gcc-4.4.6/gcc/configure.ac
--- gcc-4.4.6.orig/gcc/configure.ac	2010-12-13 19:19:43.000000000 +0100
+++ gcc-4.4.6/gcc/configure.ac	2011-08-27 19:45:43.687987316 +0200
@@ -2240,10 +2240,9 @@
   as_ver=`$gcc_cv_as --version 2>/dev/null | sed 1q`
   if echo "$as_ver" | grep GNU > /dev/null; then
 changequote(,)dnl
-    as_vers=`echo $as_ver | sed -n \
-	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*.*\)$,\1,p'`
-    as_major=`expr "$as_vers" : '\([0-9]*\)'`
-    as_minor=`expr "$as_vers" : '[0-9]*\.\([0-9]*\)'`
+    as_ver=`echo $as_ver | sed -e 's/GNU assembler\( (GNU Binutils)\)\? \([0-9.][0-9.]*\).*/\2/'`
+    as_major=`echo $as_ver | sed 's/\..*//'`
+    as_minor=`echo $as_ver | sed 's/[^.]*\.\([0-9]*\).*/\1/'`
 changequote([,])dnl
     if test $as_major -eq 2 && test $as_minor -lt 11
     then :
@@ -3308,7 +3307,7 @@
   i?86*-*-* | mips*-*-* | alpha*-*-* | powerpc*-*-* | sparc*-*-* | m68*-*-* \
   | x86_64*-*-* | hppa*-*-* | arm*-*-* \
   | xstormy16*-*-* | cris-*-* | crisv32-*-* | xtensa*-*-* | bfin-*-* | score*-*-* \
-  | spu-*-* | fido*-*-* | m32c-*-*)
+  | spu-*-* | fido*-*-* | m32c-*-* | avr32-*-*)
     insn="nop"
     ;;
   ia64*-*-* | s390*-*-*)
diff -Nur gcc-4.4.6.orig/gcc/doc/extend.texi gcc-4.4.6/gcc/doc/extend.texi
--- gcc-4.4.6.orig/gcc/doc/extend.texi	2011-03-23 22:45:18.000000000 +0100
+++ gcc-4.4.6/gcc/doc/extend.texi	2011-08-27 19:45:43.717990492 +0200
@@ -2397,7 +2397,7 @@
 
 @item interrupt
 @cindex interrupt handler functions
-Use this attribute on the ARM, AVR, CRX, M32C, M32R/D, m68k,
+Use this attribute on the ARM, AVR, AVR32, CRX, M32C, M32R/D, m68k,
 and Xstormy16 ports to indicate that the specified function is an
 interrupt handler.  The compiler will generate function entry and exit
 sequences suitable for use in an interrupt handler when this attribute
@@ -2417,6 +2417,15 @@
 
 Permissible values for this parameter are: IRQ, FIQ, SWI, ABORT and UNDEF@.
 
+Note, for the AVR32, you can specify which banking scheme is used for
+the interrupt mode this interrupt handler is used in like this:
+
+@smallexample
+void f () __attribute__ ((interrupt ("FULL")));
+@end smallexample
+
+Permissible values for this parameter are: FULL, HALF, NONE and UNDEF.
+
 On ARMv7-M the interrupt type is ignored, and the attribute means the function
 may be called with a word aligned stack pointer.
 
@@ -4188,6 +4197,23 @@
 
 @end table
 
+@subsection AVR32 Variable Attributes
+
+One attribute is currently defined for AVR32 configurations:
+@code{rmw_addressable}
+
+@table @code
+@item rmw_addressable
+@cindex @code{rmw_addressable} attribute
+
+This attribute can be used to signal that a variable can be accessed 
+with the addressing mode of the AVR32 Atomic Read-Modify-Write memory
+instructions and hence make it possible for gcc to generate these 
+instructions without using built-in functions or inline assembly statements. 
+Variables used within the AVR32 Atomic Read-Modify-Write built-in
+functions will automatically get the @code{rmw_addressable} attribute.
+@end table
+
 @subsection AVR Variable Attributes
 
 @table @code
@@ -7042,6 +7068,7 @@
 * Alpha Built-in Functions::
 * ARM iWMMXt Built-in Functions::
 * ARM NEON Intrinsics::
+* AVR32 Built-in Functions::
 * Blackfin Built-in Functions::
 * FR-V Built-in Functions::
 * X86 Built-in Functions::
@@ -7284,6 +7311,7 @@
 long long __builtin_arm_wzero ()
 @end smallexample
 
+
 @node ARM NEON Intrinsics
 @subsection ARM NEON Intrinsics
 
@@ -7292,6 +7320,74 @@
 
 @include arm-neon-intrinsics.texi
 
+@node AVR32 Built-in Functions
+@subsection AVR32 Built-in Functions
+
+Built-in functions for atomic memory (RMW) instructions. Note that these
+built-ins will fail for targets where the RMW instructions are not
+implemented. Also note that these instructions only that a Ks15 << 2
+memory address and will therefor not work with any runtime computed 
+memory addresses. The user is responsible for making sure that any
+pointers used within these functions points to a valid memory address.
+ 
+@smallexample
+void __builtin_mems(int */*ptr*/, int /*bit*/)
+void __builtin_memc(int */*ptr*/, int /*bit*/)
+void __builtin_memt(int */*ptr*/, int /*bit*/)
+@end smallexample
+
+Built-in functions for DSP instructions. Note that these built-ins will
+fail for targets where the DSP instructions are not implemented.
+
+@smallexample
+int __builtin_sats (int /*Rd*/,int /*sa*/, int /*bn*/)
+int __builtin_satu (int /*Rd*/,int /*sa*/, int /*bn*/)
+int __builtin_satrnds (int /*Rd*/,int /*sa*/, int /*bn*/)
+int __builtin_satrndu (int /*Rd*/,int /*sa*/, int /*bn*/)
+short __builtin_mulsathh_h (short, short)
+int __builtin_mulsathh_w (short, short)
+short __builtin_mulsatrndhh_h (short, short)
+int __builtin_mulsatrndwh_w (int, short)
+int __builtin_mulsatwh_w (int, short)
+int __builtin_macsathh_w (int, short, short)
+short __builtin_satadd_h (short, short)
+short __builtin_satsub_h (short, short)
+int __builtin_satadd_w (int, int)
+int __builtin_satsub_w (int, int)
+long long __builtin_mulwh_d(int, short)
+long long __builtin_mulnwh_d(int, short)
+long long __builtin_macwh_d(long long, int, short)
+long long __builtin_machh_d(long long, short, short)
+@end smallexample
+
+Other built-in functions for instructions that cannot easily be
+generated by the compiler. 
+
+@smallexample
+void __builtin_ssrf(int);
+void __builtin_csrf(int);
+void __builtin_musfr(int);
+int __builtin_mustr(void);
+int __builtin_mfsr(int /*Status Register Address*/)
+void __builtin_mtsr(int /*Status Register Address*/, int /*Value*/)
+int __builtin_mfdr(int /*Debug Register Address*/)
+void __builtin_mtdr(int /*Debug Register Address*/, int /*Value*/)
+void __builtin_cache(void * /*Address*/, int /*Cache Operation*/)
+void __builtin_sync(int /*Sync Operation*/)
+void __builtin_tlbr(void)
+void __builtin_tlbs(void)
+void __builtin_tlbw(void)
+void __builtin_breakpoint(void)
+int __builtin_xchg(void * /*Address*/, int /*Value*/ )
+short __builtin_bswap_16(short)
+int __builtin_bswap_32(int)
+void __builtin_cop(int/*cpnr*/, int/*crd*/, int/*crx*/, int/*cry*/, int/*op*/)
+int __builtin_mvcr_w(int/*cpnr*/, int/*crs*/)
+void __builtin_mvrc_w(int/*cpnr*/, int/*crd*/, int/*value*/)
+long long __builtin_mvcr_d(int/*cpnr*/, int/*crs*/)
+void __builtin_mvrc_d(int/*cpnr*/, int/*crd*/, long long/*value*/)
+@end smallexample
+
 @node Blackfin Built-in Functions
 @subsection Blackfin Built-in Functions
 
diff -Nur gcc-4.4.6.orig/gcc/doc/invoke.texi gcc-4.4.6/gcc/doc/invoke.texi
--- gcc-4.4.6.orig/gcc/doc/invoke.texi	2011-03-23 23:02:12.000000000 +0100
+++ gcc-4.4.6/gcc/doc/invoke.texi	2011-08-27 19:45:43.767989627 +0200
@@ -195,7 +195,7 @@
 -fvisibility-ms-compat @gol
 -Wabi  -Wctor-dtor-privacy @gol
 -Wnon-virtual-dtor  -Wreorder @gol
--Weffc++  -Wstrict-null-sentinel @gol
+-Weffc++  -Wno-deprecated @gol
 -Wno-non-template-friend  -Wold-style-cast @gol
 -Woverloaded-virtual  -Wno-pmf-conversions @gol
 -Wsign-promo}
@@ -641,6 +641,12 @@
 -mauto-incdec  -minmax  -mlong-calls  -mshort @gol
 -msoft-reg-count=@var{count}}
 
+@emph{AVR32 Options}
+@gccoptlist{-muse-rodata-section -mhard-float -msoft-float -mrelax @gol
+-mforce-double-align -mno-init-got -mrelax -mmd-reorg-opt -masm-addr-pseudos @gol
+-mpart=@var{part} -mcpu=@var{cpu} -march=@var{arch} @gol  
+-mfast-float -mimm-in-const-pool}
+
 @emph{MCore Options}
 @gccoptlist{-mhardlit  -mno-hardlit  -mdiv  -mno-div  -mrelax-immediates @gol
 -mno-relax-immediates  -mwide-bitfields  -mno-wide-bitfields @gol
@@ -3256,13 +3262,11 @@
 If you want to warn about code which uses the uninitialized value of the
 variable in its own initializer, use the @option{-Winit-self} option.
 
-These warnings occur for individual uninitialized or clobbered
-elements of structure, union or array variables as well as for
-variables which are uninitialized or clobbered as a whole.  They do
-not occur for variables or elements declared @code{volatile}.  Because
-these warnings depend on optimization, the exact variables or elements
-for which there are warnings will depend on the precise optimization
-options and version of GCC used.
+These warnings occur only for variables that are candidates for
+register allocation.  Therefore, they do not occur for a variable that
+is declared @code{volatile}, or whose address is taken, or whose size
+is other than 1, 2, 4 or 8 bytes.  Also, they do not occur for
+structures, unions or arrays, even when they are in registers.
 
 Note that there may be no warning about a variable that is used only
 to compute a value that itself is never used, because such
@@ -7445,10 +7449,6 @@
 we always try to remove unnecessary ivs from the set during its
 optimization when a new iv is added to the set.
 
-@item scev-max-expr-size
-Bound on size of expressions used in the scalar evolutions analyzer.
-Large expressions slow the analyzer.
-
 @item omega-max-vars
 The maximum number of variables in an Omega constraint system.
 The default value is 128.
@@ -8844,6 +8844,7 @@
 * ARC Options::
 * ARM Options::
 * AVR Options::
+* AVR32 Options::
 * Blackfin Options::
 * CRIS Options::
 * CRX Options::
@@ -9332,6 +9333,145 @@
 size.
 @end table
 
+@node AVR32 Options
+@subsection AVR32 Options
+@cindex AVR32 Options
+
+These options are defined for AVR32 implementations:
+
+@table @gcctabopt
+@item -muse-rodata-section
+@opindex muse-rodata-section
+Use section @samp{.rodata} for read-only data instead of @samp{.text}.
+
+@item -mhard-float
+@opindex mhard-float
+Use floating point coprocessor instructions.
+
+@item -msoft-float
+@opindex msoft-float
+Use software floating-point library for floating-point operations.
+
+@item -mforce-double-align
+@opindex mforce-double-align
+Force double-word alignment for double-word memory accesses.
+
+@item -masm-addr-pseudos
+@opindex masm-addr-pseudos
+Use assembler pseudo-instructions lda.w and call for handling direct
+addresses. (Enabled by default)
+
+@item -mno-init-got
+@opindex mno-init-got
+Do not initialize the GOT register before using it when compiling PIC
+code.
+
+@item -mrelax
+@opindex mrelax
+Let invoked assembler and linker do relaxing 
+(Enabled by default when optimization level is >1).
+This means that when the address of symbols are known at link time,
+the linker can optimize @samp{icall} and @samp{mcall}
+instructions into a @samp{rcall} instruction if possible. 
+Loading the address of a symbol can also be optimized.  
+
+@item -mmd-reorg-opt
+@opindex mmd-reorg-opt
+Perform machine dependent optimizations in reorg stage.
+
+@item -mpart=@var{part}
+@opindex mpart
+Generate code for the specified part. Permissible parts are: 
+@samp{ap7000},
+@samp{ap7001},
+@samp{ap7002},
+@samp{ap7200},
+@samp{uc3a0128},
+@samp{uc3a0256},
+@samp{uc3a0512},
+@samp{uc3a0512es},
+@samp{uc3a1128},
+@samp{uc3a1256},
+@samp{uc3a1512},
+@samp{uc3a1512es},
+@samp{uc3a3revd},
+@samp{uc3a364},
+@samp{uc3a364s},
+@samp{uc3a3128},
+@samp{uc3a3128s},
+@samp{uc3a3256},
+@samp{uc3a3256s},
+@samp{uc3a464},
+@samp{uc3a464s},
+@samp{uc3a4128},
+@samp{uc3a4128s},
+@samp{uc3a4256},
+@samp{uc3a4256s},
+@samp{uc3b064},
+@samp{uc3b0128},
+@samp{uc3b0256},
+@samp{uc3b0256es},
+@samp{uc3b0512},
+@samp{uc3b0512revc},
+@samp{uc3b164},
+@samp{uc3b1128},
+@samp{uc3b1256},
+@samp{uc3b1256es},
+@samp{uc3b1512},
+@samp{uc3b1512revc}
+@samp{uc64d3},
+@samp{uc128d3},
+@samp{uc64d4},
+@samp{uc128d4},
+@samp{uc3c0512crevc},
+@samp{uc3c1512crevc},
+@samp{uc3c2512crevc},
+@samp{uc3l0256},
+@samp{uc3l0128},
+@samp{uc3l064},
+@samp{uc3l032},
+@samp{uc3l016},
+@samp{uc3l064revb},
+@samp{uc64l3u},
+@samp{uc128l3u},
+@samp{uc256l3u},
+@samp{uc64l4u},
+@samp{uc128l4u},
+@samp{uc256l4u},
+@samp{uc3c064c},
+@samp{uc3c0128c},
+@samp{uc3c0256c},
+@samp{uc3c0512c},
+@samp{uc3c164c},
+@samp{uc3c1128c},
+@samp{uc3c1256c},
+@samp{uc3c1512c},
+@samp{uc3c264c},
+@samp{uc3c2128c},
+@samp{uc3c2256c},
+@samp{uc3c2512c},
+@samp{mxt768e}.
+
+@item -mcpu=@var{cpu-type}
+@opindex mcpu
+Same as -mpart. Obsolete.
+
+@item -march=@var{arch}
+@opindex march
+Generate code for the specified architecture. Permissible architectures are:
+@samp{ap}, @samp{uc} and @samp{ucr2}. 
+
+@item -mfast-float
+@opindex mfast-float
+Enable fast floating-point library that does not conform to IEEE-754 but is still good enough
+for most applications. The fast floating-point library does not round to the nearest even
+but away from zero. Enabled by default if the -funsafe-math-optimizations switch is specified. 
+
+@item -mimm-in-const-pool
+@opindex mimm-in-const-pool
+Put large immediates in constant pool. This is enabled by default for archs with insn-cache.
+@end table
+
 @node Blackfin Options
 @subsection Blackfin Options
 @cindex Blackfin Options
@@ -9387,29 +9527,12 @@
 contain speculative loads after jump instructions. If this option is used,
 @code{__WORKAROUND_SPECULATIVE_LOADS} is defined.
 
-@item -mno-specld-anomaly
-@opindex mno-specld-anomaly
-Don't generate extra code to prevent speculative loads from occurring.
-
 @item -mcsync-anomaly
 @opindex mcsync-anomaly
 When enabled, the compiler will ensure that the generated code does not
 contain CSYNC or SSYNC instructions too soon after conditional branches.
 If this option is used, @code{__WORKAROUND_SPECULATIVE_SYNCS} is defined.
 
-@item -mno-csync-anomaly
-@opindex mno-csync-anomaly
-Don't generate extra code to prevent CSYNC or SSYNC instructions from
-occurring too soon after a conditional branch.
-
-@item -mlow-64k
-@opindex mlow-64k
-When enabled, the compiler is free to take advantage of the knowledge that
-the entire program fits into the low 64k of memory.
-
-@item -mno-low-64k
-@opindex mno-low-64k
-Assume that the program is arbitrarily large.  This is the default.
 
 @item -mstack-check-l1
 @opindex mstack-check-l1
@@ -9423,11 +9546,6 @@
 without virtual memory management.  This option implies @option{-fPIC}.
 With a @samp{bfin-elf} target, this option implies @option{-msim}.
 
-@item -mno-id-shared-library
-@opindex mno-id-shared-library
-Generate code that doesn't assume ID based shared libraries are being used.
-This is the default.
-
 @item -mleaf-id-shared-library
 @opindex mleaf-id-shared-library
 Generate code that supports shared libraries via the library ID method,
@@ -9469,11 +9587,6 @@
 will lie outside of the 24 bit addressing range of the offset based
 version of subroutine call instruction.
 
-This feature is not enabled by default.  Specifying
-@option{-mno-long-calls} will restore the default behavior.  Note these
-switches have no effect on how the compiler generates code to handle
-function calls via function pointers.
-
 @item -mfast-fp
 @opindex mfast-fp
 Link with the fast floating-point library. This library relaxes some of
diff -Nur gcc-4.4.6.orig/gcc/doc/invoke.texi.orig gcc-4.4.6/gcc/doc/invoke.texi.orig
--- gcc-4.4.6.orig/gcc/doc/invoke.texi.orig	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.4.6/gcc/doc/invoke.texi.orig	2011-03-23 23:02:12.000000000 +0100
@@ -0,0 +1,16654 @@
+@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+@c 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+@c Free Software Foundation, Inc.
+@c This is part of the GCC manual.
+@c For copying conditions, see the file gcc.texi.
+
+@ignore
+@c man begin INCLUDE
+@include gcc-vers.texi
+@c man end
+
+@c man begin COPYRIGHT
+Copyright @copyright{} 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+Free Software Foundation, Inc.
+
+Permission is granted to copy, distribute and/or modify this document
+under the terms of the GNU Free Documentation License, Version 1.2 or
+any later version published by the Free Software Foundation; with the
+Invariant Sections being ``GNU General Public License'' and ``Funding
+Free Software'', the Front-Cover texts being (a) (see below), and with
+the Back-Cover Texts being (b) (see below).  A copy of the license is
+included in the gfdl(7) man page.
+
+(a) The FSF's Front-Cover Text is:
+
+     A GNU Manual
+
+(b) The FSF's Back-Cover Text is:
+
+     You have freedom to copy and modify this GNU Manual, like GNU
+     software.  Copies published by the Free Software Foundation raise
+     funds for GNU development.
+@c man end
+@c Set file name and title for the man page.
+@setfilename gcc
+@settitle GNU project C and C++ compiler
+@c man begin SYNOPSIS
+gcc [@option{-c}|@option{-S}|@option{-E}] [@option{-std=}@var{standard}]
+    [@option{-g}] [@option{-pg}] [@option{-O}@var{level}]
+    [@option{-W}@var{warn}@dots{}] [@option{-pedantic}]
+    [@option{-I}@var{dir}@dots{}] [@option{-L}@var{dir}@dots{}]
+    [@option{-D}@var{macro}[=@var{defn}]@dots{}] [@option{-U}@var{macro}]
+    [@option{-f}@var{option}@dots{}] [@option{-m}@var{machine-option}@dots{}]
+    [@option{-o} @var{outfile}] [@@@var{file}] @var{infile}@dots{}
+
+Only the most useful options are listed here; see below for the
+remainder.  @samp{g++} accepts mostly the same options as @samp{gcc}.
+@c man end
+@c man begin SEEALSO
+gpl(7), gfdl(7), fsf-funding(7),
+cpp(1), gcov(1), as(1), ld(1), gdb(1), adb(1), dbx(1), sdb(1)
+and the Info entries for @file{gcc}, @file{cpp}, @file{as},
+@file{ld}, @file{binutils} and @file{gdb}.
+@c man end
+@c man begin BUGS
+For instructions on reporting bugs, see
+@w{@value{BUGURL}}.
+@c man end
+@c man begin AUTHOR
+See the Info entry for @command{gcc}, or
+@w{@uref{http://gcc.gnu.org/onlinedocs/gcc/Contributors.html}},
+for contributors to GCC@.
+@c man end
+@end ignore
+
+@node Invoking GCC
+@chapter GCC Command Options
+@cindex GCC command options
+@cindex command options
+@cindex options, GCC command
+
+@c man begin DESCRIPTION
+When you invoke GCC, it normally does preprocessing, compilation,
+assembly and linking.  The ``overall options'' allow you to stop this
+process at an intermediate stage.  For example, the @option{-c} option
+says not to run the linker.  Then the output consists of object files
+output by the assembler.
+
+Other options are passed on to one stage of processing.  Some options
+control the preprocessor and others the compiler itself.  Yet other
+options control the assembler and linker; most of these are not
+documented here, since you rarely need to use any of them.
+
+@cindex C compilation options
+Most of the command line options that you can use with GCC are useful
+for C programs; when an option is only useful with another language
+(usually C++), the explanation says so explicitly.  If the description
+for a particular option does not mention a source language, you can use
+that option with all supported languages.
+
+@cindex C++ compilation options
+@xref{Invoking G++,,Compiling C++ Programs}, for a summary of special
+options for compiling C++ programs.
+
+@cindex grouping options
+@cindex options, grouping
+The @command{gcc} program accepts options and file names as operands.  Many
+options have multi-letter names; therefore multiple single-letter options
+may @emph{not} be grouped: @option{-dv} is very different from @w{@samp{-d
+-v}}.
+
+@cindex order of options
+@cindex options, order
+You can mix options and other arguments.  For the most part, the order
+you use doesn't matter.  Order does matter when you use several
+options of the same kind; for example, if you specify @option{-L} more
+than once, the directories are searched in the order specified.  Also,
+the placement of the @option{-l} option is significant.
+
+Many options have long names starting with @samp{-f} or with
+@samp{-W}---for example,
+@option{-fmove-loop-invariants}, @option{-Wformat} and so on.  Most of
+these have both positive and negative forms; the negative form of
+@option{-ffoo} would be @option{-fno-foo}.  This manual documents
+only one of these two forms, whichever one is not the default.
+
+@c man end
+
+@xref{Option Index}, for an index to GCC's options.
+
+@menu
+* Option Summary::      Brief list of all options, without explanations.
+* Overall Options::     Controlling the kind of output:
+                        an executable, object files, assembler files,
+                        or preprocessed source.
+* Invoking G++::        Compiling C++ programs.
+* C Dialect Options::   Controlling the variant of C language compiled.
+* C++ Dialect Options:: Variations on C++.
+* Objective-C and Objective-C++ Dialect Options:: Variations on Objective-C
+                        and Objective-C++.
+* Language Independent Options:: Controlling how diagnostics should be
+                        formatted.
+* Warning Options::     How picky should the compiler be?
+* Debugging Options::   Symbol tables, measurements, and debugging dumps.
+* Optimize Options::    How much optimization?
+* Preprocessor Options:: Controlling header files and macro definitions.
+                         Also, getting dependency information for Make.
+* Assembler Options::   Passing options to the assembler.
+* Link Options::        Specifying libraries and so on.
+* Directory Options::   Where to find header files and libraries.
+                        Where to find the compiler executable files.
+* Spec Files::          How to pass switches to sub-processes.
+* Target Options::      Running a cross-compiler, or an old version of GCC.
+* Submodel Options::    Specifying minor hardware or convention variations,
+                        such as 68010 vs 68020.
+* Code Gen Options::    Specifying conventions for function calls, data layout
+                        and register usage.
+* Environment Variables:: Env vars that affect GCC.
+* Precompiled Headers:: Compiling a header once, and using it many times.
+* Running Protoize::    Automatically adding or removing function prototypes.
+@end menu
+
+@c man begin OPTIONS
+
+@node Option Summary
+@section Option Summary
+
+Here is a summary of all the options, grouped by type.  Explanations are
+in the following sections.
+
+@table @emph
+@item Overall Options
+@xref{Overall Options,,Options Controlling the Kind of Output}.
+@gccoptlist{-c  -S  -E  -o @var{file}  -combine  -pipe  -pass-exit-codes  @gol
+-x @var{language}  -v  -###  --help@r{[}=@var{class}@r{[},@dots{}@r{]]}  --target-help  @gol
+--version -wrapper@@@var{file}}
+
+@item C Language Options
+@xref{C Dialect Options,,Options Controlling C Dialect}.
+@gccoptlist{-ansi  -std=@var{standard}  -fgnu89-inline @gol
+-aux-info @var{filename} @gol
+-fno-asm  -fno-builtin  -fno-builtin-@var{function} @gol
+-fhosted  -ffreestanding -fopenmp -fms-extensions @gol
+-trigraphs  -no-integrated-cpp  -traditional  -traditional-cpp @gol
+-fallow-single-precision  -fcond-mismatch -flax-vector-conversions @gol
+-fsigned-bitfields  -fsigned-char @gol
+-funsigned-bitfields  -funsigned-char}
+
+@item C++ Language Options
+@xref{C++ Dialect Options,,Options Controlling C++ Dialect}.
+@gccoptlist{-fabi-version=@var{n}  -fno-access-control  -fcheck-new @gol
+-fconserve-space  -ffriend-injection @gol
+-fno-elide-constructors @gol
+-fno-enforce-eh-specs @gol
+-ffor-scope  -fno-for-scope  -fno-gnu-keywords @gol
+-fno-implicit-templates @gol
+-fno-implicit-inline-templates @gol
+-fno-implement-inlines  -fms-extensions @gol
+-fno-nonansi-builtins  -fno-operator-names @gol
+-fno-optional-diags  -fpermissive @gol
+-frepo  -fno-rtti  -fstats  -ftemplate-depth-@var{n} @gol
+-fno-threadsafe-statics -fuse-cxa-atexit  -fno-weak  -nostdinc++ @gol
+-fno-default-inline  -fvisibility-inlines-hidden @gol
+-fvisibility-ms-compat @gol
+-Wabi  -Wctor-dtor-privacy @gol
+-Wnon-virtual-dtor  -Wreorder @gol
+-Weffc++  -Wstrict-null-sentinel @gol
+-Wno-non-template-friend  -Wold-style-cast @gol
+-Woverloaded-virtual  -Wno-pmf-conversions @gol
+-Wsign-promo}
+
+@item Objective-C and Objective-C++ Language Options
+@xref{Objective-C and Objective-C++ Dialect Options,,Options Controlling
+Objective-C and Objective-C++ Dialects}.
+@gccoptlist{-fconstant-string-class=@var{class-name} @gol
+-fgnu-runtime  -fnext-runtime @gol
+-fno-nil-receivers @gol
+-fobjc-call-cxx-cdtors @gol
+-fobjc-direct-dispatch @gol
+-fobjc-exceptions @gol
+-fobjc-gc @gol
+-freplace-objc-classes @gol
+-fzero-link @gol
+-gen-decls @gol
+-Wassign-intercept @gol
+-Wno-protocol  -Wselector @gol
+-Wstrict-selector-match @gol
+-Wundeclared-selector}
+
+@item Language Independent Options
+@xref{Language Independent Options,,Options to Control Diagnostic Messages Formatting}.
+@gccoptlist{-fmessage-length=@var{n}  @gol
+-fdiagnostics-show-location=@r{[}once@r{|}every-line@r{]}  @gol
+-fdiagnostics-show-option}
+
+@item Warning Options
+@xref{Warning Options,,Options to Request or Suppress Warnings}.
+@gccoptlist{-fsyntax-only  -pedantic  -pedantic-errors @gol
+-w  -Wextra  -Wall  -Waddress  -Waggregate-return  -Warray-bounds @gol
+-Wno-attributes -Wno-builtin-macro-redefined @gol
+-Wc++-compat -Wc++0x-compat -Wcast-align  -Wcast-qual  @gol
+-Wchar-subscripts -Wclobbered  -Wcomment @gol
+-Wconversion  -Wcoverage-mismatch  -Wno-deprecated  @gol
+-Wno-deprecated-declarations -Wdisabled-optimization  @gol
+-Wno-div-by-zero -Wempty-body  -Wenum-compare -Wno-endif-labels @gol
+-Werror  -Werror=* @gol
+-Wfatal-errors  -Wfloat-equal  -Wformat  -Wformat=2 @gol
+-Wno-format-contains-nul -Wno-format-extra-args -Wformat-nonliteral @gol
+-Wformat-security  -Wformat-y2k @gol
+-Wframe-larger-than=@var{len} -Wignored-qualifiers @gol
+-Wimplicit  -Wimplicit-function-declaration  -Wimplicit-int @gol
+-Winit-self  -Winline @gol
+-Wno-int-to-pointer-cast -Wno-invalid-offsetof @gol
+-Winvalid-pch -Wlarger-than=@var{len}  -Wunsafe-loop-optimizations @gol
+-Wlogical-op -Wlong-long @gol
+-Wmain  -Wmissing-braces  -Wmissing-field-initializers @gol
+-Wmissing-format-attribute  -Wmissing-include-dirs @gol
+-Wmissing-noreturn  -Wno-mudflap @gol
+-Wno-multichar  -Wnonnull  -Wno-overflow @gol
+-Woverlength-strings  -Wpacked  -Wpacked-bitfield-compat  -Wpadded @gol
+-Wparentheses  -Wpedantic-ms-format -Wno-pedantic-ms-format @gol
+-Wpointer-arith  -Wno-pointer-to-int-cast @gol
+-Wredundant-decls @gol
+-Wreturn-type  -Wsequence-point  -Wshadow @gol
+-Wsign-compare  -Wsign-conversion  -Wstack-protector @gol
+-Wstrict-aliasing -Wstrict-aliasing=n @gol
+-Wstrict-overflow -Wstrict-overflow=@var{n} @gol
+-Wswitch  -Wswitch-default  -Wswitch-enum -Wsync-nand @gol
+-Wsystem-headers  -Wtrigraphs  -Wtype-limits  -Wundef  -Wuninitialized @gol
+-Wunknown-pragmas  -Wno-pragmas -Wunreachable-code @gol
+-Wunused  -Wunused-function  -Wunused-label  -Wunused-parameter @gol
+-Wunused-value  -Wunused-variable @gol
+-Wvariadic-macros -Wvla @gol
+-Wvolatile-register-var  -Wwrite-strings}
+
+@item C and Objective-C-only Warning Options
+@gccoptlist{-Wbad-function-cast  -Wmissing-declarations @gol
+-Wmissing-parameter-type  -Wmissing-prototypes  -Wnested-externs @gol
+-Wold-style-declaration  -Wold-style-definition @gol
+-Wstrict-prototypes  -Wtraditional  -Wtraditional-conversion @gol
+-Wdeclaration-after-statement -Wpointer-sign}
+
+@item Debugging Options
+@xref{Debugging Options,,Options for Debugging Your Program or GCC}.
+@gccoptlist{-d@var{letters}  -dumpspecs  -dumpmachine  -dumpversion @gol
+-fdbg-cnt-list -fdbg-cnt=@var{counter-value-list} @gol
+-fdump-noaddr -fdump-unnumbered @gol
+-fdump-translation-unit@r{[}-@var{n}@r{]} @gol
+-fdump-class-hierarchy@r{[}-@var{n}@r{]} @gol
+-fdump-ipa-all -fdump-ipa-cgraph -fdump-ipa-inline @gol
+-fdump-statistics @gol
+-fdump-tree-all @gol
+-fdump-tree-original@r{[}-@var{n}@r{]}  @gol
+-fdump-tree-optimized@r{[}-@var{n}@r{]} @gol
+-fdump-tree-cfg -fdump-tree-vcg -fdump-tree-alias @gol
+-fdump-tree-ch @gol
+-fdump-tree-ssa@r{[}-@var{n}@r{]} -fdump-tree-pre@r{[}-@var{n}@r{]} @gol
+-fdump-tree-ccp@r{[}-@var{n}@r{]} -fdump-tree-dce@r{[}-@var{n}@r{]} @gol
+-fdump-tree-gimple@r{[}-raw@r{]} -fdump-tree-mudflap@r{[}-@var{n}@r{]} @gol
+-fdump-tree-dom@r{[}-@var{n}@r{]} @gol
+-fdump-tree-dse@r{[}-@var{n}@r{]} @gol
+-fdump-tree-phiopt@r{[}-@var{n}@r{]} @gol
+-fdump-tree-forwprop@r{[}-@var{n}@r{]} @gol
+-fdump-tree-copyrename@r{[}-@var{n}@r{]} @gol
+-fdump-tree-nrv -fdump-tree-vect @gol
+-fdump-tree-sink @gol
+-fdump-tree-sra@r{[}-@var{n}@r{]} @gol
+-fdump-tree-fre@r{[}-@var{n}@r{]} @gol
+-fdump-tree-vrp@r{[}-@var{n}@r{]} @gol
+-ftree-vectorizer-verbose=@var{n} @gol
+-fdump-tree-storeccp@r{[}-@var{n}@r{]} @gol
+-feliminate-dwarf2-dups -feliminate-unused-debug-types @gol
+-feliminate-unused-debug-symbols -femit-class-debug-always @gol
+-fmem-report -fpre-ipa-mem-report -fpost-ipa-mem-report -fprofile-arcs @gol
+-frandom-seed=@var{string} -fsched-verbose=@var{n} @gol
+-fsel-sched-verbose -fsel-sched-dump-cfg -fsel-sched-pipelining-verbose @gol
+-ftest-coverage  -ftime-report -fvar-tracking @gol
+-g  -g@var{level}  -gcoff -gdwarf-2 @gol
+-ggdb  -gstabs  -gstabs+  -gvms  -gxcoff  -gxcoff+ @gol
+-fno-merge-debug-strings -fno-dwarf2-cfi-asm @gol
+-fdebug-prefix-map=@var{old}=@var{new} @gol
+-femit-struct-debug-baseonly -femit-struct-debug-reduced @gol
+-femit-struct-debug-detailed@r{[}=@var{spec-list}@r{]} @gol
+-p  -pg  -print-file-name=@var{library}  -print-libgcc-file-name @gol
+-print-multi-directory  -print-multi-lib @gol
+-print-prog-name=@var{program}  -print-search-dirs  -Q @gol
+-print-sysroot -print-sysroot-headers-suffix @gol
+-save-temps  -time}
+
+@item Optimization Options
+@xref{Optimize Options,,Options that Control Optimization}.
+@gccoptlist{
+-falign-functions[=@var{n}] -falign-jumps[=@var{n}] @gol
+-falign-labels[=@var{n}] -falign-loops[=@var{n}] -fassociative-math @gol
+-fauto-inc-dec -fbranch-probabilities -fbranch-target-load-optimize @gol
+-fbranch-target-load-optimize2 -fbtr-bb-exclusive -fcaller-saves @gol
+-fcheck-data-deps -fconserve-stack -fcprop-registers -fcrossjumping @gol
+-fcse-follow-jumps -fcse-skip-blocks -fcx-fortran-rules -fcx-limited-range @gol
+-fdata-sections -fdce -fdce @gol
+-fdelayed-branch -fdelete-null-pointer-checks -fdse -fdse @gol
+-fearly-inlining -fexpensive-optimizations -ffast-math @gol
+-ffinite-math-only -ffloat-store -fforward-propagate @gol
+-ffunction-sections -fgcse -fgcse-after-reload -fgcse-las -fgcse-lm @gol
+-fgcse-sm -fif-conversion -fif-conversion2 -findirect-inlining @gol
+-finline-functions -finline-functions-called-once -finline-limit=@var{n} @gol
+-finline-small-functions -fipa-cp -fipa-cp-clone -fipa-matrix-reorg -fipa-pta @gol 
+-fipa-pure-const -fipa-reference -fipa-struct-reorg @gol
+-fipa-type-escape -fira-algorithm=@var{algorithm} @gol
+-fira-region=@var{region} -fira-coalesce -fno-ira-share-save-slots @gol
+-fno-ira-share-spill-slots -fira-verbose=@var{n} @gol
+-fivopts -fkeep-inline-functions -fkeep-static-consts @gol
+-floop-block -floop-interchange -floop-strip-mine @gol
+-fmerge-all-constants -fmerge-constants -fmodulo-sched @gol
+-fmodulo-sched-allow-regmoves -fmove-loop-invariants -fmudflap @gol
+-fmudflapir -fmudflapth -fno-branch-count-reg -fno-default-inline @gol
+-fno-defer-pop -fno-function-cse -fno-guess-branch-probability @gol
+-fno-inline -fno-math-errno -fno-peephole -fno-peephole2 @gol
+-fno-sched-interblock -fno-sched-spec -fno-signed-zeros @gol
+-fno-toplevel-reorder -fno-trapping-math -fno-zero-initialized-in-bss @gol
+-fomit-frame-pointer -foptimize-register-move -foptimize-sibling-calls @gol
+-fpeel-loops -fpredictive-commoning -fprefetch-loop-arrays @gol
+-fprofile-correction -fprofile-dir=@var{path} -fprofile-generate @gol
+-fprofile-generate=@var{path} @gol
+-fprofile-use -fprofile-use=@var{path} -fprofile-values @gol
+-freciprocal-math -fregmove -frename-registers -freorder-blocks @gol
+-freorder-blocks-and-partition -freorder-functions @gol
+-frerun-cse-after-loop -freschedule-modulo-scheduled-loops @gol
+-frounding-math -frtl-abstract-sequences -fsched2-use-superblocks @gol
+-fsched2-use-traces -fsched-spec-load -fsched-spec-load-dangerous @gol
+-fsched-stalled-insns-dep[=@var{n}] -fsched-stalled-insns[=@var{n}] @gol
+-fschedule-insns -fschedule-insns2 -fsection-anchors -fsee @gol
+-fselective-scheduling -fselective-scheduling2 @gol
+-fsel-sched-pipelining -fsel-sched-pipelining-outer-loops @gol
+-fsignaling-nans -fsingle-precision-constant -fsplit-ivs-in-unroller @gol
+-fsplit-wide-types -fstack-protector -fstack-protector-all @gol
+-fstrict-aliasing -fstrict-overflow -fthread-jumps -ftracer @gol
+-ftree-builtin-call-dce -ftree-ccp -ftree-ch -ftree-copy-prop @gol
+-ftree-copyrename -ftree-dce @gol
+-ftree-dominator-opts -ftree-dse -ftree-fre -ftree-loop-im @gol
+-ftree-loop-distribution @gol
+-ftree-loop-ivcanon -ftree-loop-linear -ftree-loop-optimize @gol
+-ftree-parallelize-loops=@var{n} -ftree-pre -ftree-reassoc @gol
+-ftree-sink -ftree-sra -ftree-switch-conversion @gol
+-ftree-ter -ftree-vect-loop-version -ftree-vectorize -ftree-vrp @gol
+-funit-at-a-time -funroll-all-loops -funroll-loops @gol
+-funsafe-loop-optimizations -funsafe-math-optimizations -funswitch-loops @gol
+-fvariable-expansion-in-unroller -fvect-cost-model -fvpt -fweb @gol
+-fwhole-program @gol
+--param @var{name}=@var{value}
+-O  -O0  -O1  -O2  -O3  -Os}
+
+@item Preprocessor Options
+@xref{Preprocessor Options,,Options Controlling the Preprocessor}.
+@gccoptlist{-A@var{question}=@var{answer} @gol
+-A-@var{question}@r{[}=@var{answer}@r{]} @gol
+-C  -dD  -dI  -dM  -dN @gol
+-D@var{macro}@r{[}=@var{defn}@r{]}  -E  -H @gol
+-idirafter @var{dir} @gol
+-include @var{file}  -imacros @var{file} @gol
+-iprefix @var{file}  -iwithprefix @var{dir} @gol
+-iwithprefixbefore @var{dir}  -isystem @var{dir} @gol
+-imultilib @var{dir} -isysroot @var{dir} @gol
+-M  -MM  -MF  -MG  -MP  -MQ  -MT  -nostdinc  @gol
+-P  -fworking-directory  -remap @gol
+-trigraphs  -undef  -U@var{macro}  -Wp,@var{option} @gol
+-Xpreprocessor @var{option}}
+
+@item Assembler Option
+@xref{Assembler Options,,Passing Options to the Assembler}.
+@gccoptlist{-Wa,@var{option}  -Xassembler @var{option}}
+
+@item Linker Options
+@xref{Link Options,,Options for Linking}.
+@gccoptlist{@var{object-file-name}  -l@var{library} @gol
+-nostartfiles  -nodefaultlibs  -nostdlib -pie -rdynamic @gol
+-s  -static  -static-libgcc  -shared  -shared-libgcc  -symbolic @gol
+-T @var{script}  -Wl,@var{option}  -Xlinker @var{option} @gol
+-u @var{symbol}}
+
+@item Directory Options
+@xref{Directory Options,,Options for Directory Search}.
+@gccoptlist{-B@var{prefix}  -I@var{dir}  -iquote@var{dir}  -L@var{dir}
+-specs=@var{file}  -I- --sysroot=@var{dir}}
+
+@item Target Options
+@c I wrote this xref this way to avoid overfull hbox. -- rms
+@xref{Target Options}.
+@gccoptlist{-V @var{version}  -b @var{machine}}
+
+@item Machine Dependent Options
+@xref{Submodel Options,,Hardware Models and Configurations}.
+@c This list is ordered alphanumerically by subsection name.
+@c Try and put the significant identifier (CPU or system) first,
+@c so users have a clue at guessing where the ones they want will be.
+
+@emph{ARC Options}
+@gccoptlist{-EB  -EL @gol
+-mmangle-cpu  -mcpu=@var{cpu}  -mtext=@var{text-section} @gol
+-mdata=@var{data-section}  -mrodata=@var{readonly-data-section}}
+
+@emph{ARM Options}
+@gccoptlist{-mapcs-frame  -mno-apcs-frame @gol
+-mabi=@var{name} @gol
+-mapcs-stack-check  -mno-apcs-stack-check @gol
+-mapcs-float  -mno-apcs-float @gol
+-mapcs-reentrant  -mno-apcs-reentrant @gol
+-msched-prolog  -mno-sched-prolog @gol
+-mlittle-endian  -mbig-endian  -mwords-little-endian @gol
+-mfloat-abi=@var{name}  -msoft-float  -mhard-float  -mfpe @gol
+-mthumb-interwork  -mno-thumb-interwork @gol
+-mcpu=@var{name}  -march=@var{name}  -mfpu=@var{name}  @gol
+-mstructure-size-boundary=@var{n} @gol
+-mabort-on-noreturn @gol
+-mlong-calls  -mno-long-calls @gol
+-msingle-pic-base  -mno-single-pic-base @gol
+-mpic-register=@var{reg} @gol
+-mnop-fun-dllimport @gol
+-mcirrus-fix-invalid-insns -mno-cirrus-fix-invalid-insns @gol
+-mpoke-function-name @gol
+-mthumb  -marm @gol
+-mtpcs-frame  -mtpcs-leaf-frame @gol
+-mcaller-super-interworking  -mcallee-super-interworking @gol
+-mtp=@var{name} @gol
+-mword-relocations @gol
+-mfix-cortex-m3-ldrd}
+
+@emph{AVR Options}
+@gccoptlist{-mmcu=@var{mcu}  -msize  -mno-interrupts @gol
+-mcall-prologues  -mno-tablejump  -mtiny-stack  -mint8}
+
+@emph{Blackfin Options}
+@gccoptlist{-mcpu=@var{cpu}@r{[}-@var{sirevision}@r{]} @gol
+-msim -momit-leaf-frame-pointer  -mno-omit-leaf-frame-pointer @gol
+-mspecld-anomaly  -mno-specld-anomaly  -mcsync-anomaly  -mno-csync-anomaly @gol
+-mlow-64k -mno-low64k  -mstack-check-l1  -mid-shared-library @gol
+-mno-id-shared-library  -mshared-library-id=@var{n} @gol
+-mleaf-id-shared-library  -mno-leaf-id-shared-library @gol
+-msep-data  -mno-sep-data  -mlong-calls  -mno-long-calls @gol
+-mfast-fp -minline-plt -mmulticore  -mcorea  -mcoreb  -msdram @gol
+-micplb}
+
+@emph{CRIS Options}
+@gccoptlist{-mcpu=@var{cpu}  -march=@var{cpu}  -mtune=@var{cpu} @gol
+-mmax-stack-frame=@var{n}  -melinux-stacksize=@var{n} @gol
+-metrax4  -metrax100  -mpdebug  -mcc-init  -mno-side-effects @gol
+-mstack-align  -mdata-align  -mconst-align @gol
+-m32-bit  -m16-bit  -m8-bit  -mno-prologue-epilogue  -mno-gotplt @gol
+-melf  -maout  -melinux  -mlinux  -sim  -sim2 @gol
+-mmul-bug-workaround  -mno-mul-bug-workaround}
+
+@emph{CRX Options}
+@gccoptlist{-mmac -mpush-args}
+
+@emph{Darwin Options}
+@gccoptlist{-all_load  -allowable_client  -arch  -arch_errors_fatal @gol
+-arch_only  -bind_at_load  -bundle  -bundle_loader @gol
+-client_name  -compatibility_version  -current_version @gol
+-dead_strip @gol
+-dependency-file  -dylib_file  -dylinker_install_name @gol
+-dynamic  -dynamiclib  -exported_symbols_list @gol
+-filelist  -flat_namespace  -force_cpusubtype_ALL @gol
+-force_flat_namespace  -headerpad_max_install_names @gol
+-iframework @gol
+-image_base  -init  -install_name  -keep_private_externs @gol
+-multi_module  -multiply_defined  -multiply_defined_unused @gol
+-noall_load   -no_dead_strip_inits_and_terms @gol
+-nofixprebinding -nomultidefs  -noprebind  -noseglinkedit @gol
+-pagezero_size  -prebind  -prebind_all_twolevel_modules @gol
+-private_bundle  -read_only_relocs  -sectalign @gol
+-sectobjectsymbols  -whyload  -seg1addr @gol
+-sectcreate  -sectobjectsymbols  -sectorder @gol
+-segaddr -segs_read_only_addr -segs_read_write_addr @gol
+-seg_addr_table  -seg_addr_table_filename  -seglinkedit @gol
+-segprot  -segs_read_only_addr  -segs_read_write_addr @gol
+-single_module  -static  -sub_library  -sub_umbrella @gol
+-twolevel_namespace  -umbrella  -undefined @gol
+-unexported_symbols_list  -weak_reference_mismatches @gol
+-whatsloaded -F -gused -gfull -mmacosx-version-min=@var{version} @gol
+-mkernel -mone-byte-bool}
+
+@emph{DEC Alpha Options}
+@gccoptlist{-mno-fp-regs  -msoft-float  -malpha-as  -mgas @gol
+-mieee  -mieee-with-inexact  -mieee-conformant @gol
+-mfp-trap-mode=@var{mode}  -mfp-rounding-mode=@var{mode} @gol
+-mtrap-precision=@var{mode}  -mbuild-constants @gol
+-mcpu=@var{cpu-type}  -mtune=@var{cpu-type} @gol
+-mbwx  -mmax  -mfix  -mcix @gol
+-mfloat-vax  -mfloat-ieee @gol
+-mexplicit-relocs  -msmall-data  -mlarge-data @gol
+-msmall-text  -mlarge-text @gol
+-mmemory-latency=@var{time}}
+
+@emph{DEC Alpha/VMS Options}
+@gccoptlist{-mvms-return-codes}
+
+@emph{FR30 Options}
+@gccoptlist{-msmall-model -mno-lsim}
+
+@emph{FRV Options}
+@gccoptlist{-mgpr-32  -mgpr-64  -mfpr-32  -mfpr-64 @gol
+-mhard-float  -msoft-float @gol
+-malloc-cc  -mfixed-cc  -mdword  -mno-dword @gol
+-mdouble  -mno-double @gol
+-mmedia  -mno-media  -mmuladd  -mno-muladd @gol
+-mfdpic  -minline-plt -mgprel-ro  -multilib-library-pic @gol
+-mlinked-fp  -mlong-calls  -malign-labels @gol
+-mlibrary-pic  -macc-4  -macc-8 @gol
+-mpack  -mno-pack  -mno-eflags  -mcond-move  -mno-cond-move @gol
+-moptimize-membar -mno-optimize-membar @gol
+-mscc  -mno-scc  -mcond-exec  -mno-cond-exec @gol
+-mvliw-branch  -mno-vliw-branch @gol
+-mmulti-cond-exec  -mno-multi-cond-exec  -mnested-cond-exec @gol
+-mno-nested-cond-exec  -mtomcat-stats @gol
+-mTLS -mtls @gol
+-mcpu=@var{cpu}}
+
+@emph{GNU/Linux Options}
+@gccoptlist{-muclibc}
+
+@emph{H8/300 Options}
+@gccoptlist{-mrelax  -mh  -ms  -mn  -mint32  -malign-300}
+
+@emph{HPPA Options}
+@gccoptlist{-march=@var{architecture-type} @gol
+-mbig-switch  -mdisable-fpregs  -mdisable-indexing @gol
+-mfast-indirect-calls  -mgas  -mgnu-ld   -mhp-ld @gol
+-mfixed-range=@var{register-range} @gol
+-mjump-in-delay -mlinker-opt -mlong-calls @gol
+-mlong-load-store  -mno-big-switch  -mno-disable-fpregs @gol
+-mno-disable-indexing  -mno-fast-indirect-calls  -mno-gas @gol
+-mno-jump-in-delay  -mno-long-load-store @gol
+-mno-portable-runtime  -mno-soft-float @gol
+-mno-space-regs  -msoft-float  -mpa-risc-1-0 @gol
+-mpa-risc-1-1  -mpa-risc-2-0  -mportable-runtime @gol
+-mschedule=@var{cpu-type}  -mspace-regs  -msio  -mwsio @gol
+-munix=@var{unix-std}  -nolibdld  -static  -threads}
+
+@emph{i386 and x86-64 Options}
+@gccoptlist{-mtune=@var{cpu-type}  -march=@var{cpu-type} @gol
+-mfpmath=@var{unit} @gol
+-masm=@var{dialect}  -mno-fancy-math-387 @gol
+-mno-fp-ret-in-387  -msoft-float @gol
+-mno-wide-multiply  -mrtd  -malign-double @gol
+-mpreferred-stack-boundary=@var{num}
+-mincoming-stack-boundary=@var{num}
+-mcld -mcx16 -msahf -mrecip @gol
+-mmmx  -msse  -msse2 -msse3 -mssse3 -msse4.1 -msse4.2 -msse4 -mavx @gol
+-maes -mpclmul @gol
+-msse4a -m3dnow -mpopcnt -mabm -msse5 @gol
+-mthreads  -mno-align-stringops  -minline-all-stringops @gol
+-minline-stringops-dynamically -mstringop-strategy=@var{alg} @gol
+-mpush-args  -maccumulate-outgoing-args  -m128bit-long-double @gol
+-m96bit-long-double  -mregparm=@var{num}  -msseregparm @gol
+-mveclibabi=@var{type} -mpc32 -mpc64 -mpc80 -mstackrealign @gol
+-momit-leaf-frame-pointer  -mno-red-zone -mno-tls-direct-seg-refs @gol
+-mcmodel=@var{code-model} @gol
+-m32  -m64 -mlarge-data-threshold=@var{num} @gol
+-mfused-madd -mno-fused-madd -msse2avx}
+
+@emph{i386 and x86-64 Windows Options}
+@gccoptlist{-mconsole -mcygwin -mno-cygwin -mdll
+-mnop-fun-dllimport -mthread -mwin32 -mwindows}
+
+@emph{IA-64 Options}
+@gccoptlist{-mbig-endian  -mlittle-endian  -mgnu-as  -mgnu-ld  -mno-pic @gol
+-mvolatile-asm-stop  -mregister-names  -mno-sdata @gol
+-mconstant-gp  -mauto-pic  -minline-float-divide-min-latency @gol
+-minline-float-divide-max-throughput @gol
+-minline-int-divide-min-latency @gol
+-minline-int-divide-max-throughput  @gol
+-minline-sqrt-min-latency -minline-sqrt-max-throughput @gol
+-mno-dwarf2-asm -mearly-stop-bits @gol
+-mfixed-range=@var{register-range} -mtls-size=@var{tls-size} @gol
+-mtune=@var{cpu-type} -mt -pthread -milp32 -mlp64 @gol
+-mno-sched-br-data-spec -msched-ar-data-spec -mno-sched-control-spec @gol
+-msched-br-in-data-spec -msched-ar-in-data-spec -msched-in-control-spec @gol
+-msched-ldc -mno-sched-control-ldc -mno-sched-spec-verbose @gol
+-mno-sched-prefer-non-data-spec-insns @gol
+-mno-sched-prefer-non-control-spec-insns @gol
+-mno-sched-count-spec-in-critical-path}
+
+@emph{M32R/D Options}
+@gccoptlist{-m32r2 -m32rx -m32r @gol
+-mdebug @gol
+-malign-loops -mno-align-loops @gol
+-missue-rate=@var{number} @gol
+-mbranch-cost=@var{number} @gol
+-mmodel=@var{code-size-model-type} @gol
+-msdata=@var{sdata-type} @gol
+-mno-flush-func -mflush-func=@var{name} @gol
+-mno-flush-trap -mflush-trap=@var{number} @gol
+-G @var{num}}
+
+@emph{M32C Options}
+@gccoptlist{-mcpu=@var{cpu} -msim -memregs=@var{number}}
+
+@emph{M680x0 Options}
+@gccoptlist{-march=@var{arch}  -mcpu=@var{cpu}  -mtune=@var{tune}
+-m68000  -m68020  -m68020-40  -m68020-60  -m68030  -m68040 @gol
+-m68060  -mcpu32  -m5200  -m5206e  -m528x  -m5307  -m5407 @gol
+-mcfv4e  -mbitfield  -mno-bitfield  -mc68000  -mc68020 @gol
+-mnobitfield  -mrtd  -mno-rtd  -mdiv  -mno-div  -mshort @gol
+-mno-short  -mhard-float  -m68881  -msoft-float  -mpcrel @gol
+-malign-int  -mstrict-align  -msep-data  -mno-sep-data @gol
+-mshared-library-id=n  -mid-shared-library  -mno-id-shared-library @gol
+-mxgot -mno-xgot}
+
+@emph{M68hc1x Options}
+@gccoptlist{-m6811  -m6812  -m68hc11  -m68hc12   -m68hcs12 @gol
+-mauto-incdec  -minmax  -mlong-calls  -mshort @gol
+-msoft-reg-count=@var{count}}
+
+@emph{MCore Options}
+@gccoptlist{-mhardlit  -mno-hardlit  -mdiv  -mno-div  -mrelax-immediates @gol
+-mno-relax-immediates  -mwide-bitfields  -mno-wide-bitfields @gol
+-m4byte-functions  -mno-4byte-functions  -mcallgraph-data @gol
+-mno-callgraph-data  -mslow-bytes  -mno-slow-bytes  -mno-lsim @gol
+-mlittle-endian  -mbig-endian  -m210  -m340  -mstack-increment}
+
+@emph{MIPS Options}
+@gccoptlist{-EL  -EB  -march=@var{arch}  -mtune=@var{arch} @gol
+-mips1  -mips2  -mips3  -mips4  -mips32  -mips32r2 @gol
+-mips64  -mips64r2 @gol
+-mips16  -mno-mips16  -mflip-mips16 @gol
+-minterlink-mips16  -mno-interlink-mips16 @gol
+-mabi=@var{abi}  -mabicalls  -mno-abicalls @gol
+-mshared  -mno-shared  -mplt  -mno-plt  -mxgot  -mno-xgot @gol
+-mgp32  -mgp64  -mfp32  -mfp64  -mhard-float  -msoft-float @gol
+-msingle-float  -mdouble-float  -mdsp  -mno-dsp  -mdspr2  -mno-dspr2 @gol
+-mfpu=@var{fpu-type} @gol
+-msmartmips  -mno-smartmips @gol
+-mpaired-single  -mno-paired-single  -mdmx  -mno-mdmx @gol
+-mips3d  -mno-mips3d  -mmt  -mno-mt  -mllsc  -mno-llsc @gol
+-mlong64  -mlong32  -msym32  -mno-sym32 @gol
+-G@var{num}  -mlocal-sdata  -mno-local-sdata @gol
+-mextern-sdata  -mno-extern-sdata  -mgpopt  -mno-gopt @gol
+-membedded-data  -mno-embedded-data @gol
+-muninit-const-in-rodata  -mno-uninit-const-in-rodata @gol
+-mcode-readable=@var{setting} @gol
+-msplit-addresses  -mno-split-addresses @gol
+-mexplicit-relocs  -mno-explicit-relocs @gol
+-mcheck-zero-division  -mno-check-zero-division @gol
+-mdivide-traps  -mdivide-breaks @gol
+-mmemcpy  -mno-memcpy  -mlong-calls  -mno-long-calls @gol
+-mmad  -mno-mad  -mfused-madd  -mno-fused-madd  -nocpp @gol
+-mfix-r4000  -mno-fix-r4000  -mfix-r4400  -mno-fix-r4400 @gol
+-mfix-r10000 -mno-fix-r10000  -mfix-vr4120  -mno-fix-vr4120 @gol
+-mfix-vr4130  -mno-fix-vr4130  -mfix-sb1  -mno-fix-sb1 @gol
+-mflush-func=@var{func}  -mno-flush-func @gol
+-mbranch-cost=@var{num}  -mbranch-likely  -mno-branch-likely @gol
+-mfp-exceptions -mno-fp-exceptions @gol
+-mvr4130-align -mno-vr4130-align}
+
+@emph{MMIX Options}
+@gccoptlist{-mlibfuncs  -mno-libfuncs  -mepsilon  -mno-epsilon  -mabi=gnu @gol
+-mabi=mmixware  -mzero-extend  -mknuthdiv  -mtoplevel-symbols @gol
+-melf  -mbranch-predict  -mno-branch-predict  -mbase-addresses @gol
+-mno-base-addresses  -msingle-exit  -mno-single-exit}
+
+@emph{MN10300 Options}
+@gccoptlist{-mmult-bug  -mno-mult-bug @gol
+-mam33  -mno-am33 @gol
+-mam33-2  -mno-am33-2 @gol
+-mreturn-pointer-on-d0 @gol
+-mno-crt0  -mrelax}
+
+@emph{PDP-11 Options}
+@gccoptlist{-mfpu  -msoft-float  -mac0  -mno-ac0  -m40  -m45  -m10 @gol
+-mbcopy  -mbcopy-builtin  -mint32  -mno-int16 @gol
+-mint16  -mno-int32  -mfloat32  -mno-float64 @gol
+-mfloat64  -mno-float32  -mabshi  -mno-abshi @gol
+-mbranch-expensive  -mbranch-cheap @gol
+-msplit  -mno-split  -munix-asm  -mdec-asm}
+
+@emph{picoChip Options}
+@gccoptlist{-mae=@var{ae_type} -mvliw-lookahead=@var{N}
+-msymbol-as-address -mno-inefficient-warnings}
+
+@emph{PowerPC Options}
+See RS/6000 and PowerPC Options.
+
+@emph{RS/6000 and PowerPC Options}
+@gccoptlist{-mcpu=@var{cpu-type} @gol
+-mtune=@var{cpu-type} @gol
+-mpower  -mno-power  -mpower2  -mno-power2 @gol
+-mpowerpc  -mpowerpc64  -mno-powerpc @gol
+-maltivec  -mno-altivec @gol
+-mpowerpc-gpopt  -mno-powerpc-gpopt @gol
+-mpowerpc-gfxopt  -mno-powerpc-gfxopt @gol
+-mmfcrf  -mno-mfcrf  -mpopcntb  -mno-popcntb  -mfprnd  -mno-fprnd @gol
+-mcmpb -mno-cmpb -mmfpgpr -mno-mfpgpr -mhard-dfp -mno-hard-dfp @gol
+-mnew-mnemonics  -mold-mnemonics @gol
+-mfull-toc   -mminimal-toc  -mno-fp-in-toc  -mno-sum-in-toc @gol
+-m64  -m32  -mxl-compat  -mno-xl-compat  -mpe @gol
+-malign-power  -malign-natural @gol
+-msoft-float  -mhard-float  -mmultiple  -mno-multiple @gol
+-msingle-float -mdouble-float -msimple-fpu @gol
+-mstring  -mno-string  -mupdate  -mno-update @gol
+-mavoid-indexed-addresses  -mno-avoid-indexed-addresses @gol
+-mfused-madd  -mno-fused-madd  -mbit-align  -mno-bit-align @gol
+-mstrict-align  -mno-strict-align  -mrelocatable @gol
+-mno-relocatable  -mrelocatable-lib  -mno-relocatable-lib @gol
+-mtoc  -mno-toc  -mlittle  -mlittle-endian  -mbig  -mbig-endian @gol
+-mdynamic-no-pic  -maltivec  -mswdiv @gol
+-mprioritize-restricted-insns=@var{priority} @gol
+-msched-costly-dep=@var{dependence_type} @gol
+-minsert-sched-nops=@var{scheme} @gol
+-mcall-sysv  -mcall-netbsd @gol
+-maix-struct-return  -msvr4-struct-return @gol
+-mabi=@var{abi-type} -msecure-plt -mbss-plt @gol
+-misel -mno-isel @gol
+-misel=yes  -misel=no @gol
+-mspe -mno-spe @gol
+-mspe=yes  -mspe=no @gol
+-mpaired @gol
+-mgen-cell-microcode -mwarn-cell-microcode @gol
+-mvrsave -mno-vrsave @gol
+-mmulhw -mno-mulhw @gol
+-mdlmzb -mno-dlmzb @gol
+-mfloat-gprs=yes  -mfloat-gprs=no -mfloat-gprs=single -mfloat-gprs=double @gol
+-mprototype  -mno-prototype @gol
+-msim  -mmvme  -mads  -myellowknife  -memb  -msdata @gol
+-msdata=@var{opt}  -mvxworks  -G @var{num}  -pthread}
+
+@emph{S/390 and zSeries Options}
+@gccoptlist{-mtune=@var{cpu-type}  -march=@var{cpu-type} @gol
+-mhard-float  -msoft-float  -mhard-dfp -mno-hard-dfp @gol
+-mlong-double-64 -mlong-double-128 @gol
+-mbackchain  -mno-backchain -mpacked-stack  -mno-packed-stack @gol
+-msmall-exec  -mno-small-exec  -mmvcle -mno-mvcle @gol
+-m64  -m31  -mdebug  -mno-debug  -mesa  -mzarch @gol
+-mtpf-trace -mno-tpf-trace  -mfused-madd  -mno-fused-madd @gol
+-mwarn-framesize  -mwarn-dynamicstack  -mstack-size -mstack-guard}
+
+@emph{Score Options}
+@gccoptlist{-meb -mel @gol
+-mnhwloop @gol
+-muls @gol
+-mmac @gol
+-mscore5 -mscore5u -mscore7 -mscore7d}
+
+@emph{SH Options}
+@gccoptlist{-m1  -m2  -m2e  -m3  -m3e @gol
+-m4-nofpu  -m4-single-only  -m4-single  -m4 @gol
+-m4a-nofpu -m4a-single-only -m4a-single -m4a -m4al @gol
+-m5-64media  -m5-64media-nofpu @gol
+-m5-32media  -m5-32media-nofpu @gol
+-m5-compact  -m5-compact-nofpu @gol
+-mb  -ml  -mdalign  -mrelax @gol
+-mbigtable  -mfmovd  -mhitachi -mrenesas -mno-renesas -mnomacsave @gol
+-mieee  -mbitops  -misize  -minline-ic_invalidate -mpadstruct  -mspace @gol
+-mprefergot  -musermode -multcost=@var{number} -mdiv=@var{strategy} @gol
+-mdivsi3_libfunc=@var{name} -mfixed-range=@var{register-range} @gol
+-madjust-unroll -mindexed-addressing -mgettrcost=@var{number} -mpt-fixed @gol
+-minvalid-symbols}
+
+@emph{SPARC Options}
+@gccoptlist{-mcpu=@var{cpu-type} @gol
+-mtune=@var{cpu-type} @gol
+-mcmodel=@var{code-model} @gol
+-m32  -m64  -mapp-regs  -mno-app-regs @gol
+-mfaster-structs  -mno-faster-structs @gol
+-mfpu  -mno-fpu  -mhard-float  -msoft-float @gol
+-mhard-quad-float  -msoft-quad-float @gol
+-mimpure-text  -mno-impure-text  -mlittle-endian @gol
+-mstack-bias  -mno-stack-bias @gol
+-munaligned-doubles  -mno-unaligned-doubles @gol
+-mv8plus  -mno-v8plus  -mvis  -mno-vis
+-threads -pthreads -pthread}
+
+@emph{SPU Options}
+@gccoptlist{-mwarn-reloc -merror-reloc @gol
+-msafe-dma -munsafe-dma @gol
+-mbranch-hints @gol
+-msmall-mem -mlarge-mem -mstdmain @gol
+-mfixed-range=@var{register-range}}
+
+@emph{System V Options}
+@gccoptlist{-Qy  -Qn  -YP,@var{paths}  -Ym,@var{dir}}
+
+@emph{V850 Options}
+@gccoptlist{-mlong-calls  -mno-long-calls  -mep  -mno-ep @gol
+-mprolog-function  -mno-prolog-function  -mspace @gol
+-mtda=@var{n}  -msda=@var{n}  -mzda=@var{n} @gol
+-mapp-regs  -mno-app-regs @gol
+-mdisable-callt  -mno-disable-callt @gol
+-mv850e1 @gol
+-mv850e @gol
+-mv850  -mbig-switch}
+
+@emph{VAX Options}
+@gccoptlist{-mg  -mgnu  -munix}
+
+@emph{VxWorks Options}
+@gccoptlist{-mrtp  -non-static  -Bstatic  -Bdynamic @gol
+-Xbind-lazy  -Xbind-now}
+
+@emph{x86-64 Options}
+See i386 and x86-64 Options.
+
+@emph{Xstormy16 Options}
+@gccoptlist{-msim}
+
+@emph{Xtensa Options}
+@gccoptlist{-mconst16 -mno-const16 @gol
+-mfused-madd  -mno-fused-madd @gol
+-mserialize-volatile  -mno-serialize-volatile @gol
+-mtext-section-literals  -mno-text-section-literals @gol
+-mtarget-align  -mno-target-align @gol
+-mlongcalls  -mno-longcalls}
+
+@emph{zSeries Options}
+See S/390 and zSeries Options.
+
+@item Code Generation Options
+@xref{Code Gen Options,,Options for Code Generation Conventions}.
+@gccoptlist{-fcall-saved-@var{reg}  -fcall-used-@var{reg} @gol
+-ffixed-@var{reg}  -fexceptions @gol
+-fnon-call-exceptions  -funwind-tables @gol
+-fasynchronous-unwind-tables @gol
+-finhibit-size-directive  -finstrument-functions @gol
+-finstrument-functions-exclude-function-list=@var{sym},@var{sym},@dots{} @gol
+-finstrument-functions-exclude-file-list=@var{file},@var{file},@dots{} @gol
+-fno-common  -fno-ident @gol
+-fpcc-struct-return  -fpic  -fPIC -fpie -fPIE @gol
+-fno-jump-tables @gol
+-frecord-gcc-switches @gol
+-freg-struct-return  -fshort-enums @gol
+-fshort-double  -fshort-wchar @gol
+-fverbose-asm  -fpack-struct[=@var{n}]  -fstack-check @gol
+-fstack-limit-register=@var{reg}  -fstack-limit-symbol=@var{sym} @gol
+-fno-stack-limit  -fargument-alias  -fargument-noalias @gol
+-fargument-noalias-global  -fargument-noalias-anything @gol
+-fleading-underscore  -ftls-model=@var{model} @gol
+-ftrapv  -fwrapv  -fbounds-check @gol
+-fvisibility}
+@end table
+
+@menu
+* Overall Options::     Controlling the kind of output:
+                        an executable, object files, assembler files,
+                        or preprocessed source.
+* C Dialect Options::   Controlling the variant of C language compiled.
+* C++ Dialect Options:: Variations on C++.
+* Objective-C and Objective-C++ Dialect Options:: Variations on Objective-C
+                        and Objective-C++.
+* Language Independent Options:: Controlling how diagnostics should be
+                        formatted.
+* Warning Options::     How picky should the compiler be?
+* Debugging Options::   Symbol tables, measurements, and debugging dumps.
+* Optimize Options::    How much optimization?
+* Preprocessor Options:: Controlling header files and macro definitions.
+                         Also, getting dependency information for Make.
+* Assembler Options::   Passing options to the assembler.
+* Link Options::        Specifying libraries and so on.
+* Directory Options::   Where to find header files and libraries.
+                        Where to find the compiler executable files.
+* Spec Files::          How to pass switches to sub-processes.
+* Target Options::      Running a cross-compiler, or an old version of GCC.
+@end menu
+
+@node Overall Options
+@section Options Controlling the Kind of Output
+
+Compilation can involve up to four stages: preprocessing, compilation
+proper, assembly and linking, always in that order.  GCC is capable of
+preprocessing and compiling several files either into several
+assembler input files, or into one assembler input file; then each
+assembler input file produces an object file, and linking combines all
+the object files (those newly compiled, and those specified as input)
+into an executable file.
+
+@cindex file name suffix
+For any given input file, the file name suffix determines what kind of
+compilation is done:
+
+@table @gcctabopt
+@item @var{file}.c
+C source code which must be preprocessed.
+
+@item @var{file}.i
+C source code which should not be preprocessed.
+
+@item @var{file}.ii
+C++ source code which should not be preprocessed.
+
+@item @var{file}.m
+Objective-C source code.  Note that you must link with the @file{libobjc}
+library to make an Objective-C program work.
+
+@item @var{file}.mi
+Objective-C source code which should not be preprocessed.
+
+@item @var{file}.mm
+@itemx @var{file}.M
+Objective-C++ source code.  Note that you must link with the @file{libobjc}
+library to make an Objective-C++ program work.  Note that @samp{.M} refers
+to a literal capital M@.
+
+@item @var{file}.mii
+Objective-C++ source code which should not be preprocessed.
+
+@item @var{file}.h
+C, C++, Objective-C or Objective-C++ header file to be turned into a
+precompiled header.
+
+@item @var{file}.cc
+@itemx @var{file}.cp
+@itemx @var{file}.cxx
+@itemx @var{file}.cpp
+@itemx @var{file}.CPP
+@itemx @var{file}.c++
+@itemx @var{file}.C
+C++ source code which must be preprocessed.  Note that in @samp{.cxx},
+the last two letters must both be literally @samp{x}.  Likewise,
+@samp{.C} refers to a literal capital C@.
+
+@item @var{file}.mm
+@itemx @var{file}.M
+Objective-C++ source code which must be preprocessed.
+
+@item @var{file}.mii
+Objective-C++ source code which should not be preprocessed.
+
+@item @var{file}.hh
+@itemx @var{file}.H
+@itemx @var{file}.hp
+@itemx @var{file}.hxx
+@itemx @var{file}.hpp
+@itemx @var{file}.HPP
+@itemx @var{file}.h++
+@itemx @var{file}.tcc
+C++ header file to be turned into a precompiled header.
+
+@item @var{file}.f
+@itemx @var{file}.for
+@itemx @var{file}.ftn
+Fixed form Fortran source code which should not be preprocessed.
+
+@item @var{file}.F
+@itemx @var{file}.FOR
+@itemx @var{file}.fpp
+@itemx @var{file}.FPP
+@itemx @var{file}.FTN
+Fixed form Fortran source code which must be preprocessed (with the traditional
+preprocessor).
+
+@item @var{file}.f90
+@itemx @var{file}.f95
+@itemx @var{file}.f03
+@itemx @var{file}.f08
+Free form Fortran source code which should not be preprocessed.
+
+@item @var{file}.F90
+@itemx @var{file}.F95
+@itemx @var{file}.F03
+@itemx @var{file}.F08
+Free form Fortran source code which must be preprocessed (with the
+traditional preprocessor).
+
+@c FIXME: Descriptions of Java file types.
+@c @var{file}.java
+@c @var{file}.class
+@c @var{file}.zip
+@c @var{file}.jar
+
+@item @var{file}.ads
+Ada source code file which contains a library unit declaration (a
+declaration of a package, subprogram, or generic, or a generic
+instantiation), or a library unit renaming declaration (a package,
+generic, or subprogram renaming declaration).  Such files are also
+called @dfn{specs}.
+
+@item @var{file}.adb
+Ada source code file containing a library unit body (a subprogram or
+package body).  Such files are also called @dfn{bodies}.
+
+@c GCC also knows about some suffixes for languages not yet included:
+@c Pascal:
+@c @var{file}.p
+@c @var{file}.pas
+@c Ratfor:
+@c @var{file}.r
+
+@item @var{file}.s
+Assembler code.
+
+@item @var{file}.S
+@itemx @var{file}.sx
+Assembler code which must be preprocessed.
+
+@item @var{other}
+An object file to be fed straight into linking.
+Any file name with no recognized suffix is treated this way.
+@end table
+
+@opindex x
+You can specify the input language explicitly with the @option{-x} option:
+
+@table @gcctabopt
+@item -x @var{language}
+Specify explicitly the @var{language} for the following input files
+(rather than letting the compiler choose a default based on the file
+name suffix).  This option applies to all following input files until
+the next @option{-x} option.  Possible values for @var{language} are:
+@smallexample
+c  c-header  c-cpp-output
+c++  c++-header  c++-cpp-output
+objective-c  objective-c-header  objective-c-cpp-output
+objective-c++ objective-c++-header objective-c++-cpp-output
+assembler  assembler-with-cpp
+ada
+f77  f77-cpp-input f95  f95-cpp-input
+java
+@end smallexample
+
+@item -x none
+Turn off any specification of a language, so that subsequent files are
+handled according to their file name suffixes (as they are if @option{-x}
+has not been used at all).
+
+@item -pass-exit-codes
+@opindex pass-exit-codes
+Normally the @command{gcc} program will exit with the code of 1 if any
+phase of the compiler returns a non-success return code.  If you specify
+@option{-pass-exit-codes}, the @command{gcc} program will instead return with
+numerically highest error produced by any phase that returned an error
+indication.  The C, C++, and Fortran frontends return 4, if an internal
+compiler error is encountered.
+@end table
+
+If you only want some of the stages of compilation, you can use
+@option{-x} (or filename suffixes) to tell @command{gcc} where to start, and
+one of the options @option{-c}, @option{-S}, or @option{-E} to say where
+@command{gcc} is to stop.  Note that some combinations (for example,
+@samp{-x cpp-output -E}) instruct @command{gcc} to do nothing at all.
+
+@table @gcctabopt
+@item -c
+@opindex c
+Compile or assemble the source files, but do not link.  The linking
+stage simply is not done.  The ultimate output is in the form of an
+object file for each source file.
+
+By default, the object file name for a source file is made by replacing
+the suffix @samp{.c}, @samp{.i}, @samp{.s}, etc., with @samp{.o}.
+
+Unrecognized input files, not requiring compilation or assembly, are
+ignored.
+
+@item -S
+@opindex S
+Stop after the stage of compilation proper; do not assemble.  The output
+is in the form of an assembler code file for each non-assembler input
+file specified.
+
+By default, the assembler file name for a source file is made by
+replacing the suffix @samp{.c}, @samp{.i}, etc., with @samp{.s}.
+
+Input files that don't require compilation are ignored.
+
+@item -E
+@opindex E
+Stop after the preprocessing stage; do not run the compiler proper.  The
+output is in the form of preprocessed source code, which is sent to the
+standard output.
+
+Input files which don't require preprocessing are ignored.
+
+@cindex output file option
+@item -o @var{file}
+@opindex o
+Place output in file @var{file}.  This applies regardless to whatever
+sort of output is being produced, whether it be an executable file,
+an object file, an assembler file or preprocessed C code.
+
+If @option{-o} is not specified, the default is to put an executable
+file in @file{a.out}, the object file for
+@file{@var{source}.@var{suffix}} in @file{@var{source}.o}, its
+assembler file in @file{@var{source}.s}, a precompiled header file in
+@file{@var{source}.@var{suffix}.gch}, and all preprocessed C source on
+standard output.
+
+@item -v
+@opindex v
+Print (on standard error output) the commands executed to run the stages
+of compilation.  Also print the version number of the compiler driver
+program and of the preprocessor and the compiler proper.
+
+@item -###
+@opindex ###
+Like @option{-v} except the commands are not executed and all command
+arguments are quoted.  This is useful for shell scripts to capture the
+driver-generated command lines.
+
+@item -pipe
+@opindex pipe
+Use pipes rather than temporary files for communication between the
+various stages of compilation.  This fails to work on some systems where
+the assembler is unable to read from a pipe; but the GNU assembler has
+no trouble.
+
+@item -combine
+@opindex combine
+If you are compiling multiple source files, this option tells the driver
+to pass all the source files to the compiler at once (for those
+languages for which the compiler can handle this).  This will allow
+intermodule analysis (IMA) to be performed by the compiler.  Currently the only
+language for which this is supported is C@.  If you pass source files for
+multiple languages to the driver, using this option, the driver will invoke
+the compiler(s) that support IMA once each, passing each compiler all the
+source files appropriate for it.  For those languages that do not support
+IMA this option will be ignored, and the compiler will be invoked once for
+each source file in that language.  If you use this option in conjunction
+with @option{-save-temps}, the compiler will generate multiple
+pre-processed files
+(one for each source file), but only one (combined) @file{.o} or
+@file{.s} file.
+
+@item --help
+@opindex help
+Print (on the standard output) a description of the command line options
+understood by @command{gcc}.  If the @option{-v} option is also specified
+then @option{--help} will also be passed on to the various processes
+invoked by @command{gcc}, so that they can display the command line options
+they accept.  If the @option{-Wextra} option has also been specified
+(prior to the @option{--help} option), then command line options which
+have no documentation associated with them will also be displayed.
+
+@item --target-help
+@opindex target-help
+Print (on the standard output) a description of target-specific command
+line options for each tool.  For some targets extra target-specific
+information may also be printed.
+
+@item --help=@{@var{class}@r{|[}^@r{]}@var{qualifier}@}@r{[},@dots{}@r{]}
+Print (on the standard output) a description of the command line
+options understood by the compiler that fit into all specified classes
+and qualifiers.  These are the supported classes:
+
+@table @asis
+@item @samp{optimizers}
+This will display all of the optimization options supported by the
+compiler.
+
+@item @samp{warnings}
+This will display all of the options controlling warning messages
+produced by the compiler.
+
+@item @samp{target}
+This will display target-specific options.  Unlike the
+@option{--target-help} option however, target-specific options of the
+linker and assembler will not be displayed.  This is because those
+tools do not currently support the extended @option{--help=} syntax.
+
+@item @samp{params}
+This will display the values recognized by the @option{--param}
+option.
+
+@item @var{language}
+This will display the options supported for @var{language}, where 
+@var{language} is the name of one of the languages supported in this 
+version of GCC.
+
+@item @samp{common}
+This will display the options that are common to all languages.
+@end table
+
+These are the supported qualifiers:
+
+@table @asis
+@item @samp{undocumented}
+Display only those options which are undocumented.
+
+@item @samp{joined}
+Display options which take an argument that appears after an equal
+sign in the same continuous piece of text, such as:
+@samp{--help=target}.
+
+@item @samp{separate}
+Display options which take an argument that appears as a separate word
+following the original option, such as: @samp{-o output-file}.
+@end table
+
+Thus for example to display all the undocumented target-specific
+switches supported by the compiler the following can be used:
+
+@smallexample
+--help=target,undocumented
+@end smallexample
+
+The sense of a qualifier can be inverted by prefixing it with the
+@samp{^} character, so for example to display all binary warning
+options (i.e., ones that are either on or off and that do not take an
+argument), which have a description the following can be used:
+
+@smallexample
+--help=warnings,^joined,^undocumented
+@end smallexample
+
+The argument to @option{--help=} should not consist solely of inverted
+qualifiers.
+
+Combining several classes is possible, although this usually
+restricts the output by so much that there is nothing to display.  One
+case where it does work however is when one of the classes is
+@var{target}.  So for example to display all the target-specific
+optimization options the following can be used:
+
+@smallexample
+--help=target,optimizers
+@end smallexample
+
+The @option{--help=} option can be repeated on the command line.  Each
+successive use will display its requested class of options, skipping
+those that have already been displayed.
+
+If the @option{-Q} option appears on the command line before the
+@option{--help=} option, then the descriptive text displayed by
+@option{--help=} is changed.  Instead of describing the displayed
+options, an indication is given as to whether the option is enabled,
+disabled or set to a specific value (assuming that the compiler
+knows this at the point where the @option{--help=} option is used).
+
+Here is a truncated example from the ARM port of @command{gcc}:
+
+@smallexample
+  % gcc -Q -mabi=2 --help=target -c
+  The following options are target specific:
+  -mabi=                                2
+  -mabort-on-noreturn                   [disabled]
+  -mapcs                                [disabled]
+@end smallexample
+
+The output is sensitive to the effects of previous command line
+options, so for example it is possible to find out which optimizations
+are enabled at @option{-O2} by using:
+
+@smallexample
+-Q -O2 --help=optimizers
+@end smallexample
+
+Alternatively you can discover which binary optimizations are enabled
+by @option{-O3} by using:
+
+@smallexample
+gcc -c -Q -O3 --help=optimizers > /tmp/O3-opts
+gcc -c -Q -O2 --help=optimizers > /tmp/O2-opts
+diff /tmp/O2-opts /tmp/O3-opts | grep enabled
+@end smallexample
+
+@item --version
+@opindex version
+Display the version number and copyrights of the invoked GCC@.
+
+@item -wrapper
+@opindex wrapper
+Invoke all subcommands under a wrapper program. It takes a single
+comma separated list as an argument, which will be used to invoke
+the wrapper:
+
+@smallexample
+gcc -c t.c -wrapper gdb,--args
+@end smallexample
+
+This will invoke all subprograms of gcc under "gdb --args",
+thus cc1 invocation will be "gdb --args cc1 ...".
+
+@include @value{srcdir}/../libiberty/at-file.texi
+@end table
+
+@node Invoking G++
+@section Compiling C++ Programs
+
+@cindex suffixes for C++ source
+@cindex C++ source file suffixes
+C++ source files conventionally use one of the suffixes @samp{.C},
+@samp{.cc}, @samp{.cpp}, @samp{.CPP}, @samp{.c++}, @samp{.cp}, or
+@samp{.cxx}; C++ header files often use @samp{.hh}, @samp{.hpp},
+@samp{.H}, or (for shared template code) @samp{.tcc}; and
+preprocessed C++ files use the suffix @samp{.ii}.  GCC recognizes
+files with these names and compiles them as C++ programs even if you
+call the compiler the same way as for compiling C programs (usually
+with the name @command{gcc}).
+
+@findex g++
+@findex c++
+However, the use of @command{gcc} does not add the C++ library.
+@command{g++} is a program that calls GCC and treats @samp{.c},
+@samp{.h} and @samp{.i} files as C++ source files instead of C source
+files unless @option{-x} is used, and automatically specifies linking
+against the C++ library.  This program is also useful when
+precompiling a C header file with a @samp{.h} extension for use in C++
+compilations.  On many systems, @command{g++} is also installed with
+the name @command{c++}.
+
+@cindex invoking @command{g++}
+When you compile C++ programs, you may specify many of the same
+command-line options that you use for compiling programs in any
+language; or command-line options meaningful for C and related
+languages; or options that are meaningful only for C++ programs.
+@xref{C Dialect Options,,Options Controlling C Dialect}, for
+explanations of options for languages related to C@.
+@xref{C++ Dialect Options,,Options Controlling C++ Dialect}, for
+explanations of options that are meaningful only for C++ programs.
+
+@node C Dialect Options
+@section Options Controlling C Dialect
+@cindex dialect options
+@cindex language dialect options
+@cindex options, dialect
+
+The following options control the dialect of C (or languages derived
+from C, such as C++, Objective-C and Objective-C++) that the compiler
+accepts:
+
+@table @gcctabopt
+@cindex ANSI support
+@cindex ISO support
+@item -ansi
+@opindex ansi
+In C mode, this is equivalent to @samp{-std=c89}. In C++ mode, it is
+equivalent to @samp{-std=c++98}.
+
+This turns off certain features of GCC that are incompatible with ISO
+C90 (when compiling C code), or of standard C++ (when compiling C++ code),
+such as the @code{asm} and @code{typeof} keywords, and
+predefined macros such as @code{unix} and @code{vax} that identify the
+type of system you are using.  It also enables the undesirable and
+rarely used ISO trigraph feature.  For the C compiler,
+it disables recognition of C++ style @samp{//} comments as well as
+the @code{inline} keyword.
+
+The alternate keywords @code{__asm__}, @code{__extension__},
+@code{__inline__} and @code{__typeof__} continue to work despite
+@option{-ansi}.  You would not want to use them in an ISO C program, of
+course, but it is useful to put them in header files that might be included
+in compilations done with @option{-ansi}.  Alternate predefined macros
+such as @code{__unix__} and @code{__vax__} are also available, with or
+without @option{-ansi}.
+
+The @option{-ansi} option does not cause non-ISO programs to be
+rejected gratuitously.  For that, @option{-pedantic} is required in
+addition to @option{-ansi}.  @xref{Warning Options}.
+
+The macro @code{__STRICT_ANSI__} is predefined when the @option{-ansi}
+option is used.  Some header files may notice this macro and refrain
+from declaring certain functions or defining certain macros that the
+ISO standard doesn't call for; this is to avoid interfering with any
+programs that might use these names for other things.
+
+Functions that would normally be built in but do not have semantics
+defined by ISO C (such as @code{alloca} and @code{ffs}) are not built-in
+functions when @option{-ansi} is used.  @xref{Other Builtins,,Other
+built-in functions provided by GCC}, for details of the functions
+affected.
+
+@item -std=
+@opindex std
+Determine the language standard. @xref{Standards,,Language Standards
+Supported by GCC}, for details of these standard versions.  This option
+is currently only supported when compiling C or C++. 
+
+The compiler can accept several base standards, such as @samp{c89} or
+@samp{c++98}, and GNU dialects of those standards, such as
+@samp{gnu89} or @samp{gnu++98}.  By specifying a base standard, the
+compiler will accept all programs following that standard and those
+using GNU extensions that do not contradict it.  For example,
+@samp{-std=c89} turns off certain features of GCC that are
+incompatible with ISO C90, such as the @code{asm} and @code{typeof}
+keywords, but not other GNU extensions that do not have a meaning in
+ISO C90, such as omitting the middle term of a @code{?:}
+expression. On the other hand, by specifying a GNU dialect of a
+standard, all features the compiler support are enabled, even when
+those features change the meaning of the base standard and some
+strict-conforming programs may be rejected.  The particular standard
+is used by @option{-pedantic} to identify which features are GNU
+extensions given that version of the standard. For example
+@samp{-std=gnu89 -pedantic} would warn about C++ style @samp{//}
+comments, while @samp{-std=gnu99 -pedantic} would not.
+
+A value for this option must be provided; possible values are
+
+@table @samp
+@item c89
+@itemx iso9899:1990
+Support all ISO C90 programs (certain GNU extensions that conflict
+with ISO C90 are disabled). Same as @option{-ansi} for C code.
+
+@item iso9899:199409
+ISO C90 as modified in amendment 1.
+
+@item c99
+@itemx c9x
+@itemx iso9899:1999
+@itemx iso9899:199x
+ISO C99.  Note that this standard is not yet fully supported; see
+@w{@uref{http://gcc.gnu.org/gcc-4.4/c99status.html}} for more information.  The
+names @samp{c9x} and @samp{iso9899:199x} are deprecated.
+
+@item gnu89
+GNU dialect of ISO C90 (including some C99 features). This
+is the default for C code.
+
+@item gnu99
+@itemx gnu9x
+GNU dialect of ISO C99.  When ISO C99 is fully implemented in GCC,
+this will become the default.  The name @samp{gnu9x} is deprecated.
+
+@item c++98
+The 1998 ISO C++ standard plus amendments. Same as @option{-ansi} for
+C++ code.
+
+@item gnu++98
+GNU dialect of @option{-std=c++98}.  This is the default for
+C++ code.
+
+@item c++0x
+The working draft of the upcoming ISO C++0x standard. This option
+enables experimental features that are likely to be included in
+C++0x. The working draft is constantly changing, and any feature that is
+enabled by this flag may be removed from future versions of GCC if it is
+not part of the C++0x standard.
+
+@item gnu++0x
+GNU dialect of @option{-std=c++0x}. This option enables
+experimental features that may be removed in future versions of GCC.
+@end table
+
+@item -fgnu89-inline
+@opindex fgnu89-inline
+The option @option{-fgnu89-inline} tells GCC to use the traditional
+GNU semantics for @code{inline} functions when in C99 mode.
+@xref{Inline,,An Inline Function is As Fast As a Macro}.  This option
+is accepted and ignored by GCC versions 4.1.3 up to but not including
+4.3.  In GCC versions 4.3 and later it changes the behavior of GCC in
+C99 mode.  Using this option is roughly equivalent to adding the
+@code{gnu_inline} function attribute to all inline functions
+(@pxref{Function Attributes}).
+
+The option @option{-fno-gnu89-inline} explicitly tells GCC to use the
+C99 semantics for @code{inline} when in C99 or gnu99 mode (i.e., it
+specifies the default behavior).  This option was first supported in
+GCC 4.3.  This option is not supported in C89 or gnu89 mode.
+
+The preprocessor macros @code{__GNUC_GNU_INLINE__} and
+@code{__GNUC_STDC_INLINE__} may be used to check which semantics are
+in effect for @code{inline} functions.  @xref{Common Predefined
+Macros,,,cpp,The C Preprocessor}.
+
+@item -aux-info @var{filename}
+@opindex aux-info
+Output to the given filename prototyped declarations for all functions
+declared and/or defined in a translation unit, including those in header
+files.  This option is silently ignored in any language other than C@.
+
+Besides declarations, the file indicates, in comments, the origin of
+each declaration (source file and line), whether the declaration was
+implicit, prototyped or unprototyped (@samp{I}, @samp{N} for new or
+@samp{O} for old, respectively, in the first character after the line
+number and the colon), and whether it came from a declaration or a
+definition (@samp{C} or @samp{F}, respectively, in the following
+character).  In the case of function definitions, a K&R-style list of
+arguments followed by their declarations is also provided, inside
+comments, after the declaration.
+
+@item -fno-asm
+@opindex fno-asm
+Do not recognize @code{asm}, @code{inline} or @code{typeof} as a
+keyword, so that code can use these words as identifiers.  You can use
+the keywords @code{__asm__}, @code{__inline__} and @code{__typeof__}
+instead.  @option{-ansi} implies @option{-fno-asm}.
+
+In C++, this switch only affects the @code{typeof} keyword, since
+@code{asm} and @code{inline} are standard keywords.  You may want to
+use the @option{-fno-gnu-keywords} flag instead, which has the same
+effect.  In C99 mode (@option{-std=c99} or @option{-std=gnu99}), this
+switch only affects the @code{asm} and @code{typeof} keywords, since
+@code{inline} is a standard keyword in ISO C99.
+
+@item -fno-builtin
+@itemx -fno-builtin-@var{function}
+@opindex fno-builtin
+@cindex built-in functions
+Don't recognize built-in functions that do not begin with
+@samp{__builtin_} as prefix.  @xref{Other Builtins,,Other built-in
+functions provided by GCC}, for details of the functions affected,
+including those which are not built-in functions when @option{-ansi} or
+@option{-std} options for strict ISO C conformance are used because they
+do not have an ISO standard meaning.
+
+GCC normally generates special code to handle certain built-in functions
+more efficiently; for instance, calls to @code{alloca} may become single
+instructions that adjust the stack directly, and calls to @code{memcpy}
+may become inline copy loops.  The resulting code is often both smaller
+and faster, but since the function calls no longer appear as such, you
+cannot set a breakpoint on those calls, nor can you change the behavior
+of the functions by linking with a different library.  In addition,
+when a function is recognized as a built-in function, GCC may use
+information about that function to warn about problems with calls to
+that function, or to generate more efficient code, even if the
+resulting code still contains calls to that function.  For example,
+warnings are given with @option{-Wformat} for bad calls to
+@code{printf}, when @code{printf} is built in, and @code{strlen} is
+known not to modify global memory.
+
+With the @option{-fno-builtin-@var{function}} option
+only the built-in function @var{function} is
+disabled.  @var{function} must not begin with @samp{__builtin_}.  If a
+function is named that is not built-in in this version of GCC, this
+option is ignored.  There is no corresponding
+@option{-fbuiltin-@var{function}} option; if you wish to enable
+built-in functions selectively when using @option{-fno-builtin} or
+@option{-ffreestanding}, you may define macros such as:
+
+@smallexample
+#define abs(n)          __builtin_abs ((n))
+#define strcpy(d, s)    __builtin_strcpy ((d), (s))
+@end smallexample
+
+@item -fhosted
+@opindex fhosted
+@cindex hosted environment
+
+Assert that compilation takes place in a hosted environment.  This implies
+@option{-fbuiltin}.  A hosted environment is one in which the
+entire standard library is available, and in which @code{main} has a return
+type of @code{int}.  Examples are nearly everything except a kernel.
+This is equivalent to @option{-fno-freestanding}.
+
+@item -ffreestanding
+@opindex ffreestanding
+@cindex hosted environment
+
+Assert that compilation takes place in a freestanding environment.  This
+implies @option{-fno-builtin}.  A freestanding environment
+is one in which the standard library may not exist, and program startup may
+not necessarily be at @code{main}.  The most obvious example is an OS kernel.
+This is equivalent to @option{-fno-hosted}.
+
+@xref{Standards,,Language Standards Supported by GCC}, for details of
+freestanding and hosted environments.
+
+@item -fopenmp
+@opindex fopenmp
+@cindex openmp parallel
+Enable handling of OpenMP directives @code{#pragma omp} in C/C++ and
+@code{!$omp} in Fortran.  When @option{-fopenmp} is specified, the
+compiler generates parallel code according to the OpenMP Application
+Program Interface v2.5 @w{@uref{http://www.openmp.org/}}.  This option
+implies @option{-pthread}, and thus is only supported on targets that
+have support for @option{-pthread}.
+
+@item -fms-extensions
+@opindex fms-extensions
+Accept some non-standard constructs used in Microsoft header files.
+
+Some cases of unnamed fields in structures and unions are only
+accepted with this option.  @xref{Unnamed Fields,,Unnamed struct/union
+fields within structs/unions}, for details.
+
+@item -trigraphs
+@opindex trigraphs
+Support ISO C trigraphs.  The @option{-ansi} option (and @option{-std}
+options for strict ISO C conformance) implies @option{-trigraphs}.
+
+@item -no-integrated-cpp
+@opindex no-integrated-cpp
+Performs a compilation in two passes: preprocessing and compiling.  This
+option allows a user supplied "cc1", "cc1plus", or "cc1obj" via the
+@option{-B} option.  The user supplied compilation step can then add in
+an additional preprocessing step after normal preprocessing but before
+compiling.  The default is to use the integrated cpp (internal cpp)
+
+The semantics of this option will change if "cc1", "cc1plus", and
+"cc1obj" are merged.
+
+@cindex traditional C language
+@cindex C language, traditional
+@item -traditional
+@itemx -traditional-cpp
+@opindex traditional-cpp
+@opindex traditional
+Formerly, these options caused GCC to attempt to emulate a pre-standard
+C compiler.  They are now only supported with the @option{-E} switch.
+The preprocessor continues to support a pre-standard mode.  See the GNU
+CPP manual for details.
+
+@item -fcond-mismatch
+@opindex fcond-mismatch
+Allow conditional expressions with mismatched types in the second and
+third arguments.  The value of such an expression is void.  This option
+is not supported for C++.
+
+@item -flax-vector-conversions
+@opindex flax-vector-conversions
+Allow implicit conversions between vectors with differing numbers of
+elements and/or incompatible element types.  This option should not be
+used for new code.
+
+@item -funsigned-char
+@opindex funsigned-char
+Let the type @code{char} be unsigned, like @code{unsigned char}.
+
+Each kind of machine has a default for what @code{char} should
+be.  It is either like @code{unsigned char} by default or like
+@code{signed char} by default.
+
+Ideally, a portable program should always use @code{signed char} or
+@code{unsigned char} when it depends on the signedness of an object.
+But many programs have been written to use plain @code{char} and
+expect it to be signed, or expect it to be unsigned, depending on the
+machines they were written for.  This option, and its inverse, let you
+make such a program work with the opposite default.
+
+The type @code{char} is always a distinct type from each of
+@code{signed char} or @code{unsigned char}, even though its behavior
+is always just like one of those two.
+
+@item -fsigned-char
+@opindex fsigned-char
+Let the type @code{char} be signed, like @code{signed char}.
+
+Note that this is equivalent to @option{-fno-unsigned-char}, which is
+the negative form of @option{-funsigned-char}.  Likewise, the option
+@option{-fno-signed-char} is equivalent to @option{-funsigned-char}.
+
+@item -fsigned-bitfields
+@itemx -funsigned-bitfields
+@itemx -fno-signed-bitfields
+@itemx -fno-unsigned-bitfields
+@opindex fsigned-bitfields
+@opindex funsigned-bitfields
+@opindex fno-signed-bitfields
+@opindex fno-unsigned-bitfields
+These options control whether a bit-field is signed or unsigned, when the
+declaration does not use either @code{signed} or @code{unsigned}.  By
+default, such a bit-field is signed, because this is consistent: the
+basic integer types such as @code{int} are signed types.
+@end table
+
+@node C++ Dialect Options
+@section Options Controlling C++ Dialect
+
+@cindex compiler options, C++
+@cindex C++ options, command line
+@cindex options, C++
+This section describes the command-line options that are only meaningful
+for C++ programs; but you can also use most of the GNU compiler options
+regardless of what language your program is in.  For example, you
+might compile a file @code{firstClass.C} like this:
+
+@smallexample
+g++ -g -frepo -O -c firstClass.C
+@end smallexample
+
+@noindent
+In this example, only @option{-frepo} is an option meant
+only for C++ programs; you can use the other options with any
+language supported by GCC@.
+
+Here is a list of options that are @emph{only} for compiling C++ programs:
+
+@table @gcctabopt
+
+@item -fabi-version=@var{n}
+@opindex fabi-version
+Use version @var{n} of the C++ ABI@.  Version 2 is the version of the
+C++ ABI that first appeared in G++ 3.4.  Version 1 is the version of
+the C++ ABI that first appeared in G++ 3.2.  Version 0 will always be
+the version that conforms most closely to the C++ ABI specification.
+Therefore, the ABI obtained using version 0 will change as ABI bugs
+are fixed.
+
+The default is version 2.
+
+@item -fno-access-control
+@opindex fno-access-control
+Turn off all access checking.  This switch is mainly useful for working
+around bugs in the access control code.
+
+@item -fcheck-new
+@opindex fcheck-new
+Check that the pointer returned by @code{operator new} is non-null
+before attempting to modify the storage allocated.  This check is
+normally unnecessary because the C++ standard specifies that
+@code{operator new} will only return @code{0} if it is declared
+@samp{throw()}, in which case the compiler will always check the
+return value even without this option.  In all other cases, when
+@code{operator new} has a non-empty exception specification, memory
+exhaustion is signalled by throwing @code{std::bad_alloc}.  See also
+@samp{new (nothrow)}.
+
+@item -fconserve-space
+@opindex fconserve-space
+Put uninitialized or runtime-initialized global variables into the
+common segment, as C does.  This saves space in the executable at the
+cost of not diagnosing duplicate definitions.  If you compile with this
+flag and your program mysteriously crashes after @code{main()} has
+completed, you may have an object that is being destroyed twice because
+two definitions were merged.
+
+This option is no longer useful on most targets, now that support has
+been added for putting variables into BSS without making them common.
+
+@item -fno-deduce-init-list
+@opindex fno-deduce-init-list
+Disable deduction of a template type parameter as
+std::initializer_list from a brace-enclosed initializer list, i.e.
+
+@smallexample
+template <class T> auto forward(T t) -> decltype (realfn (t))
+@{
+  return realfn (t);
+@}
+
+void f()
+@{
+  forward(@{1,2@}); // call forward<std::initializer_list<int>>
+@}
+@end smallexample
+
+This option is present because this deduction is an extension to the
+current specification in the C++0x working draft, and there was
+some concern about potential overload resolution problems.
+
+@item -ffriend-injection
+@opindex ffriend-injection
+Inject friend functions into the enclosing namespace, so that they are
+visible outside the scope of the class in which they are declared.
+Friend functions were documented to work this way in the old Annotated
+C++ Reference Manual, and versions of G++ before 4.1 always worked
+that way.  However, in ISO C++ a friend function which is not declared
+in an enclosing scope can only be found using argument dependent
+lookup.  This option causes friends to be injected as they were in
+earlier releases.
+
+This option is for compatibility, and may be removed in a future
+release of G++.
+
+@item -fno-elide-constructors
+@opindex fno-elide-constructors
+The C++ standard allows an implementation to omit creating a temporary
+which is only used to initialize another object of the same type.
+Specifying this option disables that optimization, and forces G++ to
+call the copy constructor in all cases.
+
+@item -fno-enforce-eh-specs
+@opindex fno-enforce-eh-specs
+Don't generate code to check for violation of exception specifications
+at runtime.  This option violates the C++ standard, but may be useful
+for reducing code size in production builds, much like defining
+@samp{NDEBUG}.  This does not give user code permission to throw
+exceptions in violation of the exception specifications; the compiler
+will still optimize based on the specifications, so throwing an
+unexpected exception will result in undefined behavior.
+
+@item -ffor-scope
+@itemx -fno-for-scope
+@opindex ffor-scope
+@opindex fno-for-scope
+If @option{-ffor-scope} is specified, the scope of variables declared in
+a @i{for-init-statement} is limited to the @samp{for} loop itself,
+as specified by the C++ standard.
+If @option{-fno-for-scope} is specified, the scope of variables declared in
+a @i{for-init-statement} extends to the end of the enclosing scope,
+as was the case in old versions of G++, and other (traditional)
+implementations of C++.
+
+The default if neither flag is given to follow the standard,
+but to allow and give a warning for old-style code that would
+otherwise be invalid, or have different behavior.
+
+@item -fno-gnu-keywords
+@opindex fno-gnu-keywords
+Do not recognize @code{typeof} as a keyword, so that code can use this
+word as an identifier.  You can use the keyword @code{__typeof__} instead.
+@option{-ansi} implies @option{-fno-gnu-keywords}.
+
+@item -fno-implicit-templates
+@opindex fno-implicit-templates
+Never emit code for non-inline templates which are instantiated
+implicitly (i.e.@: by use); only emit code for explicit instantiations.
+@xref{Template Instantiation}, for more information.
+
+@item -fno-implicit-inline-templates
+@opindex fno-implicit-inline-templates
+Don't emit code for implicit instantiations of inline templates, either.
+The default is to handle inlines differently so that compiles with and
+without optimization will need the same set of explicit instantiations.
+
+@item -fno-implement-inlines
+@opindex fno-implement-inlines
+To save space, do not emit out-of-line copies of inline functions
+controlled by @samp{#pragma implementation}.  This will cause linker
+errors if these functions are not inlined everywhere they are called.
+
+@item -fms-extensions
+@opindex fms-extensions
+Disable pedantic warnings about constructs used in MFC, such as implicit
+int and getting a pointer to member function via non-standard syntax.
+
+@item -fno-nonansi-builtins
+@opindex fno-nonansi-builtins
+Disable built-in declarations of functions that are not mandated by
+ANSI/ISO C@.  These include @code{ffs}, @code{alloca}, @code{_exit},
+@code{index}, @code{bzero}, @code{conjf}, and other related functions.
+
+@item -fno-operator-names
+@opindex fno-operator-names
+Do not treat the operator name keywords @code{and}, @code{bitand},
+@code{bitor}, @code{compl}, @code{not}, @code{or} and @code{xor} as
+synonyms as keywords.
+
+@item -fno-optional-diags
+@opindex fno-optional-diags
+Disable diagnostics that the standard says a compiler does not need to
+issue.  Currently, the only such diagnostic issued by G++ is the one for
+a name having multiple meanings within a class.
+
+@item -fpermissive
+@opindex fpermissive
+Downgrade some diagnostics about nonconformant code from errors to
+warnings.  Thus, using @option{-fpermissive} will allow some
+nonconforming code to compile.
+
+@item -frepo
+@opindex frepo
+Enable automatic template instantiation at link time.  This option also
+implies @option{-fno-implicit-templates}.  @xref{Template
+Instantiation}, for more information.
+
+@item -fno-rtti
+@opindex fno-rtti
+Disable generation of information about every class with virtual
+functions for use by the C++ runtime type identification features
+(@samp{dynamic_cast} and @samp{typeid}).  If you don't use those parts
+of the language, you can save some space by using this flag.  Note that
+exception handling uses the same information, but it will generate it as
+needed. The @samp{dynamic_cast} operator can still be used for casts that
+do not require runtime type information, i.e.@: casts to @code{void *} or to
+unambiguous base classes.
+
+@item -fstats
+@opindex fstats
+Emit statistics about front-end processing at the end of the compilation.
+This information is generally only useful to the G++ development team.
+
+@item -ftemplate-depth-@var{n}
+@opindex ftemplate-depth
+Set the maximum instantiation depth for template classes to @var{n}.
+A limit on the template instantiation depth is needed to detect
+endless recursions during template class instantiation.  ANSI/ISO C++
+conforming programs must not rely on a maximum depth greater than 17.
+
+@item -fno-threadsafe-statics
+@opindex fno-threadsafe-statics
+Do not emit the extra code to use the routines specified in the C++
+ABI for thread-safe initialization of local statics.  You can use this
+option to reduce code size slightly in code that doesn't need to be
+thread-safe.
+
+@item -fuse-cxa-atexit
+@opindex fuse-cxa-atexit
+Register destructors for objects with static storage duration with the
+@code{__cxa_atexit} function rather than the @code{atexit} function.
+This option is required for fully standards-compliant handling of static
+destructors, but will only work if your C library supports
+@code{__cxa_atexit}.
+
+@item -fno-use-cxa-get-exception-ptr
+@opindex fno-use-cxa-get-exception-ptr
+Don't use the @code{__cxa_get_exception_ptr} runtime routine.  This
+will cause @code{std::uncaught_exception} to be incorrect, but is necessary
+if the runtime routine is not available.
+
+@item -fvisibility-inlines-hidden
+@opindex fvisibility-inlines-hidden
+This switch declares that the user does not attempt to compare
+pointers to inline methods where the addresses of the two functions
+were taken in different shared objects.
+
+The effect of this is that GCC may, effectively, mark inline methods with
+@code{__attribute__ ((visibility ("hidden")))} so that they do not
+appear in the export table of a DSO and do not require a PLT indirection
+when used within the DSO@.  Enabling this option can have a dramatic effect
+on load and link times of a DSO as it massively reduces the size of the
+dynamic export table when the library makes heavy use of templates.
+
+The behavior of this switch is not quite the same as marking the
+methods as hidden directly, because it does not affect static variables
+local to the function or cause the compiler to deduce that
+the function is defined in only one shared object.
+
+You may mark a method as having a visibility explicitly to negate the
+effect of the switch for that method.  For example, if you do want to
+compare pointers to a particular inline method, you might mark it as
+having default visibility.  Marking the enclosing class with explicit
+visibility will have no effect.
+
+Explicitly instantiated inline methods are unaffected by this option
+as their linkage might otherwise cross a shared library boundary.
+@xref{Template Instantiation}.
+
+@item -fvisibility-ms-compat
+@opindex fvisibility-ms-compat
+This flag attempts to use visibility settings to make GCC's C++
+linkage model compatible with that of Microsoft Visual Studio.
+
+The flag makes these changes to GCC's linkage model:
+
+@enumerate
+@item
+It sets the default visibility to @code{hidden}, like
+@option{-fvisibility=hidden}.
+
+@item
+Types, but not their members, are not hidden by default.
+
+@item
+The One Definition Rule is relaxed for types without explicit
+visibility specifications which are defined in more than one different
+shared object: those declarations are permitted if they would have
+been permitted when this option was not used.
+@end enumerate
+
+In new code it is better to use @option{-fvisibility=hidden} and
+export those classes which are intended to be externally visible.
+Unfortunately it is possible for code to rely, perhaps accidentally,
+on the Visual Studio behavior.
+
+Among the consequences of these changes are that static data members
+of the same type with the same name but defined in different shared
+objects will be different, so changing one will not change the other;
+and that pointers to function members defined in different shared
+objects may not compare equal.  When this flag is given, it is a
+violation of the ODR to define types with the same name differently.
+
+@item -fno-weak
+@opindex fno-weak
+Do not use weak symbol support, even if it is provided by the linker.
+By default, G++ will use weak symbols if they are available.  This
+option exists only for testing, and should not be used by end-users;
+it will result in inferior code and has no benefits.  This option may
+be removed in a future release of G++.
+
+@item -nostdinc++
+@opindex nostdinc++
+Do not search for header files in the standard directories specific to
+C++, but do still search the other standard directories.  (This option
+is used when building the C++ library.)
+@end table
+
+In addition, these optimization, warning, and code generation options
+have meanings only for C++ programs:
+
+@table @gcctabopt
+@item -fno-default-inline
+@opindex fno-default-inline
+Do not assume @samp{inline} for functions defined inside a class scope.
+@xref{Optimize Options,,Options That Control Optimization}.  Note that these
+functions will have linkage like inline functions; they just won't be
+inlined by default.
+
+@item -Wabi @r{(C, Objective-C, C++ and Objective-C++ only)}
+@opindex Wabi
+@opindex Wno-abi
+Warn when G++ generates code that is probably not compatible with the
+vendor-neutral C++ ABI@.  Although an effort has been made to warn about
+all such cases, there are probably some cases that are not warned about,
+even though G++ is generating incompatible code.  There may also be
+cases where warnings are emitted even though the code that is generated
+will be compatible.
+
+You should rewrite your code to avoid these warnings if you are
+concerned about the fact that code generated by G++ may not be binary
+compatible with code generated by other compilers.
+
+The known incompatibilities at this point include:
+
+@itemize @bullet
+
+@item
+Incorrect handling of tail-padding for bit-fields.  G++ may attempt to
+pack data into the same byte as a base class.  For example:
+
+@smallexample
+struct A @{ virtual void f(); int f1 : 1; @};
+struct B : public A @{ int f2 : 1; @};
+@end smallexample
+
+@noindent
+In this case, G++ will place @code{B::f2} into the same byte
+as@code{A::f1}; other compilers will not.  You can avoid this problem
+by explicitly padding @code{A} so that its size is a multiple of the
+byte size on your platform; that will cause G++ and other compilers to
+layout @code{B} identically.
+
+@item
+Incorrect handling of tail-padding for virtual bases.  G++ does not use
+tail padding when laying out virtual bases.  For example:
+
+@smallexample
+struct A @{ virtual void f(); char c1; @};
+struct B @{ B(); char c2; @};
+struct C : public A, public virtual B @{@};
+@end smallexample
+
+@noindent
+In this case, G++ will not place @code{B} into the tail-padding for
+@code{A}; other compilers will.  You can avoid this problem by
+explicitly padding @code{A} so that its size is a multiple of its
+alignment (ignoring virtual base classes); that will cause G++ and other
+compilers to layout @code{C} identically.
+
+@item
+Incorrect handling of bit-fields with declared widths greater than that
+of their underlying types, when the bit-fields appear in a union.  For
+example:
+
+@smallexample
+union U @{ int i : 4096; @};
+@end smallexample
+
+@noindent
+Assuming that an @code{int} does not have 4096 bits, G++ will make the
+union too small by the number of bits in an @code{int}.
+
+@item
+Empty classes can be placed at incorrect offsets.  For example:
+
+@smallexample
+struct A @{@};
+
+struct B @{
+  A a;
+  virtual void f ();
+@};
+
+struct C : public B, public A @{@};
+@end smallexample
+
+@noindent
+G++ will place the @code{A} base class of @code{C} at a nonzero offset;
+it should be placed at offset zero.  G++ mistakenly believes that the
+@code{A} data member of @code{B} is already at offset zero.
+
+@item
+Names of template functions whose types involve @code{typename} or
+template template parameters can be mangled incorrectly.
+
+@smallexample
+template <typename Q>
+void f(typename Q::X) @{@}
+
+template <template <typename> class Q>
+void f(typename Q<int>::X) @{@}
+@end smallexample
+
+@noindent
+Instantiations of these templates may be mangled incorrectly.
+
+@end itemize
+
+It also warns psABI related changes.  The known psABI changes at this
+point include:
+
+@itemize @bullet
+
+@item
+For SYSV/x86-64, when passing union with long double, it is changed to
+pass in memory as specified in psABI.  For example:
+
+@smallexample
+union U @{
+  long double ld;
+  int i;
+@};
+@end smallexample
+
+@noindent
+@code{union U} will always be passed in memory.
+
+@end itemize
+
+@item -Wctor-dtor-privacy @r{(C++ and Objective-C++ only)}
+@opindex Wctor-dtor-privacy
+@opindex Wno-ctor-dtor-privacy
+Warn when a class seems unusable because all the constructors or
+destructors in that class are private, and it has neither friends nor
+public static member functions.
+
+@item -Wnon-virtual-dtor @r{(C++ and Objective-C++ only)}
+@opindex Wnon-virtual-dtor
+@opindex Wno-non-virtual-dtor
+Warn when a class has virtual functions and accessible non-virtual
+destructor, in which case it would be possible but unsafe to delete
+an instance of a derived class through a pointer to the base class.
+This warning is also enabled if -Weffc++ is specified.
+
+@item -Wreorder @r{(C++ and Objective-C++ only)}
+@opindex Wreorder
+@opindex Wno-reorder
+@cindex reordering, warning
+@cindex warning for reordering of member initializers
+Warn when the order of member initializers given in the code does not
+match the order in which they must be executed.  For instance:
+
+@smallexample
+struct A @{
+  int i;
+  int j;
+  A(): j (0), i (1) @{ @}
+@};
+@end smallexample
+
+The compiler will rearrange the member initializers for @samp{i}
+and @samp{j} to match the declaration order of the members, emitting
+a warning to that effect.  This warning is enabled by @option{-Wall}.
+@end table
+
+The following @option{-W@dots{}} options are not affected by @option{-Wall}.
+
+@table @gcctabopt
+@item -Weffc++ @r{(C++ and Objective-C++ only)}
+@opindex Weffc++
+@opindex Wno-effc++
+Warn about violations of the following style guidelines from Scott Meyers'
+@cite{Effective C++} book:
+
+@itemize @bullet
+@item
+Item 11:  Define a copy constructor and an assignment operator for classes
+with dynamically allocated memory.
+
+@item
+Item 12:  Prefer initialization to assignment in constructors.
+
+@item
+Item 14:  Make destructors virtual in base classes.
+
+@item
+Item 15:  Have @code{operator=} return a reference to @code{*this}.
+
+@item
+Item 23:  Don't try to return a reference when you must return an object.
+
+@end itemize
+
+Also warn about violations of the following style guidelines from
+Scott Meyers' @cite{More Effective C++} book:
+
+@itemize @bullet
+@item
+Item 6:  Distinguish between prefix and postfix forms of increment and
+decrement operators.
+
+@item
+Item 7:  Never overload @code{&&}, @code{||}, or @code{,}.
+
+@end itemize
+
+When selecting this option, be aware that the standard library
+headers do not obey all of these guidelines; use @samp{grep -v}
+to filter out those warnings.
+
+@item -Wstrict-null-sentinel @r{(C++ and Objective-C++ only)}
+@opindex Wstrict-null-sentinel
+@opindex Wno-strict-null-sentinel
+Warn also about the use of an uncasted @code{NULL} as sentinel.  When
+compiling only with GCC this is a valid sentinel, as @code{NULL} is defined
+to @code{__null}.  Although it is a null pointer constant not a null pointer,
+it is guaranteed to be of the same size as a pointer.  But this use is
+not portable across different compilers.
+
+@item -Wno-non-template-friend @r{(C++ and Objective-C++ only)}
+@opindex Wno-non-template-friend
+@opindex Wnon-template-friend
+Disable warnings when non-templatized friend functions are declared
+within a template.  Since the advent of explicit template specification
+support in G++, if the name of the friend is an unqualified-id (i.e.,
+@samp{friend foo(int)}), the C++ language specification demands that the
+friend declare or define an ordinary, nontemplate function.  (Section
+14.5.3).  Before G++ implemented explicit specification, unqualified-ids
+could be interpreted as a particular specialization of a templatized
+function.  Because this non-conforming behavior is no longer the default
+behavior for G++, @option{-Wnon-template-friend} allows the compiler to
+check existing code for potential trouble spots and is on by default.
+This new compiler behavior can be turned off with
+@option{-Wno-non-template-friend} which keeps the conformant compiler code
+but disables the helpful warning.
+
+@item -Wold-style-cast @r{(C++ and Objective-C++ only)}
+@opindex Wold-style-cast
+@opindex Wno-old-style-cast
+Warn if an old-style (C-style) cast to a non-void type is used within
+a C++ program.  The new-style casts (@samp{dynamic_cast},
+@samp{static_cast}, @samp{reinterpret_cast}, and @samp{const_cast}) are
+less vulnerable to unintended effects and much easier to search for.
+
+@item -Woverloaded-virtual @r{(C++ and Objective-C++ only)}
+@opindex Woverloaded-virtual
+@opindex Wno-overloaded-virtual
+@cindex overloaded virtual fn, warning
+@cindex warning for overloaded virtual fn
+Warn when a function declaration hides virtual functions from a
+base class.  For example, in:
+
+@smallexample
+struct A @{
+  virtual void f();
+@};
+
+struct B: public A @{
+  void f(int);
+@};
+@end smallexample
+
+the @code{A} class version of @code{f} is hidden in @code{B}, and code
+like:
+
+@smallexample
+B* b;
+b->f();
+@end smallexample
+
+will fail to compile.
+
+@item -Wno-pmf-conversions @r{(C++ and Objective-C++ only)}
+@opindex Wno-pmf-conversions
+@opindex Wpmf-conversions
+Disable the diagnostic for converting a bound pointer to member function
+to a plain pointer.
+
+@item -Wsign-promo @r{(C++ and Objective-C++ only)}
+@opindex Wsign-promo
+@opindex Wno-sign-promo
+Warn when overload resolution chooses a promotion from unsigned or
+enumerated type to a signed type, over a conversion to an unsigned type of
+the same size.  Previous versions of G++ would try to preserve
+unsignedness, but the standard mandates the current behavior.
+
+@smallexample
+struct A @{
+  operator int ();
+  A& operator = (int);
+@};
+
+main ()
+@{
+  A a,b;
+  a = b;
+@}
+@end smallexample
+
+In this example, G++ will synthesize a default @samp{A& operator =
+(const A&);}, while cfront will use the user-defined @samp{operator =}.
+@end table
+
+@node Objective-C and Objective-C++ Dialect Options
+@section Options Controlling Objective-C and Objective-C++ Dialects
+
+@cindex compiler options, Objective-C and Objective-C++
+@cindex Objective-C and Objective-C++ options, command line
+@cindex options, Objective-C and Objective-C++
+(NOTE: This manual does not describe the Objective-C and Objective-C++
+languages themselves.  See @xref{Standards,,Language Standards
+Supported by GCC}, for references.)
+
+This section describes the command-line options that are only meaningful
+for Objective-C and Objective-C++ programs, but you can also use most of
+the language-independent GNU compiler options.
+For example, you might compile a file @code{some_class.m} like this:
+
+@smallexample
+gcc -g -fgnu-runtime -O -c some_class.m
+@end smallexample
+
+@noindent
+In this example, @option{-fgnu-runtime} is an option meant only for
+Objective-C and Objective-C++ programs; you can use the other options with
+any language supported by GCC@.
+
+Note that since Objective-C is an extension of the C language, Objective-C
+compilations may also use options specific to the C front-end (e.g.,
+@option{-Wtraditional}).  Similarly, Objective-C++ compilations may use
+C++-specific options (e.g., @option{-Wabi}).
+
+Here is a list of options that are @emph{only} for compiling Objective-C
+and Objective-C++ programs:
+
+@table @gcctabopt
+@item -fconstant-string-class=@var{class-name}
+@opindex fconstant-string-class
+Use @var{class-name} as the name of the class to instantiate for each
+literal string specified with the syntax @code{@@"@dots{}"}.  The default
+class name is @code{NXConstantString} if the GNU runtime is being used, and
+@code{NSConstantString} if the NeXT runtime is being used (see below).  The
+@option{-fconstant-cfstrings} option, if also present, will override the
+@option{-fconstant-string-class} setting and cause @code{@@"@dots{}"} literals
+to be laid out as constant CoreFoundation strings.
+
+@item -fgnu-runtime
+@opindex fgnu-runtime
+Generate object code compatible with the standard GNU Objective-C
+runtime.  This is the default for most types of systems.
+
+@item -fnext-runtime
+@opindex fnext-runtime
+Generate output compatible with the NeXT runtime.  This is the default
+for NeXT-based systems, including Darwin and Mac OS X@.  The macro
+@code{__NEXT_RUNTIME__} is predefined if (and only if) this option is
+used.
+
+@item -fno-nil-receivers
+@opindex fno-nil-receivers
+Assume that all Objective-C message dispatches (e.g.,
+@code{[receiver message:arg]}) in this translation unit ensure that the receiver
+is not @code{nil}.  This allows for more efficient entry points in the runtime
+to be used.  Currently, this option is only available in conjunction with
+the NeXT runtime on Mac OS X 10.3 and later.
+
+@item -fobjc-call-cxx-cdtors
+@opindex fobjc-call-cxx-cdtors
+For each Objective-C class, check if any of its instance variables is a
+C++ object with a non-trivial default constructor.  If so, synthesize a
+special @code{- (id) .cxx_construct} instance method that will run
+non-trivial default constructors on any such instance variables, in order,
+and then return @code{self}.  Similarly, check if any instance variable
+is a C++ object with a non-trivial destructor, and if so, synthesize a
+special @code{- (void) .cxx_destruct} method that will run
+all such default destructors, in reverse order.
+
+The @code{- (id) .cxx_construct} and/or @code{- (void) .cxx_destruct} methods
+thusly generated will only operate on instance variables declared in the
+current Objective-C class, and not those inherited from superclasses.  It
+is the responsibility of the Objective-C runtime to invoke all such methods
+in an object's inheritance hierarchy.  The @code{- (id) .cxx_construct} methods
+will be invoked by the runtime immediately after a new object
+instance is allocated; the @code{- (void) .cxx_destruct} methods will
+be invoked immediately before the runtime deallocates an object instance.
+
+As of this writing, only the NeXT runtime on Mac OS X 10.4 and later has
+support for invoking the @code{- (id) .cxx_construct} and
+@code{- (void) .cxx_destruct} methods.
+
+@item -fobjc-direct-dispatch
+@opindex fobjc-direct-dispatch
+Allow fast jumps to the message dispatcher.  On Darwin this is
+accomplished via the comm page.
+
+@item -fobjc-exceptions
+@opindex fobjc-exceptions
+Enable syntactic support for structured exception handling in Objective-C,
+similar to what is offered by C++ and Java.  This option is
+unavailable in conjunction with the NeXT runtime on Mac OS X 10.2 and
+earlier.
+
+@smallexample
+  @@try @{
+    @dots{}
+       @@throw expr;
+    @dots{}
+  @}
+  @@catch (AnObjCClass *exc) @{
+    @dots{}
+      @@throw expr;
+    @dots{}
+      @@throw;
+    @dots{}
+  @}
+  @@catch (AnotherClass *exc) @{
+    @dots{}
+  @}
+  @@catch (id allOthers) @{
+    @dots{}
+  @}
+  @@finally @{
+    @dots{}
+      @@throw expr;
+    @dots{}
+  @}
+@end smallexample
+
+The @code{@@throw} statement may appear anywhere in an Objective-C or
+Objective-C++ program; when used inside of a @code{@@catch} block, the
+@code{@@throw} may appear without an argument (as shown above), in which case
+the object caught by the @code{@@catch} will be rethrown.
+
+Note that only (pointers to) Objective-C objects may be thrown and
+caught using this scheme.  When an object is thrown, it will be caught
+by the nearest @code{@@catch} clause capable of handling objects of that type,
+analogously to how @code{catch} blocks work in C++ and Java.  A
+@code{@@catch(id @dots{})} clause (as shown above) may also be provided to catch
+any and all Objective-C exceptions not caught by previous @code{@@catch}
+clauses (if any).
+
+The @code{@@finally} clause, if present, will be executed upon exit from the
+immediately preceding @code{@@try @dots{} @@catch} section.  This will happen
+regardless of whether any exceptions are thrown, caught or rethrown
+inside the @code{@@try @dots{} @@catch} section, analogously to the behavior
+of the @code{finally} clause in Java.
+
+There are several caveats to using the new exception mechanism:
+
+@itemize @bullet
+@item
+Although currently designed to be binary compatible with @code{NS_HANDLER}-style
+idioms provided by the @code{NSException} class, the new
+exceptions can only be used on Mac OS X 10.3 (Panther) and later
+systems, due to additional functionality needed in the (NeXT) Objective-C
+runtime.
+
+@item
+As mentioned above, the new exceptions do not support handling
+types other than Objective-C objects.   Furthermore, when used from
+Objective-C++, the Objective-C exception model does not interoperate with C++
+exceptions at this time.  This means you cannot @code{@@throw} an exception
+from Objective-C and @code{catch} it in C++, or vice versa
+(i.e., @code{throw @dots{} @@catch}).
+@end itemize
+
+The @option{-fobjc-exceptions} switch also enables the use of synchronization
+blocks for thread-safe execution:
+
+@smallexample
+  @@synchronized (ObjCClass *guard) @{
+    @dots{}
+  @}
+@end smallexample
+
+Upon entering the @code{@@synchronized} block, a thread of execution shall
+first check whether a lock has been placed on the corresponding @code{guard}
+object by another thread.  If it has, the current thread shall wait until
+the other thread relinquishes its lock.  Once @code{guard} becomes available,
+the current thread will place its own lock on it, execute the code contained in
+the @code{@@synchronized} block, and finally relinquish the lock (thereby
+making @code{guard} available to other threads).
+
+Unlike Java, Objective-C does not allow for entire methods to be marked
+@code{@@synchronized}.  Note that throwing exceptions out of
+@code{@@synchronized} blocks is allowed, and will cause the guarding object
+to be unlocked properly.
+
+@item -fobjc-gc
+@opindex fobjc-gc
+Enable garbage collection (GC) in Objective-C and Objective-C++ programs.
+
+@item -freplace-objc-classes
+@opindex freplace-objc-classes
+Emit a special marker instructing @command{ld(1)} not to statically link in
+the resulting object file, and allow @command{dyld(1)} to load it in at
+run time instead.  This is used in conjunction with the Fix-and-Continue
+debugging mode, where the object file in question may be recompiled and
+dynamically reloaded in the course of program execution, without the need
+to restart the program itself.  Currently, Fix-and-Continue functionality
+is only available in conjunction with the NeXT runtime on Mac OS X 10.3
+and later.
+
+@item -fzero-link
+@opindex fzero-link
+When compiling for the NeXT runtime, the compiler ordinarily replaces calls
+to @code{objc_getClass("@dots{}")} (when the name of the class is known at
+compile time) with static class references that get initialized at load time,
+which improves run-time performance.  Specifying the @option{-fzero-link} flag
+suppresses this behavior and causes calls to @code{objc_getClass("@dots{}")}
+to be retained.  This is useful in Zero-Link debugging mode, since it allows
+for individual class implementations to be modified during program execution.
+
+@item -gen-decls
+@opindex gen-decls
+Dump interface declarations for all classes seen in the source file to a
+file named @file{@var{sourcename}.decl}.
+
+@item -Wassign-intercept @r{(Objective-C and Objective-C++ only)}
+@opindex Wassign-intercept
+@opindex Wno-assign-intercept
+Warn whenever an Objective-C assignment is being intercepted by the
+garbage collector.
+
+@item -Wno-protocol @r{(Objective-C and Objective-C++ only)}
+@opindex Wno-protocol
+@opindex Wprotocol
+If a class is declared to implement a protocol, a warning is issued for
+every method in the protocol that is not implemented by the class.  The
+default behavior is to issue a warning for every method not explicitly
+implemented in the class, even if a method implementation is inherited
+from the superclass.  If you use the @option{-Wno-protocol} option, then
+methods inherited from the superclass are considered to be implemented,
+and no warning is issued for them.
+
+@item -Wselector @r{(Objective-C and Objective-C++ only)}
+@opindex Wselector
+@opindex Wno-selector
+Warn if multiple methods of different types for the same selector are
+found during compilation.  The check is performed on the list of methods
+in the final stage of compilation.  Additionally, a check is performed
+for each selector appearing in a @code{@@selector(@dots{})}
+expression, and a corresponding method for that selector has been found
+during compilation.  Because these checks scan the method table only at
+the end of compilation, these warnings are not produced if the final
+stage of compilation is not reached, for example because an error is
+found during compilation, or because the @option{-fsyntax-only} option is
+being used.
+
+@item -Wstrict-selector-match @r{(Objective-C and Objective-C++ only)}
+@opindex Wstrict-selector-match
+@opindex Wno-strict-selector-match
+Warn if multiple methods with differing argument and/or return types are
+found for a given selector when attempting to send a message using this
+selector to a receiver of type @code{id} or @code{Class}.  When this flag
+is off (which is the default behavior), the compiler will omit such warnings
+if any differences found are confined to types which share the same size
+and alignment.
+
+@item -Wundeclared-selector @r{(Objective-C and Objective-C++ only)}
+@opindex Wundeclared-selector
+@opindex Wno-undeclared-selector
+Warn if a @code{@@selector(@dots{})} expression referring to an
+undeclared selector is found.  A selector is considered undeclared if no
+method with that name has been declared before the
+@code{@@selector(@dots{})} expression, either explicitly in an
+@code{@@interface} or @code{@@protocol} declaration, or implicitly in
+an @code{@@implementation} section.  This option always performs its
+checks as soon as a @code{@@selector(@dots{})} expression is found,
+while @option{-Wselector} only performs its checks in the final stage of
+compilation.  This also enforces the coding style convention
+that methods and selectors must be declared before being used.
+
+@item -print-objc-runtime-info
+@opindex print-objc-runtime-info
+Generate C header describing the largest structure that is passed by
+value, if any.
+
+@end table
+
+@node Language Independent Options
+@section Options to Control Diagnostic Messages Formatting
+@cindex options to control diagnostics formatting
+@cindex diagnostic messages
+@cindex message formatting
+
+Traditionally, diagnostic messages have been formatted irrespective of
+the output device's aspect (e.g.@: its width, @dots{}).  The options described
+below can be used to control the diagnostic messages formatting
+algorithm, e.g.@: how many characters per line, how often source location
+information should be reported.  Right now, only the C++ front end can
+honor these options.  However it is expected, in the near future, that
+the remaining front ends would be able to digest them correctly.
+
+@table @gcctabopt
+@item -fmessage-length=@var{n}
+@opindex fmessage-length
+Try to format error messages so that they fit on lines of about @var{n}
+characters.  The default is 72 characters for @command{g++} and 0 for the rest of
+the front ends supported by GCC@.  If @var{n} is zero, then no
+line-wrapping will be done; each error message will appear on a single
+line.
+
+@opindex fdiagnostics-show-location
+@item -fdiagnostics-show-location=once
+Only meaningful in line-wrapping mode.  Instructs the diagnostic messages
+reporter to emit @emph{once} source location information; that is, in
+case the message is too long to fit on a single physical line and has to
+be wrapped, the source location won't be emitted (as prefix) again,
+over and over, in subsequent continuation lines.  This is the default
+behavior.
+
+@item -fdiagnostics-show-location=every-line
+Only meaningful in line-wrapping mode.  Instructs the diagnostic
+messages reporter to emit the same source location information (as
+prefix) for physical lines that result from the process of breaking
+a message which is too long to fit on a single line.
+
+@item -fdiagnostics-show-option
+@opindex fdiagnostics-show-option
+This option instructs the diagnostic machinery to add text to each
+diagnostic emitted, which indicates which command line option directly
+controls that diagnostic, when such an option is known to the
+diagnostic machinery.
+
+@item -Wcoverage-mismatch
+@opindex Wcoverage-mismatch
+Warn if feedback profiles do not match when using the
+@option{-fprofile-use} option.
+If a source file was changed between @option{-fprofile-gen} and
+@option{-fprofile-use}, the files with the profile feedback can fail
+to match the source file and GCC can not use the profile feedback
+information.  By default, GCC emits an error message in this case.
+The option @option{-Wcoverage-mismatch} emits a warning instead of an
+error.  GCC does not use appropriate feedback profiles, so using this
+option can result in poorly optimized code.  This option is useful
+only in the case of very minor changes such as bug fixes to an
+existing code-base.
+
+@end table
+
+@node Warning Options
+@section Options to Request or Suppress Warnings
+@cindex options to control warnings
+@cindex warning messages
+@cindex messages, warning
+@cindex suppressing warnings
+
+Warnings are diagnostic messages that report constructions which
+are not inherently erroneous but which are risky or suggest there
+may have been an error.
+
+The following language-independent options do not enable specific
+warnings but control the kinds of diagnostics produced by GCC.
+
+@table @gcctabopt
+@cindex syntax checking
+@item -fsyntax-only
+@opindex fsyntax-only
+Check the code for syntax errors, but don't do anything beyond that.
+
+@item -w
+@opindex w
+Inhibit all warning messages.
+
+@item -Werror
+@opindex Werror
+@opindex Wno-error
+Make all warnings into errors.
+
+@item -Werror=
+@opindex Werror=
+@opindex Wno-error=
+Make the specified warning into an error.  The specifier for a warning
+is appended, for example @option{-Werror=switch} turns the warnings
+controlled by @option{-Wswitch} into errors.  This switch takes a
+negative form, to be used to negate @option{-Werror} for specific
+warnings, for example @option{-Wno-error=switch} makes
+@option{-Wswitch} warnings not be errors, even when @option{-Werror}
+is in effect.  You can use the @option{-fdiagnostics-show-option}
+option to have each controllable warning amended with the option which
+controls it, to determine what to use with this option.
+
+Note that specifying @option{-Werror=}@var{foo} automatically implies
+@option{-W}@var{foo}.  However, @option{-Wno-error=}@var{foo} does not
+imply anything.
+
+@item -Wfatal-errors
+@opindex Wfatal-errors
+@opindex Wno-fatal-errors
+This option causes the compiler to abort compilation on the first error
+occurred rather than trying to keep going and printing further error
+messages.
+
+@end table
+
+You can request many specific warnings with options beginning
+@samp{-W}, for example @option{-Wimplicit} to request warnings on
+implicit declarations.  Each of these specific warning options also
+has a negative form beginning @samp{-Wno-} to turn off warnings; for
+example, @option{-Wno-implicit}.  This manual lists only one of the
+two forms, whichever is not the default.  For further,
+language-specific options also refer to @ref{C++ Dialect Options} and
+@ref{Objective-C and Objective-C++ Dialect Options}.
+
+@table @gcctabopt
+@item -pedantic
+@opindex pedantic
+Issue all the warnings demanded by strict ISO C and ISO C++;
+reject all programs that use forbidden extensions, and some other
+programs that do not follow ISO C and ISO C++.  For ISO C, follows the
+version of the ISO C standard specified by any @option{-std} option used.
+
+Valid ISO C and ISO C++ programs should compile properly with or without
+this option (though a rare few will require @option{-ansi} or a
+@option{-std} option specifying the required version of ISO C)@.  However,
+without this option, certain GNU extensions and traditional C and C++
+features are supported as well.  With this option, they are rejected.
+
+@option{-pedantic} does not cause warning messages for use of the
+alternate keywords whose names begin and end with @samp{__}.  Pedantic
+warnings are also disabled in the expression that follows
+@code{__extension__}.  However, only system header files should use
+these escape routes; application programs should avoid them.
+@xref{Alternate Keywords}.
+
+Some users try to use @option{-pedantic} to check programs for strict ISO
+C conformance.  They soon find that it does not do quite what they want:
+it finds some non-ISO practices, but not all---only those for which
+ISO C @emph{requires} a diagnostic, and some others for which
+diagnostics have been added.
+
+A feature to report any failure to conform to ISO C might be useful in
+some instances, but would require considerable additional work and would
+be quite different from @option{-pedantic}.  We don't have plans to
+support such a feature in the near future.
+
+Where the standard specified with @option{-std} represents a GNU
+extended dialect of C, such as @samp{gnu89} or @samp{gnu99}, there is a
+corresponding @dfn{base standard}, the version of ISO C on which the GNU
+extended dialect is based.  Warnings from @option{-pedantic} are given
+where they are required by the base standard.  (It would not make sense
+for such warnings to be given only for features not in the specified GNU
+C dialect, since by definition the GNU dialects of C include all
+features the compiler supports with the given option, and there would be
+nothing to warn about.)
+
+@item -pedantic-errors
+@opindex pedantic-errors
+Like @option{-pedantic}, except that errors are produced rather than
+warnings.
+
+@item -Wall
+@opindex Wall
+@opindex Wno-all
+This enables all the warnings about constructions that some users
+consider questionable, and that are easy to avoid (or modify to
+prevent the warning), even in conjunction with macros.  This also
+enables some language-specific warnings described in @ref{C++ Dialect
+Options} and @ref{Objective-C and Objective-C++ Dialect Options}.
+
+@option{-Wall} turns on the following warning flags:
+
+@gccoptlist{-Waddress   @gol
+-Warray-bounds @r{(only with} @option{-O2}@r{)}  @gol
+-Wc++0x-compat  @gol
+-Wchar-subscripts  @gol
+-Wimplicit-int  @gol
+-Wimplicit-function-declaration  @gol
+-Wcomment  @gol
+-Wformat   @gol
+-Wmain @r{(only for C/ObjC and unless} @option{-ffreestanding}@r{)}  @gol
+-Wmissing-braces  @gol
+-Wnonnull  @gol
+-Wparentheses  @gol
+-Wpointer-sign  @gol
+-Wreorder   @gol
+-Wreturn-type  @gol
+-Wsequence-point  @gol
+-Wsign-compare @r{(only in C++)}  @gol
+-Wstrict-aliasing  @gol
+-Wstrict-overflow=1  @gol
+-Wswitch  @gol
+-Wtrigraphs  @gol
+-Wuninitialized  @gol
+-Wunknown-pragmas  @gol
+-Wunused-function  @gol
+-Wunused-label     @gol
+-Wunused-value     @gol
+-Wunused-variable  @gol
+-Wvolatile-register-var @gol
+}
+
+Note that some warning flags are not implied by @option{-Wall}.  Some of
+them warn about constructions that users generally do not consider
+questionable, but which occasionally you might wish to check for;
+others warn about constructions that are necessary or hard to avoid in
+some cases, and there is no simple way to modify the code to suppress
+the warning. Some of them are enabled by @option{-Wextra} but many of
+them must be enabled individually.
+
+@item -Wextra
+@opindex W
+@opindex Wextra
+@opindex Wno-extra
+This enables some extra warning flags that are not enabled by
+@option{-Wall}. (This option used to be called @option{-W}.  The older
+name is still supported, but the newer name is more descriptive.)
+
+@gccoptlist{-Wclobbered  @gol
+-Wempty-body  @gol
+-Wignored-qualifiers @gol
+-Wmissing-field-initializers  @gol
+-Wmissing-parameter-type @r{(C only)}  @gol
+-Wold-style-declaration @r{(C only)}  @gol
+-Woverride-init  @gol
+-Wsign-compare  @gol
+-Wtype-limits  @gol
+-Wuninitialized  @gol
+-Wunused-parameter @r{(only with} @option{-Wunused} @r{or} @option{-Wall}@r{)}  @gol
+}
+
+The option @option{-Wextra} also prints warning messages for the
+following cases:
+
+@itemize @bullet
+
+@item
+A pointer is compared against integer zero with @samp{<}, @samp{<=},
+@samp{>}, or @samp{>=}.
+
+@item 
+(C++ only) An enumerator and a non-enumerator both appear in a
+conditional expression.
+
+@item 
+(C++ only) Ambiguous virtual bases.
+
+@item 
+(C++ only) Subscripting an array which has been declared @samp{register}.
+
+@item 
+(C++ only) Taking the address of a variable which has been declared
+@samp{register}.
+
+@item 
+(C++ only) A base class is not initialized in a derived class' copy
+constructor.
+
+@end itemize
+
+@item -Wchar-subscripts
+@opindex Wchar-subscripts
+@opindex Wno-char-subscripts
+Warn if an array subscript has type @code{char}.  This is a common cause
+of error, as programmers often forget that this type is signed on some
+machines.
+This warning is enabled by @option{-Wall}.
+
+@item -Wcomment
+@opindex Wcomment
+@opindex Wno-comment
+Warn whenever a comment-start sequence @samp{/*} appears in a @samp{/*}
+comment, or whenever a Backslash-Newline appears in a @samp{//} comment.
+This warning is enabled by @option{-Wall}.
+
+@item -Wformat
+@opindex Wformat
+@opindex Wno-format
+@opindex ffreestanding
+@opindex fno-builtin
+Check calls to @code{printf} and @code{scanf}, etc., to make sure that
+the arguments supplied have types appropriate to the format string
+specified, and that the conversions specified in the format string make
+sense.  This includes standard functions, and others specified by format
+attributes (@pxref{Function Attributes}), in the @code{printf},
+@code{scanf}, @code{strftime} and @code{strfmon} (an X/Open extension,
+not in the C standard) families (or other target-specific families).
+Which functions are checked without format attributes having been
+specified depends on the standard version selected, and such checks of
+functions without the attribute specified are disabled by
+@option{-ffreestanding} or @option{-fno-builtin}.
+
+The formats are checked against the format features supported by GNU
+libc version 2.2.  These include all ISO C90 and C99 features, as well
+as features from the Single Unix Specification and some BSD and GNU
+extensions.  Other library implementations may not support all these
+features; GCC does not support warning about features that go beyond a
+particular library's limitations.  However, if @option{-pedantic} is used
+with @option{-Wformat}, warnings will be given about format features not
+in the selected standard version (but not for @code{strfmon} formats,
+since those are not in any version of the C standard).  @xref{C Dialect
+Options,,Options Controlling C Dialect}.
+
+Since @option{-Wformat} also checks for null format arguments for
+several functions, @option{-Wformat} also implies @option{-Wnonnull}.
+
+@option{-Wformat} is included in @option{-Wall}.  For more control over some
+aspects of format checking, the options @option{-Wformat-y2k},
+@option{-Wno-format-extra-args}, @option{-Wno-format-zero-length},
+@option{-Wformat-nonliteral}, @option{-Wformat-security}, and
+@option{-Wformat=2} are available, but are not included in @option{-Wall}.
+
+@item -Wformat-y2k
+@opindex Wformat-y2k
+@opindex Wno-format-y2k
+If @option{-Wformat} is specified, also warn about @code{strftime}
+formats which may yield only a two-digit year.
+
+@item -Wno-format-contains-nul
+@opindex Wno-format-contains-nul
+@opindex Wformat-contains-nul
+If @option{-Wformat} is specified, do not warn about format strings that
+contain NUL bytes.
+
+@item -Wno-format-extra-args
+@opindex Wno-format-extra-args
+@opindex Wformat-extra-args
+If @option{-Wformat} is specified, do not warn about excess arguments to a
+@code{printf} or @code{scanf} format function.  The C standard specifies
+that such arguments are ignored.
+
+Where the unused arguments lie between used arguments that are
+specified with @samp{$} operand number specifications, normally
+warnings are still given, since the implementation could not know what
+type to pass to @code{va_arg} to skip the unused arguments.  However,
+in the case of @code{scanf} formats, this option will suppress the
+warning if the unused arguments are all pointers, since the Single
+Unix Specification says that such unused arguments are allowed.
+
+@item -Wno-format-zero-length @r{(C and Objective-C only)}
+@opindex Wno-format-zero-length
+@opindex Wformat-zero-length
+If @option{-Wformat} is specified, do not warn about zero-length formats.
+The C standard specifies that zero-length formats are allowed.
+
+@item -Wformat-nonliteral
+@opindex Wformat-nonliteral
+@opindex Wno-format-nonliteral
+If @option{-Wformat} is specified, also warn if the format string is not a
+string literal and so cannot be checked, unless the format function
+takes its format arguments as a @code{va_list}.
+
+@item -Wformat-security
+@opindex Wformat-security
+@opindex Wno-format-security
+If @option{-Wformat} is specified, also warn about uses of format
+functions that represent possible security problems.  At present, this
+warns about calls to @code{printf} and @code{scanf} functions where the
+format string is not a string literal and there are no format arguments,
+as in @code{printf (foo);}.  This may be a security hole if the format
+string came from untrusted input and contains @samp{%n}.  (This is
+currently a subset of what @option{-Wformat-nonliteral} warns about, but
+in future warnings may be added to @option{-Wformat-security} that are not
+included in @option{-Wformat-nonliteral}.)
+
+@item -Wformat=2
+@opindex Wformat=2
+@opindex Wno-format=2
+Enable @option{-Wformat} plus format checks not included in
+@option{-Wformat}.  Currently equivalent to @samp{-Wformat
+-Wformat-nonliteral -Wformat-security -Wformat-y2k}.
+
+@item -Wnonnull @r{(C and Objective-C only)}
+@opindex Wnonnull
+@opindex Wno-nonnull
+Warn about passing a null pointer for arguments marked as
+requiring a non-null value by the @code{nonnull} function attribute.
+
+@option{-Wnonnull} is included in @option{-Wall} and @option{-Wformat}.  It
+can be disabled with the @option{-Wno-nonnull} option.
+
+@item -Winit-self @r{(C, C++, Objective-C and Objective-C++ only)}
+@opindex Winit-self
+@opindex Wno-init-self
+Warn about uninitialized variables which are initialized with themselves.
+Note this option can only be used with the @option{-Wuninitialized} option.
+
+For example, GCC will warn about @code{i} being uninitialized in the
+following snippet only when @option{-Winit-self} has been specified:
+@smallexample
+@group
+int f()
+@{
+  int i = i;
+  return i;
+@}
+@end group
+@end smallexample
+
+@item -Wimplicit-int @r{(C and Objective-C only)}
+@opindex Wimplicit-int
+@opindex Wno-implicit-int
+Warn when a declaration does not specify a type.
+This warning is enabled by @option{-Wall}.
+
+@item -Wimplicit-function-declaration @r{(C and Objective-C only)}
+@opindex Wimplicit-function-declaration
+@opindex Wno-implicit-function-declaration
+Give a warning whenever a function is used before being declared. In
+C99 mode (@option{-std=c99} or @option{-std=gnu99}), this warning is
+enabled by default and it is made into an error by
+@option{-pedantic-errors}. This warning is also enabled by
+@option{-Wall}.
+
+@item -Wimplicit
+@opindex Wimplicit
+@opindex Wno-implicit
+Same as @option{-Wimplicit-int} and @option{-Wimplicit-function-declaration}.
+This warning is enabled by @option{-Wall}.
+
+@item -Wignored-qualifiers @r{(C and C++ only)}
+@opindex Wignored-qualifiers
+@opindex Wno-ignored-qualifiers
+Warn if the return type of a function has a type qualifier
+such as @code{const}.  For ISO C such a type qualifier has no effect,
+since the value returned by a function is not an lvalue.
+For C++, the warning is only emitted for scalar types or @code{void}.
+ISO C prohibits qualified @code{void} return types on function
+definitions, so such return types always receive a warning
+even without this option.
+
+This warning is also enabled by @option{-Wextra}.
+
+@item -Wmain
+@opindex Wmain
+@opindex Wno-main
+Warn if the type of @samp{main} is suspicious.  @samp{main} should be
+a function with external linkage, returning int, taking either zero
+arguments, two, or three arguments of appropriate types.  This warning
+is enabled by default in C++ and is enabled by either @option{-Wall}
+or @option{-pedantic}.
+
+@item -Wmissing-braces
+@opindex Wmissing-braces
+@opindex Wno-missing-braces
+Warn if an aggregate or union initializer is not fully bracketed.  In
+the following example, the initializer for @samp{a} is not fully
+bracketed, but that for @samp{b} is fully bracketed.
+
+@smallexample
+int a[2][2] = @{ 0, 1, 2, 3 @};
+int b[2][2] = @{ @{ 0, 1 @}, @{ 2, 3 @} @};
+@end smallexample
+
+This warning is enabled by @option{-Wall}.
+
+@item -Wmissing-include-dirs @r{(C, C++, Objective-C and Objective-C++ only)}
+@opindex Wmissing-include-dirs
+@opindex Wno-missing-include-dirs
+Warn if a user-supplied include directory does not exist.
+
+@item -Wparentheses
+@opindex Wparentheses
+@opindex Wno-parentheses
+Warn if parentheses are omitted in certain contexts, such
+as when there is an assignment in a context where a truth value
+is expected, or when operators are nested whose precedence people
+often get confused about.
+
+Also warn if a comparison like @samp{x<=y<=z} appears; this is
+equivalent to @samp{(x<=y ? 1 : 0) <= z}, which is a different
+interpretation from that of ordinary mathematical notation.
+
+Also warn about constructions where there may be confusion to which
+@code{if} statement an @code{else} branch belongs.  Here is an example of
+such a case:
+
+@smallexample
+@group
+@{
+  if (a)
+    if (b)
+      foo ();
+  else
+    bar ();
+@}
+@end group
+@end smallexample
+
+In C/C++, every @code{else} branch belongs to the innermost possible
+@code{if} statement, which in this example is @code{if (b)}.  This is
+often not what the programmer expected, as illustrated in the above
+example by indentation the programmer chose.  When there is the
+potential for this confusion, GCC will issue a warning when this flag
+is specified.  To eliminate the warning, add explicit braces around
+the innermost @code{if} statement so there is no way the @code{else}
+could belong to the enclosing @code{if}.  The resulting code would
+look like this:
+
+@smallexample
+@group
+@{
+  if (a)
+    @{
+      if (b)
+        foo ();
+      else
+        bar ();
+    @}
+@}
+@end group
+@end smallexample
+
+This warning is enabled by @option{-Wall}.
+
+@item -Wsequence-point
+@opindex Wsequence-point
+@opindex Wno-sequence-point
+Warn about code that may have undefined semantics because of violations
+of sequence point rules in the C and C++ standards.
+
+The C and C++ standards defines the order in which expressions in a C/C++
+program are evaluated in terms of @dfn{sequence points}, which represent
+a partial ordering between the execution of parts of the program: those
+executed before the sequence point, and those executed after it.  These
+occur after the evaluation of a full expression (one which is not part
+of a larger expression), after the evaluation of the first operand of a
+@code{&&}, @code{||}, @code{? :} or @code{,} (comma) operator, before a
+function is called (but after the evaluation of its arguments and the
+expression denoting the called function), and in certain other places.
+Other than as expressed by the sequence point rules, the order of
+evaluation of subexpressions of an expression is not specified.  All
+these rules describe only a partial order rather than a total order,
+since, for example, if two functions are called within one expression
+with no sequence point between them, the order in which the functions
+are called is not specified.  However, the standards committee have
+ruled that function calls do not overlap.
+
+It is not specified when between sequence points modifications to the
+values of objects take effect.  Programs whose behavior depends on this
+have undefined behavior; the C and C++ standards specify that ``Between
+the previous and next sequence point an object shall have its stored
+value modified at most once by the evaluation of an expression.
+Furthermore, the prior value shall be read only to determine the value
+to be stored.''.  If a program breaks these rules, the results on any
+particular implementation are entirely unpredictable.
+
+Examples of code with undefined behavior are @code{a = a++;}, @code{a[n]
+= b[n++]} and @code{a[i++] = i;}.  Some more complicated cases are not
+diagnosed by this option, and it may give an occasional false positive
+result, but in general it has been found fairly effective at detecting
+this sort of problem in programs.
+
+The standard is worded confusingly, therefore there is some debate
+over the precise meaning of the sequence point rules in subtle cases.
+Links to discussions of the problem, including proposed formal
+definitions, may be found on the GCC readings page, at
+@w{@uref{http://gcc.gnu.org/readings.html}}.
+
+This warning is enabled by @option{-Wall} for C and C++.
+
+@item -Wreturn-type
+@opindex Wreturn-type
+@opindex Wno-return-type
+Warn whenever a function is defined with a return-type that defaults
+to @code{int}.  Also warn about any @code{return} statement with no
+return-value in a function whose return-type is not @code{void}
+(falling off the end of the function body is considered returning
+without a value), and about a @code{return} statement with a
+expression in a function whose return-type is @code{void}.
+
+For C++, a function without return type always produces a diagnostic
+message, even when @option{-Wno-return-type} is specified.  The only
+exceptions are @samp{main} and functions defined in system headers.
+
+This warning is enabled by @option{-Wall}.
+
+@item -Wswitch
+@opindex Wswitch
+@opindex Wno-switch
+Warn whenever a @code{switch} statement has an index of enumerated type
+and lacks a @code{case} for one or more of the named codes of that
+enumeration.  (The presence of a @code{default} label prevents this
+warning.)  @code{case} labels outside the enumeration range also
+provoke warnings when this option is used.
+This warning is enabled by @option{-Wall}.
+
+@item -Wswitch-default
+@opindex Wswitch-default
+@opindex Wno-switch-default
+Warn whenever a @code{switch} statement does not have a @code{default}
+case.
+
+@item -Wswitch-enum
+@opindex Wswitch-enum
+@opindex Wno-switch-enum
+Warn whenever a @code{switch} statement has an index of enumerated type
+and lacks a @code{case} for one or more of the named codes of that
+enumeration.  @code{case} labels outside the enumeration range also
+provoke warnings when this option is used.
+
+@item -Wsync-nand @r{(C and C++ only)}
+@opindex Wsync-nand
+@opindex Wno-sync-nand
+Warn when @code{__sync_fetch_and_nand} and @code{__sync_nand_and_fetch}
+built-in functions are used.  These functions changed semantics in GCC 4.4.
+
+@item -Wtrigraphs
+@opindex Wtrigraphs
+@opindex Wno-trigraphs
+Warn if any trigraphs are encountered that might change the meaning of
+the program (trigraphs within comments are not warned about).
+This warning is enabled by @option{-Wall}.
+
+@item -Wunused-function
+@opindex Wunused-function
+@opindex Wno-unused-function
+Warn whenever a static function is declared but not defined or a
+non-inline static function is unused.
+This warning is enabled by @option{-Wall}.
+
+@item -Wunused-label
+@opindex Wunused-label
+@opindex Wno-unused-label
+Warn whenever a label is declared but not used.
+This warning is enabled by @option{-Wall}.
+
+To suppress this warning use the @samp{unused} attribute
+(@pxref{Variable Attributes}).
+
+@item -Wunused-parameter
+@opindex Wunused-parameter
+@opindex Wno-unused-parameter
+Warn whenever a function parameter is unused aside from its declaration.
+
+To suppress this warning use the @samp{unused} attribute
+(@pxref{Variable Attributes}).
+
+@item -Wunused-variable
+@opindex Wunused-variable
+@opindex Wno-unused-variable
+Warn whenever a local variable or non-constant static variable is unused
+aside from its declaration.
+This warning is enabled by @option{-Wall}.
+
+To suppress this warning use the @samp{unused} attribute
+(@pxref{Variable Attributes}).
+
+@item -Wunused-value
+@opindex Wunused-value
+@opindex Wno-unused-value
+Warn whenever a statement computes a result that is explicitly not
+used. To suppress this warning cast the unused expression to
+@samp{void}. This includes an expression-statement or the left-hand
+side of a comma expression that contains no side effects. For example,
+an expression such as @samp{x[i,j]} will cause a warning, while
+@samp{x[(void)i,j]} will not.
+
+This warning is enabled by @option{-Wall}.
+
+@item -Wunused
+@opindex Wunused
+@opindex Wno-unused
+All the above @option{-Wunused} options combined.
+
+In order to get a warning about an unused function parameter, you must
+either specify @samp{-Wextra -Wunused} (note that @samp{-Wall} implies
+@samp{-Wunused}), or separately specify @option{-Wunused-parameter}.
+
+@item -Wuninitialized
+@opindex Wuninitialized
+@opindex Wno-uninitialized
+Warn if an automatic variable is used without first being initialized
+or if a variable may be clobbered by a @code{setjmp} call. In C++,
+warn if a non-static reference or non-static @samp{const} member
+appears in a class without constructors.
+
+If you want to warn about code which uses the uninitialized value of the
+variable in its own initializer, use the @option{-Winit-self} option.
+
+These warnings occur for individual uninitialized or clobbered
+elements of structure, union or array variables as well as for
+variables which are uninitialized or clobbered as a whole.  They do
+not occur for variables or elements declared @code{volatile}.  Because
+these warnings depend on optimization, the exact variables or elements
+for which there are warnings will depend on the precise optimization
+options and version of GCC used.
+
+Note that there may be no warning about a variable that is used only
+to compute a value that itself is never used, because such
+computations may be deleted by data flow analysis before the warnings
+are printed.
+
+These warnings are made optional because GCC is not smart
+enough to see all the reasons why the code might be correct
+despite appearing to have an error.  Here is one example of how
+this can happen:
+
+@smallexample
+@group
+@{
+  int x;
+  switch (y)
+    @{
+    case 1: x = 1;
+      break;
+    case 2: x = 4;
+      break;
+    case 3: x = 5;
+    @}
+  foo (x);
+@}
+@end group
+@end smallexample
+
+@noindent
+If the value of @code{y} is always 1, 2 or 3, then @code{x} is
+always initialized, but GCC doesn't know this.  Here is
+another common case:
+
+@smallexample
+@{
+  int save_y;
+  if (change_y) save_y = y, y = new_y;
+  @dots{}
+  if (change_y) y = save_y;
+@}
+@end smallexample
+
+@noindent
+This has no bug because @code{save_y} is used only if it is set.
+
+@cindex @code{longjmp} warnings
+This option also warns when a non-volatile automatic variable might be
+changed by a call to @code{longjmp}.  These warnings as well are possible
+only in optimizing compilation.
+
+The compiler sees only the calls to @code{setjmp}.  It cannot know
+where @code{longjmp} will be called; in fact, a signal handler could
+call it at any point in the code.  As a result, you may get a warning
+even when there is in fact no problem because @code{longjmp} cannot
+in fact be called at the place which would cause a problem.
+
+Some spurious warnings can be avoided if you declare all the functions
+you use that never return as @code{noreturn}.  @xref{Function
+Attributes}.
+
+This warning is enabled by @option{-Wall} or @option{-Wextra}.
+
+@item -Wunknown-pragmas
+@opindex Wunknown-pragmas
+@opindex Wno-unknown-pragmas
+@cindex warning for unknown pragmas
+@cindex unknown pragmas, warning
+@cindex pragmas, warning of unknown
+Warn when a #pragma directive is encountered which is not understood by
+GCC@.  If this command line option is used, warnings will even be issued
+for unknown pragmas in system header files.  This is not the case if
+the warnings were only enabled by the @option{-Wall} command line option.
+
+@item -Wno-pragmas
+@opindex Wno-pragmas
+@opindex Wpragmas
+Do not warn about misuses of pragmas, such as incorrect parameters,
+invalid syntax, or conflicts between pragmas.  See also
+@samp{-Wunknown-pragmas}.
+
+@item -Wstrict-aliasing
+@opindex Wstrict-aliasing
+@opindex Wno-strict-aliasing
+This option is only active when @option{-fstrict-aliasing} is active.
+It warns about code which might break the strict aliasing rules that the
+compiler is using for optimization.  The warning does not catch all
+cases, but does attempt to catch the more common pitfalls.  It is
+included in @option{-Wall}.
+It is equivalent to @option{-Wstrict-aliasing=3}
+
+@item -Wstrict-aliasing=n
+@opindex Wstrict-aliasing=n
+@opindex Wno-strict-aliasing=n
+This option is only active when @option{-fstrict-aliasing} is active.
+It warns about code which might break the strict aliasing rules that the
+compiler is using for optimization.
+Higher levels correspond to higher accuracy (fewer false positives).
+Higher levels also correspond to more effort, similar to the way -O works.
+@option{-Wstrict-aliasing} is equivalent to @option{-Wstrict-aliasing=n},
+with n=3.
+
+Level 1: Most aggressive, quick, least accurate.
+Possibly useful when higher levels
+do not warn but -fstrict-aliasing still breaks the code, as it has very few 
+false negatives.  However, it has many false positives.
+Warns for all pointer conversions between possibly incompatible types, 
+even if never dereferenced.  Runs in the frontend only.
+
+Level 2: Aggressive, quick, not too precise.
+May still have many false positives (not as many as level 1 though),
+and few false negatives (but possibly more than level 1).
+Unlike level 1, it only warns when an address is taken.  Warns about
+incomplete types.  Runs in the frontend only.
+
+Level 3 (default for @option{-Wstrict-aliasing}): 
+Should have very few false positives and few false 
+negatives.  Slightly slower than levels 1 or 2 when optimization is enabled.
+Takes care of the common punn+dereference pattern in the frontend:
+@code{*(int*)&some_float}.
+If optimization is enabled, it also runs in the backend, where it deals 
+with multiple statement cases using flow-sensitive points-to information.
+Only warns when the converted pointer is dereferenced.
+Does not warn about incomplete types.
+
+@item -Wstrict-overflow
+@itemx -Wstrict-overflow=@var{n}
+@opindex Wstrict-overflow
+@opindex Wno-strict-overflow
+This option is only active when @option{-fstrict-overflow} is active.
+It warns about cases where the compiler optimizes based on the
+assumption that signed overflow does not occur.  Note that it does not
+warn about all cases where the code might overflow: it only warns
+about cases where the compiler implements some optimization.  Thus
+this warning depends on the optimization level.
+
+An optimization which assumes that signed overflow does not occur is
+perfectly safe if the values of the variables involved are such that
+overflow never does, in fact, occur.  Therefore this warning can
+easily give a false positive: a warning about code which is not
+actually a problem.  To help focus on important issues, several
+warning levels are defined.  No warnings are issued for the use of
+undefined signed overflow when estimating how many iterations a loop
+will require, in particular when determining whether a loop will be
+executed at all.
+
+@table @gcctabopt
+@item -Wstrict-overflow=1
+Warn about cases which are both questionable and easy to avoid.  For
+example: @code{x + 1 > x}; with @option{-fstrict-overflow}, the
+compiler will simplify this to @code{1}.  This level of
+@option{-Wstrict-overflow} is enabled by @option{-Wall}; higher levels
+are not, and must be explicitly requested.
+
+@item -Wstrict-overflow=2
+Also warn about other cases where a comparison is simplified to a
+constant.  For example: @code{abs (x) >= 0}.  This can only be
+simplified when @option{-fstrict-overflow} is in effect, because
+@code{abs (INT_MIN)} overflows to @code{INT_MIN}, which is less than
+zero.  @option{-Wstrict-overflow} (with no level) is the same as
+@option{-Wstrict-overflow=2}.
+
+@item -Wstrict-overflow=3
+Also warn about other cases where a comparison is simplified.  For
+example: @code{x + 1 > 1} will be simplified to @code{x > 0}.
+
+@item -Wstrict-overflow=4
+Also warn about other simplifications not covered by the above cases.
+For example: @code{(x * 10) / 5} will be simplified to @code{x * 2}.
+
+@item -Wstrict-overflow=5
+Also warn about cases where the compiler reduces the magnitude of a
+constant involved in a comparison.  For example: @code{x + 2 > y} will
+be simplified to @code{x + 1 >= y}.  This is reported only at the
+highest warning level because this simplification applies to many
+comparisons, so this warning level will give a very large number of
+false positives.
+@end table
+
+@item -Warray-bounds
+@opindex Wno-array-bounds
+@opindex Warray-bounds
+This option is only active when @option{-ftree-vrp} is active
+(default for -O2 and above). It warns about subscripts to arrays
+that are always out of bounds. This warning is enabled by @option{-Wall}.
+
+@item -Wno-div-by-zero
+@opindex Wno-div-by-zero
+@opindex Wdiv-by-zero
+Do not warn about compile-time integer division by zero.  Floating point
+division by zero is not warned about, as it can be a legitimate way of
+obtaining infinities and NaNs.
+
+@item -Wsystem-headers
+@opindex Wsystem-headers
+@opindex Wno-system-headers
+@cindex warnings from system headers
+@cindex system headers, warnings from
+Print warning messages for constructs found in system header files.
+Warnings from system headers are normally suppressed, on the assumption
+that they usually do not indicate real problems and would only make the
+compiler output harder to read.  Using this command line option tells
+GCC to emit warnings from system headers as if they occurred in user
+code.  However, note that using @option{-Wall} in conjunction with this
+option will @emph{not} warn about unknown pragmas in system
+headers---for that, @option{-Wunknown-pragmas} must also be used.
+
+@item -Wfloat-equal
+@opindex Wfloat-equal
+@opindex Wno-float-equal
+Warn if floating point values are used in equality comparisons.
+
+The idea behind this is that sometimes it is convenient (for the
+programmer) to consider floating-point values as approximations to
+infinitely precise real numbers.  If you are doing this, then you need
+to compute (by analyzing the code, or in some other way) the maximum or
+likely maximum error that the computation introduces, and allow for it
+when performing comparisons (and when producing output, but that's a
+different problem).  In particular, instead of testing for equality, you
+would check to see whether the two values have ranges that overlap; and
+this is done with the relational operators, so equality comparisons are
+probably mistaken.
+
+@item -Wtraditional @r{(C and Objective-C only)}
+@opindex Wtraditional
+@opindex Wno-traditional
+Warn about certain constructs that behave differently in traditional and
+ISO C@.  Also warn about ISO C constructs that have no traditional C
+equivalent, and/or problematic constructs which should be avoided.
+
+@itemize @bullet
+@item
+Macro parameters that appear within string literals in the macro body.
+In traditional C macro replacement takes place within string literals,
+but does not in ISO C@.
+
+@item
+In traditional C, some preprocessor directives did not exist.
+Traditional preprocessors would only consider a line to be a directive
+if the @samp{#} appeared in column 1 on the line.  Therefore
+@option{-Wtraditional} warns about directives that traditional C
+understands but would ignore because the @samp{#} does not appear as the
+first character on the line.  It also suggests you hide directives like
+@samp{#pragma} not understood by traditional C by indenting them.  Some
+traditional implementations would not recognize @samp{#elif}, so it
+suggests avoiding it altogether.
+
+@item
+A function-like macro that appears without arguments.
+
+@item
+The unary plus operator.
+
+@item
+The @samp{U} integer constant suffix, or the @samp{F} or @samp{L} floating point
+constant suffixes.  (Traditional C does support the @samp{L} suffix on integer
+constants.)  Note, these suffixes appear in macros defined in the system
+headers of most modern systems, e.g.@: the @samp{_MIN}/@samp{_MAX} macros in @code{<limits.h>}.
+Use of these macros in user code might normally lead to spurious
+warnings, however GCC's integrated preprocessor has enough context to
+avoid warning in these cases.
+
+@item
+A function declared external in one block and then used after the end of
+the block.
+
+@item
+A @code{switch} statement has an operand of type @code{long}.
+
+@item
+A non-@code{static} function declaration follows a @code{static} one.
+This construct is not accepted by some traditional C compilers.
+
+@item
+The ISO type of an integer constant has a different width or
+signedness from its traditional type.  This warning is only issued if
+the base of the constant is ten.  I.e.@: hexadecimal or octal values, which
+typically represent bit patterns, are not warned about.
+
+@item
+Usage of ISO string concatenation is detected.
+
+@item
+Initialization of automatic aggregates.
+
+@item
+Identifier conflicts with labels.  Traditional C lacks a separate
+namespace for labels.
+
+@item
+Initialization of unions.  If the initializer is zero, the warning is
+omitted.  This is done under the assumption that the zero initializer in
+user code appears conditioned on e.g.@: @code{__STDC__} to avoid missing
+initializer warnings and relies on default initialization to zero in the
+traditional C case.
+
+@item
+Conversions by prototypes between fixed/floating point values and vice
+versa.  The absence of these prototypes when compiling with traditional
+C would cause serious problems.  This is a subset of the possible
+conversion warnings, for the full set use @option{-Wtraditional-conversion}.
+
+@item
+Use of ISO C style function definitions.  This warning intentionally is
+@emph{not} issued for prototype declarations or variadic functions
+because these ISO C features will appear in your code when using
+libiberty's traditional C compatibility macros, @code{PARAMS} and
+@code{VPARAMS}.  This warning is also bypassed for nested functions
+because that feature is already a GCC extension and thus not relevant to
+traditional C compatibility.
+@end itemize
+
+@item -Wtraditional-conversion @r{(C and Objective-C only)}
+@opindex Wtraditional-conversion
+@opindex Wno-traditional-conversion
+Warn if a prototype causes a type conversion that is different from what
+would happen to the same argument in the absence of a prototype.  This
+includes conversions of fixed point to floating and vice versa, and
+conversions changing the width or signedness of a fixed point argument
+except when the same as the default promotion.
+
+@item -Wdeclaration-after-statement @r{(C and Objective-C only)}
+@opindex Wdeclaration-after-statement
+@opindex Wno-declaration-after-statement
+Warn when a declaration is found after a statement in a block.  This
+construct, known from C++, was introduced with ISO C99 and is by default
+allowed in GCC@.  It is not supported by ISO C90 and was not supported by
+GCC versions before GCC 3.0.  @xref{Mixed Declarations}.
+
+@item -Wundef
+@opindex Wundef
+@opindex Wno-undef
+Warn if an undefined identifier is evaluated in an @samp{#if} directive.
+
+@item -Wno-endif-labels
+@opindex Wno-endif-labels
+@opindex Wendif-labels
+Do not warn whenever an @samp{#else} or an @samp{#endif} are followed by text.
+
+@item -Wshadow
+@opindex Wshadow
+@opindex Wno-shadow
+Warn whenever a local variable shadows another local variable, parameter or
+global variable or whenever a built-in function is shadowed.
+
+@item -Wlarger-than=@var{len}
+@opindex Wlarger-than=@var{len}
+@opindex Wlarger-than-@var{len}
+Warn whenever an object of larger than @var{len} bytes is defined.
+
+@item -Wframe-larger-than=@var{len}
+@opindex Wframe-larger-than
+Warn if the size of a function frame is larger than @var{len} bytes.
+The computation done to determine the stack frame size is approximate
+and not conservative.
+The actual requirements may be somewhat greater than @var{len}
+even if you do not get a warning.  In addition, any space allocated
+via @code{alloca}, variable-length arrays, or related constructs
+is not included by the compiler when determining
+whether or not to issue a warning.
+
+@item -Wunsafe-loop-optimizations
+@opindex Wunsafe-loop-optimizations
+@opindex Wno-unsafe-loop-optimizations
+Warn if the loop cannot be optimized because the compiler could not
+assume anything on the bounds of the loop indices.  With
+@option{-funsafe-loop-optimizations} warn if the compiler made
+such assumptions.
+
+@item -Wno-pedantic-ms-format @r{(MinGW targets only)}
+@opindex Wno-pedantic-ms-format
+@opindex Wpedantic-ms-format
+Disables the warnings about non-ISO @code{printf} / @code{scanf} format
+width specifiers @code{I32}, @code{I64}, and @code{I} used on Windows targets
+depending on the MS runtime, when you are using the options @option{-Wformat}
+and @option{-pedantic} without gnu-extensions.
+
+@item -Wpointer-arith
+@opindex Wpointer-arith
+@opindex Wno-pointer-arith
+Warn about anything that depends on the ``size of'' a function type or
+of @code{void}.  GNU C assigns these types a size of 1, for
+convenience in calculations with @code{void *} pointers and pointers
+to functions.  In C++, warn also when an arithmetic operation involves
+@code{NULL}.  This warning is also enabled by @option{-pedantic}.
+
+@item -Wtype-limits
+@opindex Wtype-limits
+@opindex Wno-type-limits
+Warn if a comparison is always true or always false due to the limited
+range of the data type, but do not warn for constant expressions.  For
+example, warn if an unsigned variable is compared against zero with
+@samp{<} or @samp{>=}.  This warning is also enabled by
+@option{-Wextra}.
+
+@item -Wbad-function-cast @r{(C and Objective-C only)}
+@opindex Wbad-function-cast
+@opindex Wno-bad-function-cast
+Warn whenever a function call is cast to a non-matching type.
+For example, warn if @code{int malloc()} is cast to @code{anything *}.
+
+@item -Wc++-compat @r{(C and Objective-C only)}
+Warn about ISO C constructs that are outside of the common subset of
+ISO C and ISO C++, e.g.@: request for implicit conversion from
+@code{void *} to a pointer to non-@code{void} type.
+
+@item -Wc++0x-compat @r{(C++ and Objective-C++ only)}
+Warn about C++ constructs whose meaning differs between ISO C++ 1998 and
+ISO C++ 200x, e.g., identifiers in ISO C++ 1998 that will become keywords
+in ISO C++ 200x.  This warning is enabled by @option{-Wall}.
+
+@item -Wcast-qual
+@opindex Wcast-qual
+@opindex Wno-cast-qual
+Warn whenever a pointer is cast so as to remove a type qualifier from
+the target type.  For example, warn if a @code{const char *} is cast
+to an ordinary @code{char *}.
+
+@item -Wcast-align
+@opindex Wcast-align
+@opindex Wno-cast-align
+Warn whenever a pointer is cast such that the required alignment of the
+target is increased.  For example, warn if a @code{char *} is cast to
+an @code{int *} on machines where integers can only be accessed at
+two- or four-byte boundaries.
+
+@item -Wwrite-strings
+@opindex Wwrite-strings
+@opindex Wno-write-strings
+When compiling C, give string constants the type @code{const
+char[@var{length}]} so that copying the address of one into a
+non-@code{const} @code{char *} pointer will get a warning.  These
+warnings will help you find at compile time code that can try to write
+into a string constant, but only if you have been very careful about
+using @code{const} in declarations and prototypes.  Otherwise, it will
+just be a nuisance. This is why we did not make @option{-Wall} request
+these warnings.
+
+When compiling C++, warn about the deprecated conversion from string
+literals to @code{char *}.  This warning is enabled by default for C++
+programs.
+
+@item -Wclobbered
+@opindex Wclobbered
+@opindex Wno-clobbered
+Warn for variables that might be changed by @samp{longjmp} or
+@samp{vfork}.  This warning is also enabled by @option{-Wextra}.
+
+@item -Wconversion
+@opindex Wconversion
+@opindex Wno-conversion
+Warn for implicit conversions that may alter a value. This includes
+conversions between real and integer, like @code{abs (x)} when
+@code{x} is @code{double}; conversions between signed and unsigned,
+like @code{unsigned ui = -1}; and conversions to smaller types, like
+@code{sqrtf (M_PI)}. Do not warn for explicit casts like @code{abs
+((int) x)} and @code{ui = (unsigned) -1}, or if the value is not
+changed by the conversion like in @code{abs (2.0)}.  Warnings about
+conversions between signed and unsigned integers can be disabled by
+using @option{-Wno-sign-conversion}.
+
+For C++, also warn for conversions between @code{NULL} and non-pointer
+types; confusing overload resolution for user-defined conversions; and
+conversions that will never use a type conversion operator:
+conversions to @code{void}, the same type, a base class or a reference
+to them. Warnings about conversions between signed and unsigned
+integers are disabled by default in C++ unless
+@option{-Wsign-conversion} is explicitly enabled.
+
+@item -Wempty-body
+@opindex Wempty-body
+@opindex Wno-empty-body
+Warn if an empty body occurs in an @samp{if}, @samp{else} or @samp{do
+while} statement.  This warning is also enabled by @option{-Wextra}.
+
+@item -Wenum-compare @r{(C++ and Objective-C++ only)}
+@opindex Wenum-compare
+@opindex Wno-enum-compare
+Warn about a comparison between values of different enum types. This
+warning is enabled by default.
+
+@item -Wsign-compare
+@opindex Wsign-compare
+@opindex Wno-sign-compare
+@cindex warning for comparison of signed and unsigned values
+@cindex comparison of signed and unsigned values, warning
+@cindex signed and unsigned values, comparison warning
+Warn when a comparison between signed and unsigned values could produce
+an incorrect result when the signed value is converted to unsigned.
+This warning is also enabled by @option{-Wextra}; to get the other warnings
+of @option{-Wextra} without this warning, use @samp{-Wextra -Wno-sign-compare}.
+
+@item -Wsign-conversion
+@opindex Wsign-conversion
+@opindex Wno-sign-conversion
+Warn for implicit conversions that may change the sign of an integer
+value, like assigning a signed integer expression to an unsigned
+integer variable. An explicit cast silences the warning. In C, this
+option is enabled also by @option{-Wconversion}.
+
+@item -Waddress
+@opindex Waddress
+@opindex Wno-address
+Warn about suspicious uses of memory addresses. These include using
+the address of a function in a conditional expression, such as
+@code{void func(void); if (func)}, and comparisons against the memory
+address of a string literal, such as @code{if (x == "abc")}.  Such
+uses typically indicate a programmer error: the address of a function
+always evaluates to true, so their use in a conditional usually
+indicate that the programmer forgot the parentheses in a function
+call; and comparisons against string literals result in unspecified
+behavior and are not portable in C, so they usually indicate that the
+programmer intended to use @code{strcmp}.  This warning is enabled by
+@option{-Wall}.
+
+@item -Wlogical-op
+@opindex Wlogical-op
+@opindex Wno-logical-op
+Warn about suspicious uses of logical operators in expressions.
+This includes using logical operators in contexts where a
+bit-wise operator is likely to be expected.
+
+@item -Waggregate-return
+@opindex Waggregate-return
+@opindex Wno-aggregate-return
+Warn if any functions that return structures or unions are defined or
+called.  (In languages where you can return an array, this also elicits
+a warning.)
+
+@item -Wno-attributes
+@opindex Wno-attributes
+@opindex Wattributes
+Do not warn if an unexpected @code{__attribute__} is used, such as
+unrecognized attributes, function attributes applied to variables,
+etc.  This will not stop errors for incorrect use of supported
+attributes.
+
+@item -Wno-builtin-macro-redefined
+@opindex Wno-builtin-macro-redefined
+@opindex Wbuiltin-macro-redefined
+Do not warn if certain built-in macros are redefined.  This suppresses
+warnings for redefinition of @code{__TIMESTAMP__}, @code{__TIME__},
+@code{__DATE__}, @code{__FILE__}, and @code{__BASE_FILE__}.
+
+@item -Wstrict-prototypes @r{(C and Objective-C only)}
+@opindex Wstrict-prototypes
+@opindex Wno-strict-prototypes
+Warn if a function is declared or defined without specifying the
+argument types.  (An old-style function definition is permitted without
+a warning if preceded by a declaration which specifies the argument
+types.)
+
+@item -Wold-style-declaration @r{(C and Objective-C only)}
+@opindex Wold-style-declaration
+@opindex Wno-old-style-declaration
+Warn for obsolescent usages, according to the C Standard, in a
+declaration. For example, warn if storage-class specifiers like
+@code{static} are not the first things in a declaration.  This warning
+is also enabled by @option{-Wextra}.
+
+@item -Wold-style-definition @r{(C and Objective-C only)}
+@opindex Wold-style-definition
+@opindex Wno-old-style-definition
+Warn if an old-style function definition is used.  A warning is given
+even if there is a previous prototype.
+
+@item -Wmissing-parameter-type @r{(C and Objective-C only)}
+@opindex Wmissing-parameter-type
+@opindex Wno-missing-parameter-type
+A function parameter is declared without a type specifier in K&R-style
+functions:
+
+@smallexample
+void foo(bar) @{ @}
+@end smallexample
+
+This warning is also enabled by @option{-Wextra}.
+
+@item -Wmissing-prototypes @r{(C and Objective-C only)}
+@opindex Wmissing-prototypes
+@opindex Wno-missing-prototypes
+Warn if a global function is defined without a previous prototype
+declaration.  This warning is issued even if the definition itself
+provides a prototype.  The aim is to detect global functions that fail
+to be declared in header files.
+
+@item -Wmissing-declarations
+@opindex Wmissing-declarations
+@opindex Wno-missing-declarations
+Warn if a global function is defined without a previous declaration.
+Do so even if the definition itself provides a prototype.
+Use this option to detect global functions that are not declared in
+header files.  In C++, no warnings are issued for function templates,
+or for inline functions, or for functions in anonymous namespaces.
+
+@item -Wmissing-field-initializers
+@opindex Wmissing-field-initializers
+@opindex Wno-missing-field-initializers
+@opindex W
+@opindex Wextra
+@opindex Wno-extra
+Warn if a structure's initializer has some fields missing.  For
+example, the following code would cause such a warning, because
+@code{x.h} is implicitly zero:
+
+@smallexample
+struct s @{ int f, g, h; @};
+struct s x = @{ 3, 4 @};
+@end smallexample
+
+This option does not warn about designated initializers, so the following
+modification would not trigger a warning:
+
+@smallexample
+struct s @{ int f, g, h; @};
+struct s x = @{ .f = 3, .g = 4 @};
+@end smallexample
+
+This warning is included in @option{-Wextra}.  To get other @option{-Wextra}
+warnings without this one, use @samp{-Wextra -Wno-missing-field-initializers}.
+
+@item -Wmissing-noreturn
+@opindex Wmissing-noreturn
+@opindex Wno-missing-noreturn
+Warn about functions which might be candidates for attribute @code{noreturn}.
+Note these are only possible candidates, not absolute ones.  Care should
+be taken to manually verify functions actually do not ever return before
+adding the @code{noreturn} attribute, otherwise subtle code generation
+bugs could be introduced.  You will not get a warning for @code{main} in
+hosted C environments.
+
+@item -Wmissing-format-attribute
+@opindex Wmissing-format-attribute
+@opindex Wno-missing-format-attribute
+@opindex Wformat
+@opindex Wno-format
+Warn about function pointers which might be candidates for @code{format}
+attributes.  Note these are only possible candidates, not absolute ones.
+GCC will guess that function pointers with @code{format} attributes that
+are used in assignment, initialization, parameter passing or return
+statements should have a corresponding @code{format} attribute in the
+resulting type.  I.e.@: the left-hand side of the assignment or
+initialization, the type of the parameter variable, or the return type
+of the containing function respectively should also have a @code{format}
+attribute to avoid the warning.
+
+GCC will also warn about function definitions which might be
+candidates for @code{format} attributes.  Again, these are only
+possible candidates.  GCC will guess that @code{format} attributes
+might be appropriate for any function that calls a function like
+@code{vprintf} or @code{vscanf}, but this might not always be the
+case, and some functions for which @code{format} attributes are
+appropriate may not be detected.
+
+@item -Wno-multichar
+@opindex Wno-multichar
+@opindex Wmultichar
+Do not warn if a multicharacter constant (@samp{'FOOF'}) is used.
+Usually they indicate a typo in the user's code, as they have
+implementation-defined values, and should not be used in portable code.
+
+@item -Wnormalized=<none|id|nfc|nfkc>
+@opindex Wnormalized=
+@cindex NFC
+@cindex NFKC
+@cindex character set, input normalization
+In ISO C and ISO C++, two identifiers are different if they are
+different sequences of characters.  However, sometimes when characters
+outside the basic ASCII character set are used, you can have two
+different character sequences that look the same.  To avoid confusion,
+the ISO 10646 standard sets out some @dfn{normalization rules} which
+when applied ensure that two sequences that look the same are turned into
+the same sequence.  GCC can warn you if you are using identifiers which
+have not been normalized; this option controls that warning.
+
+There are four levels of warning that GCC supports.  The default is
+@option{-Wnormalized=nfc}, which warns about any identifier which is
+not in the ISO 10646 ``C'' normalized form, @dfn{NFC}.  NFC is the
+recommended form for most uses.
+
+Unfortunately, there are some characters which ISO C and ISO C++ allow
+in identifiers that when turned into NFC aren't allowable as
+identifiers.  That is, there's no way to use these symbols in portable
+ISO C or C++ and have all your identifiers in NFC@.
+@option{-Wnormalized=id} suppresses the warning for these characters.
+It is hoped that future versions of the standards involved will correct
+this, which is why this option is not the default.
+
+You can switch the warning off for all characters by writing
+@option{-Wnormalized=none}.  You would only want to do this if you
+were using some other normalization scheme (like ``D''), because
+otherwise you can easily create bugs that are literally impossible to see.
+
+Some characters in ISO 10646 have distinct meanings but look identical
+in some fonts or display methodologies, especially once formatting has
+been applied.  For instance @code{\u207F}, ``SUPERSCRIPT LATIN SMALL
+LETTER N'', will display just like a regular @code{n} which has been
+placed in a superscript.  ISO 10646 defines the @dfn{NFKC}
+normalization scheme to convert all these into a standard form as
+well, and GCC will warn if your code is not in NFKC if you use
+@option{-Wnormalized=nfkc}.  This warning is comparable to warning
+about every identifier that contains the letter O because it might be
+confused with the digit 0, and so is not the default, but may be
+useful as a local coding convention if the programming environment is
+unable to be fixed to display these characters distinctly.
+
+@item -Wno-deprecated
+@opindex Wno-deprecated
+@opindex Wdeprecated
+Do not warn about usage of deprecated features.  @xref{Deprecated Features}.
+
+@item -Wno-deprecated-declarations
+@opindex Wno-deprecated-declarations
+@opindex Wdeprecated-declarations
+Do not warn about uses of functions (@pxref{Function Attributes}),
+variables (@pxref{Variable Attributes}), and types (@pxref{Type
+Attributes}) marked as deprecated by using the @code{deprecated}
+attribute.
+
+@item -Wno-overflow
+@opindex Wno-overflow
+@opindex Woverflow
+Do not warn about compile-time overflow in constant expressions.
+
+@item -Woverride-init @r{(C and Objective-C only)}
+@opindex Woverride-init
+@opindex Wno-override-init
+@opindex W
+@opindex Wextra
+@opindex Wno-extra
+Warn if an initialized field without side effects is overridden when
+using designated initializers (@pxref{Designated Inits, , Designated
+Initializers}).
+
+This warning is included in @option{-Wextra}.  To get other
+@option{-Wextra} warnings without this one, use @samp{-Wextra
+-Wno-override-init}.
+
+@item -Wpacked
+@opindex Wpacked
+@opindex Wno-packed
+Warn if a structure is given the packed attribute, but the packed
+attribute has no effect on the layout or size of the structure.
+Such structures may be mis-aligned for little benefit.  For
+instance, in this code, the variable @code{f.x} in @code{struct bar}
+will be misaligned even though @code{struct bar} does not itself
+have the packed attribute:
+
+@smallexample
+@group
+struct foo @{
+  int x;
+  char a, b, c, d;
+@} __attribute__((packed));
+struct bar @{
+  char z;
+  struct foo f;
+@};
+@end group
+@end smallexample
+
+@item -Wpacked-bitfield-compat
+@opindex Wpacked-bitfield-compat
+@opindex Wno-packed-bitfield-compat
+The 4.1, 4.2 and 4.3 series of GCC ignore the @code{packed} attribute
+on bit-fields of type @code{char}.  This has been fixed in GCC 4.4 but
+the change can lead to differences in the structure layout.  GCC
+informs you when the offset of such a field has changed in GCC 4.4.
+For example there is no longer a 4-bit padding between field @code{a}
+and @code{b} in this structure:
+
+@smallexample
+struct foo
+@{
+  char a:4;
+  char b:8;
+@} __attribute__ ((packed));
+@end smallexample
+
+This warning is enabled by default.  Use
+@option{-Wno-packed-bitfield-compat} to disable this warning.
+
+@item -Wpadded
+@opindex Wpadded
+@opindex Wno-padded
+Warn if padding is included in a structure, either to align an element
+of the structure or to align the whole structure.  Sometimes when this
+happens it is possible to rearrange the fields of the structure to
+reduce the padding and so make the structure smaller.
+
+@item -Wredundant-decls
+@opindex Wredundant-decls
+@opindex Wno-redundant-decls
+Warn if anything is declared more than once in the same scope, even in
+cases where multiple declaration is valid and changes nothing.
+
+@item -Wnested-externs @r{(C and Objective-C only)}
+@opindex Wnested-externs
+@opindex Wno-nested-externs
+Warn if an @code{extern} declaration is encountered within a function.
+
+@item -Wunreachable-code
+@opindex Wunreachable-code
+@opindex Wno-unreachable-code
+Warn if the compiler detects that code will never be executed.
+
+This option is intended to warn when the compiler detects that at
+least a whole line of source code will never be executed, because
+some condition is never satisfied or because it is after a
+procedure that never returns.
+
+It is possible for this option to produce a warning even though there
+are circumstances under which part of the affected line can be executed,
+so care should be taken when removing apparently-unreachable code.
+
+For instance, when a function is inlined, a warning may mean that the
+line is unreachable in only one inlined copy of the function.
+
+This option is not made part of @option{-Wall} because in a debugging
+version of a program there is often substantial code which checks
+correct functioning of the program and is, hopefully, unreachable
+because the program does work.  Another common use of unreachable
+code is to provide behavior which is selectable at compile-time.
+
+@item -Winline
+@opindex Winline
+@opindex Wno-inline
+Warn if a function can not be inlined and it was declared as inline.
+Even with this option, the compiler will not warn about failures to
+inline functions declared in system headers.
+
+The compiler uses a variety of heuristics to determine whether or not
+to inline a function.  For example, the compiler takes into account
+the size of the function being inlined and the amount of inlining
+that has already been done in the current function.  Therefore,
+seemingly insignificant changes in the source program can cause the
+warnings produced by @option{-Winline} to appear or disappear.
+
+@item -Wno-invalid-offsetof @r{(C++ and Objective-C++ only)}
+@opindex Wno-invalid-offsetof
+@opindex Winvalid-offsetof
+Suppress warnings from applying the @samp{offsetof} macro to a non-POD
+type.  According to the 1998 ISO C++ standard, applying @samp{offsetof}
+to a non-POD type is undefined.  In existing C++ implementations,
+however, @samp{offsetof} typically gives meaningful results even when
+applied to certain kinds of non-POD types. (Such as a simple
+@samp{struct} that fails to be a POD type only by virtue of having a
+constructor.)  This flag is for users who are aware that they are
+writing nonportable code and who have deliberately chosen to ignore the
+warning about it.
+
+The restrictions on @samp{offsetof} may be relaxed in a future version
+of the C++ standard.
+
+@item -Wno-int-to-pointer-cast @r{(C and Objective-C only)}
+@opindex Wno-int-to-pointer-cast
+@opindex Wint-to-pointer-cast
+Suppress warnings from casts to pointer type of an integer of a
+different size.
+
+@item -Wno-pointer-to-int-cast @r{(C and Objective-C only)}
+@opindex Wno-pointer-to-int-cast
+@opindex Wpointer-to-int-cast
+Suppress warnings from casts from a pointer to an integer type of a
+different size.
+
+@item -Winvalid-pch
+@opindex Winvalid-pch
+@opindex Wno-invalid-pch
+Warn if a precompiled header (@pxref{Precompiled Headers}) is found in
+the search path but can't be used.
+
+@item -Wlong-long
+@opindex Wlong-long
+@opindex Wno-long-long
+Warn if @samp{long long} type is used.  This is default.  To inhibit
+the warning messages, use @option{-Wno-long-long}.  Flags
+@option{-Wlong-long} and @option{-Wno-long-long} are taken into account
+only when @option{-pedantic} flag is used.
+
+@item -Wvariadic-macros
+@opindex Wvariadic-macros
+@opindex Wno-variadic-macros
+Warn if variadic macros are used in pedantic ISO C90 mode, or the GNU
+alternate syntax when in pedantic ISO C99 mode.  This is default.
+To inhibit the warning messages, use @option{-Wno-variadic-macros}.
+
+@item -Wvla
+@opindex Wvla
+@opindex Wno-vla
+Warn if variable length array is used in the code.
+@option{-Wno-vla} will prevent the @option{-pedantic} warning of
+the variable length array.
+
+@item -Wvolatile-register-var
+@opindex Wvolatile-register-var
+@opindex Wno-volatile-register-var
+Warn if a register variable is declared volatile.  The volatile
+modifier does not inhibit all optimizations that may eliminate reads
+and/or writes to register variables.  This warning is enabled by
+@option{-Wall}.
+
+@item -Wdisabled-optimization
+@opindex Wdisabled-optimization
+@opindex Wno-disabled-optimization
+Warn if a requested optimization pass is disabled.  This warning does
+not generally indicate that there is anything wrong with your code; it
+merely indicates that GCC's optimizers were unable to handle the code
+effectively.  Often, the problem is that your code is too big or too
+complex; GCC will refuse to optimize programs when the optimization
+itself is likely to take inordinate amounts of time.
+
+@item -Wpointer-sign @r{(C and Objective-C only)}
+@opindex Wpointer-sign
+@opindex Wno-pointer-sign
+Warn for pointer argument passing or assignment with different signedness.
+This option is only supported for C and Objective-C@.  It is implied by
+@option{-Wall} and by @option{-pedantic}, which can be disabled with
+@option{-Wno-pointer-sign}.
+
+@item -Wstack-protector
+@opindex Wstack-protector
+@opindex Wno-stack-protector
+This option is only active when @option{-fstack-protector} is active.  It
+warns about functions that will not be protected against stack smashing.
+
+@item -Wno-mudflap
+@opindex Wno-mudflap
+Suppress warnings about constructs that cannot be instrumented by
+@option{-fmudflap}.
+
+@item -Woverlength-strings
+@opindex Woverlength-strings
+@opindex Wno-overlength-strings
+Warn about string constants which are longer than the ``minimum
+maximum'' length specified in the C standard.  Modern compilers
+generally allow string constants which are much longer than the
+standard's minimum limit, but very portable programs should avoid
+using longer strings.
+
+The limit applies @emph{after} string constant concatenation, and does
+not count the trailing NUL@.  In C89, the limit was 509 characters; in
+C99, it was raised to 4095.  C++98 does not specify a normative
+minimum maximum, so we do not diagnose overlength strings in C++@.
+
+This option is implied by @option{-pedantic}, and can be disabled with
+@option{-Wno-overlength-strings}.
+@end table
+
+@node Debugging Options
+@section Options for Debugging Your Program or GCC
+@cindex options, debugging
+@cindex debugging information options
+
+GCC has various special options that are used for debugging
+either your program or GCC:
+
+@table @gcctabopt
+@item -g
+@opindex g
+Produce debugging information in the operating system's native format
+(stabs, COFF, XCOFF, or DWARF 2)@.  GDB can work with this debugging
+information.
+
+On most systems that use stabs format, @option{-g} enables use of extra
+debugging information that only GDB can use; this extra information
+makes debugging work better in GDB but will probably make other debuggers
+crash or
+refuse to read the program.  If you want to control for certain whether
+to generate the extra information, use @option{-gstabs+}, @option{-gstabs},
+@option{-gxcoff+}, @option{-gxcoff}, or @option{-gvms} (see below).
+
+GCC allows you to use @option{-g} with
+@option{-O}.  The shortcuts taken by optimized code may occasionally
+produce surprising results: some variables you declared may not exist
+at all; flow of control may briefly move where you did not expect it;
+some statements may not be executed because they compute constant
+results or their values were already at hand; some statements may
+execute in different places because they were moved out of loops.
+
+Nevertheless it proves possible to debug optimized output.  This makes
+it reasonable to use the optimizer for programs that might have bugs.
+
+The following options are useful when GCC is generated with the
+capability for more than one debugging format.
+
+@item -ggdb
+@opindex ggdb
+Produce debugging information for use by GDB@.  This means to use the
+most expressive format available (DWARF 2, stabs, or the native format
+if neither of those are supported), including GDB extensions if at all
+possible.
+
+@item -gstabs
+@opindex gstabs
+Produce debugging information in stabs format (if that is supported),
+without GDB extensions.  This is the format used by DBX on most BSD
+systems.  On MIPS, Alpha and System V Release 4 systems this option
+produces stabs debugging output which is not understood by DBX or SDB@.
+On System V Release 4 systems this option requires the GNU assembler.
+
+@item -feliminate-unused-debug-symbols
+@opindex feliminate-unused-debug-symbols
+Produce debugging information in stabs format (if that is supported),
+for only symbols that are actually used.
+
+@item -femit-class-debug-always
+Instead of emitting debugging information for a C++ class in only one
+object file, emit it in all object files using the class.  This option
+should be used only with debuggers that are unable to handle the way GCC
+normally emits debugging information for classes because using this
+option will increase the size of debugging information by as much as a
+factor of two.
+
+@item -gstabs+
+@opindex gstabs+
+Produce debugging information in stabs format (if that is supported),
+using GNU extensions understood only by the GNU debugger (GDB)@.  The
+use of these extensions is likely to make other debuggers crash or
+refuse to read the program.
+
+@item -gcoff
+@opindex gcoff
+Produce debugging information in COFF format (if that is supported).
+This is the format used by SDB on most System V systems prior to
+System V Release 4.
+
+@item -gxcoff
+@opindex gxcoff
+Produce debugging information in XCOFF format (if that is supported).
+This is the format used by the DBX debugger on IBM RS/6000 systems.
+
+@item -gxcoff+
+@opindex gxcoff+
+Produce debugging information in XCOFF format (if that is supported),
+using GNU extensions understood only by the GNU debugger (GDB)@.  The
+use of these extensions is likely to make other debuggers crash or
+refuse to read the program, and may cause assemblers other than the GNU
+assembler (GAS) to fail with an error.
+
+@item -gdwarf-2
+@opindex gdwarf-2
+Produce debugging information in DWARF version 2 format (if that is
+supported).  This is the format used by DBX on IRIX 6.  With this
+option, GCC uses features of DWARF version 3 when they are useful;
+version 3 is upward compatible with version 2, but may still cause
+problems for older debuggers.
+
+@item -gvms
+@opindex gvms
+Produce debugging information in VMS debug format (if that is
+supported).  This is the format used by DEBUG on VMS systems.
+
+@item -g@var{level}
+@itemx -ggdb@var{level}
+@itemx -gstabs@var{level}
+@itemx -gcoff@var{level}
+@itemx -gxcoff@var{level}
+@itemx -gvms@var{level}
+Request debugging information and also use @var{level} to specify how
+much information.  The default level is 2.
+
+Level 0 produces no debug information at all.  Thus, @option{-g0} negates
+@option{-g}.
+
+Level 1 produces minimal information, enough for making backtraces in
+parts of the program that you don't plan to debug.  This includes
+descriptions of functions and external variables, but no information
+about local variables and no line numbers.
+
+Level 3 includes extra information, such as all the macro definitions
+present in the program.  Some debuggers support macro expansion when
+you use @option{-g3}.
+
+@option{-gdwarf-2} does not accept a concatenated debug level, because
+GCC used to support an option @option{-gdwarf} that meant to generate
+debug information in version 1 of the DWARF format (which is very
+different from version 2), and it would have been too confusing.  That
+debug format is long obsolete, but the option cannot be changed now.
+Instead use an additional @option{-g@var{level}} option to change the
+debug level for DWARF2.
+
+@item -feliminate-dwarf2-dups
+@opindex feliminate-dwarf2-dups
+Compress DWARF2 debugging information by eliminating duplicated
+information about each symbol.  This option only makes sense when
+generating DWARF2 debugging information with @option{-gdwarf-2}.
+
+@item -femit-struct-debug-baseonly
+Emit debug information for struct-like types
+only when the base name of the compilation source file
+matches the base name of file in which the struct was defined.
+
+This option substantially reduces the size of debugging information,
+but at significant potential loss in type information to the debugger.
+See @option{-femit-struct-debug-reduced} for a less aggressive option.
+See @option{-femit-struct-debug-detailed} for more detailed control.
+
+This option works only with DWARF 2.
+
+@item -femit-struct-debug-reduced
+Emit debug information for struct-like types
+only when the base name of the compilation source file
+matches the base name of file in which the type was defined,
+unless the struct is a template or defined in a system header.
+
+This option significantly reduces the size of debugging information,
+with some potential loss in type information to the debugger.
+See @option{-femit-struct-debug-baseonly} for a more aggressive option.
+See @option{-femit-struct-debug-detailed} for more detailed control.
+
+This option works only with DWARF 2.
+
+@item -femit-struct-debug-detailed@r{[}=@var{spec-list}@r{]}
+Specify the struct-like types
+for which the compiler will generate debug information.
+The intent is to reduce duplicate struct debug information
+between different object files within the same program.
+
+This option is a detailed version of
+@option{-femit-struct-debug-reduced} and @option{-femit-struct-debug-baseonly},
+which will serve for most needs.
+
+A specification has the syntax
+[@samp{dir:}|@samp{ind:}][@samp{ord:}|@samp{gen:}](@samp{any}|@samp{sys}|@samp{base}|@samp{none})
+
+The optional first word limits the specification to
+structs that are used directly (@samp{dir:}) or used indirectly (@samp{ind:}).
+A struct type is used directly when it is the type of a variable, member.
+Indirect uses arise through pointers to structs.
+That is, when use of an incomplete struct would be legal, the use is indirect.
+An example is
+@samp{struct one direct; struct two * indirect;}.
+
+The optional second word limits the specification to
+ordinary structs (@samp{ord:}) or generic structs (@samp{gen:}).
+Generic structs are a bit complicated to explain.
+For C++, these are non-explicit specializations of template classes,
+or non-template classes within the above.
+Other programming languages have generics,
+but @samp{-femit-struct-debug-detailed} does not yet implement them.
+
+The third word specifies the source files for those
+structs for which the compiler will emit debug information.
+The values @samp{none} and @samp{any} have the normal meaning.
+The value @samp{base} means that
+the base of name of the file in which the type declaration appears
+must match the base of the name of the main compilation file.
+In practice, this means that
+types declared in @file{foo.c} and @file{foo.h} will have debug information,
+but types declared in other header will not.
+The value @samp{sys} means those types satisfying @samp{base}
+or declared in system or compiler headers.
+
+You may need to experiment to determine the best settings for your application.
+
+The default is @samp{-femit-struct-debug-detailed=all}.
+
+This option works only with DWARF 2.
+
+@item -fno-merge-debug-strings
+@opindex fmerge-debug-strings
+@opindex fno-merge-debug-strings
+Direct the linker to not merge together strings in the debugging
+information which are identical in different object files.  Merging is
+not supported by all assemblers or linkers.  Merging decreases the size
+of the debug information in the output file at the cost of increasing
+link processing time.  Merging is enabled by default.
+
+@item -fdebug-prefix-map=@var{old}=@var{new}
+@opindex fdebug-prefix-map
+When compiling files in directory @file{@var{old}}, record debugging
+information describing them as in @file{@var{new}} instead.
+
+@item -fno-dwarf2-cfi-asm
+@opindex fdwarf2-cfi-asm
+@opindex fno-dwarf2-cfi-asm
+Emit DWARF 2 unwind info as compiler generated @code{.eh_frame} section
+instead of using GAS @code{.cfi_*} directives.
+
+@cindex @command{prof}
+@item -p
+@opindex p
+Generate extra code to write profile information suitable for the
+analysis program @command{prof}.  You must use this option when compiling
+the source files you want data about, and you must also use it when
+linking.
+
+@cindex @command{gprof}
+@item -pg
+@opindex pg
+Generate extra code to write profile information suitable for the
+analysis program @command{gprof}.  You must use this option when compiling
+the source files you want data about, and you must also use it when
+linking.
+
+@item -Q
+@opindex Q
+Makes the compiler print out each function name as it is compiled, and
+print some statistics about each pass when it finishes.
+
+@item -ftime-report
+@opindex ftime-report
+Makes the compiler print some statistics about the time consumed by each
+pass when it finishes.
+
+@item -fmem-report
+@opindex fmem-report
+Makes the compiler print some statistics about permanent memory
+allocation when it finishes.
+
+@item -fpre-ipa-mem-report
+@opindex fpre-ipa-mem-report
+@item -fpost-ipa-mem-report
+@opindex fpost-ipa-mem-report
+Makes the compiler print some statistics about permanent memory
+allocation before or after interprocedural optimization.
+
+@item -fprofile-arcs
+@opindex fprofile-arcs
+Add code so that program flow @dfn{arcs} are instrumented.  During
+execution the program records how many times each branch and call is
+executed and how many times it is taken or returns.  When the compiled
+program exits it saves this data to a file called
+@file{@var{auxname}.gcda} for each source file.  The data may be used for
+profile-directed optimizations (@option{-fbranch-probabilities}), or for
+test coverage analysis (@option{-ftest-coverage}).  Each object file's
+@var{auxname} is generated from the name of the output file, if
+explicitly specified and it is not the final executable, otherwise it is
+the basename of the source file.  In both cases any suffix is removed
+(e.g.@: @file{foo.gcda} for input file @file{dir/foo.c}, or
+@file{dir/foo.gcda} for output file specified as @option{-o dir/foo.o}).
+@xref{Cross-profiling}.
+
+@cindex @command{gcov}
+@item --coverage
+@opindex coverage
+
+This option is used to compile and link code instrumented for coverage
+analysis.  The option is a synonym for @option{-fprofile-arcs}
+@option{-ftest-coverage} (when compiling) and @option{-lgcov} (when
+linking).  See the documentation for those options for more details.
+
+@itemize
+
+@item
+Compile the source files with @option{-fprofile-arcs} plus optimization
+and code generation options.  For test coverage analysis, use the
+additional @option{-ftest-coverage} option.  You do not need to profile
+every source file in a program.
+
+@item
+Link your object files with @option{-lgcov} or @option{-fprofile-arcs}
+(the latter implies the former).
+
+@item
+Run the program on a representative workload to generate the arc profile
+information.  This may be repeated any number of times.  You can run
+concurrent instances of your program, and provided that the file system
+supports locking, the data files will be correctly updated.  Also
+@code{fork} calls are detected and correctly handled (double counting
+will not happen).
+
+@item
+For profile-directed optimizations, compile the source files again with
+the same optimization and code generation options plus
+@option{-fbranch-probabilities} (@pxref{Optimize Options,,Options that
+Control Optimization}).
+
+@item
+For test coverage analysis, use @command{gcov} to produce human readable
+information from the @file{.gcno} and @file{.gcda} files.  Refer to the
+@command{gcov} documentation for further information.
+
+@end itemize
+
+With @option{-fprofile-arcs}, for each function of your program GCC
+creates a program flow graph, then finds a spanning tree for the graph.
+Only arcs that are not on the spanning tree have to be instrumented: the
+compiler adds code to count the number of times that these arcs are
+executed.  When an arc is the only exit or only entrance to a block, the
+instrumentation code can be added to the block; otherwise, a new basic
+block must be created to hold the instrumentation code.
+
+@need 2000
+@item -ftest-coverage
+@opindex ftest-coverage
+Produce a notes file that the @command{gcov} code-coverage utility
+(@pxref{Gcov,, @command{gcov}---a Test Coverage Program}) can use to
+show program coverage.  Each source file's note file is called
+@file{@var{auxname}.gcno}.  Refer to the @option{-fprofile-arcs} option
+above for a description of @var{auxname} and instructions on how to
+generate test coverage data.  Coverage data will match the source files
+more closely, if you do not optimize.
+
+@item -fdbg-cnt-list
+@opindex fdbg-cnt-list
+Print the name and the counter upperbound for all debug counters.
+
+@item -fdbg-cnt=@var{counter-value-list}
+@opindex fdbg-cnt
+Set the internal debug counter upperbound. @var{counter-value-list} 
+is a comma-separated list of @var{name}:@var{value} pairs
+which sets the upperbound of each debug counter @var{name} to @var{value}.
+All debug counters have the initial upperbound of @var{UINT_MAX},
+thus dbg_cnt() returns true always unless the upperbound is set by this option.
+e.g. With -fdbg-cnt=dce:10,tail_call:0
+dbg_cnt(dce) will return true only for first 10 invocations
+and dbg_cnt(tail_call) will return false always.
+
+@item -d@var{letters}
+@itemx -fdump-rtl-@var{pass}
+@opindex d
+Says to make debugging dumps during compilation at times specified by
+@var{letters}.    This is used for debugging the RTL-based passes of the
+compiler.  The file names for most of the dumps are made by appending a
+pass number and a word to the @var{dumpname}.  @var{dumpname} is generated
+from the name of the output file, if explicitly specified and it is not
+an executable, otherwise it is the basename of the source file. These
+switches may have different effects when @option{-E} is used for
+preprocessing.
+
+Debug dumps can be enabled with a @option{-fdump-rtl} switch or some
+@option{-d} option @var{letters}.  Here are the possible
+letters for use in @var{pass} and @var{letters}, and their meanings:
+
+@table @gcctabopt
+
+@item -fdump-rtl-alignments
+@opindex fdump-rtl-alignments
+Dump after branch alignments have been computed.
+
+@item -fdump-rtl-asmcons
+@opindex fdump-rtl-asmcons
+Dump after fixing rtl statements that have unsatisfied in/out constraints.
+
+@item -fdump-rtl-auto_inc_dec
+@opindex fdump-rtl-auto_inc_dec
+Dump after auto-inc-dec discovery.  This pass is only run on
+architectures that have auto inc or auto dec instructions.
+
+@item -fdump-rtl-barriers
+@opindex fdump-rtl-barriers
+Dump after cleaning up the barrier instructions.
+
+@item -fdump-rtl-bbpart
+@opindex fdump-rtl-bbpart
+Dump after partitioning hot and cold basic blocks.
+
+@item -fdump-rtl-bbro
+@opindex fdump-rtl-bbro
+Dump after block reordering.
+
+@item -fdump-rtl-btl1
+@itemx -fdump-rtl-btl2
+@opindex fdump-rtl-btl2
+@opindex fdump-rtl-btl2
+@option{-fdump-rtl-btl1} and @option{-fdump-rtl-btl2} enable dumping
+after the two branch
+target load optimization passes.
+
+@item -fdump-rtl-bypass
+@opindex fdump-rtl-bypass
+Dump after jump bypassing and control flow optimizations.
+
+@item -fdump-rtl-combine
+@opindex fdump-rtl-combine
+Dump after the RTL instruction combination pass.
+
+@item -fdump-rtl-compgotos
+@opindex fdump-rtl-compgotos
+Dump after duplicating the computed gotos.
+
+@item -fdump-rtl-ce1
+@itemx -fdump-rtl-ce2
+@itemx -fdump-rtl-ce3
+@opindex fdump-rtl-ce1
+@opindex fdump-rtl-ce2
+@opindex fdump-rtl-ce3
+@option{-fdump-rtl-ce1}, @option{-fdump-rtl-ce2}, and
+@option{-fdump-rtl-ce3} enable dumping after the three
+if conversion passes. 
+
+@itemx -fdump-rtl-cprop_hardreg
+@opindex fdump-rtl-cprop_hardreg
+Dump after hard register copy propagation.
+
+@itemx -fdump-rtl-csa
+@opindex fdump-rtl-csa
+Dump after combining stack adjustments.
+
+@item -fdump-rtl-cse1
+@itemx -fdump-rtl-cse2
+@opindex fdump-rtl-cse1
+@opindex fdump-rtl-cse2
+@option{-fdump-rtl-cse1} and @option{-fdump-rtl-cse2} enable dumping after
+the two common sub-expression elimination passes.
+
+@itemx -fdump-rtl-dce
+@opindex fdump-rtl-dce
+Dump after the standalone dead code elimination passes.
+
+@itemx -fdump-rtl-dbr
+@opindex fdump-rtl-dbr
+Dump after delayed branch scheduling.
+
+@item -fdump-rtl-dce1
+@itemx -fdump-rtl-dce2
+@opindex fdump-rtl-dce1
+@opindex fdump-rtl-dce2
+@option{-fdump-rtl-dce1} and @option{-fdump-rtl-dce2} enable dumping after
+the two dead store elimination passes.
+
+@item -fdump-rtl-eh
+@opindex fdump-rtl-eh
+Dump after finalization of EH handling code.
+
+@item -fdump-rtl-eh_ranges
+@opindex fdump-rtl-eh_ranges
+Dump after conversion of EH handling range regions.
+
+@item -fdump-rtl-expand
+@opindex fdump-rtl-expand
+Dump after RTL generation.
+
+@item -fdump-rtl-fwprop1
+@itemx -fdump-rtl-fwprop2
+@opindex fdump-rtl-fwprop1
+@opindex fdump-rtl-fwprop2
+@option{-fdump-rtl-fwprop1} and @option{-fdump-rtl-fwprop2} enable
+dumping after the two forward propagation passes.
+
+@item -fdump-rtl-gcse1
+@itemx -fdump-rtl-gcse2
+@opindex fdump-rtl-gcse1
+@opindex fdump-rtl-gcse2
+@option{-fdump-rtl-gcse1} and @option{-fdump-rtl-gcse2} enable dumping
+after global common subexpression elimination.
+
+@item -fdump-rtl-init-regs
+@opindex fdump-rtl-init-regs
+Dump after the initialization of the registers.
+
+@item -fdump-rtl-initvals
+@opindex fdump-rtl-initvals
+Dump after the computation of the initial value sets.
+
+@itemx -fdump-rtl-into_cfglayout
+@opindex fdump-rtl-into_cfglayout
+Dump after converting to cfglayout mode.
+
+@item -fdump-rtl-ira
+@opindex fdump-rtl-ira
+Dump after iterated register allocation.
+
+@item -fdump-rtl-jump
+@opindex fdump-rtl-jump
+Dump after the second jump optimization.
+
+@item -fdump-rtl-loop2
+@opindex fdump-rtl-loop2
+@option{-fdump-rtl-loop2} enables dumping after the rtl
+loop optimization passes.
+
+@item -fdump-rtl-mach
+@opindex fdump-rtl-mach
+Dump after performing the machine dependent reorganization pass, if that
+pass exists.
+
+@item -fdump-rtl-mode_sw
+@opindex fdump-rtl-mode_sw
+Dump after removing redundant mode switches.
+
+@item -fdump-rtl-rnreg
+@opindex fdump-rtl-rnreg
+Dump after register renumbering.
+
+@itemx -fdump-rtl-outof_cfglayout
+@opindex fdump-rtl-outof_cfglayout
+Dump after converting from cfglayout mode.
+
+@item -fdump-rtl-peephole2
+@opindex fdump-rtl-peephole2
+Dump after the peephole pass.
+
+@item -fdump-rtl-postreload
+@opindex fdump-rtl-postreload
+Dump after post-reload optimizations.
+
+@itemx -fdump-rtl-pro_and_epilogue
+@opindex fdump-rtl-pro_and_epilogue
+Dump after generating the function pro and epilogues.
+
+@item -fdump-rtl-regmove
+@opindex fdump-rtl-regmove
+Dump after the register move pass.
+
+@item -fdump-rtl-sched1
+@itemx -fdump-rtl-sched2
+@opindex fdump-rtl-sched1
+@opindex fdump-rtl-sched2
+@option{-fdump-rtl-sched1} and @option{-fdump-rtl-sched2} enable dumping
+after the basic block scheduling passes.
+
+@item -fdump-rtl-see
+@opindex fdump-rtl-see
+Dump after sign extension elimination.
+
+@item -fdump-rtl-seqabstr
+@opindex fdump-rtl-seqabstr
+Dump after common sequence discovery. 
+
+@item -fdump-rtl-shorten
+@opindex fdump-rtl-shorten
+Dump after shortening branches.
+
+@item -fdump-rtl-sibling
+@opindex fdump-rtl-sibling
+Dump after sibling call optimizations.
+
+@item -fdump-rtl-split1
+@itemx -fdump-rtl-split2
+@itemx -fdump-rtl-split3
+@itemx -fdump-rtl-split4
+@itemx -fdump-rtl-split5
+@opindex fdump-rtl-split1
+@opindex fdump-rtl-split2
+@opindex fdump-rtl-split3
+@opindex fdump-rtl-split4
+@opindex fdump-rtl-split5
+@option{-fdump-rtl-split1}, @option{-fdump-rtl-split2},
+@option{-fdump-rtl-split3}, @option{-fdump-rtl-split4} and
+@option{-fdump-rtl-split5} enable dumping after five rounds of
+instruction splitting.
+
+@item -fdump-rtl-sms
+@opindex fdump-rtl-sms
+Dump after modulo scheduling.  This pass is only run on some
+architectures.
+
+@item -fdump-rtl-stack
+@opindex fdump-rtl-stack
+Dump after conversion from GCC's "flat register file" registers to the
+x87's stack-like registers.  This pass is only run on x86 variants.
+
+@item -fdump-rtl-subreg1
+@itemx -fdump-rtl-subreg2
+@opindex fdump-rtl-subreg1
+@opindex fdump-rtl-subreg2
+@option{-fdump-rtl-subreg1} and @option{-fdump-rtl-subreg2} enable dumping after
+the two subreg expansion passes.
+
+@item -fdump-rtl-unshare
+@opindex fdump-rtl-unshare
+Dump after all rtl has been unshared.
+
+@item -fdump-rtl-vartrack
+@opindex fdump-rtl-vartrack
+Dump after variable tracking.
+
+@item -fdump-rtl-vregs
+@opindex fdump-rtl-vregs
+Dump after converting virtual registers to hard registers.
+
+@item -fdump-rtl-web
+@opindex fdump-rtl-web
+Dump after live range splitting.
+
+@item -fdump-rtl-regclass
+@itemx -fdump-rtl-subregs_of_mode_init
+@itemx -fdump-rtl-subregs_of_mode_finish
+@itemx -fdump-rtl-dfinit
+@itemx -fdump-rtl-dfinish
+@opindex fdump-rtl-regclass
+@opindex fdump-rtl-subregs_of_mode_init
+@opindex fdump-rtl-subregs_of_mode_finish
+@opindex fdump-rtl-dfinit
+@opindex fdump-rtl-dfinish
+These dumps are defined but always produce empty files.
+
+@item -fdump-rtl-all
+@opindex fdump-rtl-all
+Produce all the dumps listed above.
+
+@item -dA
+@opindex dA
+Annotate the assembler output with miscellaneous debugging information.
+
+@item -dD
+@opindex dD
+Dump all macro definitions, at the end of preprocessing, in addition to
+normal output.
+
+@item -dH
+@opindex dH
+Produce a core dump whenever an error occurs.
+
+@item -dm
+@opindex dm
+Print statistics on memory usage, at the end of the run, to
+standard error.
+
+@item -dp
+@opindex dp
+Annotate the assembler output with a comment indicating which
+pattern and alternative was used.  The length of each instruction is
+also printed.
+
+@item -dP
+@opindex dP
+Dump the RTL in the assembler output as a comment before each instruction.
+Also turns on @option{-dp} annotation.
+
+@item -dv
+@opindex dv
+For each of the other indicated dump files (@option{-fdump-rtl-@var{pass}}),
+dump a representation of the control flow graph suitable for viewing with VCG
+to @file{@var{file}.@var{pass}.vcg}.
+
+@item -dx
+@opindex dx
+Just generate RTL for a function instead of compiling it.  Usually used
+with @option{-fdump-rtl-expand}.
+
+@item -dy
+@opindex dy
+Dump debugging information during parsing, to standard error.
+@end table
+
+@item -fdump-noaddr
+@opindex fdump-noaddr
+When doing debugging dumps, suppress address output.  This makes it more
+feasible to use diff on debugging dumps for compiler invocations with
+different compiler binaries and/or different
+text / bss / data / heap / stack / dso start locations.
+
+@item -fdump-unnumbered
+@opindex fdump-unnumbered
+When doing debugging dumps, suppress instruction numbers and address output.
+This makes it more feasible to use diff on debugging dumps for compiler
+invocations with different options, in particular with and without
+@option{-g}.
+
+@item -fdump-translation-unit @r{(C++ only)}
+@itemx -fdump-translation-unit-@var{options} @r{(C++ only)}
+@opindex fdump-translation-unit
+Dump a representation of the tree structure for the entire translation
+unit to a file.  The file name is made by appending @file{.tu} to the
+source file name.  If the @samp{-@var{options}} form is used, @var{options}
+controls the details of the dump as described for the
+@option{-fdump-tree} options.
+
+@item -fdump-class-hierarchy @r{(C++ only)}
+@itemx -fdump-class-hierarchy-@var{options} @r{(C++ only)}
+@opindex fdump-class-hierarchy
+Dump a representation of each class's hierarchy and virtual function
+table layout to a file.  The file name is made by appending @file{.class}
+to the source file name.  If the @samp{-@var{options}} form is used,
+@var{options} controls the details of the dump as described for the
+@option{-fdump-tree} options.
+
+@item -fdump-ipa-@var{switch}
+@opindex fdump-ipa
+Control the dumping at various stages of inter-procedural analysis
+language tree to a file.  The file name is generated by appending a switch
+specific suffix to the source file name.  The following dumps are possible:
+
+@table @samp
+@item all
+Enables all inter-procedural analysis dumps.
+
+@item cgraph
+Dumps information about call-graph optimization, unused function removal,
+and inlining decisions.
+
+@item inline
+Dump after function inlining.
+
+@end table
+
+@item -fdump-statistics-@var{option}
+@opindex -fdump-statistics
+Enable and control dumping of pass statistics in a separate file.  The
+file name is generated by appending a suffix ending in @samp{.statistics}
+to the source file name.  If the @samp{-@var{option}} form is used,
+@samp{-stats} will cause counters to be summed over the whole compilation unit
+while @samp{-details} will dump every event as the passes generate them.
+The default with no option is to sum counters for each function compiled.
+
+@item -fdump-tree-@var{switch}
+@itemx -fdump-tree-@var{switch}-@var{options}
+@opindex fdump-tree
+Control the dumping at various stages of processing the intermediate
+language tree to a file.  The file name is generated by appending a switch
+specific suffix to the source file name.  If the @samp{-@var{options}}
+form is used, @var{options} is a list of @samp{-} separated options that
+control the details of the dump.  Not all options are applicable to all
+dumps, those which are not meaningful will be ignored.  The following
+options are available
+
+@table @samp
+@item address
+Print the address of each node.  Usually this is not meaningful as it
+changes according to the environment and source file.  Its primary use
+is for tying up a dump file with a debug environment.
+@item slim
+Inhibit dumping of members of a scope or body of a function merely
+because that scope has been reached.  Only dump such items when they
+are directly reachable by some other path.  When dumping pretty-printed
+trees, this option inhibits dumping the bodies of control structures.
+@item raw
+Print a raw representation of the tree.  By default, trees are
+pretty-printed into a C-like representation.
+@item details
+Enable more detailed dumps (not honored by every dump option).
+@item stats
+Enable dumping various statistics about the pass (not honored by every dump
+option).
+@item blocks
+Enable showing basic block boundaries (disabled in raw dumps).
+@item vops
+Enable showing virtual operands for every statement.
+@item lineno
+Enable showing line numbers for statements.
+@item uid
+Enable showing the unique ID (@code{DECL_UID}) for each variable.
+@item verbose
+Enable showing the tree dump for each statement.
+@item all
+Turn on all options, except @option{raw}, @option{slim}, @option{verbose}
+and @option{lineno}.
+@end table
+
+The following tree dumps are possible:
+@table @samp
+
+@item original
+Dump before any tree based optimization, to @file{@var{file}.original}.
+
+@item optimized
+Dump after all tree based optimization, to @file{@var{file}.optimized}.
+
+@item gimple
+@opindex fdump-tree-gimple
+Dump each function before and after the gimplification pass to a file.  The
+file name is made by appending @file{.gimple} to the source file name.
+
+@item cfg
+@opindex fdump-tree-cfg
+Dump the control flow graph of each function to a file.  The file name is
+made by appending @file{.cfg} to the source file name.
+
+@item vcg
+@opindex fdump-tree-vcg
+Dump the control flow graph of each function to a file in VCG format.  The
+file name is made by appending @file{.vcg} to the source file name.  Note
+that if the file contains more than one function, the generated file cannot
+be used directly by VCG@.  You will need to cut and paste each function's
+graph into its own separate file first.
+
+@item ch
+@opindex fdump-tree-ch
+Dump each function after copying loop headers.  The file name is made by
+appending @file{.ch} to the source file name.
+
+@item ssa
+@opindex fdump-tree-ssa
+Dump SSA related information to a file.  The file name is made by appending
+@file{.ssa} to the source file name.
+
+@item alias
+@opindex fdump-tree-alias
+Dump aliasing information for each function.  The file name is made by
+appending @file{.alias} to the source file name.
+
+@item ccp
+@opindex fdump-tree-ccp
+Dump each function after CCP@.  The file name is made by appending
+@file{.ccp} to the source file name.
+
+@item storeccp
+@opindex fdump-tree-storeccp
+Dump each function after STORE-CCP@.  The file name is made by appending
+@file{.storeccp} to the source file name.
+
+@item pre
+@opindex fdump-tree-pre
+Dump trees after partial redundancy elimination.  The file name is made
+by appending @file{.pre} to the source file name.
+
+@item fre
+@opindex fdump-tree-fre
+Dump trees after full redundancy elimination.  The file name is made
+by appending @file{.fre} to the source file name.
+
+@item copyprop
+@opindex fdump-tree-copyprop
+Dump trees after copy propagation.  The file name is made
+by appending @file{.copyprop} to the source file name.
+
+@item store_copyprop
+@opindex fdump-tree-store_copyprop
+Dump trees after store copy-propagation.  The file name is made
+by appending @file{.store_copyprop} to the source file name.
+
+@item dce
+@opindex fdump-tree-dce
+Dump each function after dead code elimination.  The file name is made by
+appending @file{.dce} to the source file name.
+
+@item mudflap
+@opindex fdump-tree-mudflap
+Dump each function after adding mudflap instrumentation.  The file name is
+made by appending @file{.mudflap} to the source file name.
+
+@item sra
+@opindex fdump-tree-sra
+Dump each function after performing scalar replacement of aggregates.  The
+file name is made by appending @file{.sra} to the source file name.
+
+@item sink
+@opindex fdump-tree-sink
+Dump each function after performing code sinking.  The file name is made
+by appending @file{.sink} to the source file name.
+
+@item dom
+@opindex fdump-tree-dom
+Dump each function after applying dominator tree optimizations.  The file
+name is made by appending @file{.dom} to the source file name.
+
+@item dse
+@opindex fdump-tree-dse
+Dump each function after applying dead store elimination.  The file
+name is made by appending @file{.dse} to the source file name.
+
+@item phiopt
+@opindex fdump-tree-phiopt
+Dump each function after optimizing PHI nodes into straightline code.  The file
+name is made by appending @file{.phiopt} to the source file name.
+
+@item forwprop
+@opindex fdump-tree-forwprop
+Dump each function after forward propagating single use variables.  The file
+name is made by appending @file{.forwprop} to the source file name.
+
+@item copyrename
+@opindex fdump-tree-copyrename
+Dump each function after applying the copy rename optimization.  The file
+name is made by appending @file{.copyrename} to the source file name.
+
+@item nrv
+@opindex fdump-tree-nrv
+Dump each function after applying the named return value optimization on
+generic trees.  The file name is made by appending @file{.nrv} to the source
+file name.
+
+@item vect
+@opindex fdump-tree-vect
+Dump each function after applying vectorization of loops.  The file name is
+made by appending @file{.vect} to the source file name.
+
+@item vrp
+@opindex fdump-tree-vrp
+Dump each function after Value Range Propagation (VRP).  The file name
+is made by appending @file{.vrp} to the source file name.
+
+@item all
+@opindex fdump-tree-all
+Enable all the available tree dumps with the flags provided in this option.
+@end table
+
+@item -ftree-vectorizer-verbose=@var{n}
+@opindex ftree-vectorizer-verbose
+This option controls the amount of debugging output the vectorizer prints.
+This information is written to standard error, unless
+@option{-fdump-tree-all} or @option{-fdump-tree-vect} is specified,
+in which case it is output to the usual dump listing file, @file{.vect}.
+For @var{n}=0 no diagnostic information is reported.
+If @var{n}=1 the vectorizer reports each loop that got vectorized,
+and the total number of loops that got vectorized.
+If @var{n}=2 the vectorizer also reports non-vectorized loops that passed
+the first analysis phase (vect_analyze_loop_form) - i.e.@: countable,
+inner-most, single-bb, single-entry/exit loops.  This is the same verbosity
+level that @option{-fdump-tree-vect-stats} uses.
+Higher verbosity levels mean either more information dumped for each
+reported loop, or same amount of information reported for more loops:
+If @var{n}=3, alignment related information is added to the reports.
+If @var{n}=4, data-references related information (e.g.@: memory dependences,
+memory access-patterns) is added to the reports.
+If @var{n}=5, the vectorizer reports also non-vectorized inner-most loops
+that did not pass the first analysis phase (i.e., may not be countable, or
+may have complicated control-flow).
+If @var{n}=6, the vectorizer reports also non-vectorized nested loops.
+For @var{n}=7, all the information the vectorizer generates during its
+analysis and transformation is reported.  This is the same verbosity level
+that @option{-fdump-tree-vect-details} uses.
+
+@item -frandom-seed=@var{string}
+@opindex frandom-string
+This option provides a seed that GCC uses when it would otherwise use
+random numbers.  It is used to generate certain symbol names
+that have to be different in every compiled file.  It is also used to
+place unique stamps in coverage data files and the object files that
+produce them.  You can use the @option{-frandom-seed} option to produce
+reproducibly identical object files.
+
+The @var{string} should be different for every file you compile.
+
+@item -fsched-verbose=@var{n}
+@opindex fsched-verbose
+On targets that use instruction scheduling, this option controls the
+amount of debugging output the scheduler prints.  This information is
+written to standard error, unless @option{-fdump-rtl-sched1} or
+@option{-fdump-rtl-sched2} is specified, in which case it is output
+to the usual dump listing file, @file{.sched} or @file{.sched2}
+respectively.  However for @var{n} greater than nine, the output is
+always printed to standard error.
+
+For @var{n} greater than zero, @option{-fsched-verbose} outputs the
+same information as @option{-fdump-rtl-sched1} and @option{-fdump-rtl-sched2}.
+For @var{n} greater than one, it also output basic block probabilities,
+detailed ready list information and unit/insn info.  For @var{n} greater
+than two, it includes RTL at abort point, control-flow and regions info.
+And for @var{n} over four, @option{-fsched-verbose} also includes
+dependence info.
+
+@item -save-temps
+@opindex save-temps
+Store the usual ``temporary'' intermediate files permanently; place them
+in the current directory and name them based on the source file.  Thus,
+compiling @file{foo.c} with @samp{-c -save-temps} would produce files
+@file{foo.i} and @file{foo.s}, as well as @file{foo.o}.  This creates a
+preprocessed @file{foo.i} output file even though the compiler now
+normally uses an integrated preprocessor.
+
+When used in combination with the @option{-x} command line option,
+@option{-save-temps} is sensible enough to avoid over writing an
+input source file with the same extension as an intermediate file.
+The corresponding intermediate file may be obtained by renaming the
+source file before using @option{-save-temps}.
+
+@item -time
+@opindex time
+Report the CPU time taken by each subprocess in the compilation
+sequence.  For C source files, this is the compiler proper and assembler
+(plus the linker if linking is done).  The output looks like this:
+
+@smallexample
+# cc1 0.12 0.01
+# as 0.00 0.01
+@end smallexample
+
+The first number on each line is the ``user time'', that is time spent
+executing the program itself.  The second number is ``system time'',
+time spent executing operating system routines on behalf of the program.
+Both numbers are in seconds.
+
+@item -fvar-tracking
+@opindex fvar-tracking
+Run variable tracking pass.  It computes where variables are stored at each
+position in code.  Better debugging information is then generated
+(if the debugging information format supports this information).
+
+It is enabled by default when compiling with optimization (@option{-Os},
+@option{-O}, @option{-O2}, @dots{}), debugging information (@option{-g}) and
+the debug info format supports it.
+
+@item -print-file-name=@var{library}
+@opindex print-file-name
+Print the full absolute name of the library file @var{library} that
+would be used when linking---and don't do anything else.  With this
+option, GCC does not compile or link anything; it just prints the
+file name.
+
+@item -print-multi-directory
+@opindex print-multi-directory
+Print the directory name corresponding to the multilib selected by any
+other switches present in the command line.  This directory is supposed
+to exist in @env{GCC_EXEC_PREFIX}.
+
+@item -print-multi-lib
+@opindex print-multi-lib
+Print the mapping from multilib directory names to compiler switches
+that enable them.  The directory name is separated from the switches by
+@samp{;}, and each switch starts with an @samp{@@} instead of the
+@samp{-}, without spaces between multiple switches.  This is supposed to
+ease shell-processing.
+
+@item -print-prog-name=@var{program}
+@opindex print-prog-name
+Like @option{-print-file-name}, but searches for a program such as @samp{cpp}.
+
+@item -print-libgcc-file-name
+@opindex print-libgcc-file-name
+Same as @option{-print-file-name=libgcc.a}.
+
+This is useful when you use @option{-nostdlib} or @option{-nodefaultlibs}
+but you do want to link with @file{libgcc.a}.  You can do
+
+@smallexample
+gcc -nostdlib @var{files}@dots{} `gcc -print-libgcc-file-name`
+@end smallexample
+
+@item -print-search-dirs
+@opindex print-search-dirs
+Print the name of the configured installation directory and a list of
+program and library directories @command{gcc} will search---and don't do anything else.
+
+This is useful when @command{gcc} prints the error message
+@samp{installation problem, cannot exec cpp0: No such file or directory}.
+To resolve this you either need to put @file{cpp0} and the other compiler
+components where @command{gcc} expects to find them, or you can set the environment
+variable @env{GCC_EXEC_PREFIX} to the directory where you installed them.
+Don't forget the trailing @samp{/}.
+@xref{Environment Variables}.
+
+@item -print-sysroot
+@opindex print-sysroot
+Print the target sysroot directory that will be used during
+compilation.  This is the target sysroot specified either at configure
+time or using the @option{--sysroot} option, possibly with an extra
+suffix that depends on compilation options.  If no target sysroot is
+specified, the option prints nothing.
+
+@item -print-sysroot-headers-suffix
+@opindex print-sysroot-headers-suffix
+Print the suffix added to the target sysroot when searching for
+headers, or give an error if the compiler is not configured with such
+a suffix---and don't do anything else.
+
+@item -dumpmachine
+@opindex dumpmachine
+Print the compiler's target machine (for example,
+@samp{i686-pc-linux-gnu})---and don't do anything else.
+
+@item -dumpversion
+@opindex dumpversion
+Print the compiler version (for example, @samp{3.0})---and don't do
+anything else.
+
+@item -dumpspecs
+@opindex dumpspecs
+Print the compiler's built-in specs---and don't do anything else.  (This
+is used when GCC itself is being built.)  @xref{Spec Files}.
+
+@item -feliminate-unused-debug-types
+@opindex feliminate-unused-debug-types
+Normally, when producing DWARF2 output, GCC will emit debugging
+information for all types declared in a compilation
+unit, regardless of whether or not they are actually used
+in that compilation unit.  Sometimes this is useful, such as
+if, in the debugger, you want to cast a value to a type that is
+not actually used in your program (but is declared).  More often,
+however, this results in a significant amount of wasted space.
+With this option, GCC will avoid producing debug symbol output
+for types that are nowhere used in the source file being compiled.
+@end table
+
+@node Optimize Options
+@section Options That Control Optimization
+@cindex optimize options
+@cindex options, optimization
+
+These options control various sorts of optimizations.
+
+Without any optimization option, the compiler's goal is to reduce the
+cost of compilation and to make debugging produce the expected
+results.  Statements are independent: if you stop the program with a
+breakpoint between statements, you can then assign a new value to any
+variable or change the program counter to any other statement in the
+function and get exactly the results you would expect from the source
+code.
+
+Turning on optimization flags makes the compiler attempt to improve
+the performance and/or code size at the expense of compilation time
+and possibly the ability to debug the program.
+
+The compiler performs optimization based on the knowledge it has of the
+program.  Compiling multiple files at once to a single output file mode allows
+the compiler to use information gained from all of the files when compiling
+each of them.
+
+Not all optimizations are controlled directly by a flag.  Only
+optimizations that have a flag are listed.
+
+@table @gcctabopt
+@item -O
+@itemx -O1
+@opindex O
+@opindex O1
+Optimize.  Optimizing compilation takes somewhat more time, and a lot
+more memory for a large function.
+
+With @option{-O}, the compiler tries to reduce code size and execution
+time, without performing any optimizations that take a great deal of
+compilation time.
+
+@option{-O} turns on the following optimization flags:
+@gccoptlist{
+-fauto-inc-dec @gol
+-fcprop-registers @gol
+-fdce @gol
+-fdefer-pop @gol
+-fdelayed-branch @gol
+-fdse @gol
+-fguess-branch-probability @gol
+-fif-conversion2 @gol
+-fif-conversion @gol
+-finline-small-functions @gol
+-fipa-pure-const @gol
+-fipa-reference @gol
+-fmerge-constants
+-fsplit-wide-types @gol
+-ftree-builtin-call-dce @gol
+-ftree-ccp @gol
+-ftree-ch @gol
+-ftree-copyrename @gol
+-ftree-dce @gol
+-ftree-dominator-opts @gol
+-ftree-dse @gol
+-ftree-fre @gol
+-ftree-sra @gol
+-ftree-ter @gol
+-funit-at-a-time}
+
+@option{-O} also turns on @option{-fomit-frame-pointer} on machines
+where doing so does not interfere with debugging.
+
+@item -O2
+@opindex O2
+Optimize even more.  GCC performs nearly all supported optimizations
+that do not involve a space-speed tradeoff.
+As compared to @option{-O}, this option increases both compilation time
+and the performance of the generated code.
+
+@option{-O2} turns on all optimization flags specified by @option{-O}.  It
+also turns on the following optimization flags:
+@gccoptlist{-fthread-jumps @gol
+-falign-functions  -falign-jumps @gol
+-falign-loops  -falign-labels @gol
+-fcaller-saves @gol
+-fcrossjumping @gol
+-fcse-follow-jumps  -fcse-skip-blocks @gol
+-fdelete-null-pointer-checks @gol
+-fexpensive-optimizations @gol
+-fgcse  -fgcse-lm  @gol
+-findirect-inlining @gol
+-foptimize-sibling-calls @gol
+-fpeephole2 @gol
+-fregmove @gol
+-freorder-blocks  -freorder-functions @gol
+-frerun-cse-after-loop  @gol
+-fsched-interblock  -fsched-spec @gol
+-fschedule-insns  -fschedule-insns2 @gol
+-fstrict-aliasing -fstrict-overflow @gol
+-ftree-switch-conversion @gol
+-ftree-pre @gol
+-ftree-vrp}
+
+Please note the warning under @option{-fgcse} about
+invoking @option{-O2} on programs that use computed gotos.
+
+@item -O3
+@opindex O3
+Optimize yet more.  @option{-O3} turns on all optimizations specified
+by @option{-O2} and also turns on the @option{-finline-functions},
+@option{-funswitch-loops}, @option{-fpredictive-commoning},
+@option{-fgcse-after-reload}, @option{-ftree-vectorize} and
+@option{-fipa-cp-clone} options.
+
+@item -O0
+@opindex O0
+Reduce compilation time and make debugging produce the expected
+results.  This is the default.
+
+@item -Os
+@opindex Os
+Optimize for size.  @option{-Os} enables all @option{-O2} optimizations that
+do not typically increase code size.  It also performs further
+optimizations designed to reduce code size.
+
+@option{-Os} disables the following optimization flags:
+@gccoptlist{-falign-functions  -falign-jumps  -falign-loops @gol
+-falign-labels  -freorder-blocks  -freorder-blocks-and-partition @gol
+-fprefetch-loop-arrays  -ftree-vect-loop-version}
+
+If you use multiple @option{-O} options, with or without level numbers,
+the last such option is the one that is effective.
+@end table
+
+Options of the form @option{-f@var{flag}} specify machine-independent
+flags.  Most flags have both positive and negative forms; the negative
+form of @option{-ffoo} would be @option{-fno-foo}.  In the table
+below, only one of the forms is listed---the one you typically will
+use.  You can figure out the other form by either removing @samp{no-}
+or adding it.
+
+The following options control specific optimizations.  They are either
+activated by @option{-O} options or are related to ones that are.  You
+can use the following flags in the rare cases when ``fine-tuning'' of
+optimizations to be performed is desired.
+
+@table @gcctabopt
+@item -fno-default-inline
+@opindex fno-default-inline
+Do not make member functions inline by default merely because they are
+defined inside the class scope (C++ only).  Otherwise, when you specify
+@w{@option{-O}}, member functions defined inside class scope are compiled
+inline by default; i.e., you don't need to add @samp{inline} in front of
+the member function name.
+
+@item -fno-defer-pop
+@opindex fno-defer-pop
+Always pop the arguments to each function call as soon as that function
+returns.  For machines which must pop arguments after a function call,
+the compiler normally lets arguments accumulate on the stack for several
+function calls and pops them all at once.
+
+Disabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fforward-propagate
+@opindex fforward-propagate
+Perform a forward propagation pass on RTL@.  The pass tries to combine two
+instructions and checks if the result can be simplified.  If loop unrolling
+is active, two passes are performed and the second is scheduled after
+loop unrolling.
+
+This option is enabled by default at optimization levels @option{-O2},
+@option{-O3}, @option{-Os}.
+
+@item -fomit-frame-pointer
+@opindex fomit-frame-pointer
+Don't keep the frame pointer in a register for functions that
+don't need one.  This avoids the instructions to save, set up and
+restore frame pointers; it also makes an extra register available
+in many functions.  @strong{It also makes debugging impossible on
+some machines.}
+
+On some machines, such as the VAX, this flag has no effect, because
+the standard calling sequence automatically handles the frame pointer
+and nothing is saved by pretending it doesn't exist.  The
+machine-description macro @code{FRAME_POINTER_REQUIRED} controls
+whether a target machine supports this flag.  @xref{Registers,,Register
+Usage, gccint, GNU Compiler Collection (GCC) Internals}.
+
+Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -foptimize-sibling-calls
+@opindex foptimize-sibling-calls
+Optimize sibling and tail recursive calls.
+
+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fno-inline
+@opindex fno-inline
+Don't pay attention to the @code{inline} keyword.  Normally this option
+is used to keep the compiler from expanding any functions inline.
+Note that if you are not optimizing, no functions can be expanded inline.
+
+@item -finline-small-functions
+@opindex finline-small-functions
+Integrate functions into their callers when their body is smaller than expected
+function call code (so overall size of program gets smaller).  The compiler
+heuristically decides which functions are simple enough to be worth integrating
+in this way.
+
+Enabled at level @option{-O2}.
+
+@item -findirect-inlining
+@opindex findirect-inlining
+Inline also indirect calls that are discovered to be known at compile
+time thanks to previous inlining.  This option has any effect only
+when inlining itself is turned on by the @option{-finline-functions}
+or @option{-finline-small-functions} options.
+
+Enabled at level @option{-O2}.
+
+@item -finline-functions
+@opindex finline-functions
+Integrate all simple functions into their callers.  The compiler
+heuristically decides which functions are simple enough to be worth
+integrating in this way.
+
+If all calls to a given function are integrated, and the function is
+declared @code{static}, then the function is normally not output as
+assembler code in its own right.
+
+Enabled at level @option{-O3}.
+
+@item -finline-functions-called-once
+@opindex finline-functions-called-once
+Consider all @code{static} functions called once for inlining into their
+caller even if they are not marked @code{inline}.  If a call to a given
+function is integrated, then the function is not output as assembler code
+in its own right.
+
+Enabled at levels @option{-O1}, @option{-O2}, @option{-O3} and @option{-Os}.
+
+@item -fearly-inlining
+@opindex fearly-inlining
+Inline functions marked by @code{always_inline} and functions whose body seems
+smaller than the function call overhead early before doing
+@option{-fprofile-generate} instrumentation and real inlining pass.  Doing so
+makes profiling significantly cheaper and usually inlining faster on programs
+having large chains of nested wrapper functions.
+
+Enabled by default.
+
+@item -finline-limit=@var{n}
+@opindex finline-limit
+By default, GCC limits the size of functions that can be inlined.  This flag
+allows coarse control of this limit.  @var{n} is the size of functions that
+can be inlined in number of pseudo instructions.
+
+Inlining is actually controlled by a number of parameters, which may be
+specified individually by using @option{--param @var{name}=@var{value}}.
+The @option{-finline-limit=@var{n}} option sets some of these parameters
+as follows:
+
+@table @gcctabopt
+@item max-inline-insns-single
+is set to @var{n}/2.
+@item max-inline-insns-auto
+is set to @var{n}/2.
+@end table
+
+See below for a documentation of the individual
+parameters controlling inlining and for the defaults of these parameters.
+
+@emph{Note:} there may be no value to @option{-finline-limit} that results
+in default behavior.
+
+@emph{Note:} pseudo instruction represents, in this particular context, an
+abstract measurement of function's size.  In no way does it represent a count
+of assembly instructions and as such its exact meaning might change from one
+release to an another.
+
+@item -fkeep-inline-functions
+@opindex fkeep-inline-functions
+In C, emit @code{static} functions that are declared @code{inline}
+into the object file, even if the function has been inlined into all
+of its callers.  This switch does not affect functions using the
+@code{extern inline} extension in GNU C89@.  In C++, emit any and all
+inline functions into the object file.
+
+@item -fkeep-static-consts
+@opindex fkeep-static-consts
+Emit variables declared @code{static const} when optimization isn't turned
+on, even if the variables aren't referenced.
+
+GCC enables this option by default.  If you want to force the compiler to
+check if the variable was referenced, regardless of whether or not
+optimization is turned on, use the @option{-fno-keep-static-consts} option.
+
+@item -fmerge-constants
+@opindex fmerge-constants
+Attempt to merge identical constants (string constants and floating point
+constants) across compilation units.
+
+This option is the default for optimized compilation if the assembler and
+linker support it.  Use @option{-fno-merge-constants} to inhibit this
+behavior.
+
+Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fmerge-all-constants
+@opindex fmerge-all-constants
+Attempt to merge identical constants and identical variables.
+
+This option implies @option{-fmerge-constants}.  In addition to
+@option{-fmerge-constants} this considers e.g.@: even constant initialized
+arrays or initialized constant variables with integral or floating point
+types.  Languages like C or C++ require each variable, including multiple
+instances of the same variable in recursive calls, to have distinct locations,
+so using this option will result in non-conforming
+behavior.
+
+@item -fmodulo-sched
+@opindex fmodulo-sched
+Perform swing modulo scheduling immediately before the first scheduling
+pass.  This pass looks at innermost loops and reorders their
+instructions by overlapping different iterations.
+
+@item -fmodulo-sched-allow-regmoves
+@opindex fmodulo-sched-allow-regmoves
+Perform more aggressive SMS based modulo scheduling with register moves
+allowed.  By setting this flag certain anti-dependences edges will be
+deleted which will trigger the generation of reg-moves based on the
+life-range analysis.  This option is effective only with
+@option{-fmodulo-sched} enabled.
+
+@item -fno-branch-count-reg
+@opindex fno-branch-count-reg
+Do not use ``decrement and branch'' instructions on a count register,
+but instead generate a sequence of instructions that decrement a
+register, compare it against zero, then branch based upon the result.
+This option is only meaningful on architectures that support such
+instructions, which include x86, PowerPC, IA-64 and S/390.
+
+The default is @option{-fbranch-count-reg}.
+
+@item -fno-function-cse
+@opindex fno-function-cse
+Do not put function addresses in registers; make each instruction that
+calls a constant function contain the function's address explicitly.
+
+This option results in less efficient code, but some strange hacks
+that alter the assembler output may be confused by the optimizations
+performed when this option is not used.
+
+The default is @option{-ffunction-cse}
+
+@item -fno-zero-initialized-in-bss
+@opindex fno-zero-initialized-in-bss
+If the target supports a BSS section, GCC by default puts variables that
+are initialized to zero into BSS@.  This can save space in the resulting
+code.
+
+This option turns off this behavior because some programs explicitly
+rely on variables going to the data section.  E.g., so that the
+resulting executable can find the beginning of that section and/or make
+assumptions based on that.
+
+The default is @option{-fzero-initialized-in-bss}.
+
+@item -fmudflap -fmudflapth -fmudflapir
+@opindex fmudflap
+@opindex fmudflapth
+@opindex fmudflapir
+@cindex bounds checking
+@cindex mudflap
+For front-ends that support it (C and C++), instrument all risky
+pointer/array dereferencing operations, some standard library
+string/heap functions, and some other associated constructs with
+range/validity tests.  Modules so instrumented should be immune to
+buffer overflows, invalid heap use, and some other classes of C/C++
+programming errors.  The instrumentation relies on a separate runtime
+library (@file{libmudflap}), which will be linked into a program if
+@option{-fmudflap} is given at link time.  Run-time behavior of the
+instrumented program is controlled by the @env{MUDFLAP_OPTIONS}
+environment variable.  See @code{env MUDFLAP_OPTIONS=-help a.out}
+for its options.
+
+Use @option{-fmudflapth} instead of @option{-fmudflap} to compile and to
+link if your program is multi-threaded.  Use @option{-fmudflapir}, in
+addition to @option{-fmudflap} or @option{-fmudflapth}, if
+instrumentation should ignore pointer reads.  This produces less
+instrumentation (and therefore faster execution) and still provides
+some protection against outright memory corrupting writes, but allows
+erroneously read data to propagate within a program.
+
+@item -fthread-jumps
+@opindex fthread-jumps
+Perform optimizations where we check to see if a jump branches to a
+location where another comparison subsumed by the first is found.  If
+so, the first branch is redirected to either the destination of the
+second branch or a point immediately following it, depending on whether
+the condition is known to be true or false.
+
+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fsplit-wide-types
+@opindex fsplit-wide-types
+When using a type that occupies multiple registers, such as @code{long
+long} on a 32-bit system, split the registers apart and allocate them
+independently.  This normally generates better code for those types,
+but may make debugging more difficult.
+
+Enabled at levels @option{-O}, @option{-O2}, @option{-O3},
+@option{-Os}.
+
+@item -fcse-follow-jumps
+@opindex fcse-follow-jumps
+In common subexpression elimination (CSE), scan through jump instructions
+when the target of the jump is not reached by any other path.  For
+example, when CSE encounters an @code{if} statement with an
+@code{else} clause, CSE will follow the jump when the condition
+tested is false.
+
+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fcse-skip-blocks
+@opindex fcse-skip-blocks
+This is similar to @option{-fcse-follow-jumps}, but causes CSE to
+follow jumps which conditionally skip over blocks.  When CSE
+encounters a simple @code{if} statement with no else clause,
+@option{-fcse-skip-blocks} causes CSE to follow the jump around the
+body of the @code{if}.
+
+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -frerun-cse-after-loop
+@opindex frerun-cse-after-loop
+Re-run common subexpression elimination after loop optimizations has been
+performed.
+
+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fgcse
+@opindex fgcse
+Perform a global common subexpression elimination pass.
+This pass also performs global constant and copy propagation.
+
+@emph{Note:} When compiling a program using computed gotos, a GCC
+extension, you may get better runtime performance if you disable
+the global common subexpression elimination pass by adding
+@option{-fno-gcse} to the command line.
+
+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fgcse-lm
+@opindex fgcse-lm
+When @option{-fgcse-lm} is enabled, global common subexpression elimination will
+attempt to move loads which are only killed by stores into themselves.  This
+allows a loop containing a load/store sequence to be changed to a load outside
+the loop, and a copy/store within the loop.
+
+Enabled by default when gcse is enabled.
+
+@item -fgcse-sm
+@opindex fgcse-sm
+When @option{-fgcse-sm} is enabled, a store motion pass is run after
+global common subexpression elimination.  This pass will attempt to move
+stores out of loops.  When used in conjunction with @option{-fgcse-lm},
+loops containing a load/store sequence can be changed to a load before
+the loop and a store after the loop.
+
+Not enabled at any optimization level.
+
+@item -fgcse-las
+@opindex fgcse-las
+When @option{-fgcse-las} is enabled, the global common subexpression
+elimination pass eliminates redundant loads that come after stores to the
+same memory location (both partial and full redundancies).
+
+Not enabled at any optimization level.
+
+@item -fgcse-after-reload
+@opindex fgcse-after-reload
+When @option{-fgcse-after-reload} is enabled, a redundant load elimination
+pass is performed after reload.  The purpose of this pass is to cleanup
+redundant spilling.
+
+@item -funsafe-loop-optimizations
+@opindex funsafe-loop-optimizations
+If given, the loop optimizer will assume that loop indices do not
+overflow, and that the loops with nontrivial exit condition are not
+infinite.  This enables a wider range of loop optimizations even if
+the loop optimizer itself cannot prove that these assumptions are valid.
+Using @option{-Wunsafe-loop-optimizations}, the compiler will warn you
+if it finds this kind of loop.
+
+@item -fcrossjumping
+@opindex fcrossjumping
+Perform cross-jumping transformation.  This transformation unifies equivalent code and save code size.  The
+resulting code may or may not perform better than without cross-jumping.
+
+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fauto-inc-dec
+@opindex fauto-inc-dec
+Combine increments or decrements of addresses with memory accesses.
+This pass is always skipped on architectures that do not have
+instructions to support this.  Enabled by default at @option{-O} and
+higher on architectures that support this.
+
+@item -fdce
+@opindex fdce
+Perform dead code elimination (DCE) on RTL@.
+Enabled by default at @option{-O} and higher.
+
+@item -fdse
+@opindex fdse
+Perform dead store elimination (DSE) on RTL@.
+Enabled by default at @option{-O} and higher.
+
+@item -fif-conversion
+@opindex fif-conversion
+Attempt to transform conditional jumps into branch-less equivalents.  This
+include use of conditional moves, min, max, set flags and abs instructions, and
+some tricks doable by standard arithmetics.  The use of conditional execution
+on chips where it is available is controlled by @code{if-conversion2}.
+
+Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fif-conversion2
+@opindex fif-conversion2
+Use conditional execution (where available) to transform conditional jumps into
+branch-less equivalents.
+
+Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fdelete-null-pointer-checks
+@opindex fdelete-null-pointer-checks
+Use global dataflow analysis to identify and eliminate useless checks
+for null pointers.  The compiler assumes that dereferencing a null
+pointer would have halted the program.  If a pointer is checked after
+it has already been dereferenced, it cannot be null.
+
+In some environments, this assumption is not true, and programs can
+safely dereference null pointers.  Use
+@option{-fno-delete-null-pointer-checks} to disable this optimization
+for programs which depend on that behavior.
+
+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fexpensive-optimizations
+@opindex fexpensive-optimizations
+Perform a number of minor optimizations that are relatively expensive.
+
+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -foptimize-register-move
+@itemx -fregmove
+@opindex foptimize-register-move
+@opindex fregmove
+Attempt to reassign register numbers in move instructions and as
+operands of other simple instructions in order to maximize the amount of
+register tying.  This is especially helpful on machines with two-operand
+instructions.
+
+Note @option{-fregmove} and @option{-foptimize-register-move} are the same
+optimization.
+
+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fira-algorithm=@var{algorithm}
+Use specified coloring algorithm for the integrated register
+allocator.  The @var{algorithm} argument should be @code{priority} or
+@code{CB}.  The first algorithm specifies Chow's priority coloring,
+the second one specifies Chaitin-Briggs coloring.  The second
+algorithm can be unimplemented for some architectures.  If it is
+implemented, it is the default because Chaitin-Briggs coloring as a
+rule generates a better code.
+
+@item -fira-region=@var{region}
+Use specified regions for the integrated register allocator.  The
+@var{region} argument should be one of @code{all}, @code{mixed}, or
+@code{one}.  The first value means using all loops as register
+allocation regions, the second value which is the default means using
+all loops except for loops with small register pressure as the
+regions, and third one means using all function as a single region.
+The first value can give best result for machines with small size and
+irregular register set, the third one results in faster and generates
+decent code and the smallest size code, and the default value usually
+give the best results in most cases and for most architectures.
+
+@item -fira-coalesce
+@opindex fira-coalesce
+Do optimistic register coalescing.  This option might be profitable for
+architectures with big regular register files.
+
+@item -fno-ira-share-save-slots
+@opindex fno-ira-share-save-slots
+Switch off sharing stack slots used for saving call used hard
+registers living through a call.  Each hard register will get a
+separate stack slot and as a result function stack frame will be
+bigger.
+
+@item -fno-ira-share-spill-slots
+@opindex fno-ira-share-spill-slots
+Switch off sharing stack slots allocated for pseudo-registers.  Each
+pseudo-register which did not get a hard register will get a separate
+stack slot and as a result function stack frame will be bigger.
+
+@item -fira-verbose=@var{n}
+@opindex fira-verbose
+Set up how verbose dump file for the integrated register allocator
+will be.  Default value is 5.  If the value is greater or equal to 10,
+the dump file will be stderr as if the value were @var{n} minus 10.
+
+@item -fdelayed-branch
+@opindex fdelayed-branch
+If supported for the target machine, attempt to reorder instructions
+to exploit instruction slots available after delayed branch
+instructions.
+
+Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fschedule-insns
+@opindex fschedule-insns
+If supported for the target machine, attempt to reorder instructions to
+eliminate execution stalls due to required data being unavailable.  This
+helps machines that have slow floating point or memory load instructions
+by allowing other instructions to be issued until the result of the load
+or floating point instruction is required.
+
+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fschedule-insns2
+@opindex fschedule-insns2
+Similar to @option{-fschedule-insns}, but requests an additional pass of
+instruction scheduling after register allocation has been done.  This is
+especially useful on machines with a relatively small number of
+registers and where memory load instructions take more than one cycle.
+
+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fno-sched-interblock
+@opindex fno-sched-interblock
+Don't schedule instructions across basic blocks.  This is normally
+enabled by default when scheduling before register allocation, i.e.@:
+with @option{-fschedule-insns} or at @option{-O2} or higher.
+
+@item -fno-sched-spec
+@opindex fno-sched-spec
+Don't allow speculative motion of non-load instructions.  This is normally
+enabled by default when scheduling before register allocation, i.e.@:
+with @option{-fschedule-insns} or at @option{-O2} or higher.
+
+@item -fsched-spec-load
+@opindex fsched-spec-load
+Allow speculative motion of some load instructions.  This only makes
+sense when scheduling before register allocation, i.e.@: with
+@option{-fschedule-insns} or at @option{-O2} or higher.
+
+@item -fsched-spec-load-dangerous
+@opindex fsched-spec-load-dangerous
+Allow speculative motion of more load instructions.  This only makes
+sense when scheduling before register allocation, i.e.@: with
+@option{-fschedule-insns} or at @option{-O2} or higher.
+
+@item -fsched-stalled-insns
+@itemx -fsched-stalled-insns=@var{n}
+@opindex fsched-stalled-insns
+Define how many insns (if any) can be moved prematurely from the queue
+of stalled insns into the ready list, during the second scheduling pass.
+@option{-fno-sched-stalled-insns} means that no insns will be moved
+prematurely, @option{-fsched-stalled-insns=0} means there is no limit
+on how many queued insns can be moved prematurely.
+@option{-fsched-stalled-insns} without a value is equivalent to
+@option{-fsched-stalled-insns=1}.
+
+@item -fsched-stalled-insns-dep
+@itemx -fsched-stalled-insns-dep=@var{n}
+@opindex fsched-stalled-insns-dep
+Define how many insn groups (cycles) will be examined for a dependency
+on a stalled insn that is candidate for premature removal from the queue
+of stalled insns.  This has an effect only during the second scheduling pass,
+and only if @option{-fsched-stalled-insns} is used.
+@option{-fno-sched-stalled-insns-dep} is equivalent to
+@option{-fsched-stalled-insns-dep=0}.
+@option{-fsched-stalled-insns-dep} without a value is equivalent to
+@option{-fsched-stalled-insns-dep=1}.
+
+@item -fsched2-use-superblocks
+@opindex fsched2-use-superblocks
+When scheduling after register allocation, do use superblock scheduling
+algorithm.  Superblock scheduling allows motion across basic block boundaries
+resulting on faster schedules.  This option is experimental, as not all machine
+descriptions used by GCC model the CPU closely enough to avoid unreliable
+results from the algorithm.
+
+This only makes sense when scheduling after register allocation, i.e.@: with
+@option{-fschedule-insns2} or at @option{-O2} or higher.
+
+@item -fsched2-use-traces
+@opindex fsched2-use-traces
+Use @option{-fsched2-use-superblocks} algorithm when scheduling after register
+allocation and additionally perform code duplication in order to increase the
+size of superblocks using tracer pass.  See @option{-ftracer} for details on
+trace formation.
+
+This mode should produce faster but significantly longer programs.  Also
+without @option{-fbranch-probabilities} the traces constructed may not
+match the reality and hurt the performance.  This only makes
+sense when scheduling after register allocation, i.e.@: with
+@option{-fschedule-insns2} or at @option{-O2} or higher.
+
+@item -fsee
+@opindex fsee
+Eliminate redundant sign extension instructions and move the non-redundant
+ones to optimal placement using lazy code motion (LCM).
+
+@item -freschedule-modulo-scheduled-loops
+@opindex freschedule-modulo-scheduled-loops
+The modulo scheduling comes before the traditional scheduling, if a loop
+was modulo scheduled we may want to prevent the later scheduling passes
+from changing its schedule, we use this option to control that.
+
+@item -fselective-scheduling
+@opindex fselective-scheduling
+Schedule instructions using selective scheduling algorithm.  Selective
+scheduling runs instead of the first scheduler pass.
+
+@item -fselective-scheduling2
+@opindex fselective-scheduling2
+Schedule instructions using selective scheduling algorithm.  Selective
+scheduling runs instead of the second scheduler pass.
+
+@item -fsel-sched-pipelining
+@opindex fsel-sched-pipelining
+Enable software pipelining of innermost loops during selective scheduling.  
+This option has no effect until one of @option{-fselective-scheduling} or 
+@option{-fselective-scheduling2} is turned on.
+
+@item -fsel-sched-pipelining-outer-loops
+@opindex fsel-sched-pipelining-outer-loops
+When pipelining loops during selective scheduling, also pipeline outer loops.
+This option has no effect until @option{-fsel-sched-pipelining} is turned on.
+
+@item -fcaller-saves
+@opindex fcaller-saves
+Enable values to be allocated in registers that will be clobbered by
+function calls, by emitting extra instructions to save and restore the
+registers around such calls.  Such allocation is done only when it
+seems to result in better code than would otherwise be produced.
+
+This option is always enabled by default on certain machines, usually
+those which have no call-preserved registers to use instead.
+
+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fconserve-stack
+@opindex fconserve-stack
+Attempt to minimize stack usage.  The compiler will attempt to use less
+stack space, even if that makes the program slower.  This option
+implies setting the @option{large-stack-frame} parameter to 100
+and the @option{large-stack-frame-growth} parameter to 400.
+
+@item -ftree-reassoc
+@opindex ftree-reassoc
+Perform reassociation on trees.  This flag is enabled by default
+at @option{-O} and higher.
+
+@item -ftree-pre
+@opindex ftree-pre
+Perform partial redundancy elimination (PRE) on trees.  This flag is
+enabled by default at @option{-O2} and @option{-O3}.
+
+@item -ftree-fre
+@opindex ftree-fre
+Perform full redundancy elimination (FRE) on trees.  The difference
+between FRE and PRE is that FRE only considers expressions
+that are computed on all paths leading to the redundant computation.
+This analysis is faster than PRE, though it exposes fewer redundancies.
+This flag is enabled by default at @option{-O} and higher.
+
+@item -ftree-copy-prop
+@opindex ftree-copy-prop
+Perform copy propagation on trees.  This pass eliminates unnecessary
+copy operations.  This flag is enabled by default at @option{-O} and
+higher.
+
+@item -fipa-pure-const
+@opindex fipa-pure-const
+Discover which functions are pure or constant.
+Enabled by default at @option{-O} and higher.
+
+@item -fipa-reference
+@opindex fipa-reference
+Discover which static variables do not escape cannot escape the
+compilation unit.
+Enabled by default at @option{-O} and higher.
+
+@item -fipa-struct-reorg
+@opindex fipa-struct-reorg
+Perform structure reorganization optimization, that change C-like structures 
+layout in order to better utilize spatial locality.  This transformation is 
+effective for programs containing arrays of structures.  Available in two 
+compilation modes: profile-based (enabled with @option{-fprofile-generate})
+or static (which uses built-in heuristics).  Require @option{-fipa-type-escape}
+to provide the safety of this transformation.  It works only in whole program
+mode, so it requires @option{-fwhole-program} and @option{-combine} to be
+enabled.  Structures considered @samp{cold} by this transformation are not
+affected (see @option{--param struct-reorg-cold-struct-ratio=@var{value}}).
+
+With this flag, the program debug info reflects a new structure layout.
+
+@item -fipa-pta
+@opindex fipa-pta
+Perform interprocedural pointer analysis.  This option is experimental
+and does not affect generated code.
+
+@item -fipa-cp
+@opindex fipa-cp
+Perform interprocedural constant propagation.
+This optimization analyzes the program to determine when values passed
+to functions are constants and then optimizes accordingly.  
+This optimization can substantially increase performance
+if the application has constants passed to functions.
+This flag is enabled by default at @option{-O2}, @option{-Os} and @option{-O3}.
+
+@item -fipa-cp-clone
+@opindex fipa-cp-clone
+Perform function cloning to make interprocedural constant propagation stronger.
+When enabled, interprocedural constant propagation will perform function cloning
+when externally visible function can be called with constant arguments.
+Because this optimization can create multiple copies of functions,
+it may significantly increase code size
+(see @option{--param ipcp-unit-growth=@var{value}}).
+This flag is enabled by default at @option{-O3}.
+
+@item -fipa-matrix-reorg
+@opindex fipa-matrix-reorg
+Perform matrix flattening and transposing.
+Matrix flattening tries to replace a m-dimensional matrix 
+with its equivalent n-dimensional matrix, where n < m.
+This reduces the level of indirection needed for accessing the elements
+of the matrix. The second optimization is matrix transposing that
+attempts to change the order of the matrix's dimensions in order to
+improve cache locality.
+Both optimizations need the @option{-fwhole-program} flag. 
+Transposing is enabled only if profiling information is available.
+
+
+@item -ftree-sink
+@opindex ftree-sink
+Perform forward store motion  on trees.  This flag is
+enabled by default at @option{-O} and higher.
+
+@item -ftree-ccp
+@opindex ftree-ccp
+Perform sparse conditional constant propagation (CCP) on trees.  This
+pass only operates on local scalar variables and is enabled by default
+at @option{-O} and higher.
+
+@item -ftree-switch-conversion
+Perform conversion of simple initializations in a switch to
+initializations from a scalar array.  This flag is enabled by default
+at @option{-O2} and higher.
+
+@item -ftree-dce
+@opindex ftree-dce
+Perform dead code elimination (DCE) on trees.  This flag is enabled by
+default at @option{-O} and higher.
+
+@item -ftree-builtin-call-dce
+@opindex ftree-builtin-call-dce
+Perform conditional dead code elimination (DCE) for calls to builtin functions 
+that may set @code{errno} but are otherwise side-effect free.  This flag is 
+enabled by default at @option{-O2} and higher if @option{-Os} is not also 
+specified.
+
+@item -ftree-dominator-opts
+@opindex ftree-dominator-opts
+Perform a variety of simple scalar cleanups (constant/copy
+propagation, redundancy elimination, range propagation and expression
+simplification) based on a dominator tree traversal.  This also
+performs jump threading (to reduce jumps to jumps). This flag is
+enabled by default at @option{-O} and higher.
+
+@item -ftree-dse
+@opindex ftree-dse
+Perform dead store elimination (DSE) on trees.  A dead store is a store into
+a memory location which will later be overwritten by another store without
+any intervening loads.  In this case the earlier store can be deleted.  This
+flag is enabled by default at @option{-O} and higher.
+
+@item -ftree-ch
+@opindex ftree-ch
+Perform loop header copying on trees.  This is beneficial since it increases
+effectiveness of code motion optimizations.  It also saves one jump.  This flag
+is enabled by default at @option{-O} and higher.  It is not enabled
+for @option{-Os}, since it usually increases code size.
+
+@item -ftree-loop-optimize
+@opindex ftree-loop-optimize
+Perform loop optimizations on trees.  This flag is enabled by default
+at @option{-O} and higher.
+
+@item -ftree-loop-linear
+@opindex ftree-loop-linear
+Perform linear loop transformations on tree.  This flag can improve cache
+performance and allow further loop optimizations to take place.
+
+@item -floop-interchange
+Perform loop interchange transformations on loops.  Interchanging two
+nested loops switches the inner and outer loops.  For example, given a
+loop like:
+@smallexample
+DO J = 1, M
+  DO I = 1, N
+    A(J, I) = A(J, I) * C
+  ENDDO
+ENDDO
+@end smallexample
+loop interchange will transform the loop as if the user had written:
+@smallexample
+DO I = 1, N
+  DO J = 1, M
+    A(J, I) = A(J, I) * C
+  ENDDO
+ENDDO
+@end smallexample
+which can be beneficial when @code{N} is larger than the caches,
+because in Fortran, the elements of an array are stored in memory
+contiguously by column, and the original loop iterates over rows,
+potentially creating at each access a cache miss.  This optimization
+applies to all the languages supported by GCC and is not limited to
+Fortran.  To use this code transformation, GCC has to be configured
+with @option{--with-ppl} and @option{--with-cloog} to enable the
+Graphite loop transformation infrastructure.
+
+@item -floop-strip-mine
+Perform loop strip mining transformations on loops.  Strip mining
+splits a loop into two nested loops.  The outer loop has strides 
+equal to the strip size and the inner loop has strides of the 
+original loop within a strip.  For example, given a loop like:
+@smallexample
+DO I = 1, N
+  A(I) = A(I) + C
+ENDDO
+@end smallexample
+loop strip mining will transform the loop as if the user had written:
+@smallexample
+DO II = 1, N, 4
+  DO I = II, min (II + 3, N)
+    A(I) = A(I) + C
+  ENDDO
+ENDDO
+@end smallexample
+This optimization applies to all the languages supported by GCC and is
+not limited to Fortran.  To use this code transformation, GCC has to
+be configured with @option{--with-ppl} and @option{--with-cloog} to
+enable the Graphite loop transformation infrastructure.
+
+@item -floop-block
+Perform loop blocking transformations on loops.  Blocking strip mines
+each loop in the loop nest such that the memory accesses of the
+element loops fit inside caches.  For example, given a loop like:
+@smallexample
+DO I = 1, N
+  DO J = 1, M
+    A(J, I) = B(I) + C(J)
+  ENDDO
+ENDDO
+@end smallexample
+loop blocking will transform the loop as if the user had written:
+@smallexample
+DO II = 1, N, 64
+  DO JJ = 1, M, 64
+    DO I = II, min (II + 63, N)
+      DO J = JJ, min (JJ + 63, M)
+        A(J, I) = B(I) + C(J)
+      ENDDO
+    ENDDO
+  ENDDO
+ENDDO
+@end smallexample
+which can be beneficial when @code{M} is larger than the caches,
+because the innermost loop will iterate over a smaller amount of data
+that can be kept in the caches.  This optimization applies to all the
+languages supported by GCC and is not limited to Fortran.  To use this
+code transformation, GCC has to be configured with @option{--with-ppl}
+and @option{--with-cloog} to enable the Graphite loop transformation
+infrastructure.
+
+@item -fcheck-data-deps
+@opindex fcheck-data-deps
+Compare the results of several data dependence analyzers.  This option
+is used for debugging the data dependence analyzers.
+
+@item -ftree-loop-distribution
+Perform loop distribution.  This flag can improve cache performance on
+big loop bodies and allow further loop optimizations, like
+parallelization or vectorization, to take place.  For example, the loop
+@smallexample
+DO I = 1, N
+  A(I) = B(I) + C
+  D(I) = E(I) * F
+ENDDO
+@end smallexample
+is transformed to
+@smallexample
+DO I = 1, N
+   A(I) = B(I) + C
+ENDDO
+DO I = 1, N
+   D(I) = E(I) * F
+ENDDO
+@end smallexample
+
+@item -ftree-loop-im
+@opindex ftree-loop-im
+Perform loop invariant motion on trees.  This pass moves only invariants that
+would be hard to handle at RTL level (function calls, operations that expand to
+nontrivial sequences of insns).  With @option{-funswitch-loops} it also moves
+operands of conditions that are invariant out of the loop, so that we can use
+just trivial invariantness analysis in loop unswitching.  The pass also includes
+store motion.
+
+@item -ftree-loop-ivcanon
+@opindex ftree-loop-ivcanon
+Create a canonical counter for number of iterations in the loop for that
+determining number of iterations requires complicated analysis.  Later
+optimizations then may determine the number easily.  Useful especially
+in connection with unrolling.
+
+@item -fivopts
+@opindex fivopts
+Perform induction variable optimizations (strength reduction, induction
+variable merging and induction variable elimination) on trees.
+
+@item -ftree-parallelize-loops=n
+@opindex ftree-parallelize-loops
+Parallelize loops, i.e., split their iteration space to run in n threads.
+This is only possible for loops whose iterations are independent
+and can be arbitrarily reordered.  The optimization is only
+profitable on multiprocessor machines, for loops that are CPU-intensive,
+rather than constrained e.g.@: by memory bandwidth.  This option
+implies @option{-pthread}, and thus is only supported on targets
+that have support for @option{-pthread}.
+
+@item -ftree-sra
+@opindex ftree-sra
+Perform scalar replacement of aggregates.  This pass replaces structure
+references with scalars to prevent committing structures to memory too
+early.  This flag is enabled by default at @option{-O} and higher.
+
+@item -ftree-copyrename
+@opindex ftree-copyrename
+Perform copy renaming on trees.  This pass attempts to rename compiler
+temporaries to other variables at copy locations, usually resulting in
+variable names which more closely resemble the original variables.  This flag
+is enabled by default at @option{-O} and higher.
+
+@item -ftree-ter
+@opindex ftree-ter
+Perform temporary expression replacement during the SSA->normal phase.  Single
+use/single def temporaries are replaced at their use location with their
+defining expression.  This results in non-GIMPLE code, but gives the expanders
+much more complex trees to work on resulting in better RTL generation.  This is
+enabled by default at @option{-O} and higher.
+
+@item -ftree-vectorize
+@opindex ftree-vectorize
+Perform loop vectorization on trees. This flag is enabled by default at
+@option{-O3}.
+
+@item -ftree-vect-loop-version
+@opindex ftree-vect-loop-version
+Perform loop versioning when doing loop vectorization on trees.  When a loop
+appears to be vectorizable except that data alignment or data dependence cannot
+be determined at compile time then vectorized and non-vectorized versions of
+the loop are generated along with runtime checks for alignment or dependence
+to control which version is executed.  This option is enabled by default
+except at level @option{-Os} where it is disabled.
+
+@item -fvect-cost-model
+@opindex fvect-cost-model
+Enable cost model for vectorization.
+
+@item -ftree-vrp
+@opindex ftree-vrp
+Perform Value Range Propagation on trees.  This is similar to the
+constant propagation pass, but instead of values, ranges of values are
+propagated.  This allows the optimizers to remove unnecessary range
+checks like array bound checks and null pointer checks.  This is
+enabled by default at @option{-O2} and higher.  Null pointer check
+elimination is only done if @option{-fdelete-null-pointer-checks} is
+enabled.
+
+@item -ftracer
+@opindex ftracer
+Perform tail duplication to enlarge superblock size.  This transformation
+simplifies the control flow of the function allowing other optimizations to do
+better job.
+
+@item -funroll-loops
+@opindex funroll-loops
+Unroll loops whose number of iterations can be determined at compile
+time or upon entry to the loop.  @option{-funroll-loops} implies
+@option{-frerun-cse-after-loop}.  This option makes code larger,
+and may or may not make it run faster.
+
+@item -funroll-all-loops
+@opindex funroll-all-loops
+Unroll all loops, even if their number of iterations is uncertain when
+the loop is entered.  This usually makes programs run more slowly.
+@option{-funroll-all-loops} implies the same options as
+@option{-funroll-loops},
+
+@item -fsplit-ivs-in-unroller
+@opindex fsplit-ivs-in-unroller
+Enables expressing of values of induction variables in later iterations
+of the unrolled loop using the value in the first iteration.  This breaks
+long dependency chains, thus improving efficiency of the scheduling passes.
+
+Combination of @option{-fweb} and CSE is often sufficient to obtain the
+same effect.  However in cases the loop body is more complicated than
+a single basic block, this is not reliable.  It also does not work at all
+on some of the architectures due to restrictions in the CSE pass.
+
+This optimization is enabled by default.
+
+@item -fvariable-expansion-in-unroller
+@opindex fvariable-expansion-in-unroller
+With this option, the compiler will create multiple copies of some
+local variables when unrolling a loop which can result in superior code.
+
+@item -fpredictive-commoning
+@opindex fpredictive-commoning
+Perform predictive commoning optimization, i.e., reusing computations
+(especially memory loads and stores) performed in previous
+iterations of loops.
+
+This option is enabled at level @option{-O3}.
+
+@item -fprefetch-loop-arrays
+@opindex fprefetch-loop-arrays
+If supported by the target machine, generate instructions to prefetch
+memory to improve the performance of loops that access large arrays.
+
+This option may generate better or worse code; results are highly
+dependent on the structure of loops within the source code.
+
+Disabled at level @option{-Os}.
+
+@item -fno-peephole
+@itemx -fno-peephole2
+@opindex fno-peephole
+@opindex fno-peephole2
+Disable any machine-specific peephole optimizations.  The difference
+between @option{-fno-peephole} and @option{-fno-peephole2} is in how they
+are implemented in the compiler; some targets use one, some use the
+other, a few use both.
+
+@option{-fpeephole} is enabled by default.
+@option{-fpeephole2} enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fno-guess-branch-probability
+@opindex fno-guess-branch-probability
+Do not guess branch probabilities using heuristics.
+
+GCC will use heuristics to guess branch probabilities if they are
+not provided by profiling feedback (@option{-fprofile-arcs}).  These
+heuristics are based on the control flow graph.  If some branch probabilities
+are specified by @samp{__builtin_expect}, then the heuristics will be
+used to guess branch probabilities for the rest of the control flow graph,
+taking the @samp{__builtin_expect} info into account.  The interactions
+between the heuristics and @samp{__builtin_expect} can be complex, and in
+some cases, it may be useful to disable the heuristics so that the effects
+of @samp{__builtin_expect} are easier to understand.
+
+The default is @option{-fguess-branch-probability} at levels
+@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -freorder-blocks
+@opindex freorder-blocks
+Reorder basic blocks in the compiled function in order to reduce number of
+taken branches and improve code locality.
+
+Enabled at levels @option{-O2}, @option{-O3}.
+
+@item -freorder-blocks-and-partition
+@opindex freorder-blocks-and-partition
+In addition to reordering basic blocks in the compiled function, in order
+to reduce number of taken branches, partitions hot and cold basic blocks
+into separate sections of the assembly and .o files, to improve
+paging and cache locality performance.
+
+This optimization is automatically turned off in the presence of
+exception handling, for linkonce sections, for functions with a user-defined
+section attribute and on any architecture that does not support named
+sections.
+
+@item -freorder-functions
+@opindex freorder-functions
+Reorder functions in the object file in order to
+improve code locality.  This is implemented by using special
+subsections @code{.text.hot} for most frequently executed functions and
+@code{.text.unlikely} for unlikely executed functions.  Reordering is done by
+the linker so object file format must support named sections and linker must
+place them in a reasonable way.
+
+Also profile feedback must be available in to make this option effective.  See
+@option{-fprofile-arcs} for details.
+
+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fstrict-aliasing
+@opindex fstrict-aliasing
+Allow the compiler to assume the strictest aliasing rules applicable to
+the language being compiled.  For C (and C++), this activates
+optimizations based on the type of expressions.  In particular, an
+object of one type is assumed never to reside at the same address as an
+object of a different type, unless the types are almost the same.  For
+example, an @code{unsigned int} can alias an @code{int}, but not a
+@code{void*} or a @code{double}.  A character type may alias any other
+type.
+
+@anchor{Type-punning}Pay special attention to code like this:
+@smallexample
+union a_union @{
+  int i;
+  double d;
+@};
+
+int f() @{
+  union a_union t;
+  t.d = 3.0;
+  return t.i;
+@}
+@end smallexample
+The practice of reading from a different union member than the one most
+recently written to (called ``type-punning'') is common.  Even with
+@option{-fstrict-aliasing}, type-punning is allowed, provided the memory
+is accessed through the union type.  So, the code above will work as
+expected.  @xref{Structures unions enumerations and bit-fields
+implementation}.  However, this code might not:
+@smallexample
+int f() @{
+  union a_union t;
+  int* ip;
+  t.d = 3.0;
+  ip = &t.i;
+  return *ip;
+@}
+@end smallexample
+
+Similarly, access by taking the address, casting the resulting pointer
+and dereferencing the result has undefined behavior, even if the cast
+uses a union type, e.g.:
+@smallexample
+int f() @{
+  double d = 3.0;
+  return ((union a_union *) &d)->i;
+@}
+@end smallexample
+
+The @option{-fstrict-aliasing} option is enabled at levels
+@option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fstrict-overflow
+@opindex fstrict-overflow
+Allow the compiler to assume strict signed overflow rules, depending
+on the language being compiled.  For C (and C++) this means that
+overflow when doing arithmetic with signed numbers is undefined, which
+means that the compiler may assume that it will not happen.  This
+permits various optimizations.  For example, the compiler will assume
+that an expression like @code{i + 10 > i} will always be true for
+signed @code{i}.  This assumption is only valid if signed overflow is
+undefined, as the expression is false if @code{i + 10} overflows when
+using twos complement arithmetic.  When this option is in effect any
+attempt to determine whether an operation on signed numbers will
+overflow must be written carefully to not actually involve overflow.
+
+This option also allows the compiler to assume strict pointer
+semantics: given a pointer to an object, if adding an offset to that
+pointer does not produce a pointer to the same object, the addition is
+undefined.  This permits the compiler to conclude that @code{p + u >
+p} is always true for a pointer @code{p} and unsigned integer
+@code{u}.  This assumption is only valid because pointer wraparound is
+undefined, as the expression is false if @code{p + u} overflows using
+twos complement arithmetic.
+
+See also the @option{-fwrapv} option.  Using @option{-fwrapv} means
+that integer signed overflow is fully defined: it wraps.  When
+@option{-fwrapv} is used, there is no difference between
+@option{-fstrict-overflow} and @option{-fno-strict-overflow} for
+integers.  With @option{-fwrapv} certain types of overflow are
+permitted.  For example, if the compiler gets an overflow when doing
+arithmetic on constants, the overflowed value can still be used with
+@option{-fwrapv}, but not otherwise.
+
+The @option{-fstrict-overflow} option is enabled at levels
+@option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -falign-functions
+@itemx -falign-functions=@var{n}
+@opindex falign-functions
+Align the start of functions to the next power-of-two greater than
+@var{n}, skipping up to @var{n} bytes.  For instance,
+@option{-falign-functions=32} aligns functions to the next 32-byte
+boundary, but @option{-falign-functions=24} would align to the next
+32-byte boundary only if this can be done by skipping 23 bytes or less.
+
+@option{-fno-align-functions} and @option{-falign-functions=1} are
+equivalent and mean that functions will not be aligned.
+
+Some assemblers only support this flag when @var{n} is a power of two;
+in that case, it is rounded up.
+
+If @var{n} is not specified or is zero, use a machine-dependent default.
+
+Enabled at levels @option{-O2}, @option{-O3}.
+
+@item -falign-labels
+@itemx -falign-labels=@var{n}
+@opindex falign-labels
+Align all branch targets to a power-of-two boundary, skipping up to
+@var{n} bytes like @option{-falign-functions}.  This option can easily
+make code slower, because it must insert dummy operations for when the
+branch target is reached in the usual flow of the code.
+
+@option{-fno-align-labels} and @option{-falign-labels=1} are
+equivalent and mean that labels will not be aligned.
+
+If @option{-falign-loops} or @option{-falign-jumps} are applicable and
+are greater than this value, then their values are used instead.
+
+If @var{n} is not specified or is zero, use a machine-dependent default
+which is very likely to be @samp{1}, meaning no alignment.
+
+Enabled at levels @option{-O2}, @option{-O3}.
+
+@item -falign-loops
+@itemx -falign-loops=@var{n}
+@opindex falign-loops
+Align loops to a power-of-two boundary, skipping up to @var{n} bytes
+like @option{-falign-functions}.  The hope is that the loop will be
+executed many times, which will make up for any execution of the dummy
+operations.
+
+@option{-fno-align-loops} and @option{-falign-loops=1} are
+equivalent and mean that loops will not be aligned.
+
+If @var{n} is not specified or is zero, use a machine-dependent default.
+
+Enabled at levels @option{-O2}, @option{-O3}.
+
+@item -falign-jumps
+@itemx -falign-jumps=@var{n}
+@opindex falign-jumps
+Align branch targets to a power-of-two boundary, for branch targets
+where the targets can only be reached by jumping, skipping up to @var{n}
+bytes like @option{-falign-functions}.  In this case, no dummy operations
+need be executed.
+
+@option{-fno-align-jumps} and @option{-falign-jumps=1} are
+equivalent and mean that loops will not be aligned.
+
+If @var{n} is not specified or is zero, use a machine-dependent default.
+
+Enabled at levels @option{-O2}, @option{-O3}.
+
+@item -funit-at-a-time
+@opindex funit-at-a-time
+This option is left for compatibility reasons. @option{-funit-at-a-time}
+has no effect, while @option{-fno-unit-at-a-time} implies
+@option{-fno-toplevel-reorder} and @option{-fno-section-anchors}.
+
+Enabled by default.
+
+@item -fno-toplevel-reorder
+@opindex fno-toplevel-reorder
+Do not reorder top-level functions, variables, and @code{asm}
+statements.  Output them in the same order that they appear in the
+input file.  When this option is used, unreferenced static variables
+will not be removed.  This option is intended to support existing code
+which relies on a particular ordering.  For new code, it is better to
+use attributes.
+
+Enabled at level @option{-O0}.  When disabled explicitly, it also imply
+@option{-fno-section-anchors} that is otherwise enabled at @option{-O0} on some
+targets.
+
+@item -fweb
+@opindex fweb
+Constructs webs as commonly used for register allocation purposes and assign
+each web individual pseudo register.  This allows the register allocation pass
+to operate on pseudos directly, but also strengthens several other optimization
+passes, such as CSE, loop optimizer and trivial dead code remover.  It can,
+however, make debugging impossible, since variables will no longer stay in a
+``home register''.
+
+Enabled by default with @option{-funroll-loops}.
+
+@item -fwhole-program
+@opindex fwhole-program
+Assume that the current compilation unit represents whole program being
+compiled.  All public functions and variables with the exception of @code{main}
+and those merged by attribute @code{externally_visible} become static functions
+and in a affect gets more aggressively optimized by interprocedural optimizers.
+While this option is equivalent to proper use of @code{static} keyword for
+programs consisting of single file, in combination with option
+@option{--combine} this flag can be used to compile most of smaller scale C
+programs since the functions and variables become local for the whole combined
+compilation unit, not for the single source file itself.
+
+This option is not supported for Fortran programs.
+
+@item -fcprop-registers
+@opindex fcprop-registers
+After register allocation and post-register allocation instruction splitting,
+we perform a copy-propagation pass to try to reduce scheduling dependencies
+and occasionally eliminate the copy.
+
+Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.
+
+@item -fprofile-correction
+@opindex fprofile-correction
+Profiles collected using an instrumented binary for multi-threaded programs may
+be inconsistent due to missed counter updates. When this option is specified,
+GCC will use heuristics to correct or smooth out such inconsistencies. By
+default, GCC will emit an error message when an inconsistent profile is detected.
+
+@item -fprofile-dir=@var{path}
+@opindex fprofile-dir
+
+Set the directory to search the profile data files in to @var{path}.
+This option affects only the profile data generated by
+@option{-fprofile-generate}, @option{-ftest-coverage}, @option{-fprofile-arcs}
+and used by @option{-fprofile-use} and @option{-fbranch-probabilities} 
+and its related options.
+By default, GCC will use the current directory as @var{path}
+thus the profile data file will appear in the same directory as the object file.
+
+@item -fprofile-generate
+@itemx -fprofile-generate=@var{path}
+@opindex fprofile-generate
+
+Enable options usually used for instrumenting application to produce
+profile useful for later recompilation with profile feedback based
+optimization.  You must use @option{-fprofile-generate} both when
+compiling and when linking your program.
+
+The following options are enabled: @code{-fprofile-arcs}, @code{-fprofile-values}, @code{-fvpt}.
+
+If @var{path} is specified, GCC will look at the @var{path} to find
+the profile feedback data files. See @option{-fprofile-dir}.
+
+@item -fprofile-use
+@itemx -fprofile-use=@var{path}
+@opindex fprofile-use
+Enable profile feedback directed optimizations, and optimizations
+generally profitable only with profile feedback available.
+
+The following options are enabled: @code{-fbranch-probabilities}, @code{-fvpt},
+@code{-funroll-loops}, @code{-fpeel-loops}, @code{-ftracer}
+
+By default, GCC emits an error message if the feedback profiles do not
+match the source code.  This error can be turned into a warning by using
+@option{-Wcoverage-mismatch}.  Note this may result in poorly optimized
+code.
+
+If @var{path} is specified, GCC will look at the @var{path} to find
+the profile feedback data files. See @option{-fprofile-dir}.
+@end table
+
+The following options control compiler behavior regarding floating
+point arithmetic.  These options trade off between speed and
+correctness.  All must be specifically enabled.
+
+@table @gcctabopt
+@item -ffloat-store
+@opindex ffloat-store
+Do not store floating point variables in registers, and inhibit other
+options that might change whether a floating point value is taken from a
+register or memory.
+
+@cindex floating point precision
+This option prevents undesirable excess precision on machines such as
+the 68000 where the floating registers (of the 68881) keep more
+precision than a @code{double} is supposed to have.  Similarly for the
+x86 architecture.  For most programs, the excess precision does only
+good, but a few programs rely on the precise definition of IEEE floating
+point.  Use @option{-ffloat-store} for such programs, after modifying
+them to store all pertinent intermediate computations into variables.
+
+@item -ffast-math
+@opindex ffast-math
+Sets @option{-fno-math-errno}, @option{-funsafe-math-optimizations},
+@option{-ffinite-math-only}, @option{-fno-rounding-math},
+@option{-fno-signaling-nans} and @option{-fcx-limited-range}.
+
+This option causes the preprocessor macro @code{__FAST_MATH__} to be defined.
+
+This option is not turned on by any @option{-O} option since
+it can result in incorrect output for programs which depend on
+an exact implementation of IEEE or ISO rules/specifications for
+math functions. It may, however, yield faster code for programs
+that do not require the guarantees of these specifications.
+
+@item -fno-math-errno
+@opindex fno-math-errno
+Do not set ERRNO after calling math functions that are executed
+with a single instruction, e.g., sqrt.  A program that relies on
+IEEE exceptions for math error handling may want to use this flag
+for speed while maintaining IEEE arithmetic compatibility.
+
+This option is not turned on by any @option{-O} option since
+it can result in incorrect output for programs which depend on
+an exact implementation of IEEE or ISO rules/specifications for
+math functions. It may, however, yield faster code for programs
+that do not require the guarantees of these specifications.
+
+The default is @option{-fmath-errno}.
+
+On Darwin systems, the math library never sets @code{errno}.  There is
+therefore no reason for the compiler to consider the possibility that
+it might, and @option{-fno-math-errno} is the default.
+
+@item -funsafe-math-optimizations
+@opindex funsafe-math-optimizations
+
+Allow optimizations for floating-point arithmetic that (a) assume
+that arguments and results are valid and (b) may violate IEEE or
+ANSI standards.  When used at link-time, it may include libraries
+or startup files that change the default FPU control word or other
+similar optimizations.
+
+This option is not turned on by any @option{-O} option since
+it can result in incorrect output for programs which depend on
+an exact implementation of IEEE or ISO rules/specifications for
+math functions. It may, however, yield faster code for programs
+that do not require the guarantees of these specifications.
+Enables @option{-fno-signed-zeros}, @option{-fno-trapping-math},
+@option{-fassociative-math} and @option{-freciprocal-math}.
+
+The default is @option{-fno-unsafe-math-optimizations}.
+
+@item -fassociative-math
+@opindex fassociative-math
+
+Allow re-association of operands in series of floating-point operations.
+This violates the ISO C and C++ language standard by possibly changing
+computation result.  NOTE: re-ordering may change the sign of zero as
+well as ignore NaNs and inhibit or create underflow or overflow (and
+thus cannot be used on a code which relies on rounding behavior like
+@code{(x + 2**52) - 2**52)}.  May also reorder floating-point comparisons
+and thus may not be used when ordered comparisons are required.
+This option requires that both @option{-fno-signed-zeros} and
+@option{-fno-trapping-math} be in effect.  Moreover, it doesn't make
+much sense with @option{-frounding-math}.
+
+The default is @option{-fno-associative-math}.
+
+@item -freciprocal-math
+@opindex freciprocal-math
+
+Allow the reciprocal of a value to be used instead of dividing by
+the value if this enables optimizations.  For example @code{x / y}
+can be replaced with @code{x * (1/y)} which is useful if @code{(1/y)}
+is subject to common subexpression elimination.  Note that this loses
+precision and increases the number of flops operating on the value.
+
+The default is @option{-fno-reciprocal-math}.
+
+@item -ffinite-math-only
+@opindex ffinite-math-only
+Allow optimizations for floating-point arithmetic that assume
+that arguments and results are not NaNs or +-Infs.
+
+This option is not turned on by any @option{-O} option since
+it can result in incorrect output for programs which depend on
+an exact implementation of IEEE or ISO rules/specifications for
+math functions. It may, however, yield faster code for programs
+that do not require the guarantees of these specifications.
+
+The default is @option{-fno-finite-math-only}.
+
+@item -fno-signed-zeros
+@opindex fno-signed-zeros
+Allow optimizations for floating point arithmetic that ignore the
+signedness of zero.  IEEE arithmetic specifies the behavior of
+distinct +0.0 and @minus{}0.0 values, which then prohibits simplification
+of expressions such as x+0.0 or 0.0*x (even with @option{-ffinite-math-only}).
+This option implies that the sign of a zero result isn't significant.
+
+The default is @option{-fsigned-zeros}.
+
+@item -fno-trapping-math
+@opindex fno-trapping-math
+Compile code assuming that floating-point operations cannot generate
+user-visible traps.  These traps include division by zero, overflow,
+underflow, inexact result and invalid operation.  This option requires
+that @option{-fno-signaling-nans} be in effect.  Setting this option may
+allow faster code if one relies on ``non-stop'' IEEE arithmetic, for example.
+
+This option should never be turned on by any @option{-O} option since
+it can result in incorrect output for programs which depend on
+an exact implementation of IEEE or ISO rules/specifications for
+math functions.
+
+The default is @option{-ftrapping-math}.
+
+@item -frounding-math
+@opindex frounding-math
+Disable transformations and optimizations that assume default floating
+point rounding behavior.  This is round-to-zero for all floating point
+to integer conversions, and round-to-nearest for all other arithmetic
+truncations.  This option should be specified for programs that change
+the FP rounding mode dynamically, or that may be executed with a
+non-default rounding mode.  This option disables constant folding of
+floating point expressions at compile-time (which may be affected by
+rounding mode) and arithmetic transformations that are unsafe in the
+presence of sign-dependent rounding modes.
+
+The default is @option{-fno-rounding-math}.
+
+This option is experimental and does not currently guarantee to
+disable all GCC optimizations that are affected by rounding mode.
+Future versions of GCC may provide finer control of this setting
+using C99's @code{FENV_ACCESS} pragma.  This command line option
+will be used to specify the default state for @code{FENV_ACCESS}.
+
+@item -frtl-abstract-sequences
+@opindex frtl-abstract-sequences
+It is a size optimization method. This option is to find identical
+sequences of code, which can be turned into pseudo-procedures  and
+then  replace  all  occurrences with  calls to  the  newly created
+subroutine. It is kind of an opposite of @option{-finline-functions}.
+This optimization runs at RTL level.
+
+@item -fsignaling-nans
+@opindex fsignaling-nans
+Compile code assuming that IEEE signaling NaNs may generate user-visible
+traps during floating-point operations.  Setting this option disables
+optimizations that may change the number of exceptions visible with
+signaling NaNs.  This option implies @option{-ftrapping-math}.
+
+This option causes the preprocessor macro @code{__SUPPORT_SNAN__} to
+be defined.
+
+The default is @option{-fno-signaling-nans}.
+
+This option is experimental and does not currently guarantee to
+disable all GCC optimizations that affect signaling NaN behavior.
+
+@item -fsingle-precision-constant
+@opindex fsingle-precision-constant
+Treat floating point constant as single precision constant instead of
+implicitly converting it to double precision constant.
+
+@item -fcx-limited-range
+@opindex fcx-limited-range
+When enabled, this option states that a range reduction step is not
+needed when performing complex division.  Also, there is no checking
+whether the result of a complex multiplication or division is @code{NaN
++ I*NaN}, with an attempt to rescue the situation in that case.  The
+default is @option{-fno-cx-limited-range}, but is enabled by
+@option{-ffast-math}.
+
+This option controls the default setting of the ISO C99
+@code{CX_LIMITED_RANGE} pragma.  Nevertheless, the option applies to
+all languages.
+
+@item -fcx-fortran-rules
+@opindex fcx-fortran-rules
+Complex multiplication and division follow Fortran rules.  Range
+reduction is done as part of complex division, but there is no checking
+whether the result of a complex multiplication or division is @code{NaN
++ I*NaN}, with an attempt to rescue the situation in that case.
+
+The default is @option{-fno-cx-fortran-rules}.
+
+@end table
+
+The following options control optimizations that may improve
+performance, but are not enabled by any @option{-O} options.  This
+section includes experimental options that may produce broken code.
+
+@table @gcctabopt
+@item -fbranch-probabilities
+@opindex fbranch-probabilities
+After running a program compiled with @option{-fprofile-arcs}
+(@pxref{Debugging Options,, Options for Debugging Your Program or
+@command{gcc}}), you can compile it a second time using
+@option{-fbranch-probabilities}, to improve optimizations based on
+the number of times each branch was taken.  When the program
+compiled with @option{-fprofile-arcs} exits it saves arc execution
+counts to a file called @file{@var{sourcename}.gcda} for each source
+file.  The information in this data file is very dependent on the
+structure of the generated code, so you must use the same source code
+and the same optimization options for both compilations.
+
+With @option{-fbranch-probabilities}, GCC puts a
+@samp{REG_BR_PROB} note on each @samp{JUMP_INSN} and @samp{CALL_INSN}.
+These can be used to improve optimization.  Currently, they are only
+used in one place: in @file{reorg.c}, instead of guessing which path a
+branch is mostly to take, the @samp{REG_BR_PROB} values are used to
+exactly determine which path is taken more often.
+
+@item -fprofile-values
+@opindex fprofile-values
+If combined with @option{-fprofile-arcs}, it adds code so that some
+data about values of expressions in the program is gathered.
+
+With @option{-fbranch-probabilities}, it reads back the data gathered
+from profiling values of expressions and adds @samp{REG_VALUE_PROFILE}
+notes to instructions for their later usage in optimizations.
+
+Enabled with @option{-fprofile-generate} and @option{-fprofile-use}.
+
+@item -fvpt
+@opindex fvpt
+If combined with @option{-fprofile-arcs}, it instructs the compiler to add
+a code to gather information about values of expressions.
+
+With @option{-fbranch-probabilities}, it reads back the data gathered
+and actually performs the optimizations based on them.
+Currently the optimizations include specialization of division operation
+using the knowledge about the value of the denominator.
+
+@item -frename-registers
+@opindex frename-registers
+Attempt to avoid false dependencies in scheduled code by making use
+of registers left over after register allocation.  This optimization
+will most benefit processors with lots of registers.  Depending on the
+debug information format adopted by the target, however, it can
+make debugging impossible, since variables will no longer stay in
+a ``home register''.
+
+Enabled by default with @option{-funroll-loops}.
+
+@item -ftracer
+@opindex ftracer
+Perform tail duplication to enlarge superblock size.  This transformation
+simplifies the control flow of the function allowing other optimizations to do
+better job.
+
+Enabled with @option{-fprofile-use}.
+
+@item -funroll-loops
+@opindex funroll-loops
+Unroll loops whose number of iterations can be determined at compile time or
+upon entry to the loop.  @option{-funroll-loops} implies
+@option{-frerun-cse-after-loop}, @option{-fweb} and @option{-frename-registers}.
+It also turns on complete loop peeling (i.e.@: complete removal of loops with
+small constant number of iterations).  This option makes code larger, and may
+or may not make it run faster.
+
+Enabled with @option{-fprofile-use}.
+
+@item -funroll-all-loops
+@opindex funroll-all-loops
+Unroll all loops, even if their number of iterations is uncertain when
+the loop is entered.  This usually makes programs run more slowly.
+@option{-funroll-all-loops} implies the same options as
+@option{-funroll-loops}.
+
+@item -fpeel-loops
+@opindex fpeel-loops
+Peels the loops for that there is enough information that they do not
+roll much (from profile feedback).  It also turns on complete loop peeling
+(i.e.@: complete removal of loops with small constant number of iterations).
+
+Enabled with @option{-fprofile-use}.
+
+@item -fmove-loop-invariants
+@opindex fmove-loop-invariants
+Enables the loop invariant motion pass in the RTL loop optimizer.  Enabled
+at level @option{-O1}
+
+@item -funswitch-loops
+@opindex funswitch-loops
+Move branches with loop invariant conditions out of the loop, with duplicates
+of the loop on both branches (modified according to result of the condition).
+
+@item -ffunction-sections
+@itemx -fdata-sections
+@opindex ffunction-sections
+@opindex fdata-sections
+Place each function or data item into its own section in the output
+file if the target supports arbitrary sections.  The name of the
+function or the name of the data item determines the section's name
+in the output file.
+
+Use these options on systems where the linker can perform optimizations
+to improve locality of reference in the instruction space.  Most systems
+using the ELF object format and SPARC processors running Solaris 2 have
+linkers with such optimizations.  AIX may have these optimizations in
+the future.
+
+Only use these options when there are significant benefits from doing
+so.  When you specify these options, the assembler and linker will
+create larger object and executable files and will also be slower.
+You will not be able to use @code{gprof} on all systems if you
+specify this option and you may have problems with debugging if
+you specify both this option and @option{-g}.
+
+@item -fbranch-target-load-optimize
+@opindex fbranch-target-load-optimize
+Perform branch target register load optimization before prologue / epilogue
+threading.
+The use of target registers can typically be exposed only during reload,
+thus hoisting loads out of loops and doing inter-block scheduling needs
+a separate optimization pass.
+
+@item -fbranch-target-load-optimize2
+@opindex fbranch-target-load-optimize2
+Perform branch target register load optimization after prologue / epilogue
+threading.
+
+@item -fbtr-bb-exclusive
+@opindex fbtr-bb-exclusive
+When performing branch target register load optimization, don't reuse
+branch target registers in within any basic block.
+
+@item -fstack-protector
+@opindex fstack-protector
+Emit extra code to check for buffer overflows, such as stack smashing
+attacks.  This is done by adding a guard variable to functions with
+vulnerable objects.  This includes functions that call alloca, and
+functions with buffers larger than 8 bytes.  The guards are initialized
+when a function is entered and then checked when the function exits.
+If a guard check fails, an error message is printed and the program exits.
+
+@item -fstack-protector-all
+@opindex fstack-protector-all
+Like @option{-fstack-protector} except that all functions are protected.
+
+@item -fsection-anchors
+@opindex fsection-anchors
+Try to reduce the number of symbolic address calculations by using
+shared ``anchor'' symbols to address nearby objects.  This transformation
+can help to reduce the number of GOT entries and GOT accesses on some
+targets.
+
+For example, the implementation of the following function @code{foo}:
+
+@smallexample
+static int a, b, c;
+int foo (void) @{ return a + b + c; @}
+@end smallexample
+
+would usually calculate the addresses of all three variables, but if you
+compile it with @option{-fsection-anchors}, it will access the variables
+from a common anchor point instead.  The effect is similar to the
+following pseudocode (which isn't valid C):
+
+@smallexample
+int foo (void)
+@{
+  register int *xr = &x;
+  return xr[&a - &x] + xr[&b - &x] + xr[&c - &x];
+@}
+@end smallexample
+
+Not all targets support this option.
+
+@item --param @var{name}=@var{value}
+@opindex param
+In some places, GCC uses various constants to control the amount of
+optimization that is done.  For example, GCC will not inline functions
+that contain more that a certain number of instructions.  You can
+control some of these constants on the command-line using the
+@option{--param} option.
+
+The names of specific parameters, and the meaning of the values, are
+tied to the internals of the compiler, and are subject to change
+without notice in future releases.
+
+In each case, the @var{value} is an integer.  The allowable choices for
+@var{name} are given in the following table:
+
+@table @gcctabopt
+@item sra-max-structure-size
+The maximum structure size, in bytes, at which the scalar replacement
+of aggregates (SRA) optimization will perform block copies.  The
+default value, 0, implies that GCC will select the most appropriate
+size itself.
+
+@item sra-field-structure-ratio
+The threshold ratio (as a percentage) between instantiated fields and
+the complete structure size.  We say that if the ratio of the number
+of bytes in instantiated fields to the number of bytes in the complete
+structure exceeds this parameter, then block copies are not used.  The
+default is 75.
+
+@item struct-reorg-cold-struct-ratio
+The threshold ratio (as a percentage) between a structure frequency
+and the frequency of the hottest structure in the program.  This parameter
+is used by struct-reorg optimization enabled by @option{-fipa-struct-reorg}.
+We say that if the ratio of a structure frequency, calculated by profiling, 
+to the hottest structure frequency in the program is less than this 
+parameter, then structure reorganization is not applied to this structure.
+The default is 10.
+
+@item predictable-branch-cost-outcome
+When branch is predicted to be taken with probability lower than this threshold
+(in percent), then it is considered well predictable. The default is 10.
+
+@item max-crossjump-edges
+The maximum number of incoming edges to consider for crossjumping.
+The algorithm used by @option{-fcrossjumping} is @math{O(N^2)} in
+the number of edges incoming to each block.  Increasing values mean
+more aggressive optimization, making the compile time increase with
+probably small improvement in executable size.
+
+@item min-crossjump-insns
+The minimum number of instructions which must be matched at the end
+of two blocks before crossjumping will be performed on them.  This
+value is ignored in the case where all instructions in the block being
+crossjumped from are matched.  The default value is 5.
+
+@item max-grow-copy-bb-insns
+The maximum code size expansion factor when copying basic blocks
+instead of jumping.  The expansion is relative to a jump instruction.
+The default value is 8.
+
+@item max-goto-duplication-insns
+The maximum number of instructions to duplicate to a block that jumps
+to a computed goto.  To avoid @math{O(N^2)} behavior in a number of
+passes, GCC factors computed gotos early in the compilation process,
+and unfactors them as late as possible.  Only computed jumps at the
+end of a basic blocks with no more than max-goto-duplication-insns are
+unfactored.  The default value is 8.
+
+@item max-delay-slot-insn-search
+The maximum number of instructions to consider when looking for an
+instruction to fill a delay slot.  If more than this arbitrary number of
+instructions is searched, the time savings from filling the delay slot
+will be minimal so stop searching.  Increasing values mean more
+aggressive optimization, making the compile time increase with probably
+small improvement in executable run time.
+
+@item max-delay-slot-live-search
+When trying to fill delay slots, the maximum number of instructions to
+consider when searching for a block with valid live register
+information.  Increasing this arbitrarily chosen value means more
+aggressive optimization, increasing the compile time.  This parameter
+should be removed when the delay slot code is rewritten to maintain the
+control-flow graph.
+
+@item max-gcse-memory
+The approximate maximum amount of memory that will be allocated in
+order to perform the global common subexpression elimination
+optimization.  If more memory than specified is required, the
+optimization will not be done.
+
+@item max-gcse-passes
+The maximum number of passes of GCSE to run.  The default is 1.
+
+@item max-pending-list-length
+The maximum number of pending dependencies scheduling will allow
+before flushing the current state and starting over.  Large functions
+with few branches or calls can create excessively large lists which
+needlessly consume memory and resources.
+
+@item max-inline-insns-single
+Several parameters control the tree inliner used in gcc.
+This number sets the maximum number of instructions (counted in GCC's
+internal representation) in a single function that the tree inliner
+will consider for inlining.  This only affects functions declared
+inline and methods implemented in a class declaration (C++).
+The default value is 450.
+
+@item max-inline-insns-auto
+When you use @option{-finline-functions} (included in @option{-O3}),
+a lot of functions that would otherwise not be considered for inlining
+by the compiler will be investigated.  To those functions, a different
+(more restrictive) limit compared to functions declared inline can
+be applied.
+The default value is 90.
+
+@item large-function-insns
+The limit specifying really large functions.  For functions larger than this
+limit after inlining, inlining is constrained by
+@option{--param large-function-growth}.  This parameter is useful primarily
+to avoid extreme compilation time caused by non-linear algorithms used by the
+backend.
+The default value is 2700.
+
+@item large-function-growth
+Specifies maximal growth of large function caused by inlining in percents.
+The default value is 100 which limits large function growth to 2.0 times
+the original size.
+
+@item large-unit-insns
+The limit specifying large translation unit.  Growth caused by inlining of
+units larger than this limit is limited by @option{--param inline-unit-growth}.
+For small units this might be too tight (consider unit consisting of function A
+that is inline and B that just calls A three time.  If B is small relative to
+A, the growth of unit is 300\% and yet such inlining is very sane.  For very
+large units consisting of small inlineable functions however the overall unit
+growth limit is needed to avoid exponential explosion of code size.  Thus for
+smaller units, the size is increased to @option{--param large-unit-insns}
+before applying @option{--param inline-unit-growth}.  The default is 10000
+
+@item inline-unit-growth
+Specifies maximal overall growth of the compilation unit caused by inlining.
+The default value is 30 which limits unit growth to 1.3 times the original
+size.
+
+@item ipcp-unit-growth
+Specifies maximal overall growth of the compilation unit caused by
+interprocedural constant propagation.  The default value is 10 which limits
+unit growth to 1.1 times the original size.
+
+@item large-stack-frame
+The limit specifying large stack frames.  While inlining the algorithm is trying
+to not grow past this limit too much.  Default value is 256 bytes.
+
+@item large-stack-frame-growth
+Specifies maximal growth of large stack frames caused by inlining in percents.
+The default value is 1000 which limits large stack frame growth to 11 times
+the original size.
+
+@item max-inline-insns-recursive
+@itemx max-inline-insns-recursive-auto
+Specifies maximum number of instructions out-of-line copy of self recursive inline
+function can grow into by performing recursive inlining.
+
+For functions declared inline @option{--param max-inline-insns-recursive} is
+taken into account.  For function not declared inline, recursive inlining
+happens only when @option{-finline-functions} (included in @option{-O3}) is
+enabled and @option{--param max-inline-insns-recursive-auto} is used.  The
+default value is 450.
+
+@item max-inline-recursive-depth
+@itemx max-inline-recursive-depth-auto
+Specifies maximum recursion depth used by the recursive inlining.
+
+For functions declared inline @option{--param max-inline-recursive-depth} is
+taken into account.  For function not declared inline, recursive inlining
+happens only when @option{-finline-functions} (included in @option{-O3}) is
+enabled and @option{--param max-inline-recursive-depth-auto} is used.  The
+default value is 8.
+
+@item min-inline-recursive-probability
+Recursive inlining is profitable only for function having deep recursion
+in average and can hurt for function having little recursion depth by
+increasing the prologue size or complexity of function body to other
+optimizers.
+
+When profile feedback is available (see @option{-fprofile-generate}) the actual
+recursion depth can be guessed from probability that function will recurse via
+given call expression.  This parameter limits inlining only to call expression
+whose probability exceeds given threshold (in percents).  The default value is
+10.
+
+@item inline-call-cost
+Specify cost of call instruction relative to simple arithmetics operations
+(having cost of 1).  Increasing this cost disqualifies inlining of non-leaf
+functions and at the same time increases size of leaf function that is believed to
+reduce function size by being inlined.  In effect it increases amount of
+inlining for code having large abstraction penalty (many functions that just
+pass the arguments to other functions) and decrease inlining for code with low
+abstraction penalty.  The default value is 12.
+
+@item min-vect-loop-bound
+The minimum number of iterations under which a loop will not get vectorized
+when @option{-ftree-vectorize} is used.  The number of iterations after
+vectorization needs to be greater than the value specified by this option
+to allow vectorization.  The default value is 0.
+
+@item max-unrolled-insns
+The maximum number of instructions that a loop should have if that loop
+is unrolled, and if the loop is unrolled, it determines how many times
+the loop code is unrolled.
+
+@item max-average-unrolled-insns
+The maximum number of instructions biased by probabilities of their execution
+that a loop should have if that loop is unrolled, and if the loop is unrolled,
+it determines how many times the loop code is unrolled.
+
+@item max-unroll-times
+The maximum number of unrollings of a single loop.
+
+@item max-peeled-insns
+The maximum number of instructions that a loop should have if that loop
+is peeled, and if the loop is peeled, it determines how many times
+the loop code is peeled.
+
+@item max-peel-times
+The maximum number of peelings of a single loop.
+
+@item max-completely-peeled-insns
+The maximum number of insns of a completely peeled loop.
+
+@item max-completely-peel-times
+The maximum number of iterations of a loop to be suitable for complete peeling.
+
+@item max-completely-peel-loop-nest-depth
+The maximum depth of a loop nest suitable for complete peeling.
+
+@item max-unswitch-insns
+The maximum number of insns of an unswitched loop.
+
+@item max-unswitch-level
+The maximum number of branches unswitched in a single loop.
+
+@item lim-expensive
+The minimum cost of an expensive expression in the loop invariant motion.
+
+@item iv-consider-all-candidates-bound
+Bound on number of candidates for induction variables below that
+all candidates are considered for each use in induction variable
+optimizations.  Only the most relevant candidates are considered
+if there are more candidates, to avoid quadratic time complexity.
+
+@item iv-max-considered-uses
+The induction variable optimizations give up on loops that contain more
+induction variable uses.
+
+@item iv-always-prune-cand-set-bound
+If number of candidates in the set is smaller than this value,
+we always try to remove unnecessary ivs from the set during its
+optimization when a new iv is added to the set.
+
+@item scev-max-expr-size
+Bound on size of expressions used in the scalar evolutions analyzer.
+Large expressions slow the analyzer.
+
+@item omega-max-vars
+The maximum number of variables in an Omega constraint system.
+The default value is 128.
+
+@item omega-max-geqs
+The maximum number of inequalities in an Omega constraint system.
+The default value is 256.
+
+@item omega-max-eqs
+The maximum number of equalities in an Omega constraint system.
+The default value is 128.
+
+@item omega-max-wild-cards
+The maximum number of wildcard variables that the Omega solver will
+be able to insert.  The default value is 18.
+
+@item omega-hash-table-size
+The size of the hash table in the Omega solver.  The default value is
+550.
+
+@item omega-max-keys
+The maximal number of keys used by the Omega solver.  The default
+value is 500.
+
+@item omega-eliminate-redundant-constraints
+When set to 1, use expensive methods to eliminate all redundant
+constraints.  The default value is 0.
+
+@item vect-max-version-for-alignment-checks
+The maximum number of runtime checks that can be performed when
+doing loop versioning for alignment in the vectorizer.  See option
+ftree-vect-loop-version for more information.
+
+@item vect-max-version-for-alias-checks
+The maximum number of runtime checks that can be performed when
+doing loop versioning for alias in the vectorizer.  See option
+ftree-vect-loop-version for more information.
+
+@item max-iterations-to-track
+
+The maximum number of iterations of a loop the brute force algorithm
+for analysis of # of iterations of the loop tries to evaluate.
+
+@item hot-bb-count-fraction
+Select fraction of the maximal count of repetitions of basic block in program
+given basic block needs to have to be considered hot.
+
+@item hot-bb-frequency-fraction
+Select fraction of the maximal frequency of executions of basic block in
+function given basic block needs to have to be considered hot
+
+@item max-predicted-iterations
+The maximum number of loop iterations we predict statically.  This is useful
+in cases where function contain single loop with known bound and other loop
+with unknown.  We predict the known number of iterations correctly, while
+the unknown number of iterations average to roughly 10.  This means that the
+loop without bounds would appear artificially cold relative to the other one.
+
+@item align-threshold
+
+Select fraction of the maximal frequency of executions of basic block in
+function given basic block will get aligned.
+
+@item align-loop-iterations
+
+A loop expected to iterate at lest the selected number of iterations will get
+aligned.
+
+@item tracer-dynamic-coverage
+@itemx tracer-dynamic-coverage-feedback
+
+This value is used to limit superblock formation once the given percentage of
+executed instructions is covered.  This limits unnecessary code size
+expansion.
+
+The @option{tracer-dynamic-coverage-feedback} is used only when profile
+feedback is available.  The real profiles (as opposed to statically estimated
+ones) are much less balanced allowing the threshold to be larger value.
+
+@item tracer-max-code-growth
+Stop tail duplication once code growth has reached given percentage.  This is
+rather hokey argument, as most of the duplicates will be eliminated later in
+cross jumping, so it may be set to much higher values than is the desired code
+growth.
+
+@item tracer-min-branch-ratio
+
+Stop reverse growth when the reverse probability of best edge is less than this
+threshold (in percent).
+
+@item tracer-min-branch-ratio
+@itemx tracer-min-branch-ratio-feedback
+
+Stop forward growth if the best edge do have probability lower than this
+threshold.
+
+Similarly to @option{tracer-dynamic-coverage} two values are present, one for
+compilation for profile feedback and one for compilation without.  The value
+for compilation with profile feedback needs to be more conservative (higher) in
+order to make tracer effective.
+
+@item max-cse-path-length
+
+Maximum number of basic blocks on path that cse considers.  The default is 10.
+
+@item max-cse-insns
+The maximum instructions CSE process before flushing. The default is 1000.
+
+@item max-aliased-vops
+
+Maximum number of virtual operands per function allowed to represent
+aliases before triggering the alias partitioning heuristic.  Alias
+partitioning reduces compile times and memory consumption needed for
+aliasing at the expense of precision loss in alias information.  The
+default value for this parameter is 100 for -O1, 500 for -O2 and 1000
+for -O3.
+
+Notice that if a function contains more memory statements than the
+value of this parameter, it is not really possible to achieve this
+reduction.  In this case, the compiler will use the number of memory
+statements as the value for @option{max-aliased-vops}.
+
+@item avg-aliased-vops
+
+Average number of virtual operands per statement allowed to represent
+aliases before triggering the alias partitioning heuristic.  This
+works in conjunction with @option{max-aliased-vops}.  If a function
+contains more than @option{max-aliased-vops} virtual operators, then
+memory symbols will be grouped into memory partitions until either the
+total number of virtual operators is below @option{max-aliased-vops}
+or the average number of virtual operators per memory statement is
+below @option{avg-aliased-vops}.  The default value for this parameter
+is 1 for -O1 and -O2, and 3 for -O3.
+
+@item ggc-min-expand
+
+GCC uses a garbage collector to manage its own memory allocation.  This
+parameter specifies the minimum percentage by which the garbage
+collector's heap should be allowed to expand between collections.
+Tuning this may improve compilation speed; it has no effect on code
+generation.
+
+The default is 30% + 70% * (RAM/1GB) with an upper bound of 100% when
+RAM >= 1GB@.  If @code{getrlimit} is available, the notion of "RAM" is
+the smallest of actual RAM and @code{RLIMIT_DATA} or @code{RLIMIT_AS}.  If
+GCC is not able to calculate RAM on a particular platform, the lower
+bound of 30% is used.  Setting this parameter and
+@option{ggc-min-heapsize} to zero causes a full collection to occur at
+every opportunity.  This is extremely slow, but can be useful for
+debugging.
+
+@item ggc-min-heapsize
+
+Minimum size of the garbage collector's heap before it begins bothering
+to collect garbage.  The first collection occurs after the heap expands
+by @option{ggc-min-expand}% beyond @option{ggc-min-heapsize}.  Again,
+tuning this may improve compilation speed, and has no effect on code
+generation.
+
+The default is the smaller of RAM/8, RLIMIT_RSS, or a limit which
+tries to ensure that RLIMIT_DATA or RLIMIT_AS are not exceeded, but
+with a lower bound of 4096 (four megabytes) and an upper bound of
+131072 (128 megabytes).  If GCC is not able to calculate RAM on a
+particular platform, the lower bound is used.  Setting this parameter
+very large effectively disables garbage collection.  Setting this
+parameter and @option{ggc-min-expand} to zero causes a full collection
+to occur at every opportunity.
+
+@item max-reload-search-insns
+The maximum number of instruction reload should look backward for equivalent
+register.  Increasing values mean more aggressive optimization, making the
+compile time increase with probably slightly better performance.  The default
+value is 100.
+
+@item max-cselib-memory-locations
+The maximum number of memory locations cselib should take into account.
+Increasing values mean more aggressive optimization, making the compile time
+increase with probably slightly better performance.  The default value is 500.
+
+@item reorder-blocks-duplicate
+@itemx reorder-blocks-duplicate-feedback
+
+Used by basic block reordering pass to decide whether to use unconditional
+branch or duplicate the code on its destination.  Code is duplicated when its
+estimated size is smaller than this value multiplied by the estimated size of
+unconditional jump in the hot spots of the program.
+
+The @option{reorder-block-duplicate-feedback} is used only when profile
+feedback is available and may be set to higher values than
+@option{reorder-block-duplicate} since information about the hot spots is more
+accurate.
+
+@item max-sched-ready-insns
+The maximum number of instructions ready to be issued the scheduler should
+consider at any given time during the first scheduling pass.  Increasing
+values mean more thorough searches, making the compilation time increase
+with probably little benefit.  The default value is 100.
+
+@item max-sched-region-blocks
+The maximum number of blocks in a region to be considered for
+interblock scheduling.  The default value is 10.
+
+@item max-pipeline-region-blocks
+The maximum number of blocks in a region to be considered for
+pipelining in the selective scheduler.  The default value is 15.
+
+@item max-sched-region-insns
+The maximum number of insns in a region to be considered for
+interblock scheduling.  The default value is 100.
+
+@item max-pipeline-region-insns
+The maximum number of insns in a region to be considered for
+pipelining in the selective scheduler.  The default value is 200.
+
+@item min-spec-prob
+The minimum probability (in percents) of reaching a source block
+for interblock speculative scheduling.  The default value is 40.
+
+@item max-sched-extend-regions-iters
+The maximum number of iterations through CFG to extend regions.
+0 - disable region extension,
+N - do at most N iterations.
+The default value is 0.
+
+@item max-sched-insn-conflict-delay
+The maximum conflict delay for an insn to be considered for speculative motion.
+The default value is 3.
+
+@item sched-spec-prob-cutoff
+The minimal probability of speculation success (in percents), so that
+speculative insn will be scheduled.
+The default value is 40.
+
+@item sched-mem-true-dep-cost
+Minimal distance (in CPU cycles) between store and load targeting same
+memory locations.  The default value is 1.
+
+@item selsched-max-lookahead
+The maximum size of the lookahead window of selective scheduling.  It is a
+depth of search for available instructions.
+The default value is 50.
+
+@item selsched-max-sched-times
+The maximum number of times that an instruction will be scheduled during 
+selective scheduling.  This is the limit on the number of iterations 
+through which the instruction may be pipelined.  The default value is 2.
+
+@item selsched-max-insns-to-rename
+The maximum number of best instructions in the ready list that are considered
+for renaming in the selective scheduler.  The default value is 2.
+
+@item max-last-value-rtl
+The maximum size measured as number of RTLs that can be recorded in an expression
+in combiner for a pseudo register as last known value of that register.  The default
+is 10000.
+
+@item integer-share-limit
+Small integer constants can use a shared data structure, reducing the
+compiler's memory usage and increasing its speed.  This sets the maximum
+value of a shared integer constant.  The default value is 256.
+
+@item min-virtual-mappings
+Specifies the minimum number of virtual mappings in the incremental
+SSA updater that should be registered to trigger the virtual mappings
+heuristic defined by virtual-mappings-ratio.  The default value is
+100.
+
+@item virtual-mappings-ratio
+If the number of virtual mappings is virtual-mappings-ratio bigger
+than the number of virtual symbols to be updated, then the incremental
+SSA updater switches to a full update for those symbols.  The default
+ratio is 3.
+
+@item ssp-buffer-size
+The minimum size of buffers (i.e.@: arrays) that will receive stack smashing
+protection when @option{-fstack-protection} is used.
+
+@item max-jump-thread-duplication-stmts
+Maximum number of statements allowed in a block that needs to be
+duplicated when threading jumps.
+
+@item max-fields-for-field-sensitive
+Maximum number of fields in a structure we will treat in
+a field sensitive manner during pointer analysis.  The default is zero
+for -O0, and -O1 and 100 for -Os, -O2, and -O3.
+
+@item prefetch-latency
+Estimate on average number of instructions that are executed before
+prefetch finishes.  The distance we prefetch ahead is proportional
+to this constant.  Increasing this number may also lead to less
+streams being prefetched (see @option{simultaneous-prefetches}).
+
+@item simultaneous-prefetches
+Maximum number of prefetches that can run at the same time.
+
+@item l1-cache-line-size
+The size of cache line in L1 cache, in bytes.
+
+@item l1-cache-size
+The size of L1 cache, in kilobytes.
+
+@item l2-cache-size
+The size of L2 cache, in kilobytes.
+
+@item use-canonical-types
+Whether the compiler should use the ``canonical'' type system.  By
+default, this should always be 1, which uses a more efficient internal
+mechanism for comparing types in C++ and Objective-C++.  However, if
+bugs in the canonical type system are causing compilation failures,
+set this value to 0 to disable canonical types.
+
+@item switch-conversion-max-branch-ratio
+Switch initialization conversion will refuse to create arrays that are
+bigger than @option{switch-conversion-max-branch-ratio} times the number of
+branches in the switch.
+
+@item max-partial-antic-length
+Maximum length of the partial antic set computed during the tree
+partial redundancy elimination optimization (@option{-ftree-pre}) when
+optimizing at @option{-O3} and above.  For some sorts of source code
+the enhanced partial redundancy elimination optimization can run away,
+consuming all of the memory available on the host machine.  This
+parameter sets a limit on the length of the sets that are computed,
+which prevents the runaway behavior.  Setting a value of 0 for
+this parameter will allow an unlimited set length.
+
+@item sccvn-max-scc-size
+Maximum size of a strongly connected component (SCC) during SCCVN
+processing.  If this limit is hit, SCCVN processing for the whole
+function will not be done and optimizations depending on it will
+be disabled.  The default maximum SCC size is 10000.
+
+@item ira-max-loops-num
+IRA uses a regional register allocation by default.  If a function
+contains loops more than number given by the parameter, only at most
+given number of the most frequently executed loops will form regions
+for the regional register allocation.  The default value of the
+parameter is 100.
+
+@item ira-max-conflict-table-size
+Although IRA uses a sophisticated algorithm of compression conflict
+table, the table can be still big for huge functions.  If the conflict
+table for a function could be more than size in MB given by the
+parameter, the conflict table is not built and faster, simpler, and
+lower quality register allocation algorithm will be used.  The
+algorithm do not use pseudo-register conflicts.  The default value of
+the parameter is 2000.
+
+@item loop-invariant-max-bbs-in-loop
+Loop invariant motion can be very expensive, both in compile time and
+in amount of needed compile time memory, with very large loops.  Loops
+with more basic blocks than this parameter won't have loop invariant
+motion optimization performed on them.  The default value of the
+parameter is 1000 for -O1 and 10000 for -O2 and above.
+
+@end table
+@end table
+
+@node Preprocessor Options
+@section Options Controlling the Preprocessor
+@cindex preprocessor options
+@cindex options, preprocessor
+
+These options control the C preprocessor, which is run on each C source
+file before actual compilation.
+
+If you use the @option{-E} option, nothing is done except preprocessing.
+Some of these options make sense only together with @option{-E} because
+they cause the preprocessor output to be unsuitable for actual
+compilation.
+
+@table @gcctabopt
+@item -Wp,@var{option}
+@opindex Wp
+You can use @option{-Wp,@var{option}} to bypass the compiler driver
+and pass @var{option} directly through to the preprocessor.  If
+@var{option} contains commas, it is split into multiple options at the
+commas.  However, many options are modified, translated or interpreted
+by the compiler driver before being passed to the preprocessor, and
+@option{-Wp} forcibly bypasses this phase.  The preprocessor's direct
+interface is undocumented and subject to change, so whenever possible
+you should avoid using @option{-Wp} and let the driver handle the
+options instead.
+
+@item -Xpreprocessor @var{option}
+@opindex Xpreprocessor
+Pass @var{option} as an option to the preprocessor.  You can use this to
+supply system-specific preprocessor options which GCC does not know how to
+recognize.
+
+If you want to pass an option that takes an argument, you must use
+@option{-Xpreprocessor} twice, once for the option and once for the argument.
+@end table
+
+@include cppopts.texi
+
+@node Assembler Options
+@section Passing Options to the Assembler
+
+@c prevent bad page break with this line
+You can pass options to the assembler.
+
+@table @gcctabopt
+@item -Wa,@var{option}
+@opindex Wa
+Pass @var{option} as an option to the assembler.  If @var{option}
+contains commas, it is split into multiple options at the commas.
+
+@item -Xassembler @var{option}
+@opindex Xassembler
+Pass @var{option} as an option to the assembler.  You can use this to
+supply system-specific assembler options which GCC does not know how to
+recognize.
+
+If you want to pass an option that takes an argument, you must use
+@option{-Xassembler} twice, once for the option and once for the argument.
+
+@end table
+
+@node Link Options
+@section Options for Linking
+@cindex link options
+@cindex options, linking
+
+These options come into play when the compiler links object files into
+an executable output file.  They are meaningless if the compiler is
+not doing a link step.
+
+@table @gcctabopt
+@cindex file names
+@item @var{object-file-name}
+A file name that does not end in a special recognized suffix is
+considered to name an object file or library.  (Object files are
+distinguished from libraries by the linker according to the file
+contents.)  If linking is done, these object files are used as input
+to the linker.
+
+@item -c
+@itemx -S
+@itemx -E
+@opindex c
+@opindex S
+@opindex E
+If any of these options is used, then the linker is not run, and
+object file names should not be used as arguments.  @xref{Overall
+Options}.
+
+@cindex Libraries
+@item -l@var{library}
+@itemx -l @var{library}
+@opindex l
+Search the library named @var{library} when linking.  (The second
+alternative with the library as a separate argument is only for
+POSIX compliance and is not recommended.)
+
+It makes a difference where in the command you write this option; the
+linker searches and processes libraries and object files in the order they
+are specified.  Thus, @samp{foo.o -lz bar.o} searches library @samp{z}
+after file @file{foo.o} but before @file{bar.o}.  If @file{bar.o} refers
+to functions in @samp{z}, those functions may not be loaded.
+
+The linker searches a standard list of directories for the library,
+which is actually a file named @file{lib@var{library}.a}.  The linker
+then uses this file as if it had been specified precisely by name.
+
+The directories searched include several standard system directories
+plus any that you specify with @option{-L}.
+
+Normally the files found this way are library files---archive files
+whose members are object files.  The linker handles an archive file by
+scanning through it for members which define symbols that have so far
+been referenced but not defined.  But if the file that is found is an
+ordinary object file, it is linked in the usual fashion.  The only
+difference between using an @option{-l} option and specifying a file name
+is that @option{-l} surrounds @var{library} with @samp{lib} and @samp{.a}
+and searches several directories.
+
+@item -lobjc
+@opindex lobjc
+You need this special case of the @option{-l} option in order to
+link an Objective-C or Objective-C++ program.
+
+@item -nostartfiles
+@opindex nostartfiles
+Do not use the standard system startup files when linking.
+The standard system libraries are used normally, unless @option{-nostdlib}
+or @option{-nodefaultlibs} is used.
+
+@item -nodefaultlibs
+@opindex nodefaultlibs
+Do not use the standard system libraries when linking.
+Only the libraries you specify will be passed to the linker.
+The standard startup files are used normally, unless @option{-nostartfiles}
+is used.  The compiler may generate calls to @code{memcmp},
+@code{memset}, @code{memcpy} and @code{memmove}.
+These entries are usually resolved by entries in
+libc.  These entry points should be supplied through some other
+mechanism when this option is specified.
+
+@item -nostdlib
+@opindex nostdlib
+Do not use the standard system startup files or libraries when linking.
+No startup files and only the libraries you specify will be passed to
+the linker.  The compiler may generate calls to @code{memcmp}, @code{memset},
+@code{memcpy} and @code{memmove}.
+These entries are usually resolved by entries in
+libc.  These entry points should be supplied through some other
+mechanism when this option is specified.
+
+@cindex @option{-lgcc}, use with @option{-nostdlib}
+@cindex @option{-nostdlib} and unresolved references
+@cindex unresolved references and @option{-nostdlib}
+@cindex @option{-lgcc}, use with @option{-nodefaultlibs}
+@cindex @option{-nodefaultlibs} and unresolved references
+@cindex unresolved references and @option{-nodefaultlibs}
+One of the standard libraries bypassed by @option{-nostdlib} and
+@option{-nodefaultlibs} is @file{libgcc.a}, a library of internal subroutines
+that GCC uses to overcome shortcomings of particular machines, or special
+needs for some languages.
+(@xref{Interface,,Interfacing to GCC Output,gccint,GNU Compiler
+Collection (GCC) Internals},
+for more discussion of @file{libgcc.a}.)
+In most cases, you need @file{libgcc.a} even when you want to avoid
+other standard libraries.  In other words, when you specify @option{-nostdlib}
+or @option{-nodefaultlibs} you should usually specify @option{-lgcc} as well.
+This ensures that you have no unresolved references to internal GCC
+library subroutines.  (For example, @samp{__main}, used to ensure C++
+constructors will be called; @pxref{Collect2,,@code{collect2}, gccint,
+GNU Compiler Collection (GCC) Internals}.)
+
+@item -pie
+@opindex pie
+Produce a position independent executable on targets which support it.
+For predictable results, you must also specify the same set of options
+that were used to generate code (@option{-fpie}, @option{-fPIE},
+or model suboptions) when you specify this option.
+
+@item -rdynamic
+@opindex rdynamic
+Pass the flag @option{-export-dynamic} to the ELF linker, on targets
+that support it. This instructs the linker to add all symbols, not
+only used ones, to the dynamic symbol table. This option is needed
+for some uses of @code{dlopen} or to allow obtaining backtraces
+from within a program.
+
+@item -s
+@opindex s
+Remove all symbol table and relocation information from the executable.
+
+@item -static
+@opindex static
+On systems that support dynamic linking, this prevents linking with the shared
+libraries.  On other systems, this option has no effect.
+
+@item -shared
+@opindex shared
+Produce a shared object which can then be linked with other objects to
+form an executable.  Not all systems support this option.  For predictable
+results, you must also specify the same set of options that were used to
+generate code (@option{-fpic}, @option{-fPIC}, or model suboptions)
+when you specify this option.@footnote{On some systems, @samp{gcc -shared}
+needs to build supplementary stub code for constructors to work.  On
+multi-libbed systems, @samp{gcc -shared} must select the correct support
+libraries to link against.  Failing to supply the correct flags may lead
+to subtle defects.  Supplying them in cases where they are not necessary
+is innocuous.}
+
+@item -shared-libgcc
+@itemx -static-libgcc
+@opindex shared-libgcc
+@opindex static-libgcc
+On systems that provide @file{libgcc} as a shared library, these options
+force the use of either the shared or static version respectively.
+If no shared version of @file{libgcc} was built when the compiler was
+configured, these options have no effect.
+
+There are several situations in which an application should use the
+shared @file{libgcc} instead of the static version.  The most common
+of these is when the application wishes to throw and catch exceptions
+across different shared libraries.  In that case, each of the libraries
+as well as the application itself should use the shared @file{libgcc}.
+
+Therefore, the G++ and GCJ drivers automatically add
+@option{-shared-libgcc} whenever you build a shared library or a main
+executable, because C++ and Java programs typically use exceptions, so
+this is the right thing to do.
+
+If, instead, you use the GCC driver to create shared libraries, you may
+find that they will not always be linked with the shared @file{libgcc}.
+If GCC finds, at its configuration time, that you have a non-GNU linker
+or a GNU linker that does not support option @option{--eh-frame-hdr},
+it will link the shared version of @file{libgcc} into shared libraries
+by default.  Otherwise, it will take advantage of the linker and optimize
+away the linking with the shared version of @file{libgcc}, linking with
+the static version of libgcc by default.  This allows exceptions to
+propagate through such shared libraries, without incurring relocation
+costs at library load time.
+
+However, if a library or main executable is supposed to throw or catch
+exceptions, you must link it using the G++ or GCJ driver, as appropriate
+for the languages used in the program, or using the option
+@option{-shared-libgcc}, such that it is linked with the shared
+@file{libgcc}.
+
+@item -symbolic
+@opindex symbolic
+Bind references to global symbols when building a shared object.  Warn
+about any unresolved references (unless overridden by the link editor
+option @samp{-Xlinker -z -Xlinker defs}).  Only a few systems support
+this option.
+
+@item -T @var{script}
+@opindex T
+@cindex linker script
+Use @var{script} as the linker script.  This option is supported by most
+systems using the GNU linker.  On some targets, such as bare-board
+targets without an operating system, the @option{-T} option may be required 
+when linking to avoid references to undefined symbols.
+
+@item -Xlinker @var{option}
+@opindex Xlinker
+Pass @var{option} as an option to the linker.  You can use this to
+supply system-specific linker options which GCC does not know how to
+recognize.
+
+If you want to pass an option that takes a separate argument, you must use
+@option{-Xlinker} twice, once for the option and once for the argument.
+For example, to pass @option{-assert definitions}, you must write
+@samp{-Xlinker -assert -Xlinker definitions}.  It does not work to write
+@option{-Xlinker "-assert definitions"}, because this passes the entire
+string as a single argument, which is not what the linker expects.
+
+When using the GNU linker, it is usually more convenient to pass 
+arguments to linker options using the @option{@var{option}=@var{value}}
+syntax than as separate arguments.  For example, you can specify
+@samp{-Xlinker -Map=output.map} rather than
+@samp{-Xlinker -Map -Xlinker output.map}.  Other linkers may not support
+this syntax for command-line options.
+
+@item -Wl,@var{option}
+@opindex Wl
+Pass @var{option} as an option to the linker.  If @var{option} contains
+commas, it is split into multiple options at the commas.  You can use this
+syntax to pass an argument to the option.  
+For example, @samp{-Wl,-Map,output.map} passes @samp{-Map output.map} to the
+linker.  When using the GNU linker, you can also get the same effect with
+@samp{-Wl,-Map=output.map}.
+
+@item -u @var{symbol}
+@opindex u
+Pretend the symbol @var{symbol} is undefined, to force linking of
+library modules to define it.  You can use @option{-u} multiple times with
+different symbols to force loading of additional library modules.
+@end table
+
+@node Directory Options
+@section Options for Directory Search
+@cindex directory options
+@cindex options, directory search
+@cindex search path
+
+These options specify directories to search for header files, for
+libraries and for parts of the compiler:
+
+@table @gcctabopt
+@item -I@var{dir}
+@opindex I
+Add the directory @var{dir} to the head of the list of directories to be
+searched for header files.  This can be used to override a system header
+file, substituting your own version, since these directories are
+searched before the system header file directories.  However, you should
+not use this option to add directories that contain vendor-supplied
+system header files (use @option{-isystem} for that).  If you use more than
+one @option{-I} option, the directories are scanned in left-to-right
+order; the standard system directories come after.
+
+If a standard system include directory, or a directory specified with
+@option{-isystem}, is also specified with @option{-I}, the @option{-I}
+option will be ignored.  The directory will still be searched but as a
+system directory at its normal position in the system include chain.
+This is to ensure that GCC's procedure to fix buggy system headers and
+the ordering for the include_next directive are not inadvertently changed.
+If you really need to change the search order for system directories,
+use the @option{-nostdinc} and/or @option{-isystem} options.
+
+@item -iquote@var{dir}
+@opindex iquote
+Add the directory @var{dir} to the head of the list of directories to
+be searched for header files only for the case of @samp{#include
+"@var{file}"}; they are not searched for @samp{#include <@var{file}>},
+otherwise just like @option{-I}.
+
+@item -L@var{dir}
+@opindex L
+Add directory @var{dir} to the list of directories to be searched
+for @option{-l}.
+
+@item -B@var{prefix}
+@opindex B
+This option specifies where to find the executables, libraries,
+include files, and data files of the compiler itself.
+
+The compiler driver program runs one or more of the subprograms
+@file{cpp}, @file{cc1}, @file{as} and @file{ld}.  It tries
+@var{prefix} as a prefix for each program it tries to run, both with and
+without @samp{@var{machine}/@var{version}/} (@pxref{Target Options}).
+
+For each subprogram to be run, the compiler driver first tries the
+@option{-B} prefix, if any.  If that name is not found, or if @option{-B}
+was not specified, the driver tries two standard prefixes, which are
+@file{/usr/lib/gcc/} and @file{/usr/local/lib/gcc/}.  If neither of
+those results in a file name that is found, the unmodified program
+name is searched for using the directories specified in your
+@env{PATH} environment variable.
+
+The compiler will check to see if the path provided by the @option{-B}
+refers to a directory, and if necessary it will add a directory
+separator character at the end of the path.
+
+@option{-B} prefixes that effectively specify directory names also apply
+to libraries in the linker, because the compiler translates these
+options into @option{-L} options for the linker.  They also apply to
+includes files in the preprocessor, because the compiler translates these
+options into @option{-isystem} options for the preprocessor.  In this case,
+the compiler appends @samp{include} to the prefix.
+
+The run-time support file @file{libgcc.a} can also be searched for using
+the @option{-B} prefix, if needed.  If it is not found there, the two
+standard prefixes above are tried, and that is all.  The file is left
+out of the link if it is not found by those means.
+
+Another way to specify a prefix much like the @option{-B} prefix is to use
+the environment variable @env{GCC_EXEC_PREFIX}.  @xref{Environment
+Variables}.
+
+As a special kludge, if the path provided by @option{-B} is
+@file{[dir/]stage@var{N}/}, where @var{N} is a number in the range 0 to
+9, then it will be replaced by @file{[dir/]include}.  This is to help
+with boot-strapping the compiler.
+
+@item -specs=@var{file}
+@opindex specs
+Process @var{file} after the compiler reads in the standard @file{specs}
+file, in order to override the defaults that the @file{gcc} driver
+program uses when determining what switches to pass to @file{cc1},
+@file{cc1plus}, @file{as}, @file{ld}, etc.  More than one
+@option{-specs=@var{file}} can be specified on the command line, and they
+are processed in order, from left to right.
+
+@item --sysroot=@var{dir}
+@opindex sysroot
+Use @var{dir} as the logical root directory for headers and libraries.
+For example, if the compiler would normally search for headers in
+@file{/usr/include} and libraries in @file{/usr/lib}, it will instead
+search @file{@var{dir}/usr/include} and @file{@var{dir}/usr/lib}.
+
+If you use both this option and the @option{-isysroot} option, then
+the @option{--sysroot} option will apply to libraries, but the
+@option{-isysroot} option will apply to header files.
+
+The GNU linker (beginning with version 2.16) has the necessary support
+for this option.  If your linker does not support this option, the
+header file aspect of @option{--sysroot} will still work, but the
+library aspect will not.
+
+@item -I-
+@opindex I-
+This option has been deprecated.  Please use @option{-iquote} instead for
+@option{-I} directories before the @option{-I-} and remove the @option{-I-}.
+Any directories you specify with @option{-I} options before the @option{-I-}
+option are searched only for the case of @samp{#include "@var{file}"};
+they are not searched for @samp{#include <@var{file}>}.
+
+If additional directories are specified with @option{-I} options after
+the @option{-I-}, these directories are searched for all @samp{#include}
+directives.  (Ordinarily @emph{all} @option{-I} directories are used
+this way.)
+
+In addition, the @option{-I-} option inhibits the use of the current
+directory (where the current input file came from) as the first search
+directory for @samp{#include "@var{file}"}.  There is no way to
+override this effect of @option{-I-}.  With @option{-I.} you can specify
+searching the directory which was current when the compiler was
+invoked.  That is not exactly the same as what the preprocessor does
+by default, but it is often satisfactory.
+
+@option{-I-} does not inhibit the use of the standard system directories
+for header files.  Thus, @option{-I-} and @option{-nostdinc} are
+independent.
+@end table
+
+@c man end
+
+@node Spec Files
+@section Specifying subprocesses and the switches to pass to them
+@cindex Spec Files
+
+@command{gcc} is a driver program.  It performs its job by invoking a
+sequence of other programs to do the work of compiling, assembling and
+linking.  GCC interprets its command-line parameters and uses these to
+deduce which programs it should invoke, and which command-line options
+it ought to place on their command lines.  This behavior is controlled
+by @dfn{spec strings}.  In most cases there is one spec string for each
+program that GCC can invoke, but a few programs have multiple spec
+strings to control their behavior.  The spec strings built into GCC can
+be overridden by using the @option{-specs=} command-line switch to specify
+a spec file.
+
+@dfn{Spec files} are plaintext files that are used to construct spec
+strings.  They consist of a sequence of directives separated by blank
+lines.  The type of directive is determined by the first non-whitespace
+character on the line and it can be one of the following:
+
+@table @code
+@item %@var{command}
+Issues a @var{command} to the spec file processor.  The commands that can
+appear here are:
+
+@table @code
+@item %include <@var{file}>
+@cindex %include
+Search for @var{file} and insert its text at the current point in the
+specs file.
+
+@item %include_noerr <@var{file}>
+@cindex %include_noerr
+Just like @samp{%include}, but do not generate an error message if the include
+file cannot be found.
+
+@item %rename @var{old_name} @var{new_name}
+@cindex %rename
+Rename the spec string @var{old_name} to @var{new_name}.
+
+@end table
+
+@item *[@var{spec_name}]:
+This tells the compiler to create, override or delete the named spec
+string.  All lines after this directive up to the next directive or
+blank line are considered to be the text for the spec string.  If this
+results in an empty string then the spec will be deleted.  (Or, if the
+spec did not exist, then nothing will happened.)  Otherwise, if the spec
+does not currently exist a new spec will be created.  If the spec does
+exist then its contents will be overridden by the text of this
+directive, unless the first character of that text is the @samp{+}
+character, in which case the text will be appended to the spec.
+
+@item [@var{suffix}]:
+Creates a new @samp{[@var{suffix}] spec} pair.  All lines after this directive
+and up to the next directive or blank line are considered to make up the
+spec string for the indicated suffix.  When the compiler encounters an
+input file with the named suffix, it will processes the spec string in
+order to work out how to compile that file.  For example:
+
+@smallexample
+.ZZ:
+z-compile -input %i
+@end smallexample
+
+This says that any input file whose name ends in @samp{.ZZ} should be
+passed to the program @samp{z-compile}, which should be invoked with the
+command-line switch @option{-input} and with the result of performing the
+@samp{%i} substitution.  (See below.)
+
+As an alternative to providing a spec string, the text that follows a
+suffix directive can be one of the following:
+
+@table @code
+@item @@@var{language}
+This says that the suffix is an alias for a known @var{language}.  This is
+similar to using the @option{-x} command-line switch to GCC to specify a
+language explicitly.  For example:
+
+@smallexample
+.ZZ:
+@@c++
+@end smallexample
+
+Says that .ZZ files are, in fact, C++ source files.
+
+@item #@var{name}
+This causes an error messages saying:
+
+@smallexample
+@var{name} compiler not installed on this system.
+@end smallexample
+@end table
+
+GCC already has an extensive list of suffixes built into it.
+This directive will add an entry to the end of the list of suffixes, but
+since the list is searched from the end backwards, it is effectively
+possible to override earlier entries using this technique.
+
+@end table
+
+GCC has the following spec strings built into it.  Spec files can
+override these strings or create their own.  Note that individual
+targets can also add their own spec strings to this list.
+
+@smallexample
+asm          Options to pass to the assembler
+asm_final    Options to pass to the assembler post-processor
+cpp          Options to pass to the C preprocessor
+cc1          Options to pass to the C compiler
+cc1plus      Options to pass to the C++ compiler
+endfile      Object files to include at the end of the link
+link         Options to pass to the linker
+lib          Libraries to include on the command line to the linker
+libgcc       Decides which GCC support library to pass to the linker
+linker       Sets the name of the linker
+predefines   Defines to be passed to the C preprocessor
+signed_char  Defines to pass to CPP to say whether @code{char} is signed
+             by default
+startfile    Object files to include at the start of the link
+@end smallexample
+
+Here is a small example of a spec file:
+
+@smallexample
+%rename lib                 old_lib
+
+*lib:
+--start-group -lgcc -lc -leval1 --end-group %(old_lib)
+@end smallexample
+
+This example renames the spec called @samp{lib} to @samp{old_lib} and
+then overrides the previous definition of @samp{lib} with a new one.
+The new definition adds in some extra command-line options before
+including the text of the old definition.
+
+@dfn{Spec strings} are a list of command-line options to be passed to their
+corresponding program.  In addition, the spec strings can contain
+@samp{%}-prefixed sequences to substitute variable text or to
+conditionally insert text into the command line.  Using these constructs
+it is possible to generate quite complex command lines.
+
+Here is a table of all defined @samp{%}-sequences for spec
+strings.  Note that spaces are not generated automatically around the
+results of expanding these sequences.  Therefore you can concatenate them
+together or combine them with constant text in a single argument.
+
+@table @code
+@item %%
+Substitute one @samp{%} into the program name or argument.
+
+@item %i
+Substitute the name of the input file being processed.
+
+@item %b
+Substitute the basename of the input file being processed.
+This is the substring up to (and not including) the last period
+and not including the directory.
+
+@item %B
+This is the same as @samp{%b}, but include the file suffix (text after
+the last period).
+
+@item %d
+Marks the argument containing or following the @samp{%d} as a
+temporary file name, so that that file will be deleted if GCC exits
+successfully.  Unlike @samp{%g}, this contributes no text to the
+argument.
+
+@item %g@var{suffix}
+Substitute a file name that has suffix @var{suffix} and is chosen
+once per compilation, and mark the argument in the same way as
+@samp{%d}.  To reduce exposure to denial-of-service attacks, the file
+name is now chosen in a way that is hard to predict even when previously
+chosen file names are known.  For example, @samp{%g.s @dots{} %g.o @dots{} %g.s}
+might turn into @samp{ccUVUUAU.s ccXYAXZ12.o ccUVUUAU.s}.  @var{suffix} matches
+the regexp @samp{[.A-Za-z]*} or the special string @samp{%O}, which is
+treated exactly as if @samp{%O} had been preprocessed.  Previously, @samp{%g}
+was simply substituted with a file name chosen once per compilation,
+without regard to any appended suffix (which was therefore treated
+just like ordinary text), making such attacks more likely to succeed.
+
+@item %u@var{suffix}
+Like @samp{%g}, but generates a new temporary file name even if
+@samp{%u@var{suffix}} was already seen.
+
+@item %U@var{suffix}
+Substitutes the last file name generated with @samp{%u@var{suffix}}, generating a
+new one if there is no such last file name.  In the absence of any
+@samp{%u@var{suffix}}, this is just like @samp{%g@var{suffix}}, except they don't share
+the same suffix @emph{space}, so @samp{%g.s @dots{} %U.s @dots{} %g.s @dots{} %U.s}
+would involve the generation of two distinct file names, one
+for each @samp{%g.s} and another for each @samp{%U.s}.  Previously, @samp{%U} was
+simply substituted with a file name chosen for the previous @samp{%u},
+without regard to any appended suffix.
+
+@item %j@var{suffix}
+Substitutes the name of the @code{HOST_BIT_BUCKET}, if any, and if it is
+writable, and if save-temps is off; otherwise, substitute the name
+of a temporary file, just like @samp{%u}.  This temporary file is not
+meant for communication between processes, but rather as a junk
+disposal mechanism.
+
+@item %|@var{suffix}
+@itemx %m@var{suffix}
+Like @samp{%g}, except if @option{-pipe} is in effect.  In that case
+@samp{%|} substitutes a single dash and @samp{%m} substitutes nothing at
+all.  These are the two most common ways to instruct a program that it
+should read from standard input or write to standard output.  If you
+need something more elaborate you can use an @samp{%@{pipe:@code{X}@}}
+construct: see for example @file{f/lang-specs.h}.
+
+@item %.@var{SUFFIX}
+Substitutes @var{.SUFFIX} for the suffixes of a matched switch's args
+when it is subsequently output with @samp{%*}.  @var{SUFFIX} is
+terminated by the next space or %.
+
+@item %w
+Marks the argument containing or following the @samp{%w} as the
+designated output file of this compilation.  This puts the argument
+into the sequence of arguments that @samp{%o} will substitute later.
+
+@item %o
+Substitutes the names of all the output files, with spaces
+automatically placed around them.  You should write spaces
+around the @samp{%o} as well or the results are undefined.
+@samp{%o} is for use in the specs for running the linker.
+Input files whose names have no recognized suffix are not compiled
+at all, but they are included among the output files, so they will
+be linked.
+
+@item %O
+Substitutes the suffix for object files.  Note that this is
+handled specially when it immediately follows @samp{%g, %u, or %U},
+because of the need for those to form complete file names.  The
+handling is such that @samp{%O} is treated exactly as if it had already
+been substituted, except that @samp{%g, %u, and %U} do not currently
+support additional @var{suffix} characters following @samp{%O} as they would
+following, for example, @samp{.o}.
+
+@item %p
+Substitutes the standard macro predefinitions for the
+current target machine.  Use this when running @code{cpp}.
+
+@item %P
+Like @samp{%p}, but puts @samp{__} before and after the name of each
+predefined macro, except for macros that start with @samp{__} or with
+@samp{_@var{L}}, where @var{L} is an uppercase letter.  This is for ISO
+C@.
+
+@item %I
+Substitute any of @option{-iprefix} (made from @env{GCC_EXEC_PREFIX}),
+@option{-isysroot} (made from @env{TARGET_SYSTEM_ROOT}),
+@option{-isystem} (made from @env{COMPILER_PATH} and @option{-B} options)
+and @option{-imultilib} as necessary.
+
+@item %s
+Current argument is the name of a library or startup file of some sort.
+Search for that file in a standard list of directories and substitute
+the full name found.
+
+@item %e@var{str}
+Print @var{str} as an error message.  @var{str} is terminated by a newline.
+Use this when inconsistent options are detected.
+
+@item %(@var{name})
+Substitute the contents of spec string @var{name} at this point.
+
+@item %[@var{name}]
+Like @samp{%(@dots{})} but put @samp{__} around @option{-D} arguments.
+
+@item %x@{@var{option}@}
+Accumulate an option for @samp{%X}.
+
+@item %X
+Output the accumulated linker options specified by @option{-Wl} or a @samp{%x}
+spec string.
+
+@item %Y
+Output the accumulated assembler options specified by @option{-Wa}.
+
+@item %Z
+Output the accumulated preprocessor options specified by @option{-Wp}.
+
+@item %a
+Process the @code{asm} spec.  This is used to compute the
+switches to be passed to the assembler.
+
+@item %A
+Process the @code{asm_final} spec.  This is a spec string for
+passing switches to an assembler post-processor, if such a program is
+needed.
+
+@item %l
+Process the @code{link} spec.  This is the spec for computing the
+command line passed to the linker.  Typically it will make use of the
+@samp{%L %G %S %D and %E} sequences.
+
+@item %D
+Dump out a @option{-L} option for each directory that GCC believes might
+contain startup files.  If the target supports multilibs then the
+current multilib directory will be prepended to each of these paths.
+
+@item %L
+Process the @code{lib} spec.  This is a spec string for deciding which
+libraries should be included on the command line to the linker.
+
+@item %G
+Process the @code{libgcc} spec.  This is a spec string for deciding
+which GCC support library should be included on the command line to the linker.
+
+@item %S
+Process the @code{startfile} spec.  This is a spec for deciding which
+object files should be the first ones passed to the linker.  Typically
+this might be a file named @file{crt0.o}.
+
+@item %E
+Process the @code{endfile} spec.  This is a spec string that specifies
+the last object files that will be passed to the linker.
+
+@item %C
+Process the @code{cpp} spec.  This is used to construct the arguments
+to be passed to the C preprocessor.
+
+@item %1
+Process the @code{cc1} spec.  This is used to construct the options to be
+passed to the actual C compiler (@samp{cc1}).
+
+@item %2
+Process the @code{cc1plus} spec.  This is used to construct the options to be
+passed to the actual C++ compiler (@samp{cc1plus}).
+
+@item %*
+Substitute the variable part of a matched option.  See below.
+Note that each comma in the substituted string is replaced by
+a single space.
+
+@item %<@code{S}
+Remove all occurrences of @code{-S} from the command line.  Note---this
+command is position dependent.  @samp{%} commands in the spec string
+before this one will see @code{-S}, @samp{%} commands in the spec string
+after this one will not.
+
+@item %:@var{function}(@var{args})
+Call the named function @var{function}, passing it @var{args}.
+@var{args} is first processed as a nested spec string, then split
+into an argument vector in the usual fashion.  The function returns
+a string which is processed as if it had appeared literally as part
+of the current spec.
+
+The following built-in spec functions are provided:
+
+@table @code
+@item @code{getenv}
+The @code{getenv} spec function takes two arguments: an environment
+variable name and a string.  If the environment variable is not
+defined, a fatal error is issued.  Otherwise, the return value is the
+value of the environment variable concatenated with the string.  For
+example, if @env{TOPDIR} is defined as @file{/path/to/top}, then:
+
+@smallexample
+%:getenv(TOPDIR /include)
+@end smallexample
+
+expands to @file{/path/to/top/include}.
+
+@item @code{if-exists}
+The @code{if-exists} spec function takes one argument, an absolute
+pathname to a file.  If the file exists, @code{if-exists} returns the
+pathname.  Here is a small example of its usage:
+
+@smallexample
+*startfile:
+crt0%O%s %:if-exists(crti%O%s) crtbegin%O%s
+@end smallexample
+
+@item @code{if-exists-else}
+The @code{if-exists-else} spec function is similar to the @code{if-exists}
+spec function, except that it takes two arguments.  The first argument is
+an absolute pathname to a file.  If the file exists, @code{if-exists-else}
+returns the pathname.  If it does not exist, it returns the second argument.
+This way, @code{if-exists-else} can be used to select one file or another,
+based on the existence of the first.  Here is a small example of its usage:
+
+@smallexample
+*startfile:
+crt0%O%s %:if-exists(crti%O%s) \
+%:if-exists-else(crtbeginT%O%s crtbegin%O%s)
+@end smallexample
+
+@item @code{replace-outfile}
+The @code{replace-outfile} spec function takes two arguments.  It looks for the
+first argument in the outfiles array and replaces it with the second argument.  Here
+is a small example of its usage:
+
+@smallexample
+%@{fgnu-runtime:%:replace-outfile(-lobjc -lobjc-gnu)@}
+@end smallexample
+
+@item @code{print-asm-header}
+The @code{print-asm-header} function takes no arguments and simply
+prints a banner like:
+
+@smallexample
+Assembler options
+=================
+
+Use "-Wa,OPTION" to pass "OPTION" to the assembler.
+@end smallexample
+
+It is used to separate compiler options from assembler options
+in the @option{--target-help} output.
+@end table
+
+@item %@{@code{S}@}
+Substitutes the @code{-S} switch, if that switch was given to GCC@.
+If that switch was not specified, this substitutes nothing.  Note that
+the leading dash is omitted when specifying this option, and it is
+automatically inserted if the substitution is performed.  Thus the spec
+string @samp{%@{foo@}} would match the command-line option @option{-foo}
+and would output the command line option @option{-foo}.
+
+@item %W@{@code{S}@}
+Like %@{@code{S}@} but mark last argument supplied within as a file to be
+deleted on failure.
+
+@item %@{@code{S}*@}
+Substitutes all the switches specified to GCC whose names start
+with @code{-S}, but which also take an argument.  This is used for
+switches like @option{-o}, @option{-D}, @option{-I}, etc.
+GCC considers @option{-o foo} as being
+one switch whose names starts with @samp{o}.  %@{o*@} would substitute this
+text, including the space.  Thus two arguments would be generated.
+
+@item %@{@code{S}*&@code{T}*@}
+Like %@{@code{S}*@}, but preserve order of @code{S} and @code{T} options
+(the order of @code{S} and @code{T} in the spec is not significant).
+There can be any number of ampersand-separated variables; for each the
+wild card is optional.  Useful for CPP as @samp{%@{D*&U*&A*@}}.
+
+@item %@{@code{S}:@code{X}@}
+Substitutes @code{X}, if the @samp{-S} switch was given to GCC@.
+
+@item %@{!@code{S}:@code{X}@}
+Substitutes @code{X}, if the @samp{-S} switch was @emph{not} given to GCC@.
+
+@item %@{@code{S}*:@code{X}@}
+Substitutes @code{X} if one or more switches whose names start with
+@code{-S} are specified to GCC@.  Normally @code{X} is substituted only
+once, no matter how many such switches appeared.  However, if @code{%*}
+appears somewhere in @code{X}, then @code{X} will be substituted once
+for each matching switch, with the @code{%*} replaced by the part of
+that switch that matched the @code{*}.
+
+@item %@{.@code{S}:@code{X}@}
+Substitutes @code{X}, if processing a file with suffix @code{S}.
+
+@item %@{!.@code{S}:@code{X}@}
+Substitutes @code{X}, if @emph{not} processing a file with suffix @code{S}.
+
+@item %@{,@code{S}:@code{X}@}
+Substitutes @code{X}, if processing a file for language @code{S}.
+
+@item %@{!,@code{S}:@code{X}@}
+Substitutes @code{X}, if not processing a file for language @code{S}.
+
+@item %@{@code{S}|@code{P}:@code{X}@}
+Substitutes @code{X} if either @code{-S} or @code{-P} was given to
+GCC@.  This may be combined with @samp{!}, @samp{.}, @samp{,}, and
+@code{*} sequences as well, although they have a stronger binding than
+the @samp{|}.  If @code{%*} appears in @code{X}, all of the
+alternatives must be starred, and only the first matching alternative
+is substituted.
+
+For example, a spec string like this:
+
+@smallexample
+%@{.c:-foo@} %@{!.c:-bar@} %@{.c|d:-baz@} %@{!.c|d:-boggle@}
+@end smallexample
+
+will output the following command-line options from the following input
+command-line options:
+
+@smallexample
+fred.c        -foo -baz
+jim.d         -bar -boggle
+-d fred.c     -foo -baz -boggle
+-d jim.d      -bar -baz -boggle
+@end smallexample
+
+@item %@{S:X; T:Y; :D@}
+
+If @code{S} was given to GCC, substitutes @code{X}; else if @code{T} was
+given to GCC, substitutes @code{Y}; else substitutes @code{D}.  There can
+be as many clauses as you need.  This may be combined with @code{.},
+@code{,}, @code{!}, @code{|}, and @code{*} as needed.
+
+
+@end table
+
+The conditional text @code{X} in a %@{@code{S}:@code{X}@} or similar
+construct may contain other nested @samp{%} constructs or spaces, or
+even newlines.  They are processed as usual, as described above.
+Trailing white space in @code{X} is ignored.  White space may also
+appear anywhere on the left side of the colon in these constructs,
+except between @code{.} or @code{*} and the corresponding word.
+
+The @option{-O}, @option{-f}, @option{-m}, and @option{-W} switches are
+handled specifically in these constructs.  If another value of
+@option{-O} or the negated form of a @option{-f}, @option{-m}, or
+@option{-W} switch is found later in the command line, the earlier
+switch value is ignored, except with @{@code{S}*@} where @code{S} is
+just one letter, which passes all matching options.
+
+The character @samp{|} at the beginning of the predicate text is used to
+indicate that a command should be piped to the following command, but
+only if @option{-pipe} is specified.
+
+It is built into GCC which switches take arguments and which do not.
+(You might think it would be useful to generalize this to allow each
+compiler's spec to say which switches take arguments.  But this cannot
+be done in a consistent fashion.  GCC cannot even decide which input
+files have been specified without knowing which switches take arguments,
+and it must know which input files to compile in order to tell which
+compilers to run).
+
+GCC also knows implicitly that arguments starting in @option{-l} are to be
+treated as compiler output files, and passed to the linker in their
+proper position among the other output files.
+
+@c man begin OPTIONS
+
+@node Target Options
+@section Specifying Target Machine and Compiler Version
+@cindex target options
+@cindex cross compiling
+@cindex specifying machine version
+@cindex specifying compiler version and target machine
+@cindex compiler version, specifying
+@cindex target machine, specifying
+
+The usual way to run GCC is to run the executable called @file{gcc}, or
+@file{<machine>-gcc} when cross-compiling, or
+@file{<machine>-gcc-<version>} to run a version other than the one that
+was installed last.  Sometimes this is inconvenient, so GCC provides
+options that will switch to another cross-compiler or version.
+
+@table @gcctabopt
+@item -b @var{machine}
+@opindex b
+The argument @var{machine} specifies the target machine for compilation.
+
+The value to use for @var{machine} is the same as was specified as the
+machine type when configuring GCC as a cross-compiler.  For
+example, if a cross-compiler was configured with @samp{configure
+arm-elf}, meaning to compile for an arm processor with elf binaries,
+then you would specify @option{-b arm-elf} to run that cross compiler.
+Because there are other options beginning with @option{-b}, the
+configuration must contain a hyphen, or @option{-b} alone should be one
+argument followed by the configuration in the next argument.
+
+@item -V @var{version}
+@opindex V
+The argument @var{version} specifies which version of GCC to run.
+This is useful when multiple versions are installed.  For example,
+@var{version} might be @samp{4.0}, meaning to run GCC version 4.0.
+@end table
+
+The @option{-V} and @option{-b} options work by running the
+@file{<machine>-gcc-<version>} executable, so there's no real reason to
+use them if you can just run that directly.
+
+@node Submodel Options
+@section Hardware Models and Configurations
+@cindex submodel options
+@cindex specifying hardware config
+@cindex hardware models and configurations, specifying
+@cindex machine dependent options
+
+Earlier we discussed the standard option @option{-b} which chooses among
+different installed compilers for completely different target
+machines, such as VAX vs.@: 68000 vs.@: 80386.
+
+In addition, each of these target machine types can have its own
+special options, starting with @samp{-m}, to choose among various
+hardware models or configurations---for example, 68010 vs 68020,
+floating coprocessor or none.  A single installed version of the
+compiler can compile for any model or configuration, according to the
+options specified.
+
+Some configurations of the compiler also support additional special
+options, usually for compatibility with other compilers on the same
+platform.
+
+@c This list is ordered alphanumerically by subsection name.
+@c It should be the same order and spelling as these options are listed
+@c in Machine Dependent Options
+
+@menu
+* ARC Options::
+* ARM Options::
+* AVR Options::
+* Blackfin Options::
+* CRIS Options::
+* CRX Options::
+* Darwin Options::
+* DEC Alpha Options::
+* DEC Alpha/VMS Options::
+* FR30 Options::
+* FRV Options::
+* GNU/Linux Options::
+* H8/300 Options::
+* HPPA Options::
+* i386 and x86-64 Options::
+* i386 and x86-64 Windows Options::
+* IA-64 Options::
+* M32C Options::
+* M32R/D Options::
+* M680x0 Options::
+* M68hc1x Options::
+* MCore Options::
+* MIPS Options::
+* MMIX Options::
+* MN10300 Options::
+* PDP-11 Options::
+* picoChip Options::
+* PowerPC Options::
+* RS/6000 and PowerPC Options::
+* S/390 and zSeries Options::
+* Score Options::
+* SH Options::
+* SPARC Options::
+* SPU Options::
+* System V Options::
+* V850 Options::
+* VAX Options::
+* VxWorks Options::
+* x86-64 Options::
+* Xstormy16 Options::
+* Xtensa Options::
+* zSeries Options::
+@end menu
+
+@node ARC Options
+@subsection ARC Options
+@cindex ARC Options
+
+These options are defined for ARC implementations:
+
+@table @gcctabopt
+@item -EL
+@opindex EL
+Compile code for little endian mode.  This is the default.
+
+@item -EB
+@opindex EB
+Compile code for big endian mode.
+
+@item -mmangle-cpu
+@opindex mmangle-cpu
+Prepend the name of the cpu to all public symbol names.
+In multiple-processor systems, there are many ARC variants with different
+instruction and register set characteristics.  This flag prevents code
+compiled for one cpu to be linked with code compiled for another.
+No facility exists for handling variants that are ``almost identical''.
+This is an all or nothing option.
+
+@item -mcpu=@var{cpu}
+@opindex mcpu
+Compile code for ARC variant @var{cpu}.
+Which variants are supported depend on the configuration.
+All variants support @option{-mcpu=base}, this is the default.
+
+@item -mtext=@var{text-section}
+@itemx -mdata=@var{data-section}
+@itemx -mrodata=@var{readonly-data-section}
+@opindex mtext
+@opindex mdata
+@opindex mrodata
+Put functions, data, and readonly data in @var{text-section},
+@var{data-section}, and @var{readonly-data-section} respectively
+by default.  This can be overridden with the @code{section} attribute.
+@xref{Variable Attributes}.
+
+@item -mfix-cortex-m3-ldrd
+@opindex mfix-cortex-m3-ldrd
+Some Cortex-M3 cores can cause data corruption when @code{ldrd} instructions
+with overlapping destination and base registers are used.  This option avoids
+generating these instructions.  This option is enabled by default when
+@option{-mcpu=cortex-m3} is specified.
+
+@end table
+
+@node ARM Options
+@subsection ARM Options
+@cindex ARM options
+
+These @samp{-m} options are defined for Advanced RISC Machines (ARM)
+architectures:
+
+@table @gcctabopt
+@item -mabi=@var{name}
+@opindex mabi
+Generate code for the specified ABI@.  Permissible values are: @samp{apcs-gnu},
+@samp{atpcs}, @samp{aapcs}, @samp{aapcs-linux} and @samp{iwmmxt}.
+
+@item -mapcs-frame
+@opindex mapcs-frame
+Generate a stack frame that is compliant with the ARM Procedure Call
+Standard for all functions, even if this is not strictly necessary for
+correct execution of the code.  Specifying @option{-fomit-frame-pointer}
+with this option will cause the stack frames not to be generated for
+leaf functions.  The default is @option{-mno-apcs-frame}.
+
+@item -mapcs
+@opindex mapcs
+This is a synonym for @option{-mapcs-frame}.
+
+@ignore
+@c not currently implemented
+@item -mapcs-stack-check
+@opindex mapcs-stack-check
+Generate code to check the amount of stack space available upon entry to
+every function (that actually uses some stack space).  If there is
+insufficient space available then either the function
+@samp{__rt_stkovf_split_small} or @samp{__rt_stkovf_split_big} will be
+called, depending upon the amount of stack space required.  The run time
+system is required to provide these functions.  The default is
+@option{-mno-apcs-stack-check}, since this produces smaller code.
+
+@c not currently implemented
+@item -mapcs-float
+@opindex mapcs-float
+Pass floating point arguments using the float point registers.  This is
+one of the variants of the APCS@.  This option is recommended if the
+target hardware has a floating point unit or if a lot of floating point
+arithmetic is going to be performed by the code.  The default is
+@option{-mno-apcs-float}, since integer only code is slightly increased in
+size if @option{-mapcs-float} is used.
+
+@c not currently implemented
+@item -mapcs-reentrant
+@opindex mapcs-reentrant
+Generate reentrant, position independent code.  The default is
+@option{-mno-apcs-reentrant}.
+@end ignore
+
+@item -mthumb-interwork
+@opindex mthumb-interwork
+Generate code which supports calling between the ARM and Thumb
+instruction sets.  Without this option the two instruction sets cannot
+be reliably used inside one program.  The default is
+@option{-mno-thumb-interwork}, since slightly larger code is generated
+when @option{-mthumb-interwork} is specified.
+
+@item -mno-sched-prolog
+@opindex mno-sched-prolog
+Prevent the reordering of instructions in the function prolog, or the
+merging of those instruction with the instructions in the function's
+body.  This means that all functions will start with a recognizable set
+of instructions (or in fact one of a choice from a small set of
+different function prologues), and this information can be used to
+locate the start if functions inside an executable piece of code.  The
+default is @option{-msched-prolog}.
+
+@item -mfloat-abi=@var{name}
+@opindex mfloat-abi
+Specifies which floating-point ABI to use.  Permissible values
+are: @samp{soft}, @samp{softfp} and @samp{hard}.
+
+Specifying @samp{soft} causes GCC to generate output containing 
+library calls for floating-point operations.
+@samp{softfp} allows the generation of code using hardware floating-point 
+instructions, but still uses the soft-float calling conventions.  
+@samp{hard} allows generation of floating-point instructions 
+and uses FPU-specific calling conventions.
+
+Using @option{-mfloat-abi=hard} with VFP coprocessors is not supported.
+Use @option{-mfloat-abi=softfp} with the appropriate @option{-mfpu} option
+to allow the compiler to generate code that makes use of the hardware
+floating-point capabilities for these CPUs.
+
+The default depends on the specific target configuration.  Note that
+the hard-float and soft-float ABIs are not link-compatible; you must
+compile your entire program with the same ABI, and link with a
+compatible set of libraries.
+
+@item -mhard-float
+@opindex mhard-float
+Equivalent to @option{-mfloat-abi=hard}.
+
+@item -msoft-float
+@opindex msoft-float
+Equivalent to @option{-mfloat-abi=soft}.
+
+@item -mlittle-endian
+@opindex mlittle-endian
+Generate code for a processor running in little-endian mode.  This is
+the default for all standard configurations.
+
+@item -mbig-endian
+@opindex mbig-endian
+Generate code for a processor running in big-endian mode; the default is
+to compile code for a little-endian processor.
+
+@item -mwords-little-endian
+@opindex mwords-little-endian
+This option only applies when generating code for big-endian processors.
+Generate code for a little-endian word order but a big-endian byte
+order.  That is, a byte order of the form @samp{32107654}.  Note: this
+option should only be used if you require compatibility with code for
+big-endian ARM processors generated by versions of the compiler prior to
+2.8.
+
+@item -mcpu=@var{name}
+@opindex mcpu
+This specifies the name of the target ARM processor.  GCC uses this name
+to determine what kind of instructions it can emit when generating
+assembly code.  Permissible names are: @samp{arm2}, @samp{arm250},
+@samp{arm3}, @samp{arm6}, @samp{arm60}, @samp{arm600}, @samp{arm610},
+@samp{arm620}, @samp{arm7}, @samp{arm7m}, @samp{arm7d}, @samp{arm7dm},
+@samp{arm7di}, @samp{arm7dmi}, @samp{arm70}, @samp{arm700},
+@samp{arm700i}, @samp{arm710}, @samp{arm710c}, @samp{arm7100},
+@samp{arm720},
+@samp{arm7500}, @samp{arm7500fe}, @samp{arm7tdmi}, @samp{arm7tdmi-s},
+@samp{arm710t}, @samp{arm720t}, @samp{arm740t},
+@samp{strongarm}, @samp{strongarm110}, @samp{strongarm1100},
+@samp{strongarm1110},
+@samp{arm8}, @samp{arm810}, @samp{arm9}, @samp{arm9e}, @samp{arm920},
+@samp{arm920t}, @samp{arm922t}, @samp{arm946e-s}, @samp{arm966e-s},
+@samp{arm968e-s}, @samp{arm926ej-s}, @samp{arm940t}, @samp{arm9tdmi},
+@samp{arm10tdmi}, @samp{arm1020t}, @samp{arm1026ej-s},
+@samp{arm10e}, @samp{arm1020e}, @samp{arm1022e},
+@samp{arm1136j-s}, @samp{arm1136jf-s}, @samp{mpcore}, @samp{mpcorenovfp},
+@samp{arm1156t2-s}, @samp{arm1176jz-s}, @samp{arm1176jzf-s},
+@samp{cortex-a8}, @samp{cortex-a9},
+@samp{cortex-r4}, @samp{cortex-r4f}, @samp{cortex-m3},
+@samp{cortex-m1},
+@samp{xscale}, @samp{iwmmxt}, @samp{iwmmxt2}, @samp{ep9312}.
+
+@item -mtune=@var{name}
+@opindex mtune
+This option is very similar to the @option{-mcpu=} option, except that
+instead of specifying the actual target processor type, and hence
+restricting which instructions can be used, it specifies that GCC should
+tune the performance of the code as if the target were of the type
+specified in this option, but still choosing the instructions that it
+will generate based on the cpu specified by a @option{-mcpu=} option.
+For some ARM implementations better performance can be obtained by using
+this option.
+
+@item -march=@var{name}
+@opindex march
+This specifies the name of the target ARM architecture.  GCC uses this
+name to determine what kind of instructions it can emit when generating
+assembly code.  This option can be used in conjunction with or instead
+of the @option{-mcpu=} option.  Permissible names are: @samp{armv2},
+@samp{armv2a}, @samp{armv3}, @samp{armv3m}, @samp{armv4}, @samp{armv4t},
+@samp{armv5}, @samp{armv5t}, @samp{armv5e}, @samp{armv5te},
+@samp{armv6}, @samp{armv6j},
+@samp{armv6t2}, @samp{armv6z}, @samp{armv6zk}, @samp{armv6-m},
+@samp{armv7}, @samp{armv7-a}, @samp{armv7-r}, @samp{armv7-m},
+@samp{iwmmxt}, @samp{iwmmxt2}, @samp{ep9312}.
+
+@item -mfpu=@var{name}
+@itemx -mfpe=@var{number}
+@itemx -mfp=@var{number}
+@opindex mfpu
+@opindex mfpe
+@opindex mfp
+This specifies what floating point hardware (or hardware emulation) is
+available on the target.  Permissible names are: @samp{fpa}, @samp{fpe2},
+@samp{fpe3}, @samp{maverick}, @samp{vfp}, @samp{vfpv3}, @samp{vfpv3-d16} and
+@samp{neon}.  @option{-mfp} and @option{-mfpe}
+are synonyms for @option{-mfpu}=@samp{fpe}@var{number}, for compatibility
+with older versions of GCC@.
+
+If @option{-msoft-float} is specified this specifies the format of
+floating point values.
+
+@item -mstructure-size-boundary=@var{n}
+@opindex mstructure-size-boundary
+The size of all structures and unions will be rounded up to a multiple
+of the number of bits set by this option.  Permissible values are 8, 32
+and 64.  The default value varies for different toolchains.  For the COFF
+targeted toolchain the default value is 8.  A value of 64 is only allowed
+if the underlying ABI supports it.
+
+Specifying the larger number can produce faster, more efficient code, but
+can also increase the size of the program.  Different values are potentially
+incompatible.  Code compiled with one value cannot necessarily expect to
+work with code or libraries compiled with another value, if they exchange
+information using structures or unions.
+
+@item -mabort-on-noreturn
+@opindex mabort-on-noreturn
+Generate a call to the function @code{abort} at the end of a
+@code{noreturn} function.  It will be executed if the function tries to
+return.
+
+@item -mlong-calls
+@itemx -mno-long-calls
+@opindex mlong-calls
+@opindex mno-long-calls
+Tells the compiler to perform function calls by first loading the
+address of the function into a register and then performing a subroutine
+call on this register.  This switch is needed if the target function
+will lie outside of the 64 megabyte addressing range of the offset based
+version of subroutine call instruction.
+
+Even if this switch is enabled, not all function calls will be turned
+into long calls.  The heuristic is that static functions, functions
+which have the @samp{short-call} attribute, functions that are inside
+the scope of a @samp{#pragma no_long_calls} directive and functions whose
+definitions have already been compiled within the current compilation
+unit, will not be turned into long calls.  The exception to this rule is
+that weak function definitions, functions with the @samp{long-call}
+attribute or the @samp{section} attribute, and functions that are within
+the scope of a @samp{#pragma long_calls} directive, will always be
+turned into long calls.
+
+This feature is not enabled by default.  Specifying
+@option{-mno-long-calls} will restore the default behavior, as will
+placing the function calls within the scope of a @samp{#pragma
+long_calls_off} directive.  Note these switches have no effect on how
+the compiler generates code to handle function calls via function
+pointers.
+
+@item -msingle-pic-base
+@opindex msingle-pic-base
+Treat the register used for PIC addressing as read-only, rather than
+loading it in the prologue for each function.  The run-time system is
+responsible for initializing this register with an appropriate value
+before execution begins.
+
+@item -mpic-register=@var{reg}
+@opindex mpic-register
+Specify the register to be used for PIC addressing.  The default is R10
+unless stack-checking is enabled, when R9 is used.
+
+@item -mcirrus-fix-invalid-insns
+@opindex mcirrus-fix-invalid-insns
+@opindex mno-cirrus-fix-invalid-insns
+Insert NOPs into the instruction stream to in order to work around
+problems with invalid Maverick instruction combinations.  This option
+is only valid if the @option{-mcpu=ep9312} option has been used to
+enable generation of instructions for the Cirrus Maverick floating
+point co-processor.  This option is not enabled by default, since the
+problem is only present in older Maverick implementations.  The default
+can be re-enabled by use of the @option{-mno-cirrus-fix-invalid-insns}
+switch.
+
+@item -mpoke-function-name
+@opindex mpoke-function-name
+Write the name of each function into the text section, directly
+preceding the function prologue.  The generated code is similar to this:
+
+@smallexample
+     t0
+         .ascii "arm_poke_function_name", 0
+         .align
+     t1
+         .word 0xff000000 + (t1 - t0)
+     arm_poke_function_name
+         mov     ip, sp
+         stmfd   sp!, @{fp, ip, lr, pc@}
+         sub     fp, ip, #4
+@end smallexample
+
+When performing a stack backtrace, code can inspect the value of
+@code{pc} stored at @code{fp + 0}.  If the trace function then looks at
+location @code{pc - 12} and the top 8 bits are set, then we know that
+there is a function name embedded immediately preceding this location
+and has length @code{((pc[-3]) & 0xff000000)}.
+
+@item -mthumb
+@opindex mthumb
+Generate code for the Thumb instruction set.  The default is to
+use the 32-bit ARM instruction set.
+This option automatically enables either 16-bit Thumb-1 or
+mixed 16/32-bit Thumb-2 instructions based on the @option{-mcpu=@var{name}}
+and @option{-march=@var{name}} options.
+
+@item -mtpcs-frame
+@opindex mtpcs-frame
+Generate a stack frame that is compliant with the Thumb Procedure Call
+Standard for all non-leaf functions.  (A leaf function is one that does
+not call any other functions.)  The default is @option{-mno-tpcs-frame}.
+
+@item -mtpcs-leaf-frame
+@opindex mtpcs-leaf-frame
+Generate a stack frame that is compliant with the Thumb Procedure Call
+Standard for all leaf functions.  (A leaf function is one that does
+not call any other functions.)  The default is @option{-mno-apcs-leaf-frame}.
+
+@item -mcallee-super-interworking
+@opindex mcallee-super-interworking
+Gives all externally visible functions in the file being compiled an ARM
+instruction set header which switches to Thumb mode before executing the
+rest of the function.  This allows these functions to be called from
+non-interworking code.
+
+@item -mcaller-super-interworking
+@opindex mcaller-super-interworking
+Allows calls via function pointers (including virtual functions) to
+execute correctly regardless of whether the target code has been
+compiled for interworking or not.  There is a small overhead in the cost
+of executing a function pointer if this option is enabled.
+
+@item -mtp=@var{name}
+@opindex mtp
+Specify the access model for the thread local storage pointer.  The valid
+models are @option{soft}, which generates calls to @code{__aeabi_read_tp},
+@option{cp15}, which fetches the thread pointer from @code{cp15} directly
+(supported in the arm6k architecture), and @option{auto}, which uses the
+best available method for the selected processor.  The default setting is
+@option{auto}.
+
+@item -mword-relocations
+@opindex mword-relocations
+Only generate absolute relocations on word sized values (i.e. R_ARM_ABS32).
+This is enabled by default on targets (uClinux, SymbianOS) where the runtime
+loader imposes this restriction, and when @option{-fpic} or @option{-fPIC}
+is specified.
+
+@end table
+
+@node AVR Options
+@subsection AVR Options
+@cindex AVR Options
+
+These options are defined for AVR implementations:
+
+@table @gcctabopt
+@item -mmcu=@var{mcu}
+@opindex mmcu
+Specify ATMEL AVR instruction set or MCU type.
+
+Instruction set avr1 is for the minimal AVR core, not supported by the C
+compiler, only for assembler programs (MCU types: at90s1200, attiny10,
+attiny11, attiny12, attiny15, attiny28).
+
+Instruction set avr2 (default) is for the classic AVR core with up to
+8K program memory space (MCU types: at90s2313, at90s2323, attiny22,
+at90s2333, at90s2343, at90s4414, at90s4433, at90s4434, at90s8515,
+at90c8534, at90s8535).
+
+Instruction set avr3 is for the classic AVR core with up to 128K program
+memory space (MCU types: atmega103, atmega603, at43usb320, at76c711).
+
+Instruction set avr4 is for the enhanced AVR core with up to 8K program
+memory space (MCU types: atmega8, atmega83, atmega85).
+
+Instruction set avr5 is for the enhanced AVR core with up to 128K program
+memory space (MCU types: atmega16, atmega161, atmega163, atmega32, atmega323,
+atmega64, atmega128, at43usb355, at94k).
+
+@item -msize
+@opindex msize
+Output instruction sizes to the asm file.
+
+@item -mno-interrupts
+@opindex mno-interrupts
+Generated code is not compatible with hardware interrupts.
+Code size will be smaller.
+
+@item -mcall-prologues
+@opindex mcall-prologues
+Functions prologues/epilogues expanded as call to appropriate
+subroutines.  Code size will be smaller.
+
+@item -mno-tablejump
+@opindex mno-tablejump
+Do not generate tablejump insns which sometimes increase code size.
+The option is now deprecated in favor of the equivalent 
+@option{-fno-jump-tables}
+
+@item -mtiny-stack
+@opindex mtiny-stack
+Change only the low 8 bits of the stack pointer.
+
+@item -mint8
+@opindex mint8
+Assume int to be 8 bit integer.  This affects the sizes of all types: A
+char will be 1 byte, an int will be 1 byte, an long will be 2 bytes
+and long long will be 4 bytes.  Please note that this option does not
+comply to the C standards, but it will provide you with smaller code
+size.
+@end table
+
+@node Blackfin Options
+@subsection Blackfin Options
+@cindex Blackfin Options
+
+@table @gcctabopt
+@item -mcpu=@var{cpu}@r{[}-@var{sirevision}@r{]}
+@opindex mcpu=
+Specifies the name of the target Blackfin processor.  Currently, @var{cpu}
+can be one of @samp{bf512}, @samp{bf514}, @samp{bf516}, @samp{bf518},
+@samp{bf522}, @samp{bf523}, @samp{bf524}, @samp{bf525}, @samp{bf526},
+@samp{bf527}, @samp{bf531}, @samp{bf532}, @samp{bf533},
+@samp{bf534}, @samp{bf536}, @samp{bf537}, @samp{bf538}, @samp{bf539},
+@samp{bf542}, @samp{bf544}, @samp{bf547}, @samp{bf548}, @samp{bf549},
+@samp{bf561}.
+The optional @var{sirevision} specifies the silicon revision of the target
+Blackfin processor.  Any workarounds available for the targeted silicon revision
+will be enabled.  If @var{sirevision} is @samp{none}, no workarounds are enabled.
+If @var{sirevision} is @samp{any}, all workarounds for the targeted processor
+will be enabled.  The @code{__SILICON_REVISION__} macro is defined to two
+hexadecimal digits representing the major and minor numbers in the silicon
+revision.  If @var{sirevision} is @samp{none}, the @code{__SILICON_REVISION__}
+is not defined.  If @var{sirevision} is @samp{any}, the
+@code{__SILICON_REVISION__} is defined to be @code{0xffff}.
+If this optional @var{sirevision} is not used, GCC assumes the latest known
+silicon revision of the targeted Blackfin processor.
+
+Support for @samp{bf561} is incomplete.  For @samp{bf561},
+Only the processor macro is defined.
+Without this option, @samp{bf532} is used as the processor by default.
+The corresponding predefined processor macros for @var{cpu} is to
+be defined.  And for @samp{bfin-elf} toolchain, this causes the hardware BSP
+provided by libgloss to be linked in if @option{-msim} is not given.
+
+@item -msim
+@opindex msim
+Specifies that the program will be run on the simulator.  This causes
+the simulator BSP provided by libgloss to be linked in.  This option
+has effect only for @samp{bfin-elf} toolchain.
+Certain other options, such as @option{-mid-shared-library} and
+@option{-mfdpic}, imply @option{-msim}.
+
+@item -momit-leaf-frame-pointer
+@opindex momit-leaf-frame-pointer
+Don't keep the frame pointer in a register for leaf functions.  This
+avoids the instructions to save, set up and restore frame pointers and
+makes an extra register available in leaf functions.  The option
+@option{-fomit-frame-pointer} removes the frame pointer for all functions
+which might make debugging harder.
+
+@item -mspecld-anomaly
+@opindex mspecld-anomaly
+When enabled, the compiler will ensure that the generated code does not
+contain speculative loads after jump instructions. If this option is used,
+@code{__WORKAROUND_SPECULATIVE_LOADS} is defined.
+
+@item -mno-specld-anomaly
+@opindex mno-specld-anomaly
+Don't generate extra code to prevent speculative loads from occurring.
+
+@item -mcsync-anomaly
+@opindex mcsync-anomaly
+When enabled, the compiler will ensure that the generated code does not
+contain CSYNC or SSYNC instructions too soon after conditional branches.
+If this option is used, @code{__WORKAROUND_SPECULATIVE_SYNCS} is defined.
+
+@item -mno-csync-anomaly
+@opindex mno-csync-anomaly
+Don't generate extra code to prevent CSYNC or SSYNC instructions from
+occurring too soon after a conditional branch.
+
+@item -mlow-64k
+@opindex mlow-64k
+When enabled, the compiler is free to take advantage of the knowledge that
+the entire program fits into the low 64k of memory.
+
+@item -mno-low-64k
+@opindex mno-low-64k
+Assume that the program is arbitrarily large.  This is the default.
+
+@item -mstack-check-l1
+@opindex mstack-check-l1
+Do stack checking using information placed into L1 scratchpad memory by the
+uClinux kernel.
+
+@item -mid-shared-library
+@opindex mid-shared-library
+Generate code that supports shared libraries via the library ID method.
+This allows for execute in place and shared libraries in an environment
+without virtual memory management.  This option implies @option{-fPIC}.
+With a @samp{bfin-elf} target, this option implies @option{-msim}.
+
+@item -mno-id-shared-library
+@opindex mno-id-shared-library
+Generate code that doesn't assume ID based shared libraries are being used.
+This is the default.
+
+@item -mleaf-id-shared-library
+@opindex mleaf-id-shared-library
+Generate code that supports shared libraries via the library ID method,
+but assumes that this library or executable won't link against any other
+ID shared libraries.  That allows the compiler to use faster code for jumps
+and calls.
+
+@item -mno-leaf-id-shared-library
+@opindex mno-leaf-id-shared-library
+Do not assume that the code being compiled won't link against any ID shared
+libraries.  Slower code will be generated for jump and call insns.
+
+@item -mshared-library-id=n
+@opindex mshared-library-id
+Specified the identification number of the ID based shared library being
+compiled.  Specifying a value of 0 will generate more compact code, specifying
+other values will force the allocation of that number to the current
+library but is no more space or time efficient than omitting this option.
+
+@item -msep-data
+@opindex msep-data
+Generate code that allows the data segment to be located in a different
+area of memory from the text segment.  This allows for execute in place in
+an environment without virtual memory management by eliminating relocations
+against the text section.
+
+@item -mno-sep-data
+@opindex mno-sep-data
+Generate code that assumes that the data segment follows the text segment.
+This is the default.
+
+@item -mlong-calls
+@itemx -mno-long-calls
+@opindex mlong-calls
+@opindex mno-long-calls
+Tells the compiler to perform function calls by first loading the
+address of the function into a register and then performing a subroutine
+call on this register.  This switch is needed if the target function
+will lie outside of the 24 bit addressing range of the offset based
+version of subroutine call instruction.
+
+This feature is not enabled by default.  Specifying
+@option{-mno-long-calls} will restore the default behavior.  Note these
+switches have no effect on how the compiler generates code to handle
+function calls via function pointers.
+
+@item -mfast-fp
+@opindex mfast-fp
+Link with the fast floating-point library. This library relaxes some of
+the IEEE floating-point standard's rules for checking inputs against
+Not-a-Number (NAN), in the interest of performance.
+
+@item -minline-plt
+@opindex minline-plt
+Enable inlining of PLT entries in function calls to functions that are
+not known to bind locally.  It has no effect without @option{-mfdpic}.
+
+@item -mmulticore
+@opindex mmulticore
+Build standalone application for multicore Blackfin processor. Proper
+start files and link scripts will be used to support multicore.
+This option defines @code{__BFIN_MULTICORE}. It can only be used with
+@option{-mcpu=bf561@r{[}-@var{sirevision}@r{]}}. It can be used with
+@option{-mcorea} or @option{-mcoreb}. If it's used without
+@option{-mcorea} or @option{-mcoreb}, single application/dual core
+programming model is used. In this model, the main function of Core B
+should be named as coreb_main. If it's used with @option{-mcorea} or
+@option{-mcoreb}, one application per core programming model is used.
+If this option is not used, single core application programming
+model is used.
+
+@item -mcorea
+@opindex mcorea
+Build standalone application for Core A of BF561 when using
+one application per core programming model. Proper start files
+and link scripts will be used to support Core A. This option
+defines @code{__BFIN_COREA}. It must be used with @option{-mmulticore}.
+
+@item -mcoreb
+@opindex mcoreb
+Build standalone application for Core B of BF561 when using
+one application per core programming model. Proper start files
+and link scripts will be used to support Core B. This option
+defines @code{__BFIN_COREB}. When this option is used, coreb_main
+should be used instead of main. It must be used with
+@option{-mmulticore}. 
+
+@item -msdram
+@opindex msdram
+Build standalone application for SDRAM. Proper start files and
+link scripts will be used to put the application into SDRAM.
+Loader should initialize SDRAM before loading the application
+into SDRAM. This option defines @code{__BFIN_SDRAM}.
+
+@item -micplb
+@opindex micplb
+Assume that ICPLBs are enabled at runtime.  This has an effect on certain
+anomaly workarounds.  For Linux targets, the default is to assume ICPLBs
+are enabled; for standalone applications the default is off.
+@end table
+
+@node CRIS Options
+@subsection CRIS Options
+@cindex CRIS Options
+
+These options are defined specifically for the CRIS ports.
+
+@table @gcctabopt
+@item -march=@var{architecture-type}
+@itemx -mcpu=@var{architecture-type}
+@opindex march
+@opindex mcpu
+Generate code for the specified architecture.  The choices for
+@var{architecture-type} are @samp{v3}, @samp{v8} and @samp{v10} for
+respectively ETRAX@w{ }4, ETRAX@w{ }100, and ETRAX@w{ }100@w{ }LX@.
+Default is @samp{v0} except for cris-axis-linux-gnu, where the default is
+@samp{v10}.
+
+@item -mtune=@var{architecture-type}
+@opindex mtune
+Tune to @var{architecture-type} everything applicable about the generated
+code, except for the ABI and the set of available instructions.  The
+choices for @var{architecture-type} are the same as for
+@option{-march=@var{architecture-type}}.
+
+@item -mmax-stack-frame=@var{n}
+@opindex mmax-stack-frame
+Warn when the stack frame of a function exceeds @var{n} bytes.
+
+@item -metrax4
+@itemx -metrax100
+@opindex metrax4
+@opindex metrax100
+The options @option{-metrax4} and @option{-metrax100} are synonyms for
+@option{-march=v3} and @option{-march=v8} respectively.
+
+@item -mmul-bug-workaround
+@itemx -mno-mul-bug-workaround
+@opindex mmul-bug-workaround
+@opindex mno-mul-bug-workaround
+Work around a bug in the @code{muls} and @code{mulu} instructions for CPU
+models where it applies.  This option is active by default.
+
+@item -mpdebug
+@opindex mpdebug
+Enable CRIS-specific verbose debug-related information in the assembly
+code.  This option also has the effect to turn off the @samp{#NO_APP}
+formatted-code indicator to the assembler at the beginning of the
+assembly file.
+
+@item -mcc-init
+@opindex mcc-init
+Do not use condition-code results from previous instruction; always emit
+compare and test instructions before use of condition codes.
+
+@item -mno-side-effects
+@opindex mno-side-effects
+Do not emit instructions with side-effects in addressing modes other than
+post-increment.
+
+@item -mstack-align
+@itemx -mno-stack-align
+@itemx -mdata-align
+@itemx -mno-data-align
+@itemx -mconst-align
+@itemx -mno-const-align
+@opindex mstack-align
+@opindex mno-stack-align
+@opindex mdata-align
+@opindex mno-data-align
+@opindex mconst-align
+@opindex mno-const-align
+These options (no-options) arranges (eliminate arrangements) for the
+stack-frame, individual data and constants to be aligned for the maximum
+single data access size for the chosen CPU model.  The default is to
+arrange for 32-bit alignment.  ABI details such as structure layout are
+not affected by these options.
+
+@item -m32-bit
+@itemx -m16-bit
+@itemx -m8-bit
+@opindex m32-bit
+@opindex m16-bit
+@opindex m8-bit
+Similar to the stack- data- and const-align options above, these options
+arrange for stack-frame, writable data and constants to all be 32-bit,
+16-bit or 8-bit aligned.  The default is 32-bit alignment.
+
+@item -mno-prologue-epilogue
+@itemx -mprologue-epilogue
+@opindex mno-prologue-epilogue
+@opindex mprologue-epilogue
+With @option{-mno-prologue-epilogue}, the normal function prologue and
+epilogue that sets up the stack-frame are omitted and no return
+instructions or return sequences are generated in the code.  Use this
+option only together with visual inspection of the compiled code: no
+warnings or errors are generated when call-saved registers must be saved,
+or storage for local variable needs to be allocated.
+
+@item -mno-gotplt
+@itemx -mgotplt
+@opindex mno-gotplt
+@opindex mgotplt
+With @option{-fpic} and @option{-fPIC}, don't generate (do generate)
+instruction sequences that load addresses for functions from the PLT part
+of the GOT rather than (traditional on other architectures) calls to the
+PLT@.  The default is @option{-mgotplt}.
+
+@item -melf
+@opindex melf
+Legacy no-op option only recognized with the cris-axis-elf and
+cris-axis-linux-gnu targets.
+
+@item -mlinux
+@opindex mlinux
+Legacy no-op option only recognized with the cris-axis-linux-gnu target.
+
+@item -sim
+@opindex sim
+This option, recognized for the cris-axis-elf arranges
+to link with input-output functions from a simulator library.  Code,
+initialized data and zero-initialized data are allocated consecutively.
+
+@item -sim2
+@opindex sim2
+Like @option{-sim}, but pass linker options to locate initialized data at
+0x40000000 and zero-initialized data at 0x80000000.
+@end table
+
+@node CRX Options
+@subsection CRX Options
+@cindex CRX Options
+
+These options are defined specifically for the CRX ports.
+
+@table @gcctabopt
+
+@item -mmac
+@opindex mmac
+Enable the use of multiply-accumulate instructions. Disabled by default.
+
+@item -mpush-args
+@opindex mpush-args
+Push instructions will be used to pass outgoing arguments when functions
+are called. Enabled by default.
+@end table
+
+@node Darwin Options
+@subsection Darwin Options
+@cindex Darwin options
+
+These options are defined for all architectures running the Darwin operating
+system.
+
+FSF GCC on Darwin does not create ``fat'' object files; it will create
+an object file for the single architecture that it was built to
+target.  Apple's GCC on Darwin does create ``fat'' files if multiple
+@option{-arch} options are used; it does so by running the compiler or
+linker multiple times and joining the results together with
+@file{lipo}.
+
+The subtype of the file created (like @samp{ppc7400} or @samp{ppc970} or
+@samp{i686}) is determined by the flags that specify the ISA
+that GCC is targetting, like @option{-mcpu} or @option{-march}.  The
+@option{-force_cpusubtype_ALL} option can be used to override this.
+
+The Darwin tools vary in their behavior when presented with an ISA
+mismatch.  The assembler, @file{as}, will only permit instructions to
+be used that are valid for the subtype of the file it is generating,
+so you cannot put 64-bit instructions in an @samp{ppc750} object file.
+The linker for shared libraries, @file{/usr/bin/libtool}, will fail
+and print an error if asked to create a shared library with a less
+restrictive subtype than its input files (for instance, trying to put
+a @samp{ppc970} object file in a @samp{ppc7400} library).  The linker
+for executables, @file{ld}, will quietly give the executable the most
+restrictive subtype of any of its input files.
+
+@table @gcctabopt
+@item -F@var{dir}
+@opindex F
+Add the framework directory @var{dir} to the head of the list of
+directories to be searched for header files.  These directories are
+interleaved with those specified by @option{-I} options and are
+scanned in a left-to-right order.
+
+A framework directory is a directory with frameworks in it.  A
+framework is a directory with a @samp{"Headers"} and/or
+@samp{"PrivateHeaders"} directory contained directly in it that ends
+in @samp{".framework"}.  The name of a framework is the name of this
+directory excluding the @samp{".framework"}.  Headers associated with
+the framework are found in one of those two directories, with
+@samp{"Headers"} being searched first.  A subframework is a framework
+directory that is in a framework's @samp{"Frameworks"} directory.
+Includes of subframework headers can only appear in a header of a
+framework that contains the subframework, or in a sibling subframework
+header.  Two subframeworks are siblings if they occur in the same
+framework.  A subframework should not have the same name as a
+framework, a warning will be issued if this is violated.  Currently a
+subframework cannot have subframeworks, in the future, the mechanism
+may be extended to support this.  The standard frameworks can be found
+in @samp{"/System/Library/Frameworks"} and
+@samp{"/Library/Frameworks"}.  An example include looks like
+@code{#include <Framework/header.h>}, where @samp{Framework} denotes
+the name of the framework and header.h is found in the
+@samp{"PrivateHeaders"} or @samp{"Headers"} directory.
+
+@item -iframework@var{dir}
+@opindex iframework
+Like @option{-F} except the directory is a treated as a system
+directory.  The main difference between this @option{-iframework} and
+@option{-F} is that with @option{-iframework} the compiler does not
+warn about constructs contained within header files found via
+@var{dir}.  This option is valid only for the C family of languages.
+
+@item -gused
+@opindex gused
+Emit debugging information for symbols that are used.  For STABS
+debugging format, this enables @option{-feliminate-unused-debug-symbols}.
+This is by default ON@.
+
+@item -gfull
+@opindex gfull
+Emit debugging information for all symbols and types.
+
+@item -mmacosx-version-min=@var{version}
+The earliest version of MacOS X that this executable will run on
+is @var{version}.  Typical values of @var{version} include @code{10.1},
+@code{10.2}, and @code{10.3.9}.
+
+If the compiler was built to use the system's headers by default,
+then the default for this option is the system version on which the
+compiler is running, otherwise the default is to make choices which
+are compatible with as many systems and code bases as possible.
+
+@item -mkernel
+@opindex mkernel
+Enable kernel development mode.  The @option{-mkernel} option sets
+@option{-static}, @option{-fno-common}, @option{-fno-cxa-atexit},
+@option{-fno-exceptions}, @option{-fno-non-call-exceptions},
+@option{-fapple-kext}, @option{-fno-weak} and @option{-fno-rtti} where
+applicable.  This mode also sets @option{-mno-altivec},
+@option{-msoft-float}, @option{-fno-builtin} and
+@option{-mlong-branch} for PowerPC targets.
+
+@item -mone-byte-bool
+@opindex mone-byte-bool
+Override the defaults for @samp{bool} so that @samp{sizeof(bool)==1}.
+By default @samp{sizeof(bool)} is @samp{4} when compiling for
+Darwin/PowerPC and @samp{1} when compiling for Darwin/x86, so this
+option has no effect on x86.
+
+@strong{Warning:} The @option{-mone-byte-bool} switch causes GCC
+to generate code that is not binary compatible with code generated
+without that switch.  Using this switch may require recompiling all
+other modules in a program, including system libraries.  Use this
+switch to conform to a non-default data model.
+
+@item -mfix-and-continue
+@itemx -ffix-and-continue
+@itemx -findirect-data
+@opindex mfix-and-continue
+@opindex ffix-and-continue
+@opindex findirect-data
+Generate code suitable for fast turn around development.  Needed to
+enable gdb to dynamically load @code{.o} files into already running
+programs.  @option{-findirect-data} and @option{-ffix-and-continue}
+are provided for backwards compatibility.
+
+@item -all_load
+@opindex all_load
+Loads all members of static archive libraries.
+See man ld(1) for more information.
+
+@item -arch_errors_fatal
+@opindex arch_errors_fatal
+Cause the errors having to do with files that have the wrong architecture
+to be fatal.
+
+@item -bind_at_load
+@opindex bind_at_load
+Causes the output file to be marked such that the dynamic linker will
+bind all undefined references when the file is loaded or launched.
+
+@item -bundle
+@opindex bundle
+Produce a Mach-o bundle format file.
+See man ld(1) for more information.
+
+@item -bundle_loader @var{executable}
+@opindex bundle_loader
+This option specifies the @var{executable} that will be loading the build
+output file being linked.  See man ld(1) for more information.
+
+@item -dynamiclib
+@opindex dynamiclib
+When passed this option, GCC will produce a dynamic library instead of
+an executable when linking, using the Darwin @file{libtool} command.
+
+@item -force_cpusubtype_ALL
+@opindex force_cpusubtype_ALL
+This causes GCC's output file to have the @var{ALL} subtype, instead of
+one controlled by the @option{-mcpu} or @option{-march} option.
+
+@item -allowable_client  @var{client_name}
+@itemx -client_name
+@itemx -compatibility_version
+@itemx -current_version
+@itemx -dead_strip
+@itemx -dependency-file
+@itemx -dylib_file
+@itemx -dylinker_install_name
+@itemx -dynamic
+@itemx -exported_symbols_list
+@itemx -filelist
+@itemx -flat_namespace
+@itemx -force_flat_namespace
+@itemx -headerpad_max_install_names
+@itemx -image_base
+@itemx -init
+@itemx -install_name
+@itemx -keep_private_externs
+@itemx -multi_module
+@itemx -multiply_defined
+@itemx -multiply_defined_unused
+@itemx -noall_load
+@itemx -no_dead_strip_inits_and_terms
+@itemx -nofixprebinding
+@itemx -nomultidefs
+@itemx -noprebind
+@itemx -noseglinkedit
+@itemx -pagezero_size
+@itemx -prebind
+@itemx -prebind_all_twolevel_modules
+@itemx -private_bundle
+@itemx -read_only_relocs
+@itemx -sectalign
+@itemx -sectobjectsymbols
+@itemx -whyload
+@itemx -seg1addr
+@itemx -sectcreate
+@itemx -sectobjectsymbols
+@itemx -sectorder
+@itemx -segaddr
+@itemx -segs_read_only_addr
+@itemx -segs_read_write_addr
+@itemx -seg_addr_table
+@itemx -seg_addr_table_filename
+@itemx -seglinkedit
+@itemx -segprot
+@itemx -segs_read_only_addr
+@itemx -segs_read_write_addr
+@itemx -single_module
+@itemx -static
+@itemx -sub_library
+@itemx -sub_umbrella
+@itemx -twolevel_namespace
+@itemx -umbrella
+@itemx -undefined
+@itemx -unexported_symbols_list
+@itemx -weak_reference_mismatches
+@itemx -whatsloaded
+@opindex allowable_client
+@opindex client_name
+@opindex compatibility_version
+@opindex current_version
+@opindex dead_strip
+@opindex dependency-file
+@opindex dylib_file
+@opindex dylinker_install_name
+@opindex dynamic
+@opindex exported_symbols_list
+@opindex filelist
+@opindex flat_namespace
+@opindex force_flat_namespace
+@opindex headerpad_max_install_names
+@opindex image_base
+@opindex init
+@opindex install_name
+@opindex keep_private_externs
+@opindex multi_module
+@opindex multiply_defined
+@opindex multiply_defined_unused
+@opindex noall_load
+@opindex no_dead_strip_inits_and_terms
+@opindex nofixprebinding
+@opindex nomultidefs
+@opindex noprebind
+@opindex noseglinkedit
+@opindex pagezero_size
+@opindex prebind
+@opindex prebind_all_twolevel_modules
+@opindex private_bundle
+@opindex read_only_relocs
+@opindex sectalign
+@opindex sectobjectsymbols
+@opindex whyload
+@opindex seg1addr
+@opindex sectcreate
+@opindex sectobjectsymbols
+@opindex sectorder
+@opindex segaddr
+@opindex segs_read_only_addr
+@opindex segs_read_write_addr
+@opindex seg_addr_table
+@opindex seg_addr_table_filename
+@opindex seglinkedit
+@opindex segprot
+@opindex segs_read_only_addr
+@opindex segs_read_write_addr
+@opindex single_module
+@opindex static
+@opindex sub_library
+@opindex sub_umbrella
+@opindex twolevel_namespace
+@opindex umbrella
+@opindex undefined
+@opindex unexported_symbols_list
+@opindex weak_reference_mismatches
+@opindex whatsloaded
+These options are passed to the Darwin linker.  The Darwin linker man page
+describes them in detail.
+@end table
+
+@node DEC Alpha Options
+@subsection DEC Alpha Options
+
+These @samp{-m} options are defined for the DEC Alpha implementations:
+
+@table @gcctabopt
+@item -mno-soft-float
+@itemx -msoft-float
+@opindex mno-soft-float
+@opindex msoft-float
+Use (do not use) the hardware floating-point instructions for
+floating-point operations.  When @option{-msoft-float} is specified,
+functions in @file{libgcc.a} will be used to perform floating-point
+operations.  Unless they are replaced by routines that emulate the
+floating-point operations, or compiled in such a way as to call such
+emulations routines, these routines will issue floating-point
+operations.   If you are compiling for an Alpha without floating-point
+operations, you must ensure that the library is built so as not to call
+them.
+
+Note that Alpha implementations without floating-point operations are
+required to have floating-point registers.
+
+@item -mfp-reg
+@itemx -mno-fp-regs
+@opindex mfp-reg
+@opindex mno-fp-regs
+Generate code that uses (does not use) the floating-point register set.
+@option{-mno-fp-regs} implies @option{-msoft-float}.  If the floating-point
+register set is not used, floating point operands are passed in integer
+registers as if they were integers and floating-point results are passed
+in @code{$0} instead of @code{$f0}.  This is a non-standard calling sequence,
+so any function with a floating-point argument or return value called by code
+compiled with @option{-mno-fp-regs} must also be compiled with that
+option.
+
+A typical use of this option is building a kernel that does not use,
+and hence need not save and restore, any floating-point registers.
+
+@item -mieee
+@opindex mieee
+The Alpha architecture implements floating-point hardware optimized for
+maximum performance.  It is mostly compliant with the IEEE floating
+point standard.  However, for full compliance, software assistance is
+required.  This option generates code fully IEEE compliant code
+@emph{except} that the @var{inexact-flag} is not maintained (see below).
+If this option is turned on, the preprocessor macro @code{_IEEE_FP} is
+defined during compilation.  The resulting code is less efficient but is
+able to correctly support denormalized numbers and exceptional IEEE
+values such as not-a-number and plus/minus infinity.  Other Alpha
+compilers call this option @option{-ieee_with_no_inexact}.
+
+@item -mieee-with-inexact
+@opindex mieee-with-inexact
+This is like @option{-mieee} except the generated code also maintains
+the IEEE @var{inexact-flag}.  Turning on this option causes the
+generated code to implement fully-compliant IEEE math.  In addition to
+@code{_IEEE_FP}, @code{_IEEE_FP_EXACT} is defined as a preprocessor
+macro.  On some Alpha implementations the resulting code may execute
+significantly slower than the code generated by default.  Since there is
+very little code that depends on the @var{inexact-flag}, you should
+normally not specify this option.  Other Alpha compilers call this
+option @option{-ieee_with_inexact}.
+
+@item -mfp-trap-mode=@var{trap-mode}
+@opindex mfp-trap-mode
+This option controls what floating-point related traps are enabled.
+Other Alpha compilers call this option @option{-fptm @var{trap-mode}}.
+The trap mode can be set to one of four values:
+
+@table @samp
+@item n
+This is the default (normal) setting.  The only traps that are enabled
+are the ones that cannot be disabled in software (e.g., division by zero
+trap).
+
+@item u
+In addition to the traps enabled by @samp{n}, underflow traps are enabled
+as well.
+
+@item su
+Like @samp{u}, but the instructions are marked to be safe for software
+completion (see Alpha architecture manual for details).
+
+@item sui
+Like @samp{su}, but inexact traps are enabled as well.
+@end table
+
+@item -mfp-rounding-mode=@var{rounding-mode}
+@opindex mfp-rounding-mode
+Selects the IEEE rounding mode.  Other Alpha compilers call this option
+@option{-fprm @var{rounding-mode}}.  The @var{rounding-mode} can be one
+of:
+
+@table @samp
+@item n
+Normal IEEE rounding mode.  Floating point numbers are rounded towards
+the nearest machine number or towards the even machine number in case
+of a tie.
+
+@item m
+Round towards minus infinity.
+
+@item c
+Chopped rounding mode.  Floating point numbers are rounded towards zero.
+
+@item d
+Dynamic rounding mode.  A field in the floating point control register
+(@var{fpcr}, see Alpha architecture reference manual) controls the
+rounding mode in effect.  The C library initializes this register for
+rounding towards plus infinity.  Thus, unless your program modifies the
+@var{fpcr}, @samp{d} corresponds to round towards plus infinity.
+@end table
+
+@item -mtrap-precision=@var{trap-precision}
+@opindex mtrap-precision
+In the Alpha architecture, floating point traps are imprecise.  This
+means without software assistance it is impossible to recover from a
+floating trap and program execution normally needs to be terminated.
+GCC can generate code that can assist operating system trap handlers
+in determining the exact location that caused a floating point trap.
+Depending on the requirements of an application, different levels of
+precisions can be selected:
+
+@table @samp
+@item p
+Program precision.  This option is the default and means a trap handler
+can only identify which program caused a floating point exception.
+
+@item f
+Function precision.  The trap handler can determine the function that
+caused a floating point exception.
+
+@item i
+Instruction precision.  The trap handler can determine the exact
+instruction that caused a floating point exception.
+@end table
+
+Other Alpha compilers provide the equivalent options called
+@option{-scope_safe} and @option{-resumption_safe}.
+
+@item -mieee-conformant
+@opindex mieee-conformant
+This option marks the generated code as IEEE conformant.  You must not
+use this option unless you also specify @option{-mtrap-precision=i} and either
+@option{-mfp-trap-mode=su} or @option{-mfp-trap-mode=sui}.  Its only effect
+is to emit the line @samp{.eflag 48} in the function prologue of the
+generated assembly file.  Under DEC Unix, this has the effect that
+IEEE-conformant math library routines will be linked in.
+
+@item -mbuild-constants
+@opindex mbuild-constants
+Normally GCC examines a 32- or 64-bit integer constant to
+see if it can construct it from smaller constants in two or three
+instructions.  If it cannot, it will output the constant as a literal and
+generate code to load it from the data segment at runtime.
+
+Use this option to require GCC to construct @emph{all} integer constants
+using code, even if it takes more instructions (the maximum is six).
+
+You would typically use this option to build a shared library dynamic
+loader.  Itself a shared library, it must relocate itself in memory
+before it can find the variables and constants in its own data segment.
+
+@item -malpha-as
+@itemx -mgas
+@opindex malpha-as
+@opindex mgas
+Select whether to generate code to be assembled by the vendor-supplied
+assembler (@option{-malpha-as}) or by the GNU assembler @option{-mgas}.
+
+@item -mbwx
+@itemx -mno-bwx
+@itemx -mcix
+@itemx -mno-cix
+@itemx -mfix
+@itemx -mno-fix
+@itemx -mmax
+@itemx -mno-max
+@opindex mbwx
+@opindex mno-bwx
+@opindex mcix
+@opindex mno-cix
+@opindex mfix
+@opindex mno-fix
+@opindex mmax
+@opindex mno-max
+Indicate whether GCC should generate code to use the optional BWX,
+CIX, FIX and MAX instruction sets.  The default is to use the instruction
+sets supported by the CPU type specified via @option{-mcpu=} option or that
+of the CPU on which GCC was built if none was specified.
+
+@item -mfloat-vax
+@itemx -mfloat-ieee
+@opindex mfloat-vax
+@opindex mfloat-ieee
+Generate code that uses (does not use) VAX F and G floating point
+arithmetic instead of IEEE single and double precision.
+
+@item -mexplicit-relocs
+@itemx -mno-explicit-relocs
+@opindex mexplicit-relocs
+@opindex mno-explicit-relocs
+Older Alpha assemblers provided no way to generate symbol relocations
+except via assembler macros.  Use of these macros does not allow
+optimal instruction scheduling.  GNU binutils as of version 2.12
+supports a new syntax that allows the compiler to explicitly mark
+which relocations should apply to which instructions.  This option
+is mostly useful for debugging, as GCC detects the capabilities of
+the assembler when it is built and sets the default accordingly.
+
+@item -msmall-data
+@itemx -mlarge-data
+@opindex msmall-data
+@opindex mlarge-data
+When @option{-mexplicit-relocs} is in effect, static data is
+accessed via @dfn{gp-relative} relocations.  When @option{-msmall-data}
+is used, objects 8 bytes long or smaller are placed in a @dfn{small data area}
+(the @code{.sdata} and @code{.sbss} sections) and are accessed via
+16-bit relocations off of the @code{$gp} register.  This limits the
+size of the small data area to 64KB, but allows the variables to be
+directly accessed via a single instruction.
+
+The default is @option{-mlarge-data}.  With this option the data area
+is limited to just below 2GB@.  Programs that require more than 2GB of
+data must use @code{malloc} or @code{mmap} to allocate the data in the
+heap instead of in the program's data segment.
+
+When generating code for shared libraries, @option{-fpic} implies
+@option{-msmall-data} and @option{-fPIC} implies @option{-mlarge-data}.
+
+@item -msmall-text
+@itemx -mlarge-text
+@opindex msmall-text
+@opindex mlarge-text
+When @option{-msmall-text} is used, the compiler assumes that the
+code of the entire program (or shared library) fits in 4MB, and is
+thus reachable with a branch instruction.  When @option{-msmall-data}
+is used, the compiler can assume that all local symbols share the
+same @code{$gp} value, and thus reduce the number of instructions
+required for a function call from 4 to 1.
+
+The default is @option{-mlarge-text}.
+
+@item -mcpu=@var{cpu_type}
+@opindex mcpu
+Set the instruction set and instruction scheduling parameters for
+machine type @var{cpu_type}.  You can specify either the @samp{EV}
+style name or the corresponding chip number.  GCC supports scheduling
+parameters for the EV4, EV5 and EV6 family of processors and will
+choose the default values for the instruction set from the processor
+you specify.  If you do not specify a processor type, GCC will default
+to the processor on which the compiler was built.
+
+Supported values for @var{cpu_type} are
+
+@table @samp
+@item ev4
+@itemx ev45
+@itemx 21064
+Schedules as an EV4 and has no instruction set extensions.
+
+@item ev5
+@itemx 21164
+Schedules as an EV5 and has no instruction set extensions.
+
+@item ev56
+@itemx 21164a
+Schedules as an EV5 and supports the BWX extension.
+
+@item pca56
+@itemx 21164pc
+@itemx 21164PC
+Schedules as an EV5 and supports the BWX and MAX extensions.
+
+@item ev6
+@itemx 21264
+Schedules as an EV6 and supports the BWX, FIX, and MAX extensions.
+
+@item ev67
+@itemx 21264a
+Schedules as an EV6 and supports the BWX, CIX, FIX, and MAX extensions.
+@end table
+
+Native Linux/GNU toolchains also support the value @samp{native},
+which selects the best architecture option for the host processor.
+@option{-mcpu=native} has no effect if GCC does not recognize
+the processor.
+
+@item -mtune=@var{cpu_type}
+@opindex mtune
+Set only the instruction scheduling parameters for machine type
+@var{cpu_type}.  The instruction set is not changed.
+
+Native Linux/GNU toolchains also support the value @samp{native},
+which selects the best architecture option for the host processor.
+@option{-mtune=native} has no effect if GCC does not recognize
+the processor.
+
+@item -mmemory-latency=@var{time}
+@opindex mmemory-latency
+Sets the latency the scheduler should assume for typical memory
+references as seen by the application.  This number is highly
+dependent on the memory access patterns used by the application
+and the size of the external cache on the machine.
+
+Valid options for @var{time} are
+
+@table @samp
+@item @var{number}
+A decimal number representing clock cycles.
+
+@item L1
+@itemx L2
+@itemx L3
+@itemx main
+The compiler contains estimates of the number of clock cycles for
+``typical'' EV4 & EV5 hardware for the Level 1, 2 & 3 caches
+(also called Dcache, Scache, and Bcache), as well as to main memory.
+Note that L3 is only valid for EV5.
+
+@end table
+@end table
+
+@node DEC Alpha/VMS Options
+@subsection DEC Alpha/VMS Options
+
+These @samp{-m} options are defined for the DEC Alpha/VMS implementations:
+
+@table @gcctabopt
+@item -mvms-return-codes
+@opindex mvms-return-codes
+Return VMS condition codes from main.  The default is to return POSIX
+style condition (e.g.@: error) codes.
+@end table
+
+@node FR30 Options
+@subsection FR30 Options
+@cindex FR30 Options
+
+These options are defined specifically for the FR30 port.
+
+@table @gcctabopt
+
+@item -msmall-model
+@opindex msmall-model
+Use the small address space model.  This can produce smaller code, but
+it does assume that all symbolic values and addresses will fit into a
+20-bit range.
+
+@item -mno-lsim
+@opindex mno-lsim
+Assume that run-time support has been provided and so there is no need
+to include the simulator library (@file{libsim.a}) on the linker
+command line.
+
+@end table
+
+@node FRV Options
+@subsection FRV Options
+@cindex FRV Options
+
+@table @gcctabopt
+@item -mgpr-32
+@opindex mgpr-32
+
+Only use the first 32 general purpose registers.
+
+@item -mgpr-64
+@opindex mgpr-64
+
+Use all 64 general purpose registers.
+
+@item -mfpr-32
+@opindex mfpr-32
+
+Use only the first 32 floating point registers.
+
+@item -mfpr-64
+@opindex mfpr-64
+
+Use all 64 floating point registers
+
+@item -mhard-float
+@opindex mhard-float
+
+Use hardware instructions for floating point operations.
+
+@item -msoft-float
+@opindex msoft-float
+
+Use library routines for floating point operations.
+
+@item -malloc-cc
+@opindex malloc-cc
+
+Dynamically allocate condition code registers.
+
+@item -mfixed-cc
+@opindex mfixed-cc
+
+Do not try to dynamically allocate condition code registers, only
+use @code{icc0} and @code{fcc0}.
+
+@item -mdword
+@opindex mdword
+
+Change ABI to use double word insns.
+
+@item -mno-dword
+@opindex mno-dword
+
+Do not use double word instructions.
+
+@item -mdouble
+@opindex mdouble
+
+Use floating point double instructions.
+
+@item -mno-double
+@opindex mno-double
+
+Do not use floating point double instructions.
+
+@item -mmedia
+@opindex mmedia
+
+Use media instructions.
+
+@item -mno-media
+@opindex mno-media
+
+Do not use media instructions.
+
+@item -mmuladd
+@opindex mmuladd
+
+Use multiply and add/subtract instructions.
+
+@item -mno-muladd
+@opindex mno-muladd
+
+Do not use multiply and add/subtract instructions.
+
+@item -mfdpic
+@opindex mfdpic
+
+Select the FDPIC ABI, that uses function descriptors to represent
+pointers to functions.  Without any PIC/PIE-related options, it
+implies @option{-fPIE}.  With @option{-fpic} or @option{-fpie}, it
+assumes GOT entries and small data are within a 12-bit range from the
+GOT base address; with @option{-fPIC} or @option{-fPIE}, GOT offsets
+are computed with 32 bits.
+With a @samp{bfin-elf} target, this option implies @option{-msim}.
+
+@item -minline-plt
+@opindex minline-plt
+
+Enable inlining of PLT entries in function calls to functions that are
+not known to bind locally.  It has no effect without @option{-mfdpic}.
+It's enabled by default if optimizing for speed and compiling for
+shared libraries (i.e., @option{-fPIC} or @option{-fpic}), or when an
+optimization option such as @option{-O3} or above is present in the
+command line.
+
+@item -mTLS
+@opindex TLS
+
+Assume a large TLS segment when generating thread-local code.
+
+@item -mtls
+@opindex tls
+
+Do not assume a large TLS segment when generating thread-local code.
+
+@item -mgprel-ro
+@opindex mgprel-ro
+
+Enable the use of @code{GPREL} relocations in the FDPIC ABI for data
+that is known to be in read-only sections.  It's enabled by default,
+except for @option{-fpic} or @option{-fpie}: even though it may help
+make the global offset table smaller, it trades 1 instruction for 4.
+With @option{-fPIC} or @option{-fPIE}, it trades 3 instructions for 4,
+one of which may be shared by multiple symbols, and it avoids the need
+for a GOT entry for the referenced symbol, so it's more likely to be a
+win.  If it is not, @option{-mno-gprel-ro} can be used to disable it.
+
+@item -multilib-library-pic
+@opindex multilib-library-pic
+
+Link with the (library, not FD) pic libraries.  It's implied by
+@option{-mlibrary-pic}, as well as by @option{-fPIC} and
+@option{-fpic} without @option{-mfdpic}.  You should never have to use
+it explicitly.
+
+@item -mlinked-fp
+@opindex mlinked-fp
+
+Follow the EABI requirement of always creating a frame pointer whenever
+a stack frame is allocated.  This option is enabled by default and can
+be disabled with @option{-mno-linked-fp}.
+
+@item -mlong-calls
+@opindex mlong-calls
+
+Use indirect addressing to call functions outside the current
+compilation unit.  This allows the functions to be placed anywhere
+within the 32-bit address space.
+
+@item -malign-labels
+@opindex malign-labels
+
+Try to align labels to an 8-byte boundary by inserting nops into the
+previous packet.  This option only has an effect when VLIW packing
+is enabled.  It doesn't create new packets; it merely adds nops to
+existing ones.
+
+@item -mlibrary-pic
+@opindex mlibrary-pic
+
+Generate position-independent EABI code.
+
+@item -macc-4
+@opindex macc-4
+
+Use only the first four media accumulator registers.
+
+@item -macc-8
+@opindex macc-8
+
+Use all eight media accumulator registers.
+
+@item -mpack
+@opindex mpack
+
+Pack VLIW instructions.
+
+@item -mno-pack
+@opindex mno-pack
+
+Do not pack VLIW instructions.
+
+@item -mno-eflags
+@opindex mno-eflags
+
+Do not mark ABI switches in e_flags.
+
+@item -mcond-move
+@opindex mcond-move
+
+Enable the use of conditional-move instructions (default).
+
+This switch is mainly for debugging the compiler and will likely be removed
+in a future version.
+
+@item -mno-cond-move
+@opindex mno-cond-move
+
+Disable the use of conditional-move instructions.
+
+This switch is mainly for debugging the compiler and will likely be removed
+in a future version.
+
+@item -mscc
+@opindex mscc
+
+Enable the use of conditional set instructions (default).
+
+This switch is mainly for debugging the compiler and will likely be removed
+in a future version.
+
+@item -mno-scc
+@opindex mno-scc
+
+Disable the use of conditional set instructions.
+
+This switch is mainly for debugging the compiler and will likely be removed
+in a future version.
+
+@item -mcond-exec
+@opindex mcond-exec
+
+Enable the use of conditional execution (default).
+
+This switch is mainly for debugging the compiler and will likely be removed
+in a future version.
+
+@item -mno-cond-exec
+@opindex mno-cond-exec
+
+Disable the use of conditional execution.
+
+This switch is mainly for debugging the compiler and will likely be removed
+in a future version.
+
+@item -mvliw-branch
+@opindex mvliw-branch
+
+Run a pass to pack branches into VLIW instructions (default).
+
+This switch is mainly for debugging the compiler and will likely be removed
+in a future version.
+
+@item -mno-vliw-branch
+@opindex mno-vliw-branch
+
+Do not run a pass to pack branches into VLIW instructions.
+
+This switch is mainly for debugging the compiler and will likely be removed
+in a future version.
+
+@item -mmulti-cond-exec
+@opindex mmulti-cond-exec
+
+Enable optimization of @code{&&} and @code{||} in conditional execution
+(default).
+
+This switch is mainly for debugging the compiler and will likely be removed
+in a future version.
+
+@item -mno-multi-cond-exec
+@opindex mno-multi-cond-exec
+
+Disable optimization of @code{&&} and @code{||} in conditional execution.
+
+This switch is mainly for debugging the compiler and will likely be removed
+in a future version.
+
+@item -mnested-cond-exec
+@opindex mnested-cond-exec
+
+Enable nested conditional execution optimizations (default).
+
+This switch is mainly for debugging the compiler and will likely be removed
+in a future version.
+
+@item -mno-nested-cond-exec
+@opindex mno-nested-cond-exec
+
+Disable nested conditional execution optimizations.
+
+This switch is mainly for debugging the compiler and will likely be removed
+in a future version.
+
+@item -moptimize-membar
+@opindex moptimize-membar
+
+This switch removes redundant @code{membar} instructions from the
+compiler generated code.  It is enabled by default.
+
+@item -mno-optimize-membar
+@opindex mno-optimize-membar
+
+This switch disables the automatic removal of redundant @code{membar}
+instructions from the generated code.
+
+@item -mtomcat-stats
+@opindex mtomcat-stats
+
+Cause gas to print out tomcat statistics.
+
+@item -mcpu=@var{cpu}
+@opindex mcpu
+
+Select the processor type for which to generate code.  Possible values are
+@samp{frv}, @samp{fr550}, @samp{tomcat}, @samp{fr500}, @samp{fr450},
+@samp{fr405}, @samp{fr400}, @samp{fr300} and @samp{simple}.
+
+@end table
+
+@node GNU/Linux Options
+@subsection GNU/Linux Options
+
+These @samp{-m} options are defined for GNU/Linux targets:
+
+@table @gcctabopt
+@item -mglibc
+@opindex mglibc
+Use the GNU C library instead of uClibc.  This is the default except
+on @samp{*-*-linux-*uclibc*} targets.
+
+@item -muclibc
+@opindex muclibc
+Use uClibc instead of the GNU C library.  This is the default on
+@samp{*-*-linux-*uclibc*} targets.
+@end table
+
+@node H8/300 Options
+@subsection H8/300 Options
+
+These @samp{-m} options are defined for the H8/300 implementations:
+
+@table @gcctabopt
+@item -mrelax
+@opindex mrelax
+Shorten some address references at link time, when possible; uses the
+linker option @option{-relax}.  @xref{H8/300,, @code{ld} and the H8/300,
+ld, Using ld}, for a fuller description.
+
+@item -mh
+@opindex mh
+Generate code for the H8/300H@.
+
+@item -ms
+@opindex ms
+Generate code for the H8S@.
+
+@item -mn
+@opindex mn
+Generate code for the H8S and H8/300H in the normal mode.  This switch
+must be used either with @option{-mh} or @option{-ms}.
+
+@item -ms2600
+@opindex ms2600
+Generate code for the H8S/2600.  This switch must be used with @option{-ms}.
+
+@item -mint32
+@opindex mint32
+Make @code{int} data 32 bits by default.
+
+@item -malign-300
+@opindex malign-300
+On the H8/300H and H8S, use the same alignment rules as for the H8/300.
+The default for the H8/300H and H8S is to align longs and floats on 4
+byte boundaries.
+@option{-malign-300} causes them to be aligned on 2 byte boundaries.
+This option has no effect on the H8/300.
+@end table
+
+@node HPPA Options
+@subsection HPPA Options
+@cindex HPPA Options
+
+These @samp{-m} options are defined for the HPPA family of computers:
+
+@table @gcctabopt
+@item -march=@var{architecture-type}
+@opindex march
+Generate code for the specified architecture.  The choices for
+@var{architecture-type} are @samp{1.0} for PA 1.0, @samp{1.1} for PA
+1.1, and @samp{2.0} for PA 2.0 processors.  Refer to
+@file{/usr/lib/sched.models} on an HP-UX system to determine the proper
+architecture option for your machine.  Code compiled for lower numbered
+architectures will run on higher numbered architectures, but not the
+other way around.
+
+@item -mpa-risc-1-0
+@itemx -mpa-risc-1-1
+@itemx -mpa-risc-2-0
+@opindex mpa-risc-1-0
+@opindex mpa-risc-1-1
+@opindex mpa-risc-2-0
+Synonyms for @option{-march=1.0}, @option{-march=1.1}, and @option{-march=2.0} respectively.
+
+@item -mbig-switch
+@opindex mbig-switch
+Generate code suitable for big switch tables.  Use this option only if
+the assembler/linker complain about out of range branches within a switch
+table.
+
+@item -mjump-in-delay
+@opindex mjump-in-delay
+Fill delay slots of function calls with unconditional jump instructions
+by modifying the return pointer for the function call to be the target
+of the conditional jump.
+
+@item -mdisable-fpregs
+@opindex mdisable-fpregs
+Prevent floating point registers from being used in any manner.  This is
+necessary for compiling kernels which perform lazy context switching of
+floating point registers.  If you use this option and attempt to perform
+floating point operations, the compiler will abort.
+
+@item -mdisable-indexing
+@opindex mdisable-indexing
+Prevent the compiler from using indexing address modes.  This avoids some
+rather obscure problems when compiling MIG generated code under MACH@.
+
+@item -mno-space-regs
+@opindex mno-space-regs
+Generate code that assumes the target has no space registers.  This allows
+GCC to generate faster indirect calls and use unscaled index address modes.
+
+Such code is suitable for level 0 PA systems and kernels.
+
+@item -mfast-indirect-calls
+@opindex mfast-indirect-calls
+Generate code that assumes calls never cross space boundaries.  This
+allows GCC to emit code which performs faster indirect calls.
+
+This option will not work in the presence of shared libraries or nested
+functions.
+
+@item -mfixed-range=@var{register-range}
+@opindex mfixed-range
+Generate code treating the given register range as fixed registers.
+A fixed register is one that the register allocator can not use.  This is
+useful when compiling kernel code.  A register range is specified as
+two registers separated by a dash.  Multiple register ranges can be
+specified separated by a comma.
+
+@item -mlong-load-store
+@opindex mlong-load-store
+Generate 3-instruction load and store sequences as sometimes required by
+the HP-UX 10 linker.  This is equivalent to the @samp{+k} option to
+the HP compilers.
+
+@item -mportable-runtime
+@opindex mportable-runtime
+Use the portable calling conventions proposed by HP for ELF systems.
+
+@item -mgas
+@opindex mgas
+Enable the use of assembler directives only GAS understands.
+
+@item -mschedule=@var{cpu-type}
+@opindex mschedule
+Schedule code according to the constraints for the machine type
+@var{cpu-type}.  The choices for @var{cpu-type} are @samp{700}
+@samp{7100}, @samp{7100LC}, @samp{7200}, @samp{7300} and @samp{8000}.  Refer
+to @file{/usr/lib/sched.models} on an HP-UX system to determine the
+proper scheduling option for your machine.  The default scheduling is
+@samp{8000}.
+
+@item -mlinker-opt
+@opindex mlinker-opt
+Enable the optimization pass in the HP-UX linker.  Note this makes symbolic
+debugging impossible.  It also triggers a bug in the HP-UX 8 and HP-UX 9
+linkers in which they give bogus error messages when linking some programs.
+
+@item -msoft-float
+@opindex msoft-float
+Generate output containing library calls for floating point.
+@strong{Warning:} the requisite libraries are not available for all HPPA
+targets.  Normally the facilities of the machine's usual C compiler are
+used, but this cannot be done directly in cross-compilation.  You must make
+your own arrangements to provide suitable library functions for
+cross-compilation.
+
+@option{-msoft-float} changes the calling convention in the output file;
+therefore, it is only useful if you compile @emph{all} of a program with
+this option.  In particular, you need to compile @file{libgcc.a}, the
+library that comes with GCC, with @option{-msoft-float} in order for
+this to work.
+
+@item -msio
+@opindex msio
+Generate the predefine, @code{_SIO}, for server IO@.  The default is
+@option{-mwsio}.  This generates the predefines, @code{__hp9000s700},
+@code{__hp9000s700__} and @code{_WSIO}, for workstation IO@.  These
+options are available under HP-UX and HI-UX@.
+
+@item -mgnu-ld
+@opindex gnu-ld
+Use GNU ld specific options.  This passes @option{-shared} to ld when
+building a shared library.  It is the default when GCC is configured,
+explicitly or implicitly, with the GNU linker.  This option does not
+have any affect on which ld is called, it only changes what parameters
+are passed to that ld.  The ld that is called is determined by the
+@option{--with-ld} configure option, GCC's program search path, and
+finally by the user's @env{PATH}.  The linker used by GCC can be printed
+using @samp{which `gcc -print-prog-name=ld`}.  This option is only available
+on the 64 bit HP-UX GCC, i.e.@: configured with @samp{hppa*64*-*-hpux*}.
+
+@item -mhp-ld
+@opindex hp-ld
+Use HP ld specific options.  This passes @option{-b} to ld when building
+a shared library and passes @option{+Accept TypeMismatch} to ld on all
+links.  It is the default when GCC is configured, explicitly or
+implicitly, with the HP linker.  This option does not have any affect on
+which ld is called, it only changes what parameters are passed to that
+ld.  The ld that is called is determined by the @option{--with-ld}
+configure option, GCC's program search path, and finally by the user's
+@env{PATH}.  The linker used by GCC can be printed using @samp{which
+`gcc -print-prog-name=ld`}.  This option is only available on the 64 bit
+HP-UX GCC, i.e.@: configured with @samp{hppa*64*-*-hpux*}.
+
+@item -mlong-calls
+@opindex mno-long-calls
+Generate code that uses long call sequences.  This ensures that a call
+is always able to reach linker generated stubs.  The default is to generate
+long calls only when the distance from the call site to the beginning
+of the function or translation unit, as the case may be, exceeds a
+predefined limit set by the branch type being used.  The limits for
+normal calls are 7,600,000 and 240,000 bytes, respectively for the
+PA 2.0 and PA 1.X architectures.  Sibcalls are always limited at
+240,000 bytes.
+
+Distances are measured from the beginning of functions when using the
+@option{-ffunction-sections} option, or when using the @option{-mgas}
+and @option{-mno-portable-runtime} options together under HP-UX with
+the SOM linker.
+
+It is normally not desirable to use this option as it will degrade
+performance.  However, it may be useful in large applications,
+particularly when partial linking is used to build the application.
+
+The types of long calls used depends on the capabilities of the
+assembler and linker, and the type of code being generated.  The
+impact on systems that support long absolute calls, and long pic
+symbol-difference or pc-relative calls should be relatively small.
+However, an indirect call is used on 32-bit ELF systems in pic code
+and it is quite long.
+
+@item -munix=@var{unix-std}
+@opindex march
+Generate compiler predefines and select a startfile for the specified
+UNIX standard.  The choices for @var{unix-std} are @samp{93}, @samp{95}
+and @samp{98}.  @samp{93} is supported on all HP-UX versions.  @samp{95}
+is available on HP-UX 10.10 and later.  @samp{98} is available on HP-UX
+11.11 and later.  The default values are @samp{93} for HP-UX 10.00,
+@samp{95} for HP-UX 10.10 though to 11.00, and @samp{98} for HP-UX 11.11
+and later.
+
+@option{-munix=93} provides the same predefines as GCC 3.3 and 3.4.
+@option{-munix=95} provides additional predefines for @code{XOPEN_UNIX}
+and @code{_XOPEN_SOURCE_EXTENDED}, and the startfile @file{unix95.o}.
+@option{-munix=98} provides additional predefines for @code{_XOPEN_UNIX},
+@code{_XOPEN_SOURCE_EXTENDED}, @code{_INCLUDE__STDC_A1_SOURCE} and
+@code{_INCLUDE_XOPEN_SOURCE_500}, and the startfile @file{unix98.o}.
+
+It is @emph{important} to note that this option changes the interfaces
+for various library routines.  It also affects the operational behavior
+of the C library.  Thus, @emph{extreme} care is needed in using this
+option.
+
+Library code that is intended to operate with more than one UNIX
+standard must test, set and restore the variable @var{__xpg4_extended_mask}
+as appropriate.  Most GNU software doesn't provide this capability.
+
+@item -nolibdld
+@opindex nolibdld
+Suppress the generation of link options to search libdld.sl when the
+@option{-static} option is specified on HP-UX 10 and later.
+
+@item -static
+@opindex static
+The HP-UX implementation of setlocale in libc has a dependency on
+libdld.sl.  There isn't an archive version of libdld.sl.  Thus,
+when the @option{-static} option is specified, special link options
+are needed to resolve this dependency.
+
+On HP-UX 10 and later, the GCC driver adds the necessary options to
+link with libdld.sl when the @option{-static} option is specified.
+This causes the resulting binary to be dynamic.  On the 64-bit port,
+the linkers generate dynamic binaries by default in any case.  The
+@option{-nolibdld} option can be used to prevent the GCC driver from
+adding these link options.
+
+@item -threads
+@opindex threads
+Add support for multithreading with the @dfn{dce thread} library
+under HP-UX@.  This option sets flags for both the preprocessor and
+linker.
+@end table
+
+@node i386 and x86-64 Options
+@subsection Intel 386 and AMD x86-64 Options
+@cindex i386 Options
+@cindex x86-64 Options
+@cindex Intel 386 Options
+@cindex AMD x86-64 Options
+
+These @samp{-m} options are defined for the i386 and x86-64 family of
+computers:
+
+@table @gcctabopt
+@item -mtune=@var{cpu-type}
+@opindex mtune
+Tune to @var{cpu-type} everything applicable about the generated code, except
+for the ABI and the set of available instructions.  The choices for
+@var{cpu-type} are:
+@table @emph
+@item generic
+Produce code optimized for the most common IA32/AMD64/EM64T processors.
+If you know the CPU on which your code will run, then you should use
+the corresponding @option{-mtune} option instead of
+@option{-mtune=generic}.  But, if you do not know exactly what CPU users
+of your application will have, then you should use this option.
+
+As new processors are deployed in the marketplace, the behavior of this
+option will change.  Therefore, if you upgrade to a newer version of
+GCC, the code generated option will change to reflect the processors
+that were most common when that version of GCC was released.
+
+There is no @option{-march=generic} option because @option{-march}
+indicates the instruction set the compiler can use, and there is no
+generic instruction set applicable to all processors.  In contrast,
+@option{-mtune} indicates the processor (or, in this case, collection of
+processors) for which the code is optimized.
+@item native
+This selects the CPU to tune for at compilation time by determining
+the processor type of the compiling machine.  Using @option{-mtune=native}
+will produce code optimized for the local machine under the constraints
+of the selected instruction set.  Using @option{-march=native} will
+enable all instruction subsets supported by the local machine (hence
+the result might not run on different machines).
+@item i386
+Original Intel's i386 CPU@.
+@item i486
+Intel's i486 CPU@.  (No scheduling is implemented for this chip.)
+@item i586, pentium
+Intel Pentium CPU with no MMX support.
+@item pentium-mmx
+Intel PentiumMMX CPU based on Pentium core with MMX instruction set support.
+@item pentiumpro
+Intel PentiumPro CPU@.
+@item i686
+Same as @code{generic}, but when used as @code{march} option, PentiumPro
+instruction set will be used, so the code will run on all i686 family chips.
+@item pentium2
+Intel Pentium2 CPU based on PentiumPro core with MMX instruction set support.
+@item pentium3, pentium3m
+Intel Pentium3 CPU based on PentiumPro core with MMX and SSE instruction set
+support.
+@item pentium-m
+Low power version of Intel Pentium3 CPU with MMX, SSE and SSE2 instruction set
+support.  Used by Centrino notebooks.
+@item pentium4, pentium4m
+Intel Pentium4 CPU with MMX, SSE and SSE2 instruction set support.
+@item prescott
+Improved version of Intel Pentium4 CPU with MMX, SSE, SSE2 and SSE3 instruction
+set support.
+@item nocona
+Improved version of Intel Pentium4 CPU with 64-bit extensions, MMX, SSE,
+SSE2 and SSE3 instruction set support.
+@item core2
+Intel Core2 CPU with 64-bit extensions, MMX, SSE, SSE2, SSE3 and SSSE3
+instruction set support.
+@item k6
+AMD K6 CPU with MMX instruction set support.
+@item k6-2, k6-3
+Improved versions of AMD K6 CPU with MMX and 3dNOW!@: instruction set support.
+@item athlon, athlon-tbird
+AMD Athlon CPU with MMX, 3dNOW!, enhanced 3dNOW!@: and SSE prefetch instructions
+support.
+@item athlon-4, athlon-xp, athlon-mp
+Improved AMD Athlon CPU with MMX, 3dNOW!, enhanced 3dNOW!@: and full SSE
+instruction set support.
+@item k8, opteron, athlon64, athlon-fx
+AMD K8 core based CPUs with x86-64 instruction set support.  (This supersets
+MMX, SSE, SSE2, 3dNOW!, enhanced 3dNOW!@: and 64-bit instruction set extensions.)
+@item k8-sse3, opteron-sse3, athlon64-sse3
+Improved versions of k8, opteron and athlon64 with SSE3 instruction set support.
+@item amdfam10, barcelona
+AMD Family 10h core based CPUs with x86-64 instruction set support.  (This
+supersets MMX, SSE, SSE2, SSE3, SSE4A, 3dNOW!, enhanced 3dNOW!, ABM and 64-bit
+instruction set extensions.)
+@item winchip-c6
+IDT Winchip C6 CPU, dealt in same way as i486 with additional MMX instruction
+set support.
+@item winchip2
+IDT Winchip2 CPU, dealt in same way as i486 with additional MMX and 3dNOW!@:
+instruction set support.
+@item c3
+Via C3 CPU with MMX and 3dNOW!@: instruction set support.  (No scheduling is
+implemented for this chip.)
+@item c3-2
+Via C3-2 CPU with MMX and SSE instruction set support.  (No scheduling is
+implemented for this chip.)
+@item geode
+Embedded AMD CPU with MMX and 3dNOW! instruction set support.
+@end table
+
+While picking a specific @var{cpu-type} will schedule things appropriately
+for that particular chip, the compiler will not generate any code that
+does not run on the i386 without the @option{-march=@var{cpu-type}} option
+being used.
+
+@item -march=@var{cpu-type}
+@opindex march
+Generate instructions for the machine type @var{cpu-type}.  The choices
+for @var{cpu-type} are the same as for @option{-mtune}.  Moreover,
+specifying @option{-march=@var{cpu-type}} implies @option{-mtune=@var{cpu-type}}.
+
+@item -mcpu=@var{cpu-type}
+@opindex mcpu
+A deprecated synonym for @option{-mtune}.
+
+@item -mfpmath=@var{unit}
+@opindex march
+Generate floating point arithmetics for selected unit @var{unit}.  The choices
+for @var{unit} are:
+
+@table @samp
+@item 387
+Use the standard 387 floating point coprocessor present majority of chips and
+emulated otherwise.  Code compiled with this option will run almost everywhere.
+The temporary results are computed in 80bit precision instead of precision
+specified by the type resulting in slightly different results compared to most
+of other chips.  See @option{-ffloat-store} for more detailed description.
+
+This is the default choice for i386 compiler.
+
+@item sse
+Use scalar floating point instructions present in the SSE instruction set.
+This instruction set is supported by Pentium3 and newer chips, in the AMD line
+by Athlon-4, Athlon-xp and Athlon-mp chips.  The earlier version of SSE
+instruction set supports only single precision arithmetics, thus the double and
+extended precision arithmetics is still done using 387.  Later version, present
+only in Pentium4 and the future AMD x86-64 chips supports double precision
+arithmetics too.
+
+For the i386 compiler, you need to use @option{-march=@var{cpu-type}}, @option{-msse}
+or @option{-msse2} switches to enable SSE extensions and make this option
+effective.  For the x86-64 compiler, these extensions are enabled by default.
+
+The resulting code should be considerably faster in the majority of cases and avoid
+the numerical instability problems of 387 code, but may break some existing
+code that expects temporaries to be 80bit.
+
+This is the default choice for the x86-64 compiler.
+
+@item sse,387
+@itemx sse+387
+@itemx both
+Attempt to utilize both instruction sets at once.  This effectively double the
+amount of available registers and on chips with separate execution units for
+387 and SSE the execution resources too.  Use this option with care, as it is
+still experimental, because the GCC register allocator does not model separate
+functional units well resulting in instable performance.
+@end table
+
+@item -masm=@var{dialect}
+@opindex masm=@var{dialect}
+Output asm instructions using selected @var{dialect}.  Supported
+choices are @samp{intel} or @samp{att} (the default one).  Darwin does
+not support @samp{intel}.
+
+@item -mieee-fp
+@itemx -mno-ieee-fp
+@opindex mieee-fp
+@opindex mno-ieee-fp
+Control whether or not the compiler uses IEEE floating point
+comparisons.  These handle correctly the case where the result of a
+comparison is unordered.
+
+@item -msoft-float
+@opindex msoft-float
+Generate output containing library calls for floating point.
+@strong{Warning:} the requisite libraries are not part of GCC@.
+Normally the facilities of the machine's usual C compiler are used, but
+this can't be done directly in cross-compilation.  You must make your
+own arrangements to provide suitable library functions for
+cross-compilation.
+
+On machines where a function returns floating point results in the 80387
+register stack, some floating point opcodes may be emitted even if
+@option{-msoft-float} is used.
+
+@item -mno-fp-ret-in-387
+@opindex mno-fp-ret-in-387
+Do not use the FPU registers for return values of functions.
+
+The usual calling convention has functions return values of types
+@code{float} and @code{double} in an FPU register, even if there
+is no FPU@.  The idea is that the operating system should emulate
+an FPU@.
+
+The option @option{-mno-fp-ret-in-387} causes such values to be returned
+in ordinary CPU registers instead.
+
+@item -mno-fancy-math-387
+@opindex mno-fancy-math-387
+Some 387 emulators do not support the @code{sin}, @code{cos} and
+@code{sqrt} instructions for the 387.  Specify this option to avoid
+generating those instructions.  This option is the default on FreeBSD,
+OpenBSD and NetBSD@.  This option is overridden when @option{-march}
+indicates that the target cpu will always have an FPU and so the
+instruction will not need emulation.  As of revision 2.6.1, these
+instructions are not generated unless you also use the
+@option{-funsafe-math-optimizations} switch.
+
+@item -malign-double
+@itemx -mno-align-double
+@opindex malign-double
+@opindex mno-align-double
+Control whether GCC aligns @code{double}, @code{long double}, and
+@code{long long} variables on a two word boundary or a one word
+boundary.  Aligning @code{double} variables on a two word boundary will
+produce code that runs somewhat faster on a @samp{Pentium} at the
+expense of more memory.
+
+On x86-64, @option{-malign-double} is enabled by default.
+
+@strong{Warning:} if you use the @option{-malign-double} switch,
+structures containing the above types will be aligned differently than
+the published application binary interface specifications for the 386
+and will not be binary compatible with structures in code compiled
+without that switch.
+
+@item -m96bit-long-double
+@itemx -m128bit-long-double
+@opindex m96bit-long-double
+@opindex m128bit-long-double
+These switches control the size of @code{long double} type.  The i386
+application binary interface specifies the size to be 96 bits,
+so @option{-m96bit-long-double} is the default in 32 bit mode.
+
+Modern architectures (Pentium and newer) would prefer @code{long double}
+to be aligned to an 8 or 16 byte boundary.  In arrays or structures
+conforming to the ABI, this would not be possible.  So specifying a
+@option{-m128bit-long-double} will align @code{long double}
+to a 16 byte boundary by padding the @code{long double} with an additional
+32 bit zero.
+
+In the x86-64 compiler, @option{-m128bit-long-double} is the default choice as
+its ABI specifies that @code{long double} is to be aligned on 16 byte boundary.
+
+Notice that neither of these options enable any extra precision over the x87
+standard of 80 bits for a @code{long double}.
+
+@strong{Warning:} if you override the default value for your target ABI, the
+structures and arrays containing @code{long double} variables will change
+their size as well as function calling convention for function taking
+@code{long double} will be modified.  Hence they will not be binary
+compatible with arrays or structures in code compiled without that switch.
+
+@item -mlarge-data-threshold=@var{number}
+@opindex mlarge-data-threshold=@var{number}
+When @option{-mcmodel=medium} is specified, the data greater than
+@var{threshold} are placed in large data section.  This value must be the
+same across all object linked into the binary and defaults to 65535.
+
+@item -mrtd
+@opindex mrtd
+Use a different function-calling convention, in which functions that
+take a fixed number of arguments return with the @code{ret} @var{num}
+instruction, which pops their arguments while returning.  This saves one
+instruction in the caller since there is no need to pop the arguments
+there.
+
+You can specify that an individual function is called with this calling
+sequence with the function attribute @samp{stdcall}.  You can also
+override the @option{-mrtd} option by using the function attribute
+@samp{cdecl}.  @xref{Function Attributes}.
+
+@strong{Warning:} this calling convention is incompatible with the one
+normally used on Unix, so you cannot use it if you need to call
+libraries compiled with the Unix compiler.
+
+Also, you must provide function prototypes for all functions that
+take variable numbers of arguments (including @code{printf});
+otherwise incorrect code will be generated for calls to those
+functions.
+
+In addition, seriously incorrect code will result if you call a
+function with too many arguments.  (Normally, extra arguments are
+harmlessly ignored.)
+
+@item -mregparm=@var{num}
+@opindex mregparm
+Control how many registers are used to pass integer arguments.  By
+default, no registers are used to pass arguments, and at most 3
+registers can be used.  You can control this behavior for a specific
+function by using the function attribute @samp{regparm}.
+@xref{Function Attributes}.
+
+@strong{Warning:} if you use this switch, and
+@var{num} is nonzero, then you must build all modules with the same
+value, including any libraries.  This includes the system libraries and
+startup modules.
+
+@item -msseregparm
+@opindex msseregparm
+Use SSE register passing conventions for float and double arguments
+and return values.  You can control this behavior for a specific
+function by using the function attribute @samp{sseregparm}.
+@xref{Function Attributes}.
+
+@strong{Warning:} if you use this switch then you must build all
+modules with the same value, including any libraries.  This includes
+the system libraries and startup modules.
+
+@item -mpc32
+@itemx -mpc64
+@itemx -mpc80
+@opindex mpc32
+@opindex mpc64
+@opindex mpc80
+
+Set 80387 floating-point precision to 32, 64 or 80 bits.  When @option{-mpc32}
+is specified, the significands of results of floating-point operations are
+rounded to 24 bits (single precision); @option{-mpc64} rounds the
+significands of results of floating-point operations to 53 bits (double
+precision) and @option{-mpc80} rounds the significands of results of
+floating-point operations to 64 bits (extended double precision), which is
+the default.  When this option is used, floating-point operations in higher
+precisions are not available to the programmer without setting the FPU
+control word explicitly.
+
+Setting the rounding of floating-point operations to less than the default
+80 bits can speed some programs by 2% or more.  Note that some mathematical
+libraries assume that extended precision (80 bit) floating-point operations
+are enabled by default; routines in such libraries could suffer significant
+loss of accuracy, typically through so-called "catastrophic cancellation",
+when this option is used to set the precision to less than extended precision. 
+
+@item -mstackrealign
+@opindex mstackrealign
+Realign the stack at entry.  On the Intel x86, the @option{-mstackrealign}
+option will generate an alternate prologue and epilogue that realigns the
+runtime stack if necessary.  This supports mixing legacy codes that keep
+a 4-byte aligned stack with modern codes that keep a 16-byte stack for
+SSE compatibility.  See also the attribute @code{force_align_arg_pointer},
+applicable to individual functions.
+
+@item -mpreferred-stack-boundary=@var{num}
+@opindex mpreferred-stack-boundary
+Attempt to keep the stack boundary aligned to a 2 raised to @var{num}
+byte boundary.  If @option{-mpreferred-stack-boundary} is not specified,
+the default is 4 (16 bytes or 128 bits).
+
+@item -mincoming-stack-boundary=@var{num}
+@opindex mincoming-stack-boundary
+Assume the incoming stack is aligned to a 2 raised to @var{num} byte
+boundary.  If @option{-mincoming-stack-boundary} is not specified,
+the one specified by @option{-mpreferred-stack-boundary} will be used.
+
+On Pentium and PentiumPro, @code{double} and @code{long double} values
+should be aligned to an 8 byte boundary (see @option{-malign-double}) or
+suffer significant run time performance penalties.  On Pentium III, the
+Streaming SIMD Extension (SSE) data type @code{__m128} may not work
+properly if it is not 16 byte aligned.
+
+To ensure proper alignment of this values on the stack, the stack boundary
+must be as aligned as that required by any value stored on the stack.
+Further, every function must be generated such that it keeps the stack
+aligned.  Thus calling a function compiled with a higher preferred
+stack boundary from a function compiled with a lower preferred stack
+boundary will most likely misalign the stack.  It is recommended that
+libraries that use callbacks always use the default setting.
+
+This extra alignment does consume extra stack space, and generally
+increases code size.  Code that is sensitive to stack space usage, such
+as embedded systems and operating system kernels, may want to reduce the
+preferred alignment to @option{-mpreferred-stack-boundary=2}.
+
+@item -mmmx
+@itemx -mno-mmx
+@itemx -msse
+@itemx -mno-sse
+@itemx -msse2
+@itemx -mno-sse2
+@itemx -msse3
+@itemx -mno-sse3
+@itemx -mssse3
+@itemx -mno-ssse3
+@itemx -msse4.1
+@itemx -mno-sse4.1
+@itemx -msse4.2
+@itemx -mno-sse4.2
+@itemx -msse4
+@itemx -mno-sse4
+@itemx -mavx
+@itemx -mno-avx
+@itemx -maes
+@itemx -mno-aes
+@itemx -mpclmul
+@itemx -mno-pclmul
+@itemx -msse4a
+@itemx -mno-sse4a
+@itemx -msse5
+@itemx -mno-sse5
+@itemx -m3dnow
+@itemx -mno-3dnow
+@itemx -mpopcnt
+@itemx -mno-popcnt
+@itemx -mabm
+@itemx -mno-abm
+@opindex mmmx
+@opindex mno-mmx
+@opindex msse
+@opindex mno-sse
+@opindex m3dnow
+@opindex mno-3dnow
+These switches enable or disable the use of instructions in the MMX,
+SSE, SSE2, SSE3, SSSE3, SSE4.1, AVX, AES, PCLMUL, SSE4A, SSE5, ABM or
+3DNow!@: extended instruction sets.
+These extensions are also available as built-in functions: see
+@ref{X86 Built-in Functions}, for details of the functions enabled and
+disabled by these switches.
+
+To have SSE/SSE2 instructions generated automatically from floating-point
+code (as opposed to 387 instructions), see @option{-mfpmath=sse}.
+
+GCC depresses SSEx instructions when @option{-mavx} is used. Instead, it
+generates new AVX instructions or AVX equivalence for all SSEx instructions
+when needed.
+
+These options will enable GCC to use these extended instructions in
+generated code, even without @option{-mfpmath=sse}.  Applications which
+perform runtime CPU detection must compile separate files for each
+supported architecture, using the appropriate flags.  In particular,
+the file containing the CPU detection code should be compiled without
+these options.
+
+@item -mcld
+@opindex mcld
+This option instructs GCC to emit a @code{cld} instruction in the prologue
+of functions that use string instructions.  String instructions depend on
+the DF flag to select between autoincrement or autodecrement mode.  While the
+ABI specifies the DF flag to be cleared on function entry, some operating
+systems violate this specification by not clearing the DF flag in their
+exception dispatchers.  The exception handler can be invoked with the DF flag
+set which leads to wrong direction mode, when string instructions are used.
+This option can be enabled by default on 32-bit x86 targets by configuring
+GCC with the @option{--enable-cld} configure option.  Generation of @code{cld}
+instructions can be suppressed with the @option{-mno-cld} compiler option
+in this case.
+
+@item -mcx16
+@opindex mcx16
+This option will enable GCC to use CMPXCHG16B instruction in generated code.
+CMPXCHG16B allows for atomic operations on 128-bit double quadword (or oword)
+data types.  This is useful for high resolution counters that could be updated
+by multiple processors (or cores).  This instruction is generated as part of
+atomic built-in functions: see @ref{Atomic Builtins} for details.
+
+@item -msahf
+@opindex msahf
+This option will enable GCC to use SAHF instruction in generated 64-bit code.
+Early Intel CPUs with Intel 64 lacked LAHF and SAHF instructions supported
+by AMD64 until introduction of Pentium 4 G1 step in December 2005.  LAHF and
+SAHF are load and store instructions, respectively, for certain status flags.
+In 64-bit mode, SAHF instruction is used to optimize @code{fmod}, @code{drem}
+or @code{remainder} built-in functions: see @ref{Other Builtins} for details.
+
+@item -mrecip
+@opindex mrecip
+This option will enable GCC to use RCPSS and RSQRTSS instructions (and their
+vectorized variants RCPPS and RSQRTPS) with an additional Newton-Raphson step
+to increase precision instead of DIVSS and SQRTSS (and their vectorized
+variants) for single precision floating point arguments.  These instructions
+are generated only when @option{-funsafe-math-optimizations} is enabled
+together with @option{-finite-math-only} and @option{-fno-trapping-math}.
+Note that while the throughput of the sequence is higher than the throughput
+of the non-reciprocal instruction, the precision of the sequence can be
+decreased by up to 2 ulp (i.e. the inverse of 1.0 equals 0.99999994).
+
+@item -mveclibabi=@var{type}
+@opindex mveclibabi
+Specifies the ABI type to use for vectorizing intrinsics using an
+external library.  Supported types are @code{svml} for the Intel short
+vector math library and @code{acml} for the AMD math core library style
+of interfacing.  GCC will currently emit calls to @code{vmldExp2},
+@code{vmldLn2}, @code{vmldLog102}, @code{vmldLog102}, @code{vmldPow2},
+@code{vmldTanh2}, @code{vmldTan2}, @code{vmldAtan2}, @code{vmldAtanh2},
+@code{vmldCbrt2}, @code{vmldSinh2}, @code{vmldSin2}, @code{vmldAsinh2},
+@code{vmldAsin2}, @code{vmldCosh2}, @code{vmldCos2}, @code{vmldAcosh2},
+@code{vmldAcos2}, @code{vmlsExp4}, @code{vmlsLn4}, @code{vmlsLog104},
+@code{vmlsLog104}, @code{vmlsPow4}, @code{vmlsTanh4}, @code{vmlsTan4},
+@code{vmlsAtan4}, @code{vmlsAtanh4}, @code{vmlsCbrt4}, @code{vmlsSinh4},
+@code{vmlsSin4}, @code{vmlsAsinh4}, @code{vmlsAsin4}, @code{vmlsCosh4},
+@code{vmlsCos4}, @code{vmlsAcosh4} and @code{vmlsAcos4} for corresponding
+function type when @option{-mveclibabi=svml} is used and @code{__vrd2_sin},
+@code{__vrd2_cos}, @code{__vrd2_exp}, @code{__vrd2_log}, @code{__vrd2_log2},
+@code{__vrd2_log10}, @code{__vrs4_sinf}, @code{__vrs4_cosf},
+@code{__vrs4_expf}, @code{__vrs4_logf}, @code{__vrs4_log2f},
+@code{__vrs4_log10f} and @code{__vrs4_powf} for corresponding function type
+when @option{-mveclibabi=acml} is used. Both @option{-ftree-vectorize} and
+@option{-funsafe-math-optimizations} have to be enabled. A SVML or ACML ABI
+compatible library will have to be specified at link time.
+
+@item -mpush-args
+@itemx -mno-push-args
+@opindex mpush-args
+@opindex mno-push-args
+Use PUSH operations to store outgoing parameters.  This method is shorter
+and usually equally fast as method using SUB/MOV operations and is enabled
+by default.  In some cases disabling it may improve performance because of
+improved scheduling and reduced dependencies.
+
+@item -maccumulate-outgoing-args
+@opindex maccumulate-outgoing-args
+If enabled, the maximum amount of space required for outgoing arguments will be
+computed in the function prologue.  This is faster on most modern CPUs
+because of reduced dependencies, improved scheduling and reduced stack usage
+when preferred stack boundary is not equal to 2.  The drawback is a notable
+increase in code size.  This switch implies @option{-mno-push-args}.
+
+@item -mthreads
+@opindex mthreads
+Support thread-safe exception handling on @samp{Mingw32}.  Code that relies
+on thread-safe exception handling must compile and link all code with the
+@option{-mthreads} option.  When compiling, @option{-mthreads} defines
+@option{-D_MT}; when linking, it links in a special thread helper library
+@option{-lmingwthrd} which cleans up per thread exception handling data.
+
+@item -mno-align-stringops
+@opindex mno-align-stringops
+Do not align destination of inlined string operations.  This switch reduces
+code size and improves performance in case the destination is already aligned,
+but GCC doesn't know about it.
+
+@item -minline-all-stringops
+@opindex minline-all-stringops
+By default GCC inlines string operations only when destination is known to be
+aligned at least to 4 byte boundary.  This enables more inlining, increase code
+size, but may improve performance of code that depends on fast memcpy, strlen
+and memset for short lengths.
+
+@item -minline-stringops-dynamically
+@opindex minline-stringops-dynamically
+For string operation of unknown size, inline runtime checks so for small
+blocks inline code is used, while for large blocks library call is used.
+
+@item -mstringop-strategy=@var{alg}
+@opindex mstringop-strategy=@var{alg}
+Overwrite internal decision heuristic about particular algorithm to inline
+string operation with.  The allowed values are @code{rep_byte},
+@code{rep_4byte}, @code{rep_8byte} for expanding using i386 @code{rep} prefix
+of specified size, @code{byte_loop}, @code{loop}, @code{unrolled_loop} for
+expanding inline loop, @code{libcall} for always expanding library call.
+
+@item -momit-leaf-frame-pointer
+@opindex momit-leaf-frame-pointer
+Don't keep the frame pointer in a register for leaf functions.  This
+avoids the instructions to save, set up and restore frame pointers and
+makes an extra register available in leaf functions.  The option
+@option{-fomit-frame-pointer} removes the frame pointer for all functions
+which might make debugging harder.
+
+@item -mtls-direct-seg-refs
+@itemx -mno-tls-direct-seg-refs
+@opindex mtls-direct-seg-refs
+Controls whether TLS variables may be accessed with offsets from the
+TLS segment register (@code{%gs} for 32-bit, @code{%fs} for 64-bit),
+or whether the thread base pointer must be added.  Whether or not this
+is legal depends on the operating system, and whether it maps the
+segment to cover the entire TLS area.
+
+For systems that use GNU libc, the default is on.
+
+@item -mfused-madd
+@itemx -mno-fused-madd
+@opindex mfused-madd
+Enable automatic generation of fused floating point multiply-add instructions
+if the ISA supports such instructions.  The -mfused-madd option is on by
+default.  The fused multiply-add instructions have a different
+rounding behavior compared to executing a multiply followed by an add.
+
+@item -msse2avx
+@itemx -mno-sse2avx
+@opindex msse2avx
+Specify that the assembler should encode SSE instructions with VEX
+prefix.  The option @option{-mavx} turns this on by default.
+@end table
+
+These @samp{-m} switches are supported in addition to the above
+on AMD x86-64 processors in 64-bit environments.
+
+@table @gcctabopt
+@item -m32
+@itemx -m64
+@opindex m32
+@opindex m64
+Generate code for a 32-bit or 64-bit environment.
+The 32-bit environment sets int, long and pointer to 32 bits and
+generates code that runs on any i386 system.
+The 64-bit environment sets int to 32 bits and long and pointer
+to 64 bits and generates code for AMD's x86-64 architecture. For
+darwin only the -m64 option turns off the @option{-fno-pic} and
+@option{-mdynamic-no-pic} options.
+
+@item -mno-red-zone
+@opindex no-red-zone
+Do not use a so called red zone for x86-64 code.  The red zone is mandated
+by the x86-64 ABI, it is a 128-byte area beyond the location of the
+stack pointer that will not be modified by signal or interrupt handlers
+and therefore can be used for temporary data without adjusting the stack
+pointer.  The flag @option{-mno-red-zone} disables this red zone.
+
+@item -mcmodel=small
+@opindex mcmodel=small
+Generate code for the small code model: the program and its symbols must
+be linked in the lower 2 GB of the address space.  Pointers are 64 bits.
+Programs can be statically or dynamically linked.  This is the default
+code model.
+
+@item -mcmodel=kernel
+@opindex mcmodel=kernel
+Generate code for the kernel code model.  The kernel runs in the
+negative 2 GB of the address space.
+This model has to be used for Linux kernel code.
+
+@item -mcmodel=medium
+@opindex mcmodel=medium
+Generate code for the medium model: The program is linked in the lower 2
+GB of the address space.  Small symbols are also placed there.  Symbols
+with sizes larger than @option{-mlarge-data-threshold} are put into
+large data or bss sections and can be located above 2GB.  Programs can
+be statically or dynamically linked.
+
+@item -mcmodel=large
+@opindex mcmodel=large
+Generate code for the large model: This model makes no assumptions
+about addresses and sizes of sections.
+@end table
+
+@node i386 and x86-64 Windows Options
+@subsection i386 and x86-64 Windows Options
+@cindex i386 and x86-64 Windows Options
+
+These additional options are available for Windows targets:
+
+@table @gcctabopt
+@item -mconsole
+@opindex mconsole
+This option is available for Cygwin and MinGW targets.  It
+specifies that a console application is to be generated, by
+instructing the linker to set the PE header subsystem type
+required for console applications.
+This is the default behaviour for Cygwin and MinGW targets.
+
+@item -mcygwin
+@opindex mcygwin
+This option is available for Cygwin targets.  It specifies that
+the Cygwin internal interface is to be used for predefined
+preprocessor macros, C runtime libraries and related linker
+paths and options.  For Cygwin targets this is the default behaviour.
+This option is deprecated and will be removed in a future release.
+
+@item -mno-cygwin
+@opindex mno-cygwin
+This option is available for Cygwin targets.  It specifies that
+the MinGW internal interface is to be used instead of Cygwin's, by
+setting MinGW-related predefined macros and linker paths and default
+library options.
+This option is deprecated and will be removed in a future release.
+
+@item -mdll
+@opindex mdll
+This option is available for Cygwin and MinGW targets.  It
+specifies that a DLL - a dynamic link library - is to be
+generated, enabling the selection of the required runtime
+startup object and entry point.
+
+@item -mnop-fun-dllimport
+@opindex mnop-fun-dllimport
+This option is available for Cygwin and MinGW targets.  It
+specifies that the dllimport attribute should be ignored.
+
+@item -mthread
+@opindex mthread
+This option is available for MinGW targets. It specifies
+that MinGW-specific thread support is to be used.
+
+@item -mwin32
+@opindex mwin32
+This option is available for Cygwin and MinGW targets.  It
+specifies that the typical Windows pre-defined macros are to
+be set in the pre-processor, but does not influence the choice
+of runtime library/startup code.
+
+@item -mwindows
+@opindex mwindows
+This option is available for Cygwin and MinGW targets.  It
+specifies that a GUI application is to be generated by
+instructing the linker to set the PE header subsystem type
+appropriately.
+@end table
+
+See also under @ref{i386 and x86-64 Options} for standard options.
+
+@node IA-64 Options
+@subsection IA-64 Options
+@cindex IA-64 Options
+
+These are the @samp{-m} options defined for the Intel IA-64 architecture.
+
+@table @gcctabopt
+@item -mbig-endian
+@opindex mbig-endian
+Generate code for a big endian target.  This is the default for HP-UX@.
+
+@item -mlittle-endian
+@opindex mlittle-endian
+Generate code for a little endian target.  This is the default for AIX5
+and GNU/Linux.
+
+@item -mgnu-as
+@itemx -mno-gnu-as
+@opindex mgnu-as
+@opindex mno-gnu-as
+Generate (or don't) code for the GNU assembler.  This is the default.
+@c Also, this is the default if the configure option @option{--with-gnu-as}
+@c is used.
+
+@item -mgnu-ld
+@itemx -mno-gnu-ld
+@opindex mgnu-ld
+@opindex mno-gnu-ld
+Generate (or don't) code for the GNU linker.  This is the default.
+@c Also, this is the default if the configure option @option{--with-gnu-ld}
+@c is used.
+
+@item -mno-pic
+@opindex mno-pic
+Generate code that does not use a global pointer register.  The result
+is not position independent code, and violates the IA-64 ABI@.
+
+@item -mvolatile-asm-stop
+@itemx -mno-volatile-asm-stop
+@opindex mvolatile-asm-stop
+@opindex mno-volatile-asm-stop
+Generate (or don't) a stop bit immediately before and after volatile asm
+statements.
+
+@item -mregister-names
+@itemx -mno-register-names
+@opindex mregister-names
+@opindex mno-register-names
+Generate (or don't) @samp{in}, @samp{loc}, and @samp{out} register names for
+the stacked registers.  This may make assembler output more readable.
+
+@item -mno-sdata
+@itemx -msdata
+@opindex mno-sdata
+@opindex msdata
+Disable (or enable) optimizations that use the small data section.  This may
+be useful for working around optimizer bugs.
+
+@item -mconstant-gp
+@opindex mconstant-gp
+Generate code that uses a single constant global pointer value.  This is
+useful when compiling kernel code.
+
+@item -mauto-pic
+@opindex mauto-pic
+Generate code that is self-relocatable.  This implies @option{-mconstant-gp}.
+This is useful when compiling firmware code.
+
+@item -minline-float-divide-min-latency
+@opindex minline-float-divide-min-latency
+Generate code for inline divides of floating point values
+using the minimum latency algorithm.
+
+@item -minline-float-divide-max-throughput
+@opindex minline-float-divide-max-throughput
+Generate code for inline divides of floating point values
+using the maximum throughput algorithm.
+
+@item -minline-int-divide-min-latency
+@opindex minline-int-divide-min-latency
+Generate code for inline divides of integer values
+using the minimum latency algorithm.
+
+@item -minline-int-divide-max-throughput
+@opindex minline-int-divide-max-throughput
+Generate code for inline divides of integer values
+using the maximum throughput algorithm.
+
+@item -minline-sqrt-min-latency
+@opindex minline-sqrt-min-latency
+Generate code for inline square roots
+using the minimum latency algorithm.
+
+@item -minline-sqrt-max-throughput
+@opindex minline-sqrt-max-throughput
+Generate code for inline square roots
+using the maximum throughput algorithm.
+
+@item -mno-dwarf2-asm
+@itemx -mdwarf2-asm
+@opindex mno-dwarf2-asm
+@opindex mdwarf2-asm
+Don't (or do) generate assembler code for the DWARF2 line number debugging
+info.  This may be useful when not using the GNU assembler.
+
+@item -mearly-stop-bits
+@itemx -mno-early-stop-bits
+@opindex mearly-stop-bits
+@opindex mno-early-stop-bits
+Allow stop bits to be placed earlier than immediately preceding the
+instruction that triggered the stop bit.  This can improve instruction
+scheduling, but does not always do so.
+
+@item -mfixed-range=@var{register-range}
+@opindex mfixed-range
+Generate code treating the given register range as fixed registers.
+A fixed register is one that the register allocator can not use.  This is
+useful when compiling kernel code.  A register range is specified as
+two registers separated by a dash.  Multiple register ranges can be
+specified separated by a comma.
+
+@item -mtls-size=@var{tls-size}
+@opindex mtls-size
+Specify bit size of immediate TLS offsets.  Valid values are 14, 22, and
+64.
+
+@item -mtune=@var{cpu-type}
+@opindex mtune
+Tune the instruction scheduling for a particular CPU, Valid values are
+itanium, itanium1, merced, itanium2, and mckinley.
+
+@item -mt
+@itemx -pthread
+@opindex mt
+@opindex pthread
+Add support for multithreading using the POSIX threads library.  This
+option sets flags for both the preprocessor and linker.  It does
+not affect the thread safety of object code produced by the compiler or
+that of libraries supplied with it.  These are HP-UX specific flags.
+
+@item -milp32
+@itemx -mlp64
+@opindex milp32
+@opindex mlp64
+Generate code for a 32-bit or 64-bit environment.
+The 32-bit environment sets int, long and pointer to 32 bits.
+The 64-bit environment sets int to 32 bits and long and pointer
+to 64 bits.  These are HP-UX specific flags.
+
+@item -mno-sched-br-data-spec
+@itemx -msched-br-data-spec
+@opindex mno-sched-br-data-spec
+@opindex msched-br-data-spec
+(Dis/En)able data speculative scheduling before reload.
+This will result in generation of the ld.a instructions and
+the corresponding check instructions (ld.c / chk.a).
+The default is 'disable'.
+
+@item -msched-ar-data-spec
+@itemx -mno-sched-ar-data-spec
+@opindex msched-ar-data-spec
+@opindex mno-sched-ar-data-spec
+(En/Dis)able data speculative scheduling after reload.
+This will result in generation of the ld.a instructions and
+the corresponding check instructions (ld.c / chk.a).
+The default is 'enable'.
+
+@item -mno-sched-control-spec
+@itemx -msched-control-spec
+@opindex mno-sched-control-spec
+@opindex msched-control-spec
+(Dis/En)able control speculative scheduling.  This feature is
+available only during region scheduling (i.e.@: before reload).
+This will result in generation of the ld.s instructions and
+the corresponding check instructions chk.s .
+The default is 'disable'.
+
+@item -msched-br-in-data-spec
+@itemx -mno-sched-br-in-data-spec
+@opindex msched-br-in-data-spec
+@opindex mno-sched-br-in-data-spec
+(En/Dis)able speculative scheduling of the instructions that
+are dependent on the data speculative loads before reload.
+This is effective only with @option{-msched-br-data-spec} enabled.
+The default is 'enable'.
+
+@item -msched-ar-in-data-spec
+@itemx -mno-sched-ar-in-data-spec
+@opindex msched-ar-in-data-spec
+@opindex mno-sched-ar-in-data-spec
+(En/Dis)able speculative scheduling of the instructions that
+are dependent on the data speculative loads after reload.
+This is effective only with @option{-msched-ar-data-spec} enabled.
+The default is 'enable'.
+
+@item -msched-in-control-spec
+@itemx -mno-sched-in-control-spec
+@opindex msched-in-control-spec
+@opindex mno-sched-in-control-spec
+(En/Dis)able speculative scheduling of the instructions that
+are dependent on the control speculative loads.
+This is effective only with @option{-msched-control-spec} enabled.
+The default is 'enable'.
+
+@item -msched-ldc
+@itemx -mno-sched-ldc
+@opindex msched-ldc
+@opindex mno-sched-ldc
+(En/Dis)able use of simple data speculation checks ld.c .
+If disabled, only chk.a instructions will be emitted to check
+data speculative loads.
+The default is 'enable'.
+
+@item -mno-sched-control-ldc
+@itemx -msched-control-ldc
+@opindex mno-sched-control-ldc
+@opindex msched-control-ldc
+(Dis/En)able use of ld.c instructions to check control speculative loads.
+If enabled, in case of control speculative load with no speculatively
+scheduled dependent instructions this load will be emitted as ld.sa and
+ld.c will be used to check it.
+The default is 'disable'.
+
+@item -mno-sched-spec-verbose
+@itemx -msched-spec-verbose
+@opindex mno-sched-spec-verbose
+@opindex msched-spec-verbose
+(Dis/En)able printing of the information about speculative motions.
+
+@item -mno-sched-prefer-non-data-spec-insns
+@itemx -msched-prefer-non-data-spec-insns
+@opindex mno-sched-prefer-non-data-spec-insns
+@opindex msched-prefer-non-data-spec-insns
+If enabled, data speculative instructions will be chosen for schedule
+only if there are no other choices at the moment.  This will make
+the use of the data speculation much more conservative.
+The default is 'disable'.
+
+@item -mno-sched-prefer-non-control-spec-insns
+@itemx -msched-prefer-non-control-spec-insns
+@opindex mno-sched-prefer-non-control-spec-insns
+@opindex msched-prefer-non-control-spec-insns
+If enabled, control speculative instructions will be chosen for schedule
+only if there are no other choices at the moment.  This will make
+the use of the control speculation much more conservative.
+The default is 'disable'.
+
+@item -mno-sched-count-spec-in-critical-path
+@itemx -msched-count-spec-in-critical-path
+@opindex mno-sched-count-spec-in-critical-path
+@opindex msched-count-spec-in-critical-path
+If enabled, speculative dependencies will be considered during
+computation of the instructions priorities.  This will make the use of the
+speculation a bit more conservative.
+The default is 'disable'.
+
+@end table
+
+@node M32C Options
+@subsection M32C Options
+@cindex M32C options
+
+@table @gcctabopt
+@item -mcpu=@var{name}
+@opindex mcpu=
+Select the CPU for which code is generated.  @var{name} may be one of
+@samp{r8c} for the R8C/Tiny series, @samp{m16c} for the M16C (up to
+/60) series, @samp{m32cm} for the M16C/80 series, or @samp{m32c} for
+the M32C/80 series.
+
+@item -msim
+@opindex msim
+Specifies that the program will be run on the simulator.  This causes
+an alternate runtime library to be linked in which supports, for
+example, file I/O@.  You must not use this option when generating
+programs that will run on real hardware; you must provide your own
+runtime library for whatever I/O functions are needed.
+
+@item -memregs=@var{number}
+@opindex memregs=
+Specifies the number of memory-based pseudo-registers GCC will use
+during code generation.  These pseudo-registers will be used like real
+registers, so there is a tradeoff between GCC's ability to fit the
+code into available registers, and the performance penalty of using
+memory instead of registers.  Note that all modules in a program must
+be compiled with the same value for this option.  Because of that, you
+must not use this option with the default runtime libraries gcc
+builds.
+
+@end table
+
+@node M32R/D Options
+@subsection M32R/D Options
+@cindex M32R/D options
+
+These @option{-m} options are defined for Renesas M32R/D architectures:
+
+@table @gcctabopt
+@item -m32r2
+@opindex m32r2
+Generate code for the M32R/2@.
+
+@item -m32rx
+@opindex m32rx
+Generate code for the M32R/X@.
+
+@item -m32r
+@opindex m32r
+Generate code for the M32R@.  This is the default.
+
+@item -mmodel=small
+@opindex mmodel=small
+Assume all objects live in the lower 16MB of memory (so that their addresses
+can be loaded with the @code{ld24} instruction), and assume all subroutines
+are reachable with the @code{bl} instruction.
+This is the default.
+
+The addressability of a particular object can be set with the
+@code{model} attribute.
+
+@item -mmodel=medium
+@opindex mmodel=medium
+Assume objects may be anywhere in the 32-bit address space (the compiler
+will generate @code{seth/add3} instructions to load their addresses), and
+assume all subroutines are reachable with the @code{bl} instruction.
+
+@item -mmodel=large
+@opindex mmodel=large
+Assume objects may be anywhere in the 32-bit address space (the compiler
+will generate @code{seth/add3} instructions to load their addresses), and
+assume subroutines may not be reachable with the @code{bl} instruction
+(the compiler will generate the much slower @code{seth/add3/jl}
+instruction sequence).
+
+@item -msdata=none
+@opindex msdata=none
+Disable use of the small data area.  Variables will be put into
+one of @samp{.data}, @samp{bss}, or @samp{.rodata} (unless the
+@code{section} attribute has been specified).
+This is the default.
+
+The small data area consists of sections @samp{.sdata} and @samp{.sbss}.
+Objects may be explicitly put in the small data area with the
+@code{section} attribute using one of these sections.
+
+@item -msdata=sdata
+@opindex msdata=sdata
+Put small global and static data in the small data area, but do not
+generate special code to reference them.
+
+@item -msdata=use
+@opindex msdata=use
+Put small global and static data in the small data area, and generate
+special instructions to reference them.
+
+@item -G @var{num}
+@opindex G
+@cindex smaller data references
+Put global and static objects less than or equal to @var{num} bytes
+into the small data or bss sections instead of the normal data or bss
+sections.  The default value of @var{num} is 8.
+The @option{-msdata} option must be set to one of @samp{sdata} or @samp{use}
+for this option to have any effect.
+
+All modules should be compiled with the same @option{-G @var{num}} value.
+Compiling with different values of @var{num} may or may not work; if it
+doesn't the linker will give an error message---incorrect code will not be
+generated.
+
+@item -mdebug
+@opindex mdebug
+Makes the M32R specific code in the compiler display some statistics
+that might help in debugging programs.
+
+@item -malign-loops
+@opindex malign-loops
+Align all loops to a 32-byte boundary.
+
+@item -mno-align-loops
+@opindex mno-align-loops
+Do not enforce a 32-byte alignment for loops.  This is the default.
+
+@item -missue-rate=@var{number}
+@opindex missue-rate=@var{number}
+Issue @var{number} instructions per cycle.  @var{number} can only be 1
+or 2.
+
+@item -mbranch-cost=@var{number}
+@opindex mbranch-cost=@var{number}
+@var{number} can only be 1 or 2.  If it is 1 then branches will be
+preferred over conditional code, if it is 2, then the opposite will
+apply.
+
+@item -mflush-trap=@var{number}
+@opindex mflush-trap=@var{number}
+Specifies the trap number to use to flush the cache.  The default is
+12.  Valid numbers are between 0 and 15 inclusive.
+
+@item -mno-flush-trap
+@opindex mno-flush-trap
+Specifies that the cache cannot be flushed by using a trap.
+
+@item -mflush-func=@var{name}
+@opindex mflush-func=@var{name}
+Specifies the name of the operating system function to call to flush
+the cache.  The default is @emph{_flush_cache}, but a function call
+will only be used if a trap is not available.
+
+@item -mno-flush-func
+@opindex mno-flush-func
+Indicates that there is no OS function for flushing the cache.
+
+@end table
+
+@node M680x0 Options
+@subsection M680x0 Options
+@cindex M680x0 options
+
+These are the @samp{-m} options defined for M680x0 and ColdFire processors.
+The default settings depend on which architecture was selected when
+the compiler was configured; the defaults for the most common choices
+are given below.
+
+@table @gcctabopt
+@item -march=@var{arch}
+@opindex march
+Generate code for a specific M680x0 or ColdFire instruction set
+architecture.  Permissible values of @var{arch} for M680x0
+architectures are: @samp{68000}, @samp{68010}, @samp{68020},
+@samp{68030}, @samp{68040}, @samp{68060} and @samp{cpu32}.  ColdFire
+architectures are selected according to Freescale's ISA classification
+and the permissible values are: @samp{isaa}, @samp{isaaplus},
+@samp{isab} and @samp{isac}.
+
+gcc defines a macro @samp{__mcf@var{arch}__} whenever it is generating
+code for a ColdFire target.  The @var{arch} in this macro is one of the
+@option{-march} arguments given above.
+
+When used together, @option{-march} and @option{-mtune} select code
+that runs on a family of similar processors but that is optimized
+for a particular microarchitecture.
+
+@item -mcpu=@var{cpu}
+@opindex mcpu
+Generate code for a specific M680x0 or ColdFire processor.
+The M680x0 @var{cpu}s are: @samp{68000}, @samp{68010}, @samp{68020},
+@samp{68030}, @samp{68040}, @samp{68060}, @samp{68302}, @samp{68332}
+and @samp{cpu32}.  The ColdFire @var{cpu}s are given by the table
+below, which also classifies the CPUs into families:
+
+@multitable @columnfractions 0.20 0.80
+@item @strong{Family} @tab @strong{@samp{-mcpu} arguments}
+@item @samp{51qe} @tab @samp{51qe}
+@item @samp{5206} @tab @samp{5202} @samp{5204} @samp{5206}
+@item @samp{5206e} @tab @samp{5206e}
+@item @samp{5208} @tab @samp{5207} @samp{5208}
+@item @samp{5211a} @tab @samp{5210a} @samp{5211a}
+@item @samp{5213} @tab @samp{5211} @samp{5212} @samp{5213}
+@item @samp{5216} @tab @samp{5214} @samp{5216}
+@item @samp{52235} @tab @samp{52230} @samp{52231} @samp{52232} @samp{52233} @samp{52234} @samp{52235}
+@item @samp{5225} @tab @samp{5224} @samp{5225}
+@item @samp{5235} @tab @samp{5232} @samp{5233} @samp{5234} @samp{5235} @samp{523x}
+@item @samp{5249} @tab @samp{5249}
+@item @samp{5250} @tab @samp{5250}
+@item @samp{5271} @tab @samp{5270} @samp{5271}
+@item @samp{5272} @tab @samp{5272}
+@item @samp{5275} @tab @samp{5274} @samp{5275}
+@item @samp{5282} @tab @samp{5280} @samp{5281} @samp{5282} @samp{528x}
+@item @samp{5307} @tab @samp{5307}
+@item @samp{5329} @tab @samp{5327} @samp{5328} @samp{5329} @samp{532x}
+@item @samp{5373} @tab @samp{5372} @samp{5373} @samp{537x}
+@item @samp{5407} @tab @samp{5407}
+@item @samp{5475} @tab @samp{5470} @samp{5471} @samp{5472} @samp{5473} @samp{5474} @samp{5475} @samp{547x} @samp{5480} @samp{5481} @samp{5482} @samp{5483} @samp{5484} @samp{5485}
+@end multitable
+
+@option{-mcpu=@var{cpu}} overrides @option{-march=@var{arch}} if
+@var{arch} is compatible with @var{cpu}.  Other combinations of
+@option{-mcpu} and @option{-march} are rejected.
+
+gcc defines the macro @samp{__mcf_cpu_@var{cpu}} when ColdFire target
+@var{cpu} is selected.  It also defines @samp{__mcf_family_@var{family}},
+where the value of @var{family} is given by the table above.
+
+@item -mtune=@var{tune}
+@opindex mtune
+Tune the code for a particular microarchitecture, within the
+constraints set by @option{-march} and @option{-mcpu}.
+The M680x0 microarchitectures are: @samp{68000}, @samp{68010},
+@samp{68020}, @samp{68030}, @samp{68040}, @samp{68060}
+and @samp{cpu32}.  The ColdFire microarchitectures
+are: @samp{cfv1}, @samp{cfv2}, @samp{cfv3}, @samp{cfv4} and @samp{cfv4e}.
+
+You can also use @option{-mtune=68020-40} for code that needs
+to run relatively well on 68020, 68030 and 68040 targets.
+@option{-mtune=68020-60} is similar but includes 68060 targets
+as well.  These two options select the same tuning decisions as
+@option{-m68020-40} and @option{-m68020-60} respectively.
+
+gcc defines the macros @samp{__mc@var{arch}} and @samp{__mc@var{arch}__}
+when tuning for 680x0 architecture @var{arch}.  It also defines
+@samp{mc@var{arch}} unless either @option{-ansi} or a non-GNU @option{-std}
+option is used.  If gcc is tuning for a range of architectures,
+as selected by @option{-mtune=68020-40} or @option{-mtune=68020-60},
+it defines the macros for every architecture in the range.
+
+gcc also defines the macro @samp{__m@var{uarch}__} when tuning for
+ColdFire microarchitecture @var{uarch}, where @var{uarch} is one
+of the arguments given above.
+
+@item -m68000
+@itemx -mc68000
+@opindex m68000
+@opindex mc68000
+Generate output for a 68000.  This is the default
+when the compiler is configured for 68000-based systems.
+It is equivalent to @option{-march=68000}.
+
+Use this option for microcontrollers with a 68000 or EC000 core,
+including the 68008, 68302, 68306, 68307, 68322, 68328 and 68356.
+
+@item -m68010
+@opindex m68010
+Generate output for a 68010.  This is the default
+when the compiler is configured for 68010-based systems.
+It is equivalent to @option{-march=68010}.
+
+@item -m68020
+@itemx -mc68020
+@opindex m68020
+@opindex mc68020
+Generate output for a 68020.  This is the default
+when the compiler is configured for 68020-based systems.
+It is equivalent to @option{-march=68020}.
+
+@item -m68030
+@opindex m68030
+Generate output for a 68030.  This is the default when the compiler is
+configured for 68030-based systems.  It is equivalent to
+@option{-march=68030}.
+
+@item -m68040
+@opindex m68040
+Generate output for a 68040.  This is the default when the compiler is
+configured for 68040-based systems.  It is equivalent to
+@option{-march=68040}.
+
+This option inhibits the use of 68881/68882 instructions that have to be
+emulated by software on the 68040.  Use this option if your 68040 does not
+have code to emulate those instructions.
+
+@item -m68060
+@opindex m68060
+Generate output for a 68060.  This is the default when the compiler is
+configured for 68060-based systems.  It is equivalent to
+@option{-march=68060}.
+
+This option inhibits the use of 68020 and 68881/68882 instructions that
+have to be emulated by software on the 68060.  Use this option if your 68060
+does not have code to emulate those instructions.
+
+@item -mcpu32
+@opindex mcpu32
+Generate output for a CPU32.  This is the default
+when the compiler is configured for CPU32-based systems.
+It is equivalent to @option{-march=cpu32}.
+
+Use this option for microcontrollers with a
+CPU32 or CPU32+ core, including the 68330, 68331, 68332, 68333, 68334,
+68336, 68340, 68341, 68349 and 68360.
+
+@item -m5200
+@opindex m5200
+Generate output for a 520X ColdFire CPU@.  This is the default
+when the compiler is configured for 520X-based systems.
+It is equivalent to @option{-mcpu=5206}, and is now deprecated
+in favor of that option.
+
+Use this option for microcontroller with a 5200 core, including
+the MCF5202, MCF5203, MCF5204 and MCF5206.
+
+@item -m5206e
+@opindex m5206e
+Generate output for a 5206e ColdFire CPU@.  The option is now
+deprecated in favor of the equivalent @option{-mcpu=5206e}.
+
+@item -m528x
+@opindex m528x
+Generate output for a member of the ColdFire 528X family.
+The option is now deprecated in favor of the equivalent
+@option{-mcpu=528x}.
+
+@item -m5307
+@opindex m5307
+Generate output for a ColdFire 5307 CPU@.  The option is now deprecated
+in favor of the equivalent @option{-mcpu=5307}.
+
+@item -m5407
+@opindex m5407
+Generate output for a ColdFire 5407 CPU@.  The option is now deprecated
+in favor of the equivalent @option{-mcpu=5407}.
+
+@item -mcfv4e
+@opindex mcfv4e
+Generate output for a ColdFire V4e family CPU (e.g.@: 547x/548x).
+This includes use of hardware floating point instructions.
+The option is equivalent to @option{-mcpu=547x}, and is now
+deprecated in favor of that option.
+
+@item -m68020-40
+@opindex m68020-40
+Generate output for a 68040, without using any of the new instructions.
+This results in code which can run relatively efficiently on either a
+68020/68881 or a 68030 or a 68040.  The generated code does use the
+68881 instructions that are emulated on the 68040.
+
+The option is equivalent to @option{-march=68020} @option{-mtune=68020-40}.
+
+@item -m68020-60
+@opindex m68020-60
+Generate output for a 68060, without using any of the new instructions.
+This results in code which can run relatively efficiently on either a
+68020/68881 or a 68030 or a 68040.  The generated code does use the
+68881 instructions that are emulated on the 68060.
+
+The option is equivalent to @option{-march=68020} @option{-mtune=68020-60}.
+
+@item -mhard-float
+@itemx -m68881
+@opindex mhard-float
+@opindex m68881
+Generate floating-point instructions.  This is the default for 68020
+and above, and for ColdFire devices that have an FPU@.  It defines the
+macro @samp{__HAVE_68881__} on M680x0 targets and @samp{__mcffpu__}
+on ColdFire targets.
+
+@item -msoft-float
+@opindex msoft-float
+Do not generate floating-point instructions; use library calls instead.
+This is the default for 68000, 68010, and 68832 targets.  It is also
+the default for ColdFire devices that have no FPU.
+
+@item -mdiv
+@itemx -mno-div
+@opindex mdiv
+@opindex mno-div
+Generate (do not generate) ColdFire hardware divide and remainder
+instructions.  If @option{-march} is used without @option{-mcpu},
+the default is ``on'' for ColdFire architectures and ``off'' for M680x0
+architectures.  Otherwise, the default is taken from the target CPU
+(either the default CPU, or the one specified by @option{-mcpu}).  For
+example, the default is ``off'' for @option{-mcpu=5206} and ``on'' for
+@option{-mcpu=5206e}.
+
+gcc defines the macro @samp{__mcfhwdiv__} when this option is enabled.
+
+@item -mshort
+@opindex mshort
+Consider type @code{int} to be 16 bits wide, like @code{short int}.
+Additionally, parameters passed on the stack are also aligned to a
+16-bit boundary even on targets whose API mandates promotion to 32-bit.
+
+@item -mno-short
+@opindex mno-short
+Do not consider type @code{int} to be 16 bits wide.  This is the default.
+
+@item -mnobitfield
+@itemx -mno-bitfield
+@opindex mnobitfield
+@opindex mno-bitfield
+Do not use the bit-field instructions.  The @option{-m68000}, @option{-mcpu32}
+and @option{-m5200} options imply @w{@option{-mnobitfield}}.
+
+@item -mbitfield
+@opindex mbitfield
+Do use the bit-field instructions.  The @option{-m68020} option implies
+@option{-mbitfield}.  This is the default if you use a configuration
+designed for a 68020.
+
+@item -mrtd
+@opindex mrtd
+Use a different function-calling convention, in which functions
+that take a fixed number of arguments return with the @code{rtd}
+instruction, which pops their arguments while returning.  This
+saves one instruction in the caller since there is no need to pop
+the arguments there.
+
+This calling convention is incompatible with the one normally
+used on Unix, so you cannot use it if you need to call libraries
+compiled with the Unix compiler.
+
+Also, you must provide function prototypes for all functions that
+take variable numbers of arguments (including @code{printf});
+otherwise incorrect code will be generated for calls to those
+functions.
+
+In addition, seriously incorrect code will result if you call a
+function with too many arguments.  (Normally, extra arguments are
+harmlessly ignored.)
+
+The @code{rtd} instruction is supported by the 68010, 68020, 68030,
+68040, 68060 and CPU32 processors, but not by the 68000 or 5200.
+
+@item -mno-rtd
+@opindex mno-rtd
+Do not use the calling conventions selected by @option{-mrtd}.
+This is the default.
+
+@item -malign-int
+@itemx -mno-align-int
+@opindex malign-int
+@opindex mno-align-int
+Control whether GCC aligns @code{int}, @code{long}, @code{long long},
+@code{float}, @code{double}, and @code{long double} variables on a 32-bit
+boundary (@option{-malign-int}) or a 16-bit boundary (@option{-mno-align-int}).
+Aligning variables on 32-bit boundaries produces code that runs somewhat
+faster on processors with 32-bit busses at the expense of more memory.
+
+@strong{Warning:} if you use the @option{-malign-int} switch, GCC will
+align structures containing the above types  differently than
+most published application binary interface specifications for the m68k.
+
+@item -mpcrel
+@opindex mpcrel
+Use the pc-relative addressing mode of the 68000 directly, instead of
+using a global offset table.  At present, this option implies @option{-fpic},
+allowing at most a 16-bit offset for pc-relative addressing.  @option{-fPIC} is
+not presently supported with @option{-mpcrel}, though this could be supported for
+68020 and higher processors.
+
+@item -mno-strict-align
+@itemx -mstrict-align
+@opindex mno-strict-align
+@opindex mstrict-align
+Do not (do) assume that unaligned memory references will be handled by
+the system.
+
+@item -msep-data
+Generate code that allows the data segment to be located in a different
+area of memory from the text segment.  This allows for execute in place in
+an environment without virtual memory management.  This option implies
+@option{-fPIC}.
+
+@item -mno-sep-data
+Generate code that assumes that the data segment follows the text segment.
+This is the default.
+
+@item -mid-shared-library
+Generate code that supports shared libraries via the library ID method.
+This allows for execute in place and shared libraries in an environment
+without virtual memory management.  This option implies @option{-fPIC}.
+
+@item -mno-id-shared-library
+Generate code that doesn't assume ID based shared libraries are being used.
+This is the default.
+
+@item -mshared-library-id=n
+Specified the identification number of the ID based shared library being
+compiled.  Specifying a value of 0 will generate more compact code, specifying
+other values will force the allocation of that number to the current
+library but is no more space or time efficient than omitting this option.
+
+@item -mxgot
+@itemx -mno-xgot
+@opindex mxgot
+@opindex mno-xgot
+When generating position-independent code for ColdFire, generate code
+that works if the GOT has more than 8192 entries.  This code is
+larger and slower than code generated without this option.  On M680x0
+processors, this option is not needed; @option{-fPIC} suffices.
+
+GCC normally uses a single instruction to load values from the GOT@.
+While this is relatively efficient, it only works if the GOT
+is smaller than about 64k.  Anything larger causes the linker
+to report an error such as:
+
+@cindex relocation truncated to fit (ColdFire)
+@smallexample
+relocation truncated to fit: R_68K_GOT16O foobar
+@end smallexample
+
+If this happens, you should recompile your code with @option{-mxgot}.
+It should then work with very large GOTs.  However, code generated with
+@option{-mxgot} is less efficient, since it takes 4 instructions to fetch
+the value of a global symbol.
+
+Note that some linkers, including newer versions of the GNU linker,
+can create multiple GOTs and sort GOT entries.  If you have such a linker,
+you should only need to use @option{-mxgot} when compiling a single
+object file that accesses more than 8192 GOT entries.  Very few do.
+
+These options have no effect unless GCC is generating
+position-independent code.
+
+@end table
+
+@node M68hc1x Options
+@subsection M68hc1x Options
+@cindex M68hc1x options
+
+These are the @samp{-m} options defined for the 68hc11 and 68hc12
+microcontrollers.  The default values for these options depends on
+which style of microcontroller was selected when the compiler was configured;
+the defaults for the most common choices are given below.
+
+@table @gcctabopt
+@item -m6811
+@itemx -m68hc11
+@opindex m6811
+@opindex m68hc11
+Generate output for a 68HC11.  This is the default
+when the compiler is configured for 68HC11-based systems.
+
+@item -m6812
+@itemx -m68hc12
+@opindex m6812
+@opindex m68hc12
+Generate output for a 68HC12.  This is the default
+when the compiler is configured for 68HC12-based systems.
+
+@item -m68S12
+@itemx -m68hcs12
+@opindex m68S12
+@opindex m68hcs12
+Generate output for a 68HCS12.
+
+@item -mauto-incdec
+@opindex mauto-incdec
+Enable the use of 68HC12 pre and post auto-increment and auto-decrement
+addressing modes.
+
+@item -minmax
+@itemx -nominmax
+@opindex minmax
+@opindex mnominmax
+Enable the use of 68HC12 min and max instructions.
+
+@item -mlong-calls
+@itemx -mno-long-calls
+@opindex mlong-calls
+@opindex mno-long-calls
+Treat all calls as being far away (near).  If calls are assumed to be
+far away, the compiler will use the @code{call} instruction to
+call a function and the @code{rtc} instruction for returning.
+
+@item -mshort
+@opindex mshort
+Consider type @code{int} to be 16 bits wide, like @code{short int}.
+
+@item -msoft-reg-count=@var{count}
+@opindex msoft-reg-count
+Specify the number of pseudo-soft registers which are used for the
+code generation.  The maximum number is 32.  Using more pseudo-soft
+register may or may not result in better code depending on the program.
+The default is 4 for 68HC11 and 2 for 68HC12.
+
+@end table
+
+@node MCore Options
+@subsection MCore Options
+@cindex MCore options
+
+These are the @samp{-m} options defined for the Motorola M*Core
+processors.
+
+@table @gcctabopt
+
+@item -mhardlit
+@itemx -mno-hardlit
+@opindex mhardlit
+@opindex mno-hardlit
+Inline constants into the code stream if it can be done in two
+instructions or less.
+
+@item -mdiv
+@itemx -mno-div
+@opindex mdiv
+@opindex mno-div
+Use the divide instruction.  (Enabled by default).
+
+@item -mrelax-immediate
+@itemx -mno-relax-immediate
+@opindex mrelax-immediate
+@opindex mno-relax-immediate
+Allow arbitrary sized immediates in bit operations.
+
+@item -mwide-bitfields
+@itemx -mno-wide-bitfields
+@opindex mwide-bitfields
+@opindex mno-wide-bitfields
+Always treat bit-fields as int-sized.
+
+@item -m4byte-functions
+@itemx -mno-4byte-functions
+@opindex m4byte-functions
+@opindex mno-4byte-functions
+Force all functions to be aligned to a four byte boundary.
+
+@item -mcallgraph-data
+@itemx -mno-callgraph-data
+@opindex mcallgraph-data
+@opindex mno-callgraph-data
+Emit callgraph information.
+
+@item -mslow-bytes
+@itemx -mno-slow-bytes
+@opindex mslow-bytes
+@opindex mno-slow-bytes
+Prefer word access when reading byte quantities.
+
+@item -mlittle-endian
+@itemx -mbig-endian
+@opindex mlittle-endian
+@opindex mbig-endian
+Generate code for a little endian target.
+
+@item -m210
+@itemx -m340
+@opindex m210
+@opindex m340
+Generate code for the 210 processor.
+
+@item -mno-lsim
+@opindex no-lsim
+Assume that run-time support has been provided and so omit the
+simulator library (@file{libsim.a)} from the linker command line.
+
+@item -mstack-increment=@var{size}
+@opindex mstack-increment
+Set the maximum amount for a single stack increment operation.  Large
+values can increase the speed of programs which contain functions
+that need a large amount of stack space, but they can also trigger a
+segmentation fault if the stack is extended too much.  The default
+value is 0x1000.
+
+@end table
+
+@node MIPS Options
+@subsection MIPS Options
+@cindex MIPS options
+
+@table @gcctabopt
+
+@item -EB
+@opindex EB
+Generate big-endian code.
+
+@item -EL
+@opindex EL
+Generate little-endian code.  This is the default for @samp{mips*el-*-*}
+configurations.
+
+@item -march=@var{arch}
+@opindex march
+Generate code that will run on @var{arch}, which can be the name of a
+generic MIPS ISA, or the name of a particular processor.
+The ISA names are:
+@samp{mips1}, @samp{mips2}, @samp{mips3}, @samp{mips4},
+@samp{mips32}, @samp{mips32r2}, @samp{mips64} and @samp{mips64r2}.
+The processor names are:
+@samp{4kc}, @samp{4km}, @samp{4kp}, @samp{4ksc},
+@samp{4kec}, @samp{4kem}, @samp{4kep}, @samp{4ksd},
+@samp{5kc}, @samp{5kf},
+@samp{20kc},
+@samp{24kc}, @samp{24kf2_1}, @samp{24kf1_1},
+@samp{24kec}, @samp{24kef2_1}, @samp{24kef1_1},
+@samp{34kc}, @samp{34kf2_1}, @samp{34kf1_1},
+@samp{74kc}, @samp{74kf2_1}, @samp{74kf1_1}, @samp{74kf3_2},
+@samp{loongson2e}, @samp{loongson2f},
+@samp{m4k},
+@samp{octeon},
+@samp{orion},
+@samp{r2000}, @samp{r3000}, @samp{r3900}, @samp{r4000}, @samp{r4400},
+@samp{r4600}, @samp{r4650}, @samp{r6000}, @samp{r8000},
+@samp{rm7000}, @samp{rm9000},
+@samp{r10000}, @samp{r12000}, @samp{r14000}, @samp{r16000},
+@samp{sb1},
+@samp{sr71000},
+@samp{vr4100}, @samp{vr4111}, @samp{vr4120}, @samp{vr4130}, @samp{vr4300},
+@samp{vr5000}, @samp{vr5400}, @samp{vr5500}
+and @samp{xlr}.
+The special value @samp{from-abi} selects the
+most compatible architecture for the selected ABI (that is,
+@samp{mips1} for 32-bit ABIs and @samp{mips3} for 64-bit ABIs)@.
+
+Native Linux/GNU toolchains also support the value @samp{native},
+which selects the best architecture option for the host processor.
+@option{-march=native} has no effect if GCC does not recognize
+the processor.
+
+In processor names, a final @samp{000} can be abbreviated as @samp{k}
+(for example, @samp{-march=r2k}).  Prefixes are optional, and
+@samp{vr} may be written @samp{r}.
+
+Names of the form @samp{@var{n}f2_1} refer to processors with
+FPUs clocked at half the rate of the core, names of the form
+@samp{@var{n}f1_1} refer to processors with FPUs clocked at the same
+rate as the core, and names of the form @samp{@var{n}f3_2} refer to
+processors with FPUs clocked a ratio of 3:2 with respect to the core.
+For compatibility reasons, @samp{@var{n}f} is accepted as a synonym
+for @samp{@var{n}f2_1} while @samp{@var{n}x} and @samp{@var{b}fx} are
+accepted as synonyms for @samp{@var{n}f1_1}.
+
+GCC defines two macros based on the value of this option.  The first
+is @samp{_MIPS_ARCH}, which gives the name of target architecture, as
+a string.  The second has the form @samp{_MIPS_ARCH_@var{foo}},
+where @var{foo} is the capitalized value of @samp{_MIPS_ARCH}@.
+For example, @samp{-march=r2000} will set @samp{_MIPS_ARCH}
+to @samp{"r2000"} and define the macro @samp{_MIPS_ARCH_R2000}.
+
+Note that the @samp{_MIPS_ARCH} macro uses the processor names given
+above.  In other words, it will have the full prefix and will not
+abbreviate @samp{000} as @samp{k}.  In the case of @samp{from-abi},
+the macro names the resolved architecture (either @samp{"mips1"} or
+@samp{"mips3"}).  It names the default architecture when no
+@option{-march} option is given.
+
+@item -mtune=@var{arch}
+@opindex mtune
+Optimize for @var{arch}.  Among other things, this option controls
+the way instructions are scheduled, and the perceived cost of arithmetic
+operations.  The list of @var{arch} values is the same as for
+@option{-march}.
+
+When this option is not used, GCC will optimize for the processor
+specified by @option{-march}.  By using @option{-march} and
+@option{-mtune} together, it is possible to generate code that will
+run on a family of processors, but optimize the code for one
+particular member of that family.
+
+@samp{-mtune} defines the macros @samp{_MIPS_TUNE} and
+@samp{_MIPS_TUNE_@var{foo}}, which work in the same way as the
+@samp{-march} ones described above.
+
+@item -mips1
+@opindex mips1
+Equivalent to @samp{-march=mips1}.
+
+@item -mips2
+@opindex mips2
+Equivalent to @samp{-march=mips2}.
+
+@item -mips3
+@opindex mips3
+Equivalent to @samp{-march=mips3}.
+
+@item -mips4
+@opindex mips4
+Equivalent to @samp{-march=mips4}.
+
+@item -mips32
+@opindex mips32
+Equivalent to @samp{-march=mips32}.
+
+@item -mips32r2
+@opindex mips32r2
+Equivalent to @samp{-march=mips32r2}.
+
+@item -mips64
+@opindex mips64
+Equivalent to @samp{-march=mips64}.
+
+@item -mips64r2
+@opindex mips64r2
+Equivalent to @samp{-march=mips64r2}.
+
+@item -mips16
+@itemx -mno-mips16
+@opindex mips16
+@opindex mno-mips16
+Generate (do not generate) MIPS16 code.  If GCC is targetting a
+MIPS32 or MIPS64 architecture, it will make use of the MIPS16e ASE@.
+
+MIPS16 code generation can also be controlled on a per-function basis
+by means of @code{mips16} and @code{nomips16} attributes.  
+@xref{Function Attributes}, for more information.
+
+@item -mflip-mips16
+@opindex mflip-mips16
+Generate MIPS16 code on alternating functions.  This option is provided
+for regression testing of mixed MIPS16/non-MIPS16 code generation, and is
+not intended for ordinary use in compiling user code.
+
+@item -minterlink-mips16
+@itemx -mno-interlink-mips16
+@opindex minterlink-mips16
+@opindex mno-interlink-mips16
+Require (do not require) that non-MIPS16 code be link-compatible with
+MIPS16 code.
+
+For example, non-MIPS16 code cannot jump directly to MIPS16 code;
+it must either use a call or an indirect jump.  @option{-minterlink-mips16}
+therefore disables direct jumps unless GCC knows that the target of the
+jump is not MIPS16.
+
+@item -mabi=32
+@itemx -mabi=o64
+@itemx -mabi=n32
+@itemx -mabi=64
+@itemx -mabi=eabi
+@opindex mabi=32
+@opindex mabi=o64
+@opindex mabi=n32
+@opindex mabi=64
+@opindex mabi=eabi
+Generate code for the given ABI@.
+
+Note that the EABI has a 32-bit and a 64-bit variant.  GCC normally
+generates 64-bit code when you select a 64-bit architecture, but you
+can use @option{-mgp32} to get 32-bit code instead.
+
+For information about the O64 ABI, see
+@w{@uref{http://gcc.gnu.org/projects/mipso64-abi.html}}.
+
+GCC supports a variant of the o32 ABI in which floating-point registers
+are 64 rather than 32 bits wide.  You can select this combination with
+@option{-mabi=32} @option{-mfp64}.  This ABI relies on the @samp{mthc1}
+and @samp{mfhc1} instructions and is therefore only supported for
+MIPS32R2 processors.
+
+The register assignments for arguments and return values remain the
+same, but each scalar value is passed in a single 64-bit register
+rather than a pair of 32-bit registers.  For example, scalar
+floating-point values are returned in @samp{$f0} only, not a
+@samp{$f0}/@samp{$f1} pair.  The set of call-saved registers also
+remains the same, but all 64 bits are saved.
+
+@item -mabicalls
+@itemx -mno-abicalls
+@opindex mabicalls
+@opindex mno-abicalls
+Generate (do not generate) code that is suitable for SVR4-style
+dynamic objects.  @option{-mabicalls} is the default for SVR4-based
+systems.
+
+@item -mshared
+@itemx -mno-shared
+Generate (do not generate) code that is fully position-independent,
+and that can therefore be linked into shared libraries.  This option
+only affects @option{-mabicalls}.
+
+All @option{-mabicalls} code has traditionally been position-independent,
+regardless of options like @option{-fPIC} and @option{-fpic}.  However,
+as an extension, the GNU toolchain allows executables to use absolute
+accesses for locally-binding symbols.  It can also use shorter GP
+initialization sequences and generate direct calls to locally-defined
+functions.  This mode is selected by @option{-mno-shared}.
+
+@option{-mno-shared} depends on binutils 2.16 or higher and generates
+objects that can only be linked by the GNU linker.  However, the option
+does not affect the ABI of the final executable; it only affects the ABI
+of relocatable objects.  Using @option{-mno-shared} will generally make
+executables both smaller and quicker.
+
+@option{-mshared} is the default.
+
+@item -mplt
+@itemx -mno-plt
+@opindex mplt
+@opindex mno-plt
+Assume (do not assume) that the static and dynamic linkers
+support PLTs and copy relocations.  This option only affects
+@samp{-mno-shared -mabicalls}.  For the n64 ABI, this option
+has no effect without @samp{-msym32}.
+
+You can make @option{-mplt} the default by configuring
+GCC with @option{--with-mips-plt}.  The default is
+@option{-mno-plt} otherwise.
+
+@item -mxgot
+@itemx -mno-xgot
+@opindex mxgot
+@opindex mno-xgot
+Lift (do not lift) the usual restrictions on the size of the global
+offset table.
+
+GCC normally uses a single instruction to load values from the GOT@.
+While this is relatively efficient, it will only work if the GOT
+is smaller than about 64k.  Anything larger will cause the linker
+to report an error such as:
+
+@cindex relocation truncated to fit (MIPS)
+@smallexample
+relocation truncated to fit: R_MIPS_GOT16 foobar
+@end smallexample
+
+If this happens, you should recompile your code with @option{-mxgot}.
+It should then work with very large GOTs, although it will also be
+less efficient, since it will take three instructions to fetch the
+value of a global symbol.
+
+Note that some linkers can create multiple GOTs.  If you have such a
+linker, you should only need to use @option{-mxgot} when a single object
+file accesses more than 64k's worth of GOT entries.  Very few do.
+
+These options have no effect unless GCC is generating position
+independent code.
+
+@item -mgp32
+@opindex mgp32
+Assume that general-purpose registers are 32 bits wide.
+
+@item -mgp64
+@opindex mgp64
+Assume that general-purpose registers are 64 bits wide.
+
+@item -mfp32
+@opindex mfp32
+Assume that floating-point registers are 32 bits wide.
+
+@item -mfp64
+@opindex mfp64
+Assume that floating-point registers are 64 bits wide.
+
+@item -mhard-float
+@opindex mhard-float
+Use floating-point coprocessor instructions.
+
+@item -msoft-float
+@opindex msoft-float
+Do not use floating-point coprocessor instructions.  Implement
+floating-point calculations using library calls instead.
+
+@item -msingle-float
+@opindex msingle-float
+Assume that the floating-point coprocessor only supports single-precision
+operations.
+
+@item -mdouble-float
+@opindex mdouble-float
+Assume that the floating-point coprocessor supports double-precision
+operations.  This is the default.
+
+@item -mllsc
+@itemx -mno-llsc
+@opindex mllsc
+@opindex mno-llsc
+Use (do not use) @samp{ll}, @samp{sc}, and @samp{sync} instructions to
+implement atomic memory built-in functions.  When neither option is
+specified, GCC will use the instructions if the target architecture
+supports them.
+
+@option{-mllsc} is useful if the runtime environment can emulate the
+instructions and @option{-mno-llsc} can be useful when compiling for
+nonstandard ISAs.  You can make either option the default by
+configuring GCC with @option{--with-llsc} and @option{--without-llsc}
+respectively.  @option{--with-llsc} is the default for some
+configurations; see the installation documentation for details.
+
+@item -mdsp
+@itemx -mno-dsp
+@opindex mdsp
+@opindex mno-dsp
+Use (do not use) revision 1 of the MIPS DSP ASE@.
+@xref{MIPS DSP Built-in Functions}.  This option defines the
+preprocessor macro @samp{__mips_dsp}.  It also defines
+@samp{__mips_dsp_rev} to 1.
+
+@item -mdspr2
+@itemx -mno-dspr2
+@opindex mdspr2
+@opindex mno-dspr2
+Use (do not use) revision 2 of the MIPS DSP ASE@.
+@xref{MIPS DSP Built-in Functions}.  This option defines the
+preprocessor macros @samp{__mips_dsp} and @samp{__mips_dspr2}.
+It also defines @samp{__mips_dsp_rev} to 2.
+
+@item -msmartmips
+@itemx -mno-smartmips
+@opindex msmartmips
+@opindex mno-smartmips
+Use (do not use) the MIPS SmartMIPS ASE.
+
+@item -mpaired-single
+@itemx -mno-paired-single
+@opindex mpaired-single
+@opindex mno-paired-single
+Use (do not use) paired-single floating-point instructions.
+@xref{MIPS Paired-Single Support}.  This option requires
+hardware floating-point support to be enabled.
+
+@item -mdmx
+@itemx -mno-mdmx
+@opindex mdmx
+@opindex mno-mdmx
+Use (do not use) MIPS Digital Media Extension instructions.
+This option can only be used when generating 64-bit code and requires
+hardware floating-point support to be enabled.
+
+@item -mips3d
+@itemx -mno-mips3d
+@opindex mips3d
+@opindex mno-mips3d
+Use (do not use) the MIPS-3D ASE@.  @xref{MIPS-3D Built-in Functions}.
+The option @option{-mips3d} implies @option{-mpaired-single}.
+
+@item -mmt
+@itemx -mno-mt
+@opindex mmt
+@opindex mno-mt
+Use (do not use) MT Multithreading instructions.
+
+@item -mlong64
+@opindex mlong64
+Force @code{long} types to be 64 bits wide.  See @option{-mlong32} for
+an explanation of the default and the way that the pointer size is
+determined.
+
+@item -mlong32
+@opindex mlong32
+Force @code{long}, @code{int}, and pointer types to be 32 bits wide.
+
+The default size of @code{int}s, @code{long}s and pointers depends on
+the ABI@.  All the supported ABIs use 32-bit @code{int}s.  The n64 ABI
+uses 64-bit @code{long}s, as does the 64-bit EABI; the others use
+32-bit @code{long}s.  Pointers are the same size as @code{long}s,
+or the same size as integer registers, whichever is smaller.
+
+@item -msym32
+@itemx -mno-sym32
+@opindex msym32
+@opindex mno-sym32
+Assume (do not assume) that all symbols have 32-bit values, regardless
+of the selected ABI@.  This option is useful in combination with
+@option{-mabi=64} and @option{-mno-abicalls} because it allows GCC
+to generate shorter and faster references to symbolic addresses.
+
+@item -G @var{num}
+@opindex G
+Put definitions of externally-visible data in a small data section
+if that data is no bigger than @var{num} bytes.  GCC can then access
+the data more efficiently; see @option{-mgpopt} for details.
+
+The default @option{-G} option depends on the configuration.
+
+@item -mlocal-sdata
+@itemx -mno-local-sdata
+@opindex mlocal-sdata
+@opindex mno-local-sdata
+Extend (do not extend) the @option{-G} behavior to local data too,
+such as to static variables in C@.  @option{-mlocal-sdata} is the
+default for all configurations.
+
+If the linker complains that an application is using too much small data,
+you might want to try rebuilding the less performance-critical parts with
+@option{-mno-local-sdata}.  You might also want to build large
+libraries with @option{-mno-local-sdata}, so that the libraries leave
+more room for the main program.
+
+@item -mextern-sdata
+@itemx -mno-extern-sdata
+@opindex mextern-sdata
+@opindex mno-extern-sdata
+Assume (do not assume) that externally-defined data will be in
+a small data section if that data is within the @option{-G} limit.
+@option{-mextern-sdata} is the default for all configurations.
+
+If you compile a module @var{Mod} with @option{-mextern-sdata} @option{-G
+@var{num}} @option{-mgpopt}, and @var{Mod} references a variable @var{Var}
+that is no bigger than @var{num} bytes, you must make sure that @var{Var}
+is placed in a small data section.  If @var{Var} is defined by another
+module, you must either compile that module with a high-enough
+@option{-G} setting or attach a @code{section} attribute to @var{Var}'s
+definition.  If @var{Var} is common, you must link the application
+with a high-enough @option{-G} setting.
+
+The easiest way of satisfying these restrictions is to compile
+and link every module with the same @option{-G} option.  However,
+you may wish to build a library that supports several different
+small data limits.  You can do this by compiling the library with
+the highest supported @option{-G} setting and additionally using
+@option{-mno-extern-sdata} to stop the library from making assumptions
+about externally-defined data.
+
+@item -mgpopt
+@itemx -mno-gpopt
+@opindex mgpopt
+@opindex mno-gpopt
+Use (do not use) GP-relative accesses for symbols that are known to be
+in a small data section; see @option{-G}, @option{-mlocal-sdata} and
+@option{-mextern-sdata}.  @option{-mgpopt} is the default for all
+configurations.
+
+@option{-mno-gpopt} is useful for cases where the @code{$gp} register
+might not hold the value of @code{_gp}.  For example, if the code is
+part of a library that might be used in a boot monitor, programs that
+call boot monitor routines will pass an unknown value in @code{$gp}.
+(In such situations, the boot monitor itself would usually be compiled
+with @option{-G0}.)
+
+@option{-mno-gpopt} implies @option{-mno-local-sdata} and
+@option{-mno-extern-sdata}.
+
+@item -membedded-data
+@itemx -mno-embedded-data
+@opindex membedded-data
+@opindex mno-embedded-data
+Allocate variables to the read-only data section first if possible, then
+next in the small data section if possible, otherwise in data.  This gives
+slightly slower code than the default, but reduces the amount of RAM required
+when executing, and thus may be preferred for some embedded systems.
+
+@item -muninit-const-in-rodata
+@itemx -mno-uninit-const-in-rodata
+@opindex muninit-const-in-rodata
+@opindex mno-uninit-const-in-rodata
+Put uninitialized @code{const} variables in the read-only data section.
+This option is only meaningful in conjunction with @option{-membedded-data}.
+
+@item -mcode-readable=@var{setting}
+@opindex mcode-readable
+Specify whether GCC may generate code that reads from executable sections.
+There are three possible settings:
+
+@table @gcctabopt
+@item -mcode-readable=yes
+Instructions may freely access executable sections.  This is the
+default setting.
+
+@item -mcode-readable=pcrel
+MIPS16 PC-relative load instructions can access executable sections,
+but other instructions must not do so.  This option is useful on 4KSc
+and 4KSd processors when the code TLBs have the Read Inhibit bit set.
+It is also useful on processors that can be configured to have a dual
+instruction/data SRAM interface and that, like the M4K, automatically
+redirect PC-relative loads to the instruction RAM.
+
+@item -mcode-readable=no
+Instructions must not access executable sections.  This option can be
+useful on targets that are configured to have a dual instruction/data
+SRAM interface but that (unlike the M4K) do not automatically redirect
+PC-relative loads to the instruction RAM.
+@end table
+
+@item -msplit-addresses
+@itemx -mno-split-addresses
+@opindex msplit-addresses
+@opindex mno-split-addresses
+Enable (disable) use of the @code{%hi()} and @code{%lo()} assembler
+relocation operators.  This option has been superseded by
+@option{-mexplicit-relocs} but is retained for backwards compatibility.
+
+@item -mexplicit-relocs
+@itemx -mno-explicit-relocs
+@opindex mexplicit-relocs
+@opindex mno-explicit-relocs
+Use (do not use) assembler relocation operators when dealing with symbolic
+addresses.  The alternative, selected by @option{-mno-explicit-relocs},
+is to use assembler macros instead.
+
+@option{-mexplicit-relocs} is the default if GCC was configured
+to use an assembler that supports relocation operators.
+
+@item -mcheck-zero-division
+@itemx -mno-check-zero-division
+@opindex mcheck-zero-division
+@opindex mno-check-zero-division
+Trap (do not trap) on integer division by zero.
+
+The default is @option{-mcheck-zero-division}.
+
+@item -mdivide-traps
+@itemx -mdivide-breaks
+@opindex mdivide-traps
+@opindex mdivide-breaks
+MIPS systems check for division by zero by generating either a
+conditional trap or a break instruction.  Using traps results in
+smaller code, but is only supported on MIPS II and later.  Also, some
+versions of the Linux kernel have a bug that prevents trap from
+generating the proper signal (@code{SIGFPE}).  Use @option{-mdivide-traps} to
+allow conditional traps on architectures that support them and
+@option{-mdivide-breaks} to force the use of breaks.
+
+The default is usually @option{-mdivide-traps}, but this can be
+overridden at configure time using @option{--with-divide=breaks}.
+Divide-by-zero checks can be completely disabled using
+@option{-mno-check-zero-division}.
+
+@item -mmemcpy
+@itemx -mno-memcpy
+@opindex mmemcpy
+@opindex mno-memcpy
+Force (do not force) the use of @code{memcpy()} for non-trivial block
+moves.  The default is @option{-mno-memcpy}, which allows GCC to inline
+most constant-sized copies.
+
+@item -mlong-calls
+@itemx -mno-long-calls
+@opindex mlong-calls
+@opindex mno-long-calls
+Disable (do not disable) use of the @code{jal} instruction.  Calling
+functions using @code{jal} is more efficient but requires the caller
+and callee to be in the same 256 megabyte segment.
+
+This option has no effect on abicalls code.  The default is
+@option{-mno-long-calls}.
+
+@item -mmad
+@itemx -mno-mad
+@opindex mmad
+@opindex mno-mad
+Enable (disable) use of the @code{mad}, @code{madu} and @code{mul}
+instructions, as provided by the R4650 ISA@.
+
+@item -mfused-madd
+@itemx -mno-fused-madd
+@opindex mfused-madd
+@opindex mno-fused-madd
+Enable (disable) use of the floating point multiply-accumulate
+instructions, when they are available.  The default is
+@option{-mfused-madd}.
+
+When multiply-accumulate instructions are used, the intermediate
+product is calculated to infinite precision and is not subject to
+the FCSR Flush to Zero bit.  This may be undesirable in some
+circumstances.
+
+@item -nocpp
+@opindex nocpp
+Tell the MIPS assembler to not run its preprocessor over user
+assembler files (with a @samp{.s} suffix) when assembling them.
+
+@item -mfix-r4000
+@itemx -mno-fix-r4000
+@opindex mfix-r4000
+@opindex mno-fix-r4000
+Work around certain R4000 CPU errata:
+@itemize @minus
+@item
+A double-word or a variable shift may give an incorrect result if executed
+immediately after starting an integer division.
+@item
+A double-word or a variable shift may give an incorrect result if executed
+while an integer multiplication is in progress.
+@item
+An integer division may give an incorrect result if started in a delay slot
+of a taken branch or a jump.
+@end itemize
+
+@item -mfix-r4400
+@itemx -mno-fix-r4400
+@opindex mfix-r4400
+@opindex mno-fix-r4400
+Work around certain R4400 CPU errata:
+@itemize @minus
+@item
+A double-word or a variable shift may give an incorrect result if executed
+immediately after starting an integer division.
+@end itemize
+
+@item -mfix-r10000
+@itemx -mno-fix-r10000
+@opindex mfix-r10000
+@opindex mno-fix-r10000
+Work around certain R10000 errata:
+@itemize @minus
+@item
+@code{ll}/@code{sc} sequences may not behave atomically on revisions
+prior to 3.0.  They may deadlock on revisions 2.6 and earlier.
+@end itemize
+
+This option can only be used if the target architecture supports
+branch-likely instructions.  @option{-mfix-r10000} is the default when
+@option{-march=r10000} is used; @option{-mno-fix-r10000} is the default
+otherwise.
+
+@item -mfix-vr4120
+@itemx -mno-fix-vr4120
+@opindex mfix-vr4120
+Work around certain VR4120 errata:
+@itemize @minus
+@item
+@code{dmultu} does not always produce the correct result.
+@item
+@code{div} and @code{ddiv} do not always produce the correct result if one
+of the operands is negative.
+@end itemize
+The workarounds for the division errata rely on special functions in
+@file{libgcc.a}.  At present, these functions are only provided by
+the @code{mips64vr*-elf} configurations.
+
+Other VR4120 errata require a nop to be inserted between certain pairs of
+instructions.  These errata are handled by the assembler, not by GCC itself.
+
+@item -mfix-vr4130
+@opindex mfix-vr4130
+Work around the VR4130 @code{mflo}/@code{mfhi} errata.  The
+workarounds are implemented by the assembler rather than by GCC,
+although GCC will avoid using @code{mflo} and @code{mfhi} if the
+VR4130 @code{macc}, @code{macchi}, @code{dmacc} and @code{dmacchi}
+instructions are available instead.
+
+@item -mfix-sb1
+@itemx -mno-fix-sb1
+@opindex mfix-sb1
+Work around certain SB-1 CPU core errata.
+(This flag currently works around the SB-1 revision 2
+``F1'' and ``F2'' floating point errata.)
+
+@item -mr10k-cache-barrier=@var{setting}
+@opindex mr10k-cache-barrier
+Specify whether GCC should insert cache barriers to avoid the
+side-effects of speculation on R10K processors.
+
+In common with many processors, the R10K tries to predict the outcome
+of a conditional branch and speculatively executes instructions from
+the ``taken'' branch.  It later aborts these instructions if the
+predicted outcome was wrong.  However, on the R10K, even aborted
+instructions can have side effects.
+
+This problem only affects kernel stores and, depending on the system,
+kernel loads.  As an example, a speculatively-executed store may load
+the target memory into cache and mark the cache line as dirty, even if
+the store itself is later aborted.  If a DMA operation writes to the
+same area of memory before the ``dirty'' line is flushed, the cached
+data will overwrite the DMA-ed data.  See the R10K processor manual
+for a full description, including other potential problems.
+
+One workaround is to insert cache barrier instructions before every memory
+access that might be speculatively executed and that might have side
+effects even if aborted.  @option{-mr10k-cache-barrier=@var{setting}}
+controls GCC's implementation of this workaround.  It assumes that
+aborted accesses to any byte in the following regions will not have
+side effects:
+
+@enumerate
+@item
+the memory occupied by the current function's stack frame;
+
+@item
+the memory occupied by an incoming stack argument;
+
+@item
+the memory occupied by an object with a link-time-constant address.
+@end enumerate
+
+It is the kernel's responsibility to ensure that speculative
+accesses to these regions are indeed safe.
+
+If the input program contains a function declaration such as:
+
+@smallexample
+void foo (void);
+@end smallexample
+
+then the implementation of @code{foo} must allow @code{j foo} and
+@code{jal foo} to be executed speculatively.  GCC honors this
+restriction for functions it compiles itself.  It expects non-GCC
+functions (such as hand-written assembly code) to do the same.
+
+The option has three forms:
+
+@table @gcctabopt
+@item -mr10k-cache-barrier=load-store
+Insert a cache barrier before a load or store that might be
+speculatively executed and that might have side effects even
+if aborted.
+
+@item -mr10k-cache-barrier=store
+Insert a cache barrier before a store that might be speculatively
+executed and that might have side effects even if aborted.
+
+@item -mr10k-cache-barrier=none
+Disable the insertion of cache barriers.  This is the default setting.
+@end table
+
+@item -mflush-func=@var{func}
+@itemx -mno-flush-func
+@opindex mflush-func
+Specifies the function to call to flush the I and D caches, or to not
+call any such function.  If called, the function must take the same
+arguments as the common @code{_flush_func()}, that is, the address of the
+memory range for which the cache is being flushed, the size of the
+memory range, and the number 3 (to flush both caches).  The default
+depends on the target GCC was configured for, but commonly is either
+@samp{_flush_func} or @samp{__cpu_flush}.
+
+@item mbranch-cost=@var{num}
+@opindex mbranch-cost
+Set the cost of branches to roughly @var{num} ``simple'' instructions.
+This cost is only a heuristic and is not guaranteed to produce
+consistent results across releases.  A zero cost redundantly selects
+the default, which is based on the @option{-mtune} setting.
+
+@item -mbranch-likely
+@itemx -mno-branch-likely
+@opindex mbranch-likely
+@opindex mno-branch-likely
+Enable or disable use of Branch Likely instructions, regardless of the
+default for the selected architecture.  By default, Branch Likely
+instructions may be generated if they are supported by the selected
+architecture.  An exception is for the MIPS32 and MIPS64 architectures
+and processors which implement those architectures; for those, Branch
+Likely instructions will not be generated by default because the MIPS32
+and MIPS64 architectures specifically deprecate their use.
+
+@item -mfp-exceptions
+@itemx -mno-fp-exceptions
+@opindex mfp-exceptions
+Specifies whether FP exceptions are enabled.  This affects how we schedule
+FP instructions for some processors.  The default is that FP exceptions are
+enabled.
+
+For instance, on the SB-1, if FP exceptions are disabled, and we are emitting
+64-bit code, then we can use both FP pipes.  Otherwise, we can only use one
+FP pipe.
+
+@item -mvr4130-align
+@itemx -mno-vr4130-align
+@opindex mvr4130-align
+The VR4130 pipeline is two-way superscalar, but can only issue two
+instructions together if the first one is 8-byte aligned.  When this
+option is enabled, GCC will align pairs of instructions that it
+thinks should execute in parallel.
+
+This option only has an effect when optimizing for the VR4130.
+It normally makes code faster, but at the expense of making it bigger.
+It is enabled by default at optimization level @option{-O3}.
+@end table
+
+@node MMIX Options
+@subsection MMIX Options
+@cindex MMIX Options
+
+These options are defined for the MMIX:
+
+@table @gcctabopt
+@item -mlibfuncs
+@itemx -mno-libfuncs
+@opindex mlibfuncs
+@opindex mno-libfuncs
+Specify that intrinsic library functions are being compiled, passing all
+values in registers, no matter the size.
+
+@item -mepsilon
+@itemx -mno-epsilon
+@opindex mepsilon
+@opindex mno-epsilon
+Generate floating-point comparison instructions that compare with respect
+to the @code{rE} epsilon register.
+
+@item -mabi=mmixware
+@itemx -mabi=gnu
+@opindex mabi-mmixware
+@opindex mabi=gnu
+Generate code that passes function parameters and return values that (in
+the called function) are seen as registers @code{$0} and up, as opposed to
+the GNU ABI which uses global registers @code{$231} and up.
+
+@item -mzero-extend
+@itemx -mno-zero-extend
+@opindex mzero-extend
+@opindex mno-zero-extend
+When reading data from memory in sizes shorter than 64 bits, use (do not
+use) zero-extending load instructions by default, rather than
+sign-extending ones.
+
+@item -mknuthdiv
+@itemx -mno-knuthdiv
+@opindex mknuthdiv
+@opindex mno-knuthdiv
+Make the result of a division yielding a remainder have the same sign as
+the divisor.  With the default, @option{-mno-knuthdiv}, the sign of the
+remainder follows the sign of the dividend.  Both methods are
+arithmetically valid, the latter being almost exclusively used.
+
+@item -mtoplevel-symbols
+@itemx -mno-toplevel-symbols
+@opindex mtoplevel-symbols
+@opindex mno-toplevel-symbols
+Prepend (do not prepend) a @samp{:} to all global symbols, so the assembly
+code can be used with the @code{PREFIX} assembly directive.
+
+@item -melf
+@opindex melf
+Generate an executable in the ELF format, rather than the default
+@samp{mmo} format used by the @command{mmix} simulator.
+
+@item -mbranch-predict
+@itemx -mno-branch-predict
+@opindex mbranch-predict
+@opindex mno-branch-predict
+Use (do not use) the probable-branch instructions, when static branch
+prediction indicates a probable branch.
+
+@item -mbase-addresses
+@itemx -mno-base-addresses
+@opindex mbase-addresses
+@opindex mno-base-addresses
+Generate (do not generate) code that uses @emph{base addresses}.  Using a
+base address automatically generates a request (handled by the assembler
+and the linker) for a constant to be set up in a global register.  The
+register is used for one or more base address requests within the range 0
+to 255 from the value held in the register.  The generally leads to short
+and fast code, but the number of different data items that can be
+addressed is limited.  This means that a program that uses lots of static
+data may require @option{-mno-base-addresses}.
+
+@item -msingle-exit
+@itemx -mno-single-exit
+@opindex msingle-exit
+@opindex mno-single-exit
+Force (do not force) generated code to have a single exit point in each
+function.
+@end table
+
+@node MN10300 Options
+@subsection MN10300 Options
+@cindex MN10300 options
+
+These @option{-m} options are defined for Matsushita MN10300 architectures:
+
+@table @gcctabopt
+@item -mmult-bug
+@opindex mmult-bug
+Generate code to avoid bugs in the multiply instructions for the MN10300
+processors.  This is the default.
+
+@item -mno-mult-bug
+@opindex mno-mult-bug
+Do not generate code to avoid bugs in the multiply instructions for the
+MN10300 processors.
+
+@item -mam33
+@opindex mam33
+Generate code which uses features specific to the AM33 processor.
+
+@item -mno-am33
+@opindex mno-am33
+Do not generate code which uses features specific to the AM33 processor.  This
+is the default.
+
+@item -mreturn-pointer-on-d0
+@opindex mreturn-pointer-on-d0
+When generating a function which returns a pointer, return the pointer
+in both @code{a0} and @code{d0}.  Otherwise, the pointer is returned
+only in a0, and attempts to call such functions without a prototype
+would result in errors.  Note that this option is on by default; use
+@option{-mno-return-pointer-on-d0} to disable it.
+
+@item -mno-crt0
+@opindex mno-crt0
+Do not link in the C run-time initialization object file.
+
+@item -mrelax
+@opindex mrelax
+Indicate to the linker that it should perform a relaxation optimization pass
+to shorten branches, calls and absolute memory addresses.  This option only
+has an effect when used on the command line for the final link step.
+
+This option makes symbolic debugging impossible.
+@end table
+
+@node PDP-11 Options
+@subsection PDP-11 Options
+@cindex PDP-11 Options
+
+These options are defined for the PDP-11:
+
+@table @gcctabopt
+@item -mfpu
+@opindex mfpu
+Use hardware FPP floating point.  This is the default.  (FIS floating
+point on the PDP-11/40 is not supported.)
+
+@item -msoft-float
+@opindex msoft-float
+Do not use hardware floating point.
+
+@item -mac0
+@opindex mac0
+Return floating-point results in ac0 (fr0 in Unix assembler syntax).
+
+@item -mno-ac0
+@opindex mno-ac0
+Return floating-point results in memory.  This is the default.
+
+@item -m40
+@opindex m40
+Generate code for a PDP-11/40.
+
+@item -m45
+@opindex m45
+Generate code for a PDP-11/45.  This is the default.
+
+@item -m10
+@opindex m10
+Generate code for a PDP-11/10.
+
+@item -mbcopy-builtin
+@opindex bcopy-builtin
+Use inline @code{movmemhi} patterns for copying memory.  This is the
+default.
+
+@item -mbcopy
+@opindex mbcopy
+Do not use inline @code{movmemhi} patterns for copying memory.
+
+@item -mint16
+@itemx -mno-int32
+@opindex mint16
+@opindex mno-int32
+Use 16-bit @code{int}.  This is the default.
+
+@item -mint32
+@itemx -mno-int16
+@opindex mint32
+@opindex mno-int16
+Use 32-bit @code{int}.
+
+@item -mfloat64
+@itemx -mno-float32
+@opindex mfloat64
+@opindex mno-float32
+Use 64-bit @code{float}.  This is the default.
+
+@item -mfloat32
+@itemx -mno-float64
+@opindex mfloat32
+@opindex mno-float64
+Use 32-bit @code{float}.
+
+@item -mabshi
+@opindex mabshi
+Use @code{abshi2} pattern.  This is the default.
+
+@item -mno-abshi
+@opindex mno-abshi
+Do not use @code{abshi2} pattern.
+
+@item -mbranch-expensive
+@opindex mbranch-expensive
+Pretend that branches are expensive.  This is for experimenting with
+code generation only.
+
+@item -mbranch-cheap
+@opindex mbranch-cheap
+Do not pretend that branches are expensive.  This is the default.
+
+@item -msplit
+@opindex msplit
+Generate code for a system with split I&D@.
+
+@item -mno-split
+@opindex mno-split
+Generate code for a system without split I&D@.  This is the default.
+
+@item -munix-asm
+@opindex munix-asm
+Use Unix assembler syntax.  This is the default when configured for
+@samp{pdp11-*-bsd}.
+
+@item -mdec-asm
+@opindex mdec-asm
+Use DEC assembler syntax.  This is the default when configured for any
+PDP-11 target other than @samp{pdp11-*-bsd}.
+@end table
+
+@node picoChip Options
+@subsection picoChip Options
+@cindex picoChip options
+
+These @samp{-m} options are defined for picoChip implementations:
+
+@table @gcctabopt
+
+@item -mae=@var{ae_type}
+@opindex mcpu
+Set the instruction set, register set, and instruction scheduling
+parameters for array element type @var{ae_type}.  Supported values
+for @var{ae_type} are @samp{ANY}, @samp{MUL}, and @samp{MAC}.
+
+@option{-mae=ANY} selects a completely generic AE type.  Code
+generated with this option will run on any of the other AE types.  The
+code will not be as efficient as it would be if compiled for a specific
+AE type, and some types of operation (e.g., multiplication) will not
+work properly on all types of AE.
+
+@option{-mae=MUL} selects a MUL AE type.  This is the most useful AE type
+for compiled code, and is the default.
+
+@option{-mae=MAC} selects a DSP-style MAC AE.  Code compiled with this
+option may suffer from poor performance of byte (char) manipulation,
+since the DSP AE does not provide hardware support for byte load/stores.
+
+@item -msymbol-as-address
+Enable the compiler to directly use a symbol name as an address in a
+load/store instruction, without first loading it into a
+register.  Typically, the use of this option will generate larger
+programs, which run faster than when the option isn't used.  However, the
+results vary from program to program, so it is left as a user option,
+rather than being permanently enabled.
+
+@item -mno-inefficient-warnings
+Disables warnings about the generation of inefficient code.  These
+warnings can be generated, for example, when compiling code which
+performs byte-level memory operations on the MAC AE type.  The MAC AE has
+no hardware support for byte-level memory operations, so all byte
+load/stores must be synthesized from word load/store operations.  This is
+inefficient and a warning will be generated indicating to the programmer
+that they should rewrite the code to avoid byte operations, or to target
+an AE type which has the necessary hardware support.  This option enables
+the warning to be turned off.
+
+@end table
+
+@node PowerPC Options
+@subsection PowerPC Options
+@cindex PowerPC options
+
+These are listed under @xref{RS/6000 and PowerPC Options}.
+
+@node RS/6000 and PowerPC Options
+@subsection IBM RS/6000 and PowerPC Options
+@cindex RS/6000 and PowerPC Options
+@cindex IBM RS/6000 and PowerPC Options
+
+These @samp{-m} options are defined for the IBM RS/6000 and PowerPC:
+@table @gcctabopt
+@item -mpower
+@itemx -mno-power
+@itemx -mpower2
+@itemx -mno-power2
+@itemx -mpowerpc
+@itemx -mno-powerpc
+@itemx -mpowerpc-gpopt
+@itemx -mno-powerpc-gpopt
+@itemx -mpowerpc-gfxopt
+@itemx -mno-powerpc-gfxopt
+@itemx -mpowerpc64
+@itemx -mno-powerpc64
+@itemx -mmfcrf
+@itemx -mno-mfcrf
+@itemx -mpopcntb
+@itemx -mno-popcntb
+@itemx -mfprnd
+@itemx -mno-fprnd
+@itemx -mcmpb
+@itemx -mno-cmpb
+@itemx -mmfpgpr
+@itemx -mno-mfpgpr
+@itemx -mhard-dfp
+@itemx -mno-hard-dfp
+@opindex mpower
+@opindex mno-power
+@opindex mpower2
+@opindex mno-power2
+@opindex mpowerpc
+@opindex mno-powerpc
+@opindex mpowerpc-gpopt
+@opindex mno-powerpc-gpopt
+@opindex mpowerpc-gfxopt
+@opindex mno-powerpc-gfxopt
+@opindex mpowerpc64
+@opindex mno-powerpc64
+@opindex mmfcrf
+@opindex mno-mfcrf
+@opindex mpopcntb
+@opindex mno-popcntb
+@opindex mfprnd
+@opindex mno-fprnd
+@opindex mcmpb
+@opindex mno-cmpb
+@opindex mmfpgpr
+@opindex mno-mfpgpr
+@opindex mhard-dfp
+@opindex mno-hard-dfp
+GCC supports two related instruction set architectures for the
+RS/6000 and PowerPC@.  The @dfn{POWER} instruction set are those
+instructions supported by the @samp{rios} chip set used in the original
+RS/6000 systems and the @dfn{PowerPC} instruction set is the
+architecture of the Freescale MPC5xx, MPC6xx, MPC8xx microprocessors, and
+the IBM 4xx, 6xx, and follow-on microprocessors.
+
+Neither architecture is a subset of the other.  However there is a
+large common subset of instructions supported by both.  An MQ
+register is included in processors supporting the POWER architecture.
+
+You use these options to specify which instructions are available on the
+processor you are using.  The default value of these options is
+determined when configuring GCC@.  Specifying the
+@option{-mcpu=@var{cpu_type}} overrides the specification of these
+options.  We recommend you use the @option{-mcpu=@var{cpu_type}} option
+rather than the options listed above.
+
+The @option{-mpower} option allows GCC to generate instructions that
+are found only in the POWER architecture and to use the MQ register.
+Specifying @option{-mpower2} implies @option{-power} and also allows GCC
+to generate instructions that are present in the POWER2 architecture but
+not the original POWER architecture.
+
+The @option{-mpowerpc} option allows GCC to generate instructions that
+are found only in the 32-bit subset of the PowerPC architecture.
+Specifying @option{-mpowerpc-gpopt} implies @option{-mpowerpc} and also allows
+GCC to use the optional PowerPC architecture instructions in the
+General Purpose group, including floating-point square root.  Specifying
+@option{-mpowerpc-gfxopt} implies @option{-mpowerpc} and also allows GCC to
+use the optional PowerPC architecture instructions in the Graphics
+group, including floating-point select.
+
+The @option{-mmfcrf} option allows GCC to generate the move from
+condition register field instruction implemented on the POWER4
+processor and other processors that support the PowerPC V2.01
+architecture.
+The @option{-mpopcntb} option allows GCC to generate the popcount and
+double precision FP reciprocal estimate instruction implemented on the
+POWER5 processor and other processors that support the PowerPC V2.02
+architecture.
+The @option{-mfprnd} option allows GCC to generate the FP round to
+integer instructions implemented on the POWER5+ processor and other
+processors that support the PowerPC V2.03 architecture.
+The @option{-mcmpb} option allows GCC to generate the compare bytes
+instruction implemented on the POWER6 processor and other processors
+that support the PowerPC V2.05 architecture.
+The @option{-mmfpgpr} option allows GCC to generate the FP move to/from
+general purpose register instructions implemented on the POWER6X
+processor and other processors that support the extended PowerPC V2.05
+architecture.
+The @option{-mhard-dfp} option allows GCC to generate the decimal floating
+point instructions implemented on some POWER processors.
+
+The @option{-mpowerpc64} option allows GCC to generate the additional
+64-bit instructions that are found in the full PowerPC64 architecture
+and to treat GPRs as 64-bit, doubleword quantities.  GCC defaults to
+@option{-mno-powerpc64}.
+
+If you specify both @option{-mno-power} and @option{-mno-powerpc}, GCC
+will use only the instructions in the common subset of both
+architectures plus some special AIX common-mode calls, and will not use
+the MQ register.  Specifying both @option{-mpower} and @option{-mpowerpc}
+permits GCC to use any instruction from either architecture and to
+allow use of the MQ register; specify this for the Motorola MPC601.
+
+@item -mnew-mnemonics
+@itemx -mold-mnemonics
+@opindex mnew-mnemonics
+@opindex mold-mnemonics
+Select which mnemonics to use in the generated assembler code.  With
+@option{-mnew-mnemonics}, GCC uses the assembler mnemonics defined for
+the PowerPC architecture.  With @option{-mold-mnemonics} it uses the
+assembler mnemonics defined for the POWER architecture.  Instructions
+defined in only one architecture have only one mnemonic; GCC uses that
+mnemonic irrespective of which of these options is specified.
+
+GCC defaults to the mnemonics appropriate for the architecture in
+use.  Specifying @option{-mcpu=@var{cpu_type}} sometimes overrides the
+value of these option.  Unless you are building a cross-compiler, you
+should normally not specify either @option{-mnew-mnemonics} or
+@option{-mold-mnemonics}, but should instead accept the default.
+
+@item -mcpu=@var{cpu_type}
+@opindex mcpu
+Set architecture type, register usage, choice of mnemonics, and
+instruction scheduling parameters for machine type @var{cpu_type}.
+Supported values for @var{cpu_type} are @samp{401}, @samp{403},
+@samp{405}, @samp{405fp}, @samp{440}, @samp{440fp}, @samp{464}, @samp{464fp},
+@samp{505}, @samp{601}, @samp{602}, @samp{603}, @samp{603e}, @samp{604},
+@samp{604e}, @samp{620}, @samp{630}, @samp{740}, @samp{7400},
+@samp{7450}, @samp{750}, @samp{801}, @samp{821}, @samp{823},
+@samp{860}, @samp{970}, @samp{8540}, @samp{e300c2}, @samp{e300c3},
+@samp{e500mc}, @samp{ec603e}, @samp{G3}, @samp{G4}, @samp{G5},
+@samp{power}, @samp{power2}, @samp{power3}, @samp{power4},
+@samp{power5}, @samp{power5+}, @samp{power6}, @samp{power6x}, @samp{power7}
+@samp{common}, @samp{powerpc}, @samp{powerpc64}, @samp{rios},
+@samp{rios1}, @samp{rios2}, @samp{rsc}, and @samp{rs64}.
+
+@option{-mcpu=common} selects a completely generic processor.  Code
+generated under this option will run on any POWER or PowerPC processor.
+GCC will use only the instructions in the common subset of both
+architectures, and will not use the MQ register.  GCC assumes a generic
+processor model for scheduling purposes.
+
+@option{-mcpu=power}, @option{-mcpu=power2}, @option{-mcpu=powerpc}, and
+@option{-mcpu=powerpc64} specify generic POWER, POWER2, pure 32-bit
+PowerPC (i.e., not MPC601), and 64-bit PowerPC architecture machine
+types, with an appropriate, generic processor model assumed for
+scheduling purposes.
+
+The other options specify a specific processor.  Code generated under
+those options will run best on that processor, and may not run at all on
+others.
+
+The @option{-mcpu} options automatically enable or disable the
+following options:
+
+@gccoptlist{-maltivec  -mfprnd  -mhard-float  -mmfcrf  -mmultiple @gol
+-mnew-mnemonics  -mpopcntb  -mpower  -mpower2  -mpowerpc64 @gol
+-mpowerpc-gpopt  -mpowerpc-gfxopt  -msingle-float -mdouble-float @gol
+-msimple-fpu -mstring  -mmulhw  -mdlmzb  -mmfpgpr}
+
+The particular options set for any particular CPU will vary between
+compiler versions, depending on what setting seems to produce optimal
+code for that CPU; it doesn't necessarily reflect the actual hardware's
+capabilities.  If you wish to set an individual option to a particular
+value, you may specify it after the @option{-mcpu} option, like
+@samp{-mcpu=970 -mno-altivec}.
+
+On AIX, the @option{-maltivec} and @option{-mpowerpc64} options are
+not enabled or disabled by the @option{-mcpu} option at present because
+AIX does not have full support for these options.  You may still
+enable or disable them individually if you're sure it'll work in your
+environment.
+
+@item -mtune=@var{cpu_type}
+@opindex mtune
+Set the instruction scheduling parameters for machine type
+@var{cpu_type}, but do not set the architecture type, register usage, or
+choice of mnemonics, as @option{-mcpu=@var{cpu_type}} would.  The same
+values for @var{cpu_type} are used for @option{-mtune} as for
+@option{-mcpu}.  If both are specified, the code generated will use the
+architecture, registers, and mnemonics set by @option{-mcpu}, but the
+scheduling parameters set by @option{-mtune}.
+
+@item -mswdiv
+@itemx -mno-swdiv
+@opindex mswdiv
+@opindex mno-swdiv
+Generate code to compute division as reciprocal estimate and iterative
+refinement, creating opportunities for increased throughput.  This
+feature requires: optional PowerPC Graphics instruction set for single
+precision and FRE instruction for double precision, assuming divides
+cannot generate user-visible traps, and the domain values not include
+Infinities, denormals or zero denominator.
+
+@item -maltivec
+@itemx -mno-altivec
+@opindex maltivec
+@opindex mno-altivec
+Generate code that uses (does not use) AltiVec instructions, and also
+enable the use of built-in functions that allow more direct access to
+the AltiVec instruction set.  You may also need to set
+@option{-mabi=altivec} to adjust the current ABI with AltiVec ABI
+enhancements.
+
+@item -mvrsave
+@itemx -mno-vrsave
+@opindex mvrsave
+@opindex mno-vrsave
+Generate VRSAVE instructions when generating AltiVec code.
+
+@item -mgen-cell-microcode
+@opindex mgen-cell-microcode
+Generate Cell microcode instructions
+
+@item -mwarn-cell-microcode
+@opindex mwarn-cell-microcode
+Warning when a Cell microcode instruction is going to emitted.  An example
+of a Cell microcode instruction is a variable shift.
+
+@item -msecure-plt
+@opindex msecure-plt
+Generate code that allows ld and ld.so to build executables and shared
+libraries with non-exec .plt and .got sections.  This is a PowerPC
+32-bit SYSV ABI option.
+
+@item -mbss-plt
+@opindex mbss-plt
+Generate code that uses a BSS .plt section that ld.so fills in, and
+requires .plt and .got sections that are both writable and executable.
+This is a PowerPC 32-bit SYSV ABI option.
+
+@item -misel
+@itemx -mno-isel
+@opindex misel
+@opindex mno-isel
+This switch enables or disables the generation of ISEL instructions.
+
+@item -misel=@var{yes/no}
+This switch has been deprecated.  Use @option{-misel} and
+@option{-mno-isel} instead.
+
+@item -mspe
+@itemx -mno-spe
+@opindex mspe
+@opindex mno-spe
+This switch enables or disables the generation of SPE simd
+instructions.
+
+@item -mpaired
+@itemx -mno-paired
+@opindex mpaired
+@opindex mno-paired
+This switch enables or disables the generation of PAIRED simd
+instructions.
+
+@item -mspe=@var{yes/no}
+This option has been deprecated.  Use @option{-mspe} and
+@option{-mno-spe} instead.
+
+@item -mfloat-gprs=@var{yes/single/double/no}
+@itemx -mfloat-gprs
+@opindex mfloat-gprs
+This switch enables or disables the generation of floating point
+operations on the general purpose registers for architectures that
+support it.
+
+The argument @var{yes} or @var{single} enables the use of
+single-precision floating point operations.
+
+The argument @var{double} enables the use of single and
+double-precision floating point operations.
+
+The argument @var{no} disables floating point operations on the
+general purpose registers.
+
+This option is currently only available on the MPC854x.
+
+@item -m32
+@itemx -m64
+@opindex m32
+@opindex m64
+Generate code for 32-bit or 64-bit environments of Darwin and SVR4
+targets (including GNU/Linux).  The 32-bit environment sets int, long
+and pointer to 32 bits and generates code that runs on any PowerPC
+variant.  The 64-bit environment sets int to 32 bits and long and
+pointer to 64 bits, and generates code for PowerPC64, as for
+@option{-mpowerpc64}.
+
+@item -mfull-toc
+@itemx -mno-fp-in-toc
+@itemx -mno-sum-in-toc
+@itemx -mminimal-toc
+@opindex mfull-toc
+@opindex mno-fp-in-toc
+@opindex mno-sum-in-toc
+@opindex mminimal-toc
+Modify generation of the TOC (Table Of Contents), which is created for
+every executable file.  The @option{-mfull-toc} option is selected by
+default.  In that case, GCC will allocate at least one TOC entry for
+each unique non-automatic variable reference in your program.  GCC
+will also place floating-point constants in the TOC@.  However, only
+16,384 entries are available in the TOC@.
+
+If you receive a linker error message that saying you have overflowed
+the available TOC space, you can reduce the amount of TOC space used
+with the @option{-mno-fp-in-toc} and @option{-mno-sum-in-toc} options.
+@option{-mno-fp-in-toc} prevents GCC from putting floating-point
+constants in the TOC and @option{-mno-sum-in-toc} forces GCC to
+generate code to calculate the sum of an address and a constant at
+run-time instead of putting that sum into the TOC@.  You may specify one
+or both of these options.  Each causes GCC to produce very slightly
+slower and larger code at the expense of conserving TOC space.
+
+If you still run out of space in the TOC even when you specify both of
+these options, specify @option{-mminimal-toc} instead.  This option causes
+GCC to make only one TOC entry for every file.  When you specify this
+option, GCC will produce code that is slower and larger but which
+uses extremely little TOC space.  You may wish to use this option
+only on files that contain less frequently executed code.
+
+@item -maix64
+@itemx -maix32
+@opindex maix64
+@opindex maix32
+Enable 64-bit AIX ABI and calling convention: 64-bit pointers, 64-bit
+@code{long} type, and the infrastructure needed to support them.
+Specifying @option{-maix64} implies @option{-mpowerpc64} and
+@option{-mpowerpc}, while @option{-maix32} disables the 64-bit ABI and
+implies @option{-mno-powerpc64}.  GCC defaults to @option{-maix32}.
+
+@item -mxl-compat
+@itemx -mno-xl-compat
+@opindex mxl-compat
+@opindex mno-xl-compat
+Produce code that conforms more closely to IBM XL compiler semantics
+when using AIX-compatible ABI@.  Pass floating-point arguments to
+prototyped functions beyond the register save area (RSA) on the stack
+in addition to argument FPRs.  Do not assume that most significant
+double in 128-bit long double value is properly rounded when comparing
+values and converting to double.  Use XL symbol names for long double
+support routines.
+
+The AIX calling convention was extended but not initially documented to
+handle an obscure K&R C case of calling a function that takes the
+address of its arguments with fewer arguments than declared.  IBM XL
+compilers access floating point arguments which do not fit in the
+RSA from the stack when a subroutine is compiled without
+optimization.  Because always storing floating-point arguments on the
+stack is inefficient and rarely needed, this option is not enabled by
+default and only is necessary when calling subroutines compiled by IBM
+XL compilers without optimization.
+
+@item -mpe
+@opindex mpe
+Support @dfn{IBM RS/6000 SP} @dfn{Parallel Environment} (PE)@.  Link an
+application written to use message passing with special startup code to
+enable the application to run.  The system must have PE installed in the
+standard location (@file{/usr/lpp/ppe.poe/}), or the @file{specs} file
+must be overridden with the @option{-specs=} option to specify the
+appropriate directory location.  The Parallel Environment does not
+support threads, so the @option{-mpe} option and the @option{-pthread}
+option are incompatible.
+
+@item -malign-natural
+@itemx -malign-power
+@opindex malign-natural
+@opindex malign-power
+On AIX, 32-bit Darwin, and 64-bit PowerPC GNU/Linux, the option
+@option{-malign-natural} overrides the ABI-defined alignment of larger
+types, such as floating-point doubles, on their natural size-based boundary.
+The option @option{-malign-power} instructs GCC to follow the ABI-specified
+alignment rules.  GCC defaults to the standard alignment defined in the ABI@.
+
+On 64-bit Darwin, natural alignment is the default, and @option{-malign-power}
+is not supported.
+
+@item -msoft-float
+@itemx -mhard-float
+@opindex msoft-float
+@opindex mhard-float
+Generate code that does not use (uses) the floating-point register set.
+Software floating point emulation is provided if you use the
+@option{-msoft-float} option, and pass the option to GCC when linking.
+
+@item -msingle-float
+@itemx -mdouble-float
+@opindex msingle-float
+@opindex mdouble-float
+Generate code for single or double-precision floating point operations. 
+@option{-mdouble-float} implies @option{-msingle-float}. 
+
+@item -msimple-fpu
+@opindex msimple-fpu
+Do not generate sqrt and div instructions for hardware floating point unit.
+
+@item -mfpu
+@opindex mfpu
+Specify type of floating point unit.  Valid values are @var{sp_lite} 
+(equivalent to -msingle-float -msimple-fpu), @var{dp_lite} (equivalent
+to -mdouble-float -msimple-fpu), @var{sp_full} (equivalent to -msingle-float),
+and @var{dp_full} (equivalent to -mdouble-float).
+
+@item -mxilinx-fpu
+@opindex mxilinx-fpu
+Perform optimizations for floating point unit on Xilinx PPC 405/440.
+
+@item -mmultiple
+@itemx -mno-multiple
+@opindex mmultiple
+@opindex mno-multiple
+Generate code that uses (does not use) the load multiple word
+instructions and the store multiple word instructions.  These
+instructions are generated by default on POWER systems, and not
+generated on PowerPC systems.  Do not use @option{-mmultiple} on little
+endian PowerPC systems, since those instructions do not work when the
+processor is in little endian mode.  The exceptions are PPC740 and
+PPC750 which permit the instructions usage in little endian mode.
+
+@item -mstring
+@itemx -mno-string
+@opindex mstring
+@opindex mno-string
+Generate code that uses (does not use) the load string instructions
+and the store string word instructions to save multiple registers and
+do small block moves.  These instructions are generated by default on
+POWER systems, and not generated on PowerPC systems.  Do not use
+@option{-mstring} on little endian PowerPC systems, since those
+instructions do not work when the processor is in little endian mode.
+The exceptions are PPC740 and PPC750 which permit the instructions
+usage in little endian mode.
+
+@item -mupdate
+@itemx -mno-update
+@opindex mupdate
+@opindex mno-update
+Generate code that uses (does not use) the load or store instructions
+that update the base register to the address of the calculated memory
+location.  These instructions are generated by default.  If you use
+@option{-mno-update}, there is a small window between the time that the
+stack pointer is updated and the address of the previous frame is
+stored, which means code that walks the stack frame across interrupts or
+signals may get corrupted data.
+
+@item -mavoid-indexed-addresses
+@item -mno-avoid-indexed-addresses
+@opindex mavoid-indexed-addresses
+@opindex mno-avoid-indexed-addresses
+Generate code that tries to avoid (not avoid) the use of indexed load
+or store instructions. These instructions can incur a performance
+penalty on Power6 processors in certain situations, such as when
+stepping through large arrays that cross a 16M boundary.  This option
+is enabled by default when targetting Power6 and disabled otherwise.
+
+@item -mfused-madd
+@itemx -mno-fused-madd
+@opindex mfused-madd
+@opindex mno-fused-madd
+Generate code that uses (does not use) the floating point multiply and
+accumulate instructions.  These instructions are generated by default if
+hardware floating is used.
+
+@item -mmulhw
+@itemx -mno-mulhw
+@opindex mmulhw
+@opindex mno-mulhw
+Generate code that uses (does not use) the half-word multiply and
+multiply-accumulate instructions on the IBM 405, 440 and 464 processors.
+These instructions are generated by default when targetting those
+processors.
+
+@item -mdlmzb
+@itemx -mno-dlmzb
+@opindex mdlmzb
+@opindex mno-dlmzb
+Generate code that uses (does not use) the string-search @samp{dlmzb}
+instruction on the IBM 405, 440 and 464 processors.  This instruction is
+generated by default when targetting those processors.
+
+@item -mno-bit-align
+@itemx -mbit-align
+@opindex mno-bit-align
+@opindex mbit-align
+On System V.4 and embedded PowerPC systems do not (do) force structures
+and unions that contain bit-fields to be aligned to the base type of the
+bit-field.
+
+For example, by default a structure containing nothing but 8
+@code{unsigned} bit-fields of length 1 would be aligned to a 4 byte
+boundary and have a size of 4 bytes.  By using @option{-mno-bit-align},
+the structure would be aligned to a 1 byte boundary and be one byte in
+size.
+
+@item -mno-strict-align
+@itemx -mstrict-align
+@opindex mno-strict-align
+@opindex mstrict-align
+On System V.4 and embedded PowerPC systems do not (do) assume that
+unaligned memory references will be handled by the system.
+
+@item -mrelocatable
+@itemx -mno-relocatable
+@opindex mrelocatable
+@opindex mno-relocatable
+On embedded PowerPC systems generate code that allows (does not allow)
+the program to be relocated to a different address at runtime.  If you
+use @option{-mrelocatable} on any module, all objects linked together must
+be compiled with @option{-mrelocatable} or @option{-mrelocatable-lib}.
+
+@item -mrelocatable-lib
+@itemx -mno-relocatable-lib
+@opindex mrelocatable-lib
+@opindex mno-relocatable-lib
+On embedded PowerPC systems generate code that allows (does not allow)
+the program to be relocated to a different address at runtime.  Modules
+compiled with @option{-mrelocatable-lib} can be linked with either modules
+compiled without @option{-mrelocatable} and @option{-mrelocatable-lib} or
+with modules compiled with the @option{-mrelocatable} options.
+
+@item -mno-toc
+@itemx -mtoc
+@opindex mno-toc
+@opindex mtoc
+On System V.4 and embedded PowerPC systems do not (do) assume that
+register 2 contains a pointer to a global area pointing to the addresses
+used in the program.
+
+@item -mlittle
+@itemx -mlittle-endian
+@opindex mlittle
+@opindex mlittle-endian
+On System V.4 and embedded PowerPC systems compile code for the
+processor in little endian mode.  The @option{-mlittle-endian} option is
+the same as @option{-mlittle}.
+
+@item -mbig
+@itemx -mbig-endian
+@opindex mbig
+@opindex mbig-endian
+On System V.4 and embedded PowerPC systems compile code for the
+processor in big endian mode.  The @option{-mbig-endian} option is
+the same as @option{-mbig}.
+
+@item -mdynamic-no-pic
+@opindex mdynamic-no-pic
+On Darwin and Mac OS X systems, compile code so that it is not
+relocatable, but that its external references are relocatable.  The
+resulting code is suitable for applications, but not shared
+libraries.
+
+@item -mprioritize-restricted-insns=@var{priority}
+@opindex mprioritize-restricted-insns
+This option controls the priority that is assigned to
+dispatch-slot restricted instructions during the second scheduling
+pass.  The argument @var{priority} takes the value @var{0/1/2} to assign
+@var{no/highest/second-highest} priority to dispatch slot restricted
+instructions.
+
+@item -msched-costly-dep=@var{dependence_type}
+@opindex msched-costly-dep
+This option controls which dependences are considered costly
+by the target during instruction scheduling.  The argument
+@var{dependence_type} takes one of the following values:
+@var{no}: no dependence is costly,
+@var{all}: all dependences are costly,
+@var{true_store_to_load}: a true dependence from store to load is costly,
+@var{store_to_load}: any dependence from store to load is costly,
+@var{number}: any dependence which latency >= @var{number} is costly.
+
+@item -minsert-sched-nops=@var{scheme}
+@opindex minsert-sched-nops
+This option controls which nop insertion scheme will be used during
+the second scheduling pass.  The argument @var{scheme} takes one of the
+following values:
+@var{no}: Don't insert nops.
+@var{pad}: Pad with nops any dispatch group which has vacant issue slots,
+according to the scheduler's grouping.
+@var{regroup_exact}: Insert nops to force costly dependent insns into
+separate groups.  Insert exactly as many nops as needed to force an insn
+to a new group, according to the estimated processor grouping.
+@var{number}: Insert nops to force costly dependent insns into
+separate groups.  Insert @var{number} nops to force an insn to a new group.
+
+@item -mcall-sysv
+@opindex mcall-sysv
+On System V.4 and embedded PowerPC systems compile code using calling
+conventions that adheres to the March 1995 draft of the System V
+Application Binary Interface, PowerPC processor supplement.  This is the
+default unless you configured GCC using @samp{powerpc-*-eabiaix}.
+
+@item -mcall-sysv-eabi
+@opindex mcall-sysv-eabi
+Specify both @option{-mcall-sysv} and @option{-meabi} options.
+
+@item -mcall-sysv-noeabi
+@opindex mcall-sysv-noeabi
+Specify both @option{-mcall-sysv} and @option{-mno-eabi} options.
+
+@item -mcall-solaris
+@opindex mcall-solaris
+On System V.4 and embedded PowerPC systems compile code for the Solaris
+operating system.
+
+@item -mcall-linux
+@opindex mcall-linux
+On System V.4 and embedded PowerPC systems compile code for the
+Linux-based GNU system.
+
+@item -mcall-gnu
+@opindex mcall-gnu
+On System V.4 and embedded PowerPC systems compile code for the
+Hurd-based GNU system.
+
+@item -mcall-netbsd
+@opindex mcall-netbsd
+On System V.4 and embedded PowerPC systems compile code for the
+NetBSD operating system.
+
+@item -maix-struct-return
+@opindex maix-struct-return
+Return all structures in memory (as specified by the AIX ABI)@.
+
+@item -msvr4-struct-return
+@opindex msvr4-struct-return
+Return structures smaller than 8 bytes in registers (as specified by the
+SVR4 ABI)@.
+
+@item -mabi=@var{abi-type}
+@opindex mabi
+Extend the current ABI with a particular extension, or remove such extension.
+Valid values are @var{altivec}, @var{no-altivec}, @var{spe},
+@var{no-spe}, @var{ibmlongdouble}, @var{ieeelongdouble}@.
+
+@item -mabi=spe
+@opindex mabi=spe
+Extend the current ABI with SPE ABI extensions.  This does not change
+the default ABI, instead it adds the SPE ABI extensions to the current
+ABI@.
+
+@item -mabi=no-spe
+@opindex mabi=no-spe
+Disable Booke SPE ABI extensions for the current ABI@.
+
+@item -mabi=ibmlongdouble
+@opindex mabi=ibmlongdouble
+Change the current ABI to use IBM extended precision long double.
+This is a PowerPC 32-bit SYSV ABI option.
+
+@item -mabi=ieeelongdouble
+@opindex mabi=ieeelongdouble
+Change the current ABI to use IEEE extended precision long double.
+This is a PowerPC 32-bit Linux ABI option.
+
+@item -mprototype
+@itemx -mno-prototype
+@opindex mprototype
+@opindex mno-prototype
+On System V.4 and embedded PowerPC systems assume that all calls to
+variable argument functions are properly prototyped.  Otherwise, the
+compiler must insert an instruction before every non prototyped call to
+set or clear bit 6 of the condition code register (@var{CR}) to
+indicate whether floating point values were passed in the floating point
+registers in case the function takes a variable arguments.  With
+@option{-mprototype}, only calls to prototyped variable argument functions
+will set or clear the bit.
+
+@item -msim
+@opindex msim
+On embedded PowerPC systems, assume that the startup module is called
+@file{sim-crt0.o} and that the standard C libraries are @file{libsim.a} and
+@file{libc.a}.  This is the default for @samp{powerpc-*-eabisim}
+configurations.
+
+@item -mmvme
+@opindex mmvme
+On embedded PowerPC systems, assume that the startup module is called
+@file{crt0.o} and the standard C libraries are @file{libmvme.a} and
+@file{libc.a}.
+
+@item -mads
+@opindex mads
+On embedded PowerPC systems, assume that the startup module is called
+@file{crt0.o} and the standard C libraries are @file{libads.a} and
+@file{libc.a}.
+
+@item -myellowknife
+@opindex myellowknife
+On embedded PowerPC systems, assume that the startup module is called
+@file{crt0.o} and the standard C libraries are @file{libyk.a} and
+@file{libc.a}.
+
+@item -mvxworks
+@opindex mvxworks
+On System V.4 and embedded PowerPC systems, specify that you are
+compiling for a VxWorks system.
+
+@item -memb
+@opindex memb
+On embedded PowerPC systems, set the @var{PPC_EMB} bit in the ELF flags
+header to indicate that @samp{eabi} extended relocations are used.
+
+@item -meabi
+@itemx -mno-eabi
+@opindex meabi
+@opindex mno-eabi
+On System V.4 and embedded PowerPC systems do (do not) adhere to the
+Embedded Applications Binary Interface (eabi) which is a set of
+modifications to the System V.4 specifications.  Selecting @option{-meabi}
+means that the stack is aligned to an 8 byte boundary, a function
+@code{__eabi} is called to from @code{main} to set up the eabi
+environment, and the @option{-msdata} option can use both @code{r2} and
+@code{r13} to point to two separate small data areas.  Selecting
+@option{-mno-eabi} means that the stack is aligned to a 16 byte boundary,
+do not call an initialization function from @code{main}, and the
+@option{-msdata} option will only use @code{r13} to point to a single
+small data area.  The @option{-meabi} option is on by default if you
+configured GCC using one of the @samp{powerpc*-*-eabi*} options.
+
+@item -msdata=eabi
+@opindex msdata=eabi
+On System V.4 and embedded PowerPC systems, put small initialized
+@code{const} global and static data in the @samp{.sdata2} section, which
+is pointed to by register @code{r2}.  Put small initialized
+non-@code{const} global and static data in the @samp{.sdata} section,
+which is pointed to by register @code{r13}.  Put small uninitialized
+global and static data in the @samp{.sbss} section, which is adjacent to
+the @samp{.sdata} section.  The @option{-msdata=eabi} option is
+incompatible with the @option{-mrelocatable} option.  The
+@option{-msdata=eabi} option also sets the @option{-memb} option.
+
+@item -msdata=sysv
+@opindex msdata=sysv
+On System V.4 and embedded PowerPC systems, put small global and static
+data in the @samp{.sdata} section, which is pointed to by register
+@code{r13}.  Put small uninitialized global and static data in the
+@samp{.sbss} section, which is adjacent to the @samp{.sdata} section.
+The @option{-msdata=sysv} option is incompatible with the
+@option{-mrelocatable} option.
+
+@item -msdata=default
+@itemx -msdata
+@opindex msdata=default
+@opindex msdata
+On System V.4 and embedded PowerPC systems, if @option{-meabi} is used,
+compile code the same as @option{-msdata=eabi}, otherwise compile code the
+same as @option{-msdata=sysv}.
+
+@item -msdata=data
+@opindex msdata=data
+On System V.4 and embedded PowerPC systems, put small global
+data in the @samp{.sdata} section.  Put small uninitialized global
+data in the @samp{.sbss} section.  Do not use register @code{r13}
+to address small data however.  This is the default behavior unless
+other @option{-msdata} options are used.
+
+@item -msdata=none
+@itemx -mno-sdata
+@opindex msdata=none
+@opindex mno-sdata
+On embedded PowerPC systems, put all initialized global and static data
+in the @samp{.data} section, and all uninitialized data in the
+@samp{.bss} section.
+
+@item -G @var{num}
+@opindex G
+@cindex smaller data references (PowerPC)
+@cindex .sdata/.sdata2 references (PowerPC)
+On embedded PowerPC systems, put global and static items less than or
+equal to @var{num} bytes into the small data or bss sections instead of
+the normal data or bss section.  By default, @var{num} is 8.  The
+@option{-G @var{num}} switch is also passed to the linker.
+All modules should be compiled with the same @option{-G @var{num}} value.
+
+@item -mregnames
+@itemx -mno-regnames
+@opindex mregnames
+@opindex mno-regnames
+On System V.4 and embedded PowerPC systems do (do not) emit register
+names in the assembly language output using symbolic forms.
+
+@item -mlongcall
+@itemx -mno-longcall
+@opindex mlongcall
+@opindex mno-longcall
+By default assume that all calls are far away so that a longer more
+expensive calling sequence is required.  This is required for calls
+further than 32 megabytes (33,554,432 bytes) from the current location.
+A short call will be generated if the compiler knows
+the call cannot be that far away.  This setting can be overridden by
+the @code{shortcall} function attribute, or by @code{#pragma
+longcall(0)}.
+
+Some linkers are capable of detecting out-of-range calls and generating
+glue code on the fly.  On these systems, long calls are unnecessary and
+generate slower code.  As of this writing, the AIX linker can do this,
+as can the GNU linker for PowerPC/64.  It is planned to add this feature
+to the GNU linker for 32-bit PowerPC systems as well.
+
+On Darwin/PPC systems, @code{#pragma longcall} will generate ``jbsr
+callee, L42'', plus a ``branch island'' (glue code).  The two target
+addresses represent the callee and the ``branch island''.  The
+Darwin/PPC linker will prefer the first address and generate a ``bl
+callee'' if the PPC ``bl'' instruction will reach the callee directly;
+otherwise, the linker will generate ``bl L42'' to call the ``branch
+island''.  The ``branch island'' is appended to the body of the
+calling function; it computes the full 32-bit address of the callee
+and jumps to it.
+
+On Mach-O (Darwin) systems, this option directs the compiler emit to
+the glue for every direct call, and the Darwin linker decides whether
+to use or discard it.
+
+In the future, we may cause GCC to ignore all longcall specifications
+when the linker is known to generate glue.
+
+@item -pthread
+@opindex pthread
+Adds support for multithreading with the @dfn{pthreads} library.
+This option sets flags for both the preprocessor and linker.
+
+@end table
+
+@node S/390 and zSeries Options
+@subsection S/390 and zSeries Options
+@cindex S/390 and zSeries Options
+
+These are the @samp{-m} options defined for the S/390 and zSeries architecture.
+
+@table @gcctabopt
+@item -mhard-float
+@itemx -msoft-float
+@opindex mhard-float
+@opindex msoft-float
+Use (do not use) the hardware floating-point instructions and registers
+for floating-point operations.  When @option{-msoft-float} is specified,
+functions in @file{libgcc.a} will be used to perform floating-point
+operations.  When @option{-mhard-float} is specified, the compiler
+generates IEEE floating-point instructions.  This is the default.
+
+@item -mhard-dfp
+@itemx -mno-hard-dfp
+@opindex mhard-dfp
+@opindex mno-hard-dfp
+Use (do not use) the hardware decimal-floating-point instructions for
+decimal-floating-point operations.  When @option{-mno-hard-dfp} is
+specified, functions in @file{libgcc.a} will be used to perform
+decimal-floating-point operations.  When @option{-mhard-dfp} is
+specified, the compiler generates decimal-floating-point hardware
+instructions.  This is the default for @option{-march=z9-ec} or higher.
+
+@item -mlong-double-64
+@itemx -mlong-double-128
+@opindex mlong-double-64
+@opindex mlong-double-128
+These switches control the size of @code{long double} type. A size
+of 64bit makes the @code{long double} type equivalent to the @code{double}
+type. This is the default.
+
+@item -mbackchain
+@itemx -mno-backchain
+@opindex mbackchain
+@opindex mno-backchain
+Store (do not store) the address of the caller's frame as backchain pointer
+into the callee's stack frame.
+A backchain may be needed to allow debugging using tools that do not understand
+DWARF-2 call frame information.
+When @option{-mno-packed-stack} is in effect, the backchain pointer is stored
+at the bottom of the stack frame; when @option{-mpacked-stack} is in effect,
+the backchain is placed into the topmost word of the 96/160 byte register
+save area.
+
+In general, code compiled with @option{-mbackchain} is call-compatible with
+code compiled with @option{-mmo-backchain}; however, use of the backchain
+for debugging purposes usually requires that the whole binary is built with
+@option{-mbackchain}.  Note that the combination of @option{-mbackchain},
+@option{-mpacked-stack} and @option{-mhard-float} is not supported.  In order
+to build a linux kernel use @option{-msoft-float}.
+
+The default is to not maintain the backchain.
+
+@item -mpacked-stack
+@itemx -mno-packed-stack
+@opindex mpacked-stack
+@opindex mno-packed-stack
+Use (do not use) the packed stack layout.  When @option{-mno-packed-stack} is
+specified, the compiler uses the all fields of the 96/160 byte register save
+area only for their default purpose; unused fields still take up stack space.
+When @option{-mpacked-stack} is specified, register save slots are densely
+packed at the top of the register save area; unused space is reused for other
+purposes, allowing for more efficient use of the available stack space.
+However, when @option{-mbackchain} is also in effect, the topmost word of
+the save area is always used to store the backchain, and the return address
+register is always saved two words below the backchain.
+
+As long as the stack frame backchain is not used, code generated with
+@option{-mpacked-stack} is call-compatible with code generated with
+@option{-mno-packed-stack}.  Note that some non-FSF releases of GCC 2.95 for
+S/390 or zSeries generated code that uses the stack frame backchain at run
+time, not just for debugging purposes.  Such code is not call-compatible
+with code compiled with @option{-mpacked-stack}.  Also, note that the
+combination of @option{-mbackchain},
+@option{-mpacked-stack} and @option{-mhard-float} is not supported.  In order
+to build a linux kernel use @option{-msoft-float}.
+
+The default is to not use the packed stack layout.
+
+@item -msmall-exec
+@itemx -mno-small-exec
+@opindex msmall-exec
+@opindex mno-small-exec
+Generate (or do not generate) code using the @code{bras} instruction
+to do subroutine calls.
+This only works reliably if the total executable size does not
+exceed 64k.  The default is to use the @code{basr} instruction instead,
+which does not have this limitation.
+
+@item -m64
+@itemx -m31
+@opindex m64
+@opindex m31
+When @option{-m31} is specified, generate code compliant to the
+GNU/Linux for S/390 ABI@.  When @option{-m64} is specified, generate
+code compliant to the GNU/Linux for zSeries ABI@.  This allows GCC in
+particular to generate 64-bit instructions.  For the @samp{s390}
+targets, the default is @option{-m31}, while the @samp{s390x}
+targets default to @option{-m64}.
+
+@item -mzarch
+@itemx -mesa
+@opindex mzarch
+@opindex mesa
+When @option{-mzarch} is specified, generate code using the
+instructions available on z/Architecture.
+When @option{-mesa} is specified, generate code using the
+instructions available on ESA/390.  Note that @option{-mesa} is
+not possible with @option{-m64}.
+When generating code compliant to the GNU/Linux for S/390 ABI,
+the default is @option{-mesa}.  When generating code compliant
+to the GNU/Linux for zSeries ABI, the default is @option{-mzarch}.
+
+@item -mmvcle
+@itemx -mno-mvcle
+@opindex mmvcle
+@opindex mno-mvcle
+Generate (or do not generate) code using the @code{mvcle} instruction
+to perform block moves.  When @option{-mno-mvcle} is specified,
+use a @code{mvc} loop instead.  This is the default unless optimizing for
+size.
+
+@item -mdebug
+@itemx -mno-debug
+@opindex mdebug
+@opindex mno-debug
+Print (or do not print) additional debug information when compiling.
+The default is to not print debug information.
+
+@item -march=@var{cpu-type}
+@opindex march
+Generate code that will run on @var{cpu-type}, which is the name of a system
+representing a certain processor type.  Possible values for
+@var{cpu-type} are @samp{g5}, @samp{g6}, @samp{z900}, @samp{z990},
+@samp{z9-109}, @samp{z9-ec} and @samp{z10}.
+When generating code using the instructions available on z/Architecture,
+the default is @option{-march=z900}.  Otherwise, the default is
+@option{-march=g5}.
+
+@item -mtune=@var{cpu-type}
+@opindex mtune
+Tune to @var{cpu-type} everything applicable about the generated code,
+except for the ABI and the set of available instructions.
+The list of @var{cpu-type} values is the same as for @option{-march}.
+The default is the value used for @option{-march}.
+
+@item -mtpf-trace
+@itemx -mno-tpf-trace
+@opindex mtpf-trace
+@opindex mno-tpf-trace
+Generate code that adds (does not add) in TPF OS specific branches to trace
+routines in the operating system.  This option is off by default, even
+when compiling for the TPF OS@.
+
+@item -mfused-madd
+@itemx -mno-fused-madd
+@opindex mfused-madd
+@opindex mno-fused-madd
+Generate code that uses (does not use) the floating point multiply and
+accumulate instructions.  These instructions are generated by default if
+hardware floating point is used.
+
+@item -mwarn-framesize=@var{framesize}
+@opindex mwarn-framesize
+Emit a warning if the current function exceeds the given frame size.  Because
+this is a compile time check it doesn't need to be a real problem when the program
+runs.  It is intended to identify functions which most probably cause
+a stack overflow.  It is useful to be used in an environment with limited stack
+size e.g.@: the linux kernel.
+
+@item -mwarn-dynamicstack
+@opindex mwarn-dynamicstack
+Emit a warning if the function calls alloca or uses dynamically
+sized arrays.  This is generally a bad idea with a limited stack size.
+
+@item -mstack-guard=@var{stack-guard}
+@itemx -mstack-size=@var{stack-size}
+@opindex mstack-guard
+@opindex mstack-size
+If these options are provided the s390 back end emits additional instructions in
+the function prologue which trigger a trap if the stack size is @var{stack-guard}
+bytes above the @var{stack-size} (remember that the stack on s390 grows downward).
+If the @var{stack-guard} option is omitted the smallest power of 2 larger than
+the frame size of the compiled function is chosen.
+These options are intended to be used to help debugging stack overflow problems.
+The additionally emitted code causes only little overhead and hence can also be
+used in production like systems without greater performance degradation.  The given
+values have to be exact powers of 2 and @var{stack-size} has to be greater than
+@var{stack-guard} without exceeding 64k.
+In order to be efficient the extra code makes the assumption that the stack starts
+at an address aligned to the value given by @var{stack-size}.
+The @var{stack-guard} option can only be used in conjunction with @var{stack-size}.
+@end table
+
+@node Score Options
+@subsection Score Options
+@cindex Score Options
+
+These options are defined for Score implementations:
+
+@table @gcctabopt
+@item -meb
+@opindex meb
+Compile code for big endian mode.  This is the default.
+
+@item -mel
+@opindex mel
+Compile code for little endian mode. 
+
+@item -mnhwloop
+@opindex mnhwloop
+Disable generate bcnz instruction.
+
+@item -muls
+@opindex muls
+Enable generate unaligned load and store instruction.
+
+@item -mmac
+@opindex mmac
+Enable the use of multiply-accumulate instructions. Disabled by default. 
+
+@item -mscore5
+@opindex mscore5
+Specify the SCORE5 as the target architecture.
+
+@item -mscore5u
+@opindex mscore5u
+Specify the SCORE5U of the target architecture.
+
+@item -mscore7
+@opindex mscore7
+Specify the SCORE7 as the target architecture. This is the default.
+
+@item -mscore7d
+@opindex mscore7d
+Specify the SCORE7D as the target architecture.
+@end table
+
+@node SH Options
+@subsection SH Options
+
+These @samp{-m} options are defined for the SH implementations:
+
+@table @gcctabopt
+@item -m1
+@opindex m1
+Generate code for the SH1.
+
+@item -m2
+@opindex m2
+Generate code for the SH2.
+
+@item -m2e
+Generate code for the SH2e.
+
+@item -m3
+@opindex m3
+Generate code for the SH3.
+
+@item -m3e
+@opindex m3e
+Generate code for the SH3e.
+
+@item -m4-nofpu
+@opindex m4-nofpu
+Generate code for the SH4 without a floating-point unit.
+
+@item -m4-single-only
+@opindex m4-single-only
+Generate code for the SH4 with a floating-point unit that only
+supports single-precision arithmetic.
+
+@item -m4-single
+@opindex m4-single
+Generate code for the SH4 assuming the floating-point unit is in
+single-precision mode by default.
+
+@item -m4
+@opindex m4
+Generate code for the SH4.
+
+@item -m4a-nofpu
+@opindex m4a-nofpu
+Generate code for the SH4al-dsp, or for a SH4a in such a way that the
+floating-point unit is not used.
+
+@item -m4a-single-only
+@opindex m4a-single-only
+Generate code for the SH4a, in such a way that no double-precision
+floating point operations are used.
+
+@item -m4a-single
+@opindex m4a-single
+Generate code for the SH4a assuming the floating-point unit is in
+single-precision mode by default.
+
+@item -m4a
+@opindex m4a
+Generate code for the SH4a.
+
+@item -m4al
+@opindex m4al
+Same as @option{-m4a-nofpu}, except that it implicitly passes
+@option{-dsp} to the assembler.  GCC doesn't generate any DSP
+instructions at the moment.
+
+@item -mb
+@opindex mb
+Compile code for the processor in big endian mode.
+
+@item -ml
+@opindex ml
+Compile code for the processor in little endian mode.
+
+@item -mdalign
+@opindex mdalign
+Align doubles at 64-bit boundaries.  Note that this changes the calling
+conventions, and thus some functions from the standard C library will
+not work unless you recompile it first with @option{-mdalign}.
+
+@item -mrelax
+@opindex mrelax
+Shorten some address references at link time, when possible; uses the
+linker option @option{-relax}.
+
+@item -mbigtable
+@opindex mbigtable
+Use 32-bit offsets in @code{switch} tables.  The default is to use
+16-bit offsets.
+
+@item -mbitops
+@opindex mbitops
+Enable the use of bit manipulation instructions on SH2A.
+
+@item -mfmovd
+@opindex mfmovd
+Enable the use of the instruction @code{fmovd}.
+
+@item -mhitachi
+@opindex mhitachi
+Comply with the calling conventions defined by Renesas.
+
+@item -mrenesas
+@opindex mhitachi
+Comply with the calling conventions defined by Renesas.
+
+@item -mno-renesas
+@opindex mhitachi
+Comply with the calling conventions defined for GCC before the Renesas
+conventions were available.  This option is the default for all
+targets of the SH toolchain except for @samp{sh-symbianelf}.
+
+@item -mnomacsave
+@opindex mnomacsave
+Mark the @code{MAC} register as call-clobbered, even if
+@option{-mhitachi} is given.
+
+@item -mieee
+@opindex mieee
+Increase IEEE-compliance of floating-point code.
+At the moment, this is equivalent to @option{-fno-finite-math-only}.
+When generating 16 bit SH opcodes, getting IEEE-conforming results for
+comparisons of NANs / infinities incurs extra overhead in every
+floating point comparison, therefore the default is set to
+@option{-ffinite-math-only}.
+
+@item -minline-ic_invalidate
+@opindex minline-ic_invalidate
+Inline code to invalidate instruction cache entries after setting up
+nested function trampolines.
+This option has no effect if -musermode is in effect and the selected
+code generation option (e.g. -m4) does not allow the use of the icbi
+instruction.
+If the selected code generation option does not allow the use of the icbi
+instruction, and -musermode is not in effect, the inlined code will
+manipulate the instruction cache address array directly with an associative
+write.  This not only requires privileged mode, but it will also
+fail if the cache line had been mapped via the TLB and has become unmapped.
+
+@item -misize
+@opindex misize
+Dump instruction size and location in the assembly code.
+
+@item -mpadstruct
+@opindex mpadstruct
+This option is deprecated.  It pads structures to multiple of 4 bytes,
+which is incompatible with the SH ABI@.
+
+@item -mspace
+@opindex mspace
+Optimize for space instead of speed.  Implied by @option{-Os}.
+
+@item -mprefergot
+@opindex mprefergot
+When generating position-independent code, emit function calls using
+the Global Offset Table instead of the Procedure Linkage Table.
+
+@item -musermode
+@opindex musermode
+Don't generate privileged mode only code; implies -mno-inline-ic_invalidate
+if the inlined code would not work in user mode.
+This is the default when the target is @code{sh-*-linux*}.
+
+@item -multcost=@var{number}
+@opindex multcost=@var{number}
+Set the cost to assume for a multiply insn.
+
+@item -mdiv=@var{strategy}
+@opindex mdiv=@var{strategy}
+Set the division strategy to use for SHmedia code.  @var{strategy} must be
+one of: call, call2, fp, inv, inv:minlat, inv20u, inv20l, inv:call,
+inv:call2, inv:fp .
+"fp" performs the operation in floating point.  This has a very high latency,
+but needs only a few instructions, so it might be a good choice if
+your code has enough easily exploitable ILP to allow the compiler to
+schedule the floating point instructions together with other instructions.
+Division by zero causes a floating point exception.
+"inv" uses integer operations to calculate the inverse of the divisor,
+and then multiplies the dividend with the inverse.  This strategy allows
+cse and hoisting of the inverse calculation.  Division by zero calculates
+an unspecified result, but does not trap.
+"inv:minlat" is a variant of "inv" where if no cse / hoisting opportunities
+have been found, or if the entire operation has been hoisted to the same
+place, the last stages of the inverse calculation are intertwined with the
+final multiply to reduce the overall latency, at the expense of using a few
+more instructions, and thus offering fewer scheduling opportunities with
+other code.
+"call" calls a library function that usually implements the inv:minlat
+strategy.
+This gives high code density for m5-*media-nofpu compilations.
+"call2" uses a different entry point of the same library function, where it
+assumes that a pointer to a lookup table has already been set up, which
+exposes the pointer load to cse / code hoisting optimizations.
+"inv:call", "inv:call2" and "inv:fp" all use the "inv" algorithm for initial
+code generation, but if the code stays unoptimized, revert to the "call",
+"call2", or "fp" strategies, respectively.  Note that the
+potentially-trapping side effect of division by zero is carried by a
+separate instruction, so it is possible that all the integer instructions
+are hoisted out, but the marker for the side effect stays where it is.
+A recombination to fp operations or a call is not possible in that case.
+"inv20u" and "inv20l" are variants of the "inv:minlat" strategy.  In the case
+that the inverse calculation was nor separated from the multiply, they speed
+up division where the dividend fits into 20 bits (plus sign where applicable),
+by inserting a test to skip a number of operations in this case; this test
+slows down the case of larger dividends.  inv20u assumes the case of a such
+a small dividend to be unlikely, and inv20l assumes it to be likely.
+
+@item -mdivsi3_libfunc=@var{name}
+@opindex mdivsi3_libfunc=@var{name}
+Set the name of the library function used for 32 bit signed division to
+@var{name}.  This only affect the name used in the call and inv:call
+division strategies, and the compiler will still expect the same
+sets of input/output/clobbered registers as if this option was not present.
+
+@item -mfixed-range=@var{register-range}
+@opindex mfixed-range
+Generate code treating the given register range as fixed registers.
+A fixed register is one that the register allocator can not use.  This is
+useful when compiling kernel code.  A register range is specified as
+two registers separated by a dash.  Multiple register ranges can be
+specified separated by a comma.
+
+@item -madjust-unroll
+@opindex madjust-unroll
+Throttle unrolling to avoid thrashing target registers.
+This option only has an effect if the gcc code base supports the
+TARGET_ADJUST_UNROLL_MAX target hook.
+
+@item -mindexed-addressing
+@opindex mindexed-addressing
+Enable the use of the indexed addressing mode for SHmedia32/SHcompact.
+This is only safe if the hardware and/or OS implement 32 bit wrap-around
+semantics for the indexed addressing mode.  The architecture allows the
+implementation of processors with 64 bit MMU, which the OS could use to
+get 32 bit addressing, but since no current hardware implementation supports
+this or any other way to make the indexed addressing mode safe to use in
+the 32 bit ABI, the default is -mno-indexed-addressing.
+
+@item -mgettrcost=@var{number}
+@opindex mgettrcost=@var{number}
+Set the cost assumed for the gettr instruction to @var{number}.
+The default is 2 if @option{-mpt-fixed} is in effect, 100 otherwise.
+
+@item -mpt-fixed
+@opindex mpt-fixed
+Assume pt* instructions won't trap.  This will generally generate better
+scheduled code, but is unsafe on current hardware.  The current architecture
+definition says that ptabs and ptrel trap when the target anded with 3 is 3.
+This has the unintentional effect of making it unsafe to schedule ptabs /
+ptrel before a branch, or hoist it out of a loop.  For example,
+__do_global_ctors, a part of libgcc that runs constructors at program
+startup, calls functions in a list which is delimited by @minus{}1.  With the
+-mpt-fixed option, the ptabs will be done before testing against @minus{}1.
+That means that all the constructors will be run a bit quicker, but when
+the loop comes to the end of the list, the program crashes because ptabs
+loads @minus{}1 into a target register.  Since this option is unsafe for any
+hardware implementing the current architecture specification, the default
+is -mno-pt-fixed.  Unless the user specifies a specific cost with
+@option{-mgettrcost}, -mno-pt-fixed also implies @option{-mgettrcost=100};
+this deters register allocation using target registers for storing
+ordinary integers.
+
+@item -minvalid-symbols
+@opindex minvalid-symbols
+Assume symbols might be invalid.  Ordinary function symbols generated by
+the compiler will always be valid to load with movi/shori/ptabs or
+movi/shori/ptrel, but with assembler and/or linker tricks it is possible
+to generate symbols that will cause ptabs / ptrel to trap.
+This option is only meaningful when @option{-mno-pt-fixed} is in effect.
+It will then prevent cross-basic-block cse, hoisting and most scheduling
+of symbol loads.  The default is @option{-mno-invalid-symbols}.
+@end table
+
+@node SPARC Options
+@subsection SPARC Options
+@cindex SPARC options
+
+These @samp{-m} options are supported on the SPARC:
+
+@table @gcctabopt
+@item -mno-app-regs
+@itemx -mapp-regs
+@opindex mno-app-regs
+@opindex mapp-regs
+Specify @option{-mapp-regs} to generate output using the global registers
+2 through 4, which the SPARC SVR4 ABI reserves for applications.  This
+is the default.
+
+To be fully SVR4 ABI compliant at the cost of some performance loss,
+specify @option{-mno-app-regs}.  You should compile libraries and system
+software with this option.
+
+@item -mfpu
+@itemx -mhard-float
+@opindex mfpu
+@opindex mhard-float
+Generate output containing floating point instructions.  This is the
+default.
+
+@item -mno-fpu
+@itemx -msoft-float
+@opindex mno-fpu
+@opindex msoft-float
+Generate output containing library calls for floating point.
+@strong{Warning:} the requisite libraries are not available for all SPARC
+targets.  Normally the facilities of the machine's usual C compiler are
+used, but this cannot be done directly in cross-compilation.  You must make
+your own arrangements to provide suitable library functions for
+cross-compilation.  The embedded targets @samp{sparc-*-aout} and
+@samp{sparclite-*-*} do provide software floating point support.
+
+@option{-msoft-float} changes the calling convention in the output file;
+therefore, it is only useful if you compile @emph{all} of a program with
+this option.  In particular, you need to compile @file{libgcc.a}, the
+library that comes with GCC, with @option{-msoft-float} in order for
+this to work.
+
+@item -mhard-quad-float
+@opindex mhard-quad-float
+Generate output containing quad-word (long double) floating point
+instructions.
+
+@item -msoft-quad-float
+@opindex msoft-quad-float
+Generate output containing library calls for quad-word (long double)
+floating point instructions.  The functions called are those specified
+in the SPARC ABI@.  This is the default.
+
+As of this writing, there are no SPARC implementations that have hardware
+support for the quad-word floating point instructions.  They all invoke
+a trap handler for one of these instructions, and then the trap handler
+emulates the effect of the instruction.  Because of the trap handler overhead,
+this is much slower than calling the ABI library routines.  Thus the
+@option{-msoft-quad-float} option is the default.
+
+@item -mno-unaligned-doubles
+@itemx -munaligned-doubles
+@opindex mno-unaligned-doubles
+@opindex munaligned-doubles
+Assume that doubles have 8 byte alignment.  This is the default.
+
+With @option{-munaligned-doubles}, GCC assumes that doubles have 8 byte
+alignment only if they are contained in another type, or if they have an
+absolute address.  Otherwise, it assumes they have 4 byte alignment.
+Specifying this option avoids some rare compatibility problems with code
+generated by other compilers.  It is not the default because it results
+in a performance loss, especially for floating point code.
+
+@item -mno-faster-structs
+@itemx -mfaster-structs
+@opindex mno-faster-structs
+@opindex mfaster-structs
+With @option{-mfaster-structs}, the compiler assumes that structures
+should have 8 byte alignment.  This enables the use of pairs of
+@code{ldd} and @code{std} instructions for copies in structure
+assignment, in place of twice as many @code{ld} and @code{st} pairs.
+However, the use of this changed alignment directly violates the SPARC
+ABI@.  Thus, it's intended only for use on targets where the developer
+acknowledges that their resulting code will not be directly in line with
+the rules of the ABI@.
+
+@item -mimpure-text
+@opindex mimpure-text
+@option{-mimpure-text}, used in addition to @option{-shared}, tells
+the compiler to not pass @option{-z text} to the linker when linking a
+shared object.  Using this option, you can link position-dependent
+code into a shared object.
+
+@option{-mimpure-text} suppresses the ``relocations remain against
+allocatable but non-writable sections'' linker error message.
+However, the necessary relocations will trigger copy-on-write, and the
+shared object is not actually shared across processes.  Instead of
+using @option{-mimpure-text}, you should compile all source code with
+@option{-fpic} or @option{-fPIC}.
+
+This option is only available on SunOS and Solaris.
+
+@item -mcpu=@var{cpu_type}
+@opindex mcpu
+Set the instruction set, register set, and instruction scheduling parameters
+for machine type @var{cpu_type}.  Supported values for @var{cpu_type} are
+@samp{v7}, @samp{cypress}, @samp{v8}, @samp{supersparc}, @samp{sparclite},
+@samp{f930}, @samp{f934}, @samp{hypersparc}, @samp{sparclite86x},
+@samp{sparclet}, @samp{tsc701}, @samp{v9}, @samp{ultrasparc},
+@samp{ultrasparc3}, @samp{niagara} and @samp{niagara2}.
+
+Default instruction scheduling parameters are used for values that select
+an architecture and not an implementation.  These are @samp{v7}, @samp{v8},
+@samp{sparclite}, @samp{sparclet}, @samp{v9}.
+
+Here is a list of each supported architecture and their supported
+implementations.
+
+@smallexample
+    v7:             cypress
+    v8:             supersparc, hypersparc
+    sparclite:      f930, f934, sparclite86x
+    sparclet:       tsc701
+    v9:             ultrasparc, ultrasparc3, niagara, niagara2
+@end smallexample
+
+By default (unless configured otherwise), GCC generates code for the V7
+variant of the SPARC architecture.  With @option{-mcpu=cypress}, the compiler
+additionally optimizes it for the Cypress CY7C602 chip, as used in the
+SPARCStation/SPARCServer 3xx series.  This is also appropriate for the older
+SPARCStation 1, 2, IPX etc.
+
+With @option{-mcpu=v8}, GCC generates code for the V8 variant of the SPARC
+architecture.  The only difference from V7 code is that the compiler emits
+the integer multiply and integer divide instructions which exist in SPARC-V8
+but not in SPARC-V7.  With @option{-mcpu=supersparc}, the compiler additionally
+optimizes it for the SuperSPARC chip, as used in the SPARCStation 10, 1000 and
+2000 series.
+
+With @option{-mcpu=sparclite}, GCC generates code for the SPARClite variant of
+the SPARC architecture.  This adds the integer multiply, integer divide step
+and scan (@code{ffs}) instructions which exist in SPARClite but not in SPARC-V7.
+With @option{-mcpu=f930}, the compiler additionally optimizes it for the
+Fujitsu MB86930 chip, which is the original SPARClite, with no FPU@.  With
+@option{-mcpu=f934}, the compiler additionally optimizes it for the Fujitsu
+MB86934 chip, which is the more recent SPARClite with FPU@.
+
+With @option{-mcpu=sparclet}, GCC generates code for the SPARClet variant of
+the SPARC architecture.  This adds the integer multiply, multiply/accumulate,
+integer divide step and scan (@code{ffs}) instructions which exist in SPARClet
+but not in SPARC-V7.  With @option{-mcpu=tsc701}, the compiler additionally
+optimizes it for the TEMIC SPARClet chip.
+
+With @option{-mcpu=v9}, GCC generates code for the V9 variant of the SPARC
+architecture.  This adds 64-bit integer and floating-point move instructions,
+3 additional floating-point condition code registers and conditional move
+instructions.  With @option{-mcpu=ultrasparc}, the compiler additionally
+optimizes it for the Sun UltraSPARC I/II/IIi chips.  With
+@option{-mcpu=ultrasparc3}, the compiler additionally optimizes it for the
+Sun UltraSPARC III/III+/IIIi/IIIi+/IV/IV+ chips.  With
+@option{-mcpu=niagara}, the compiler additionally optimizes it for
+Sun UltraSPARC T1 chips.  With @option{-mcpu=niagara2}, the compiler
+additionally optimizes it for Sun UltraSPARC T2 chips.
+
+@item -mtune=@var{cpu_type}
+@opindex mtune
+Set the instruction scheduling parameters for machine type
+@var{cpu_type}, but do not set the instruction set or register set that the
+option @option{-mcpu=@var{cpu_type}} would.
+
+The same values for @option{-mcpu=@var{cpu_type}} can be used for
+@option{-mtune=@var{cpu_type}}, but the only useful values are those
+that select a particular cpu implementation.  Those are @samp{cypress},
+@samp{supersparc}, @samp{hypersparc}, @samp{f930}, @samp{f934},
+@samp{sparclite86x}, @samp{tsc701}, @samp{ultrasparc},
+@samp{ultrasparc3}, @samp{niagara}, and @samp{niagara2}.
+
+@item -mv8plus
+@itemx -mno-v8plus
+@opindex mv8plus
+@opindex mno-v8plus
+With @option{-mv8plus}, GCC generates code for the SPARC-V8+ ABI@.  The
+difference from the V8 ABI is that the global and out registers are
+considered 64-bit wide.  This is enabled by default on Solaris in 32-bit
+mode for all SPARC-V9 processors.
+
+@item -mvis
+@itemx -mno-vis
+@opindex mvis
+@opindex mno-vis
+With @option{-mvis}, GCC generates code that takes advantage of the UltraSPARC
+Visual Instruction Set extensions.  The default is @option{-mno-vis}.
+@end table
+
+These @samp{-m} options are supported in addition to the above
+on SPARC-V9 processors in 64-bit environments:
+
+@table @gcctabopt
+@item -mlittle-endian
+@opindex mlittle-endian
+Generate code for a processor running in little-endian mode.  It is only
+available for a few configurations and most notably not on Solaris and Linux.
+
+@item -m32
+@itemx -m64
+@opindex m32
+@opindex m64
+Generate code for a 32-bit or 64-bit environment.
+The 32-bit environment sets int, long and pointer to 32 bits.
+The 64-bit environment sets int to 32 bits and long and pointer
+to 64 bits.
+
+@item -mcmodel=medlow
+@opindex mcmodel=medlow
+Generate code for the Medium/Low code model: 64-bit addresses, programs
+must be linked in the low 32 bits of memory.  Programs can be statically
+or dynamically linked.
+
+@item -mcmodel=medmid
+@opindex mcmodel=medmid
+Generate code for the Medium/Middle code model: 64-bit addresses, programs
+must be linked in the low 44 bits of memory, the text and data segments must
+be less than 2GB in size and the data segment must be located within 2GB of
+the text segment.
+
+@item -mcmodel=medany
+@opindex mcmodel=medany
+Generate code for the Medium/Anywhere code model: 64-bit addresses, programs
+may be linked anywhere in memory, the text and data segments must be less
+than 2GB in size and the data segment must be located within 2GB of the
+text segment.
+
+@item -mcmodel=embmedany
+@opindex mcmodel=embmedany
+Generate code for the Medium/Anywhere code model for embedded systems:
+64-bit addresses, the text and data segments must be less than 2GB in
+size, both starting anywhere in memory (determined at link time).  The
+global register %g4 points to the base of the data segment.  Programs
+are statically linked and PIC is not supported.
+
+@item -mstack-bias
+@itemx -mno-stack-bias
+@opindex mstack-bias
+@opindex mno-stack-bias
+With @option{-mstack-bias}, GCC assumes that the stack pointer, and
+frame pointer if present, are offset by @minus{}2047 which must be added back
+when making stack frame references.  This is the default in 64-bit mode.
+Otherwise, assume no such offset is present.
+@end table
+
+These switches are supported in addition to the above on Solaris:
+
+@table @gcctabopt
+@item -threads
+@opindex threads
+Add support for multithreading using the Solaris threads library.  This
+option sets flags for both the preprocessor and linker.  This option does
+not affect the thread safety of object code produced by the compiler or
+that of libraries supplied with it.
+
+@item -pthreads
+@opindex pthreads
+Add support for multithreading using the POSIX threads library.  This
+option sets flags for both the preprocessor and linker.  This option does
+not affect the thread safety of object code produced  by the compiler or
+that of libraries supplied with it.
+
+@item -pthread
+@opindex pthread
+This is a synonym for @option{-pthreads}.
+@end table
+
+@node SPU Options
+@subsection SPU Options
+@cindex SPU options
+
+These @samp{-m} options are supported on the SPU:
+
+@table @gcctabopt
+@item -mwarn-reloc
+@itemx -merror-reloc
+@opindex mwarn-reloc
+@opindex merror-reloc
+
+The loader for SPU does not handle dynamic relocations.  By default, GCC
+will give an error when it generates code that requires a dynamic
+relocation.  @option{-mno-error-reloc} disables the error,
+@option{-mwarn-reloc} will generate a warning instead.
+
+@item -msafe-dma
+@itemx -munsafe-dma
+@opindex msafe-dma
+@opindex munsafe-dma
+
+Instructions which initiate or test completion of DMA must not be
+reordered with respect to loads and stores of the memory which is being
+accessed.  Users typically address this problem using the volatile
+keyword, but that can lead to inefficient code in places where the
+memory is known to not change.  Rather than mark the memory as volatile
+we treat the DMA instructions as potentially effecting all memory.  With
+@option{-munsafe-dma} users must use the volatile keyword to protect
+memory accesses.
+
+@item -mbranch-hints
+@opindex mbranch-hints
+
+By default, GCC will generate a branch hint instruction to avoid
+pipeline stalls for always taken or probably taken branches.  A hint
+will not be generated closer than 8 instructions away from its branch.
+There is little reason to disable them, except for debugging purposes,
+or to make an object a little bit smaller.
+
+@item -msmall-mem
+@itemx -mlarge-mem
+@opindex msmall-mem
+@opindex mlarge-mem
+
+By default, GCC generates code assuming that addresses are never larger
+than 18 bits.  With @option{-mlarge-mem} code is generated that assumes
+a full 32 bit address.
+
+@item -mstdmain
+@opindex mstdmain
+
+By default, GCC links against startup code that assumes the SPU-style
+main function interface (which has an unconventional parameter list).
+With @option{-mstdmain}, GCC will link your program against startup
+code that assumes a C99-style interface to @code{main}, including a
+local copy of @code{argv} strings.
+
+@item -mfixed-range=@var{register-range}
+@opindex mfixed-range
+Generate code treating the given register range as fixed registers.
+A fixed register is one that the register allocator can not use.  This is
+useful when compiling kernel code.  A register range is specified as
+two registers separated by a dash.  Multiple register ranges can be
+specified separated by a comma.
+
+@item -mdual-nops
+@itemx -mdual-nops=@var{n}
+@opindex mdual-nops
+By default, GCC will insert nops to increase dual issue when it expects
+it to increase performance.  @var{n} can be a value from 0 to 10.  A
+smaller @var{n} will insert fewer nops.  10 is the default, 0 is the
+same as @option{-mno-dual-nops}.  Disabled with @option{-Os}.
+
+@item -mhint-max-nops=@var{n}
+@opindex mhint-max-nops
+Maximum number of nops to insert for a branch hint.  A branch hint must
+be at least 8 instructions away from the branch it is effecting.  GCC
+will insert up to @var{n} nops to enforce this, otherwise it will not
+generate the branch hint.
+
+@item -mhint-max-distance=@var{n}
+@opindex mhint-max-distance
+The encoding of the branch hint instruction limits the hint to be within
+256 instructions of the branch it is effecting.  By default, GCC makes
+sure it is within 125. 
+
+@item -msafe-hints
+@opindex msafe-hints
+Work around a hardware bug which causes the SPU to stall indefinitely.
+By default, GCC will insert the @code{hbrp} instruction to make sure
+this stall won't happen.
+
+@end table
+
+@node System V Options
+@subsection Options for System V
+
+These additional options are available on System V Release 4 for
+compatibility with other compilers on those systems:
+
+@table @gcctabopt
+@item -G
+@opindex G
+Create a shared object.
+It is recommended that @option{-symbolic} or @option{-shared} be used instead.
+
+@item -Qy
+@opindex Qy
+Identify the versions of each tool used by the compiler, in a
+@code{.ident} assembler directive in the output.
+
+@item -Qn
+@opindex Qn
+Refrain from adding @code{.ident} directives to the output file (this is
+the default).
+
+@item -YP,@var{dirs}
+@opindex YP
+Search the directories @var{dirs}, and no others, for libraries
+specified with @option{-l}.
+
+@item -Ym,@var{dir}
+@opindex Ym
+Look in the directory @var{dir} to find the M4 preprocessor.
+The assembler uses this option.
+@c This is supposed to go with a -Yd for predefined M4 macro files, but
+@c the generic assembler that comes with Solaris takes just -Ym.
+@end table
+
+@node V850 Options
+@subsection V850 Options
+@cindex V850 Options
+
+These @samp{-m} options are defined for V850 implementations:
+
+@table @gcctabopt
+@item -mlong-calls
+@itemx -mno-long-calls
+@opindex mlong-calls
+@opindex mno-long-calls
+Treat all calls as being far away (near).  If calls are assumed to be
+far away, the compiler will always load the functions address up into a
+register, and call indirect through the pointer.
+
+@item -mno-ep
+@itemx -mep
+@opindex mno-ep
+@opindex mep
+Do not optimize (do optimize) basic blocks that use the same index
+pointer 4 or more times to copy pointer into the @code{ep} register, and
+use the shorter @code{sld} and @code{sst} instructions.  The @option{-mep}
+option is on by default if you optimize.
+
+@item -mno-prolog-function
+@itemx -mprolog-function
+@opindex mno-prolog-function
+@opindex mprolog-function
+Do not use (do use) external functions to save and restore registers
+at the prologue and epilogue of a function.  The external functions
+are slower, but use less code space if more than one function saves
+the same number of registers.  The @option{-mprolog-function} option
+is on by default if you optimize.
+
+@item -mspace
+@opindex mspace
+Try to make the code as small as possible.  At present, this just turns
+on the @option{-mep} and @option{-mprolog-function} options.
+
+@item -mtda=@var{n}
+@opindex mtda
+Put static or global variables whose size is @var{n} bytes or less into
+the tiny data area that register @code{ep} points to.  The tiny data
+area can hold up to 256 bytes in total (128 bytes for byte references).
+
+@item -msda=@var{n}
+@opindex msda
+Put static or global variables whose size is @var{n} bytes or less into
+the small data area that register @code{gp} points to.  The small data
+area can hold up to 64 kilobytes.
+
+@item -mzda=@var{n}
+@opindex mzda
+Put static or global variables whose size is @var{n} bytes or less into
+the first 32 kilobytes of memory.
+
+@item -mv850
+@opindex mv850
+Specify that the target processor is the V850.
+
+@item -mbig-switch
+@opindex mbig-switch
+Generate code suitable for big switch tables.  Use this option only if
+the assembler/linker complain about out of range branches within a switch
+table.
+
+@item -mapp-regs
+@opindex mapp-regs
+This option will cause r2 and r5 to be used in the code generated by
+the compiler.  This setting is the default.
+
+@item -mno-app-regs
+@opindex mno-app-regs
+This option will cause r2 and r5 to be treated as fixed registers.
+
+@item -mv850e1
+@opindex mv850e1
+Specify that the target processor is the V850E1.  The preprocessor
+constants @samp{__v850e1__} and @samp{__v850e__} will be defined if
+this option is used.
+
+@item -mv850e
+@opindex mv850e
+Specify that the target processor is the V850E@.  The preprocessor
+constant @samp{__v850e__} will be defined if this option is used.
+
+If neither @option{-mv850} nor @option{-mv850e} nor @option{-mv850e1}
+are defined then a default target processor will be chosen and the
+relevant @samp{__v850*__} preprocessor constant will be defined.
+
+The preprocessor constants @samp{__v850} and @samp{__v851__} are always
+defined, regardless of which processor variant is the target.
+
+@item -mdisable-callt
+@opindex mdisable-callt
+This option will suppress generation of the CALLT instruction for the
+v850e and v850e1 flavors of the v850 architecture.  The default is
+@option{-mno-disable-callt} which allows the CALLT instruction to be used.
+
+@end table
+
+@node VAX Options
+@subsection VAX Options
+@cindex VAX options
+
+These @samp{-m} options are defined for the VAX:
+
+@table @gcctabopt
+@item -munix
+@opindex munix
+Do not output certain jump instructions (@code{aobleq} and so on)
+that the Unix assembler for the VAX cannot handle across long
+ranges.
+
+@item -mgnu
+@opindex mgnu
+Do output those jump instructions, on the assumption that you
+will assemble with the GNU assembler.
+
+@item -mg
+@opindex mg
+Output code for g-format floating point numbers instead of d-format.
+@end table
+
+@node VxWorks Options
+@subsection VxWorks Options
+@cindex VxWorks Options
+
+The options in this section are defined for all VxWorks targets.
+Options specific to the target hardware are listed with the other
+options for that target.
+
+@table @gcctabopt
+@item -mrtp
+@opindex mrtp
+GCC can generate code for both VxWorks kernels and real time processes
+(RTPs).  This option switches from the former to the latter.  It also
+defines the preprocessor macro @code{__RTP__}.
+
+@item -non-static
+@opindex non-static
+Link an RTP executable against shared libraries rather than static
+libraries.  The options @option{-static} and @option{-shared} can
+also be used for RTPs (@pxref{Link Options}); @option{-static}
+is the default.
+
+@item -Bstatic
+@itemx -Bdynamic
+@opindex Bstatic
+@opindex Bdynamic
+These options are passed down to the linker.  They are defined for
+compatibility with Diab.
+
+@item -Xbind-lazy
+@opindex Xbind-lazy
+Enable lazy binding of function calls.  This option is equivalent to
+@option{-Wl,-z,now} and is defined for compatibility with Diab.
+
+@item -Xbind-now
+@opindex Xbind-now
+Disable lazy binding of function calls.  This option is the default and
+is defined for compatibility with Diab.
+@end table
+
+@node x86-64 Options
+@subsection x86-64 Options
+@cindex x86-64 options
+
+These are listed under @xref{i386 and x86-64 Options}.
+
+@node Xstormy16 Options
+@subsection Xstormy16 Options
+@cindex Xstormy16 Options
+
+These options are defined for Xstormy16:
+
+@table @gcctabopt
+@item -msim
+@opindex msim
+Choose startup files and linker script suitable for the simulator.
+@end table
+
+@node Xtensa Options
+@subsection Xtensa Options
+@cindex Xtensa Options
+
+These options are supported for Xtensa targets:
+
+@table @gcctabopt
+@item -mconst16
+@itemx -mno-const16
+@opindex mconst16
+@opindex mno-const16
+Enable or disable use of @code{CONST16} instructions for loading
+constant values.  The @code{CONST16} instruction is currently not a
+standard option from Tensilica.  When enabled, @code{CONST16}
+instructions are always used in place of the standard @code{L32R}
+instructions.  The use of @code{CONST16} is enabled by default only if
+the @code{L32R} instruction is not available.
+
+@item -mfused-madd
+@itemx -mno-fused-madd
+@opindex mfused-madd
+@opindex mno-fused-madd
+Enable or disable use of fused multiply/add and multiply/subtract
+instructions in the floating-point option.  This has no effect if the
+floating-point option is not also enabled.  Disabling fused multiply/add
+and multiply/subtract instructions forces the compiler to use separate
+instructions for the multiply and add/subtract operations.  This may be
+desirable in some cases where strict IEEE 754-compliant results are
+required: the fused multiply add/subtract instructions do not round the
+intermediate result, thereby producing results with @emph{more} bits of
+precision than specified by the IEEE standard.  Disabling fused multiply
+add/subtract instructions also ensures that the program output is not
+sensitive to the compiler's ability to combine multiply and add/subtract
+operations.
+
+@item -mserialize-volatile
+@itemx -mno-serialize-volatile
+@opindex mserialize-volatile
+@opindex mno-serialize-volatile
+When this option is enabled, GCC inserts @code{MEMW} instructions before
+@code{volatile} memory references to guarantee sequential consistency.
+The default is @option{-mserialize-volatile}.  Use
+@option{-mno-serialize-volatile} to omit the @code{MEMW} instructions.
+
+@item -mtext-section-literals
+@itemx -mno-text-section-literals
+@opindex mtext-section-literals
+@opindex mno-text-section-literals
+Control the treatment of literal pools.  The default is
+@option{-mno-text-section-literals}, which places literals in a separate
+section in the output file.  This allows the literal pool to be placed
+in a data RAM/ROM, and it also allows the linker to combine literal
+pools from separate object files to remove redundant literals and
+improve code size.  With @option{-mtext-section-literals}, the literals
+are interspersed in the text section in order to keep them as close as
+possible to their references.  This may be necessary for large assembly
+files.
+
+@item -mtarget-align
+@itemx -mno-target-align
+@opindex mtarget-align
+@opindex mno-target-align
+When this option is enabled, GCC instructs the assembler to
+automatically align instructions to reduce branch penalties at the
+expense of some code density.  The assembler attempts to widen density
+instructions to align branch targets and the instructions following call
+instructions.  If there are not enough preceding safe density
+instructions to align a target, no widening will be performed.  The
+default is @option{-mtarget-align}.  These options do not affect the
+treatment of auto-aligned instructions like @code{LOOP}, which the
+assembler will always align, either by widening density instructions or
+by inserting no-op instructions.
+
+@item -mlongcalls
+@itemx -mno-longcalls
+@opindex mlongcalls
+@opindex mno-longcalls
+When this option is enabled, GCC instructs the assembler to translate
+direct calls to indirect calls unless it can determine that the target
+of a direct call is in the range allowed by the call instruction.  This
+translation typically occurs for calls to functions in other source
+files.  Specifically, the assembler translates a direct @code{CALL}
+instruction into an @code{L32R} followed by a @code{CALLX} instruction.
+The default is @option{-mno-longcalls}.  This option should be used in
+programs where the call target can potentially be out of range.  This
+option is implemented in the assembler, not the compiler, so the
+assembly code generated by GCC will still show direct call
+instructions---look at the disassembled object code to see the actual
+instructions.  Note that the assembler will use an indirect call for
+every cross-file call, not just those that really will be out of range.
+@end table
+
+@node zSeries Options
+@subsection zSeries Options
+@cindex zSeries options
+
+These are listed under @xref{S/390 and zSeries Options}.
+
+@node Code Gen Options
+@section Options for Code Generation Conventions
+@cindex code generation conventions
+@cindex options, code generation
+@cindex run-time options
+
+These machine-independent options control the interface conventions
+used in code generation.
+
+Most of them have both positive and negative forms; the negative form
+of @option{-ffoo} would be @option{-fno-foo}.  In the table below, only
+one of the forms is listed---the one which is not the default.  You
+can figure out the other form by either removing @samp{no-} or adding
+it.
+
+@table @gcctabopt
+@item -fbounds-check
+@opindex fbounds-check
+For front-ends that support it, generate additional code to check that
+indices used to access arrays are within the declared range.  This is
+currently only supported by the Java and Fortran front-ends, where
+this option defaults to true and false respectively.
+
+@item -ftrapv
+@opindex ftrapv
+This option generates traps for signed overflow on addition, subtraction,
+multiplication operations.
+
+@item -fwrapv
+@opindex fwrapv
+This option instructs the compiler to assume that signed arithmetic
+overflow of addition, subtraction and multiplication wraps around
+using twos-complement representation.  This flag enables some optimizations
+and disables others.  This option is enabled by default for the Java
+front-end, as required by the Java language specification.
+
+@item -fexceptions
+@opindex fexceptions
+Enable exception handling.  Generates extra code needed to propagate
+exceptions.  For some targets, this implies GCC will generate frame
+unwind information for all functions, which can produce significant data
+size overhead, although it does not affect execution.  If you do not
+specify this option, GCC will enable it by default for languages like
+C++ which normally require exception handling, and disable it for
+languages like C that do not normally require it.  However, you may need
+to enable this option when compiling C code that needs to interoperate
+properly with exception handlers written in C++.  You may also wish to
+disable this option if you are compiling older C++ programs that don't
+use exception handling.
+
+@item -fnon-call-exceptions
+@opindex fnon-call-exceptions
+Generate code that allows trapping instructions to throw exceptions.
+Note that this requires platform-specific runtime support that does
+not exist everywhere.  Moreover, it only allows @emph{trapping}
+instructions to throw exceptions, i.e.@: memory references or floating
+point instructions.  It does not allow exceptions to be thrown from
+arbitrary signal handlers such as @code{SIGALRM}.
+
+@item -funwind-tables
+@opindex funwind-tables
+Similar to @option{-fexceptions}, except that it will just generate any needed
+static data, but will not affect the generated code in any other way.
+You will normally not enable this option; instead, a language processor
+that needs this handling would enable it on your behalf.
+
+@item -fasynchronous-unwind-tables
+@opindex fasynchronous-unwind-tables
+Generate unwind table in dwarf2 format, if supported by target machine.  The
+table is exact at each instruction boundary, so it can be used for stack
+unwinding from asynchronous events (such as debugger or garbage collector).
+
+@item -fpcc-struct-return
+@opindex fpcc-struct-return
+Return ``short'' @code{struct} and @code{union} values in memory like
+longer ones, rather than in registers.  This convention is less
+efficient, but it has the advantage of allowing intercallability between
+GCC-compiled files and files compiled with other compilers, particularly
+the Portable C Compiler (pcc).
+
+The precise convention for returning structures in memory depends
+on the target configuration macros.
+
+Short structures and unions are those whose size and alignment match
+that of some integer type.
+
+@strong{Warning:} code compiled with the @option{-fpcc-struct-return}
+switch is not binary compatible with code compiled with the
+@option{-freg-struct-return} switch.
+Use it to conform to a non-default application binary interface.
+
+@item -freg-struct-return
+@opindex freg-struct-return
+Return @code{struct} and @code{union} values in registers when possible.
+This is more efficient for small structures than
+@option{-fpcc-struct-return}.
+
+If you specify neither @option{-fpcc-struct-return} nor
+@option{-freg-struct-return}, GCC defaults to whichever convention is
+standard for the target.  If there is no standard convention, GCC
+defaults to @option{-fpcc-struct-return}, except on targets where GCC is
+the principal compiler.  In those cases, we can choose the standard, and
+we chose the more efficient register return alternative.
+
+@strong{Warning:} code compiled with the @option{-freg-struct-return}
+switch is not binary compatible with code compiled with the
+@option{-fpcc-struct-return} switch.
+Use it to conform to a non-default application binary interface.
+
+@item -fshort-enums
+@opindex fshort-enums
+Allocate to an @code{enum} type only as many bytes as it needs for the
+declared range of possible values.  Specifically, the @code{enum} type
+will be equivalent to the smallest integer type which has enough room.
+
+@strong{Warning:} the @option{-fshort-enums} switch causes GCC to generate
+code that is not binary compatible with code generated without that switch.
+Use it to conform to a non-default application binary interface.
+
+@item -fshort-double
+@opindex fshort-double
+Use the same size for @code{double} as for @code{float}.
+
+@strong{Warning:} the @option{-fshort-double} switch causes GCC to generate
+code that is not binary compatible with code generated without that switch.
+Use it to conform to a non-default application binary interface.
+
+@item -fshort-wchar
+@opindex fshort-wchar
+Override the underlying type for @samp{wchar_t} to be @samp{short
+unsigned int} instead of the default for the target.  This option is
+useful for building programs to run under WINE@.
+
+@strong{Warning:} the @option{-fshort-wchar} switch causes GCC to generate
+code that is not binary compatible with code generated without that switch.
+Use it to conform to a non-default application binary interface.
+
+@item -fno-common
+@opindex fno-common
+In C code, controls the placement of uninitialized global variables.
+Unix C compilers have traditionally permitted multiple definitions of
+such variables in different compilation units by placing the variables
+in a common block.  
+This is the behavior specified by @option{-fcommon}, and is the default 
+for GCC on most targets.  
+On the other hand, this behavior is not required by ISO C, and on some
+targets may carry a speed or code size penalty on variable references.
+The @option{-fno-common} option specifies that the compiler should place 
+uninitialized global variables in the data section of the object file,
+rather than generating them as common blocks.
+This has the effect that if the same variable is declared 
+(without @code{extern}) in two different compilations,
+you will get a multiple-definition error when you link them.
+In this case, you must compile with @option{-fcommon} instead.  
+Compiling with @option{-fno-common} is useful on targets for which 
+it provides better performance, or if you wish to verify that the
+program will work on other systems which always treat uninitialized
+variable declarations this way.
+
+@item -fno-ident
+@opindex fno-ident
+Ignore the @samp{#ident} directive.
+
+@item -finhibit-size-directive
+@opindex finhibit-size-directive
+Don't output a @code{.size} assembler directive, or anything else that
+would cause trouble if the function is split in the middle, and the
+two halves are placed at locations far apart in memory.  This option is
+used when compiling @file{crtstuff.c}; you should not need to use it
+for anything else.
+
+@item -fverbose-asm
+@opindex fverbose-asm
+Put extra commentary information in the generated assembly code to
+make it more readable.  This option is generally only of use to those
+who actually need to read the generated assembly code (perhaps while
+debugging the compiler itself).
+
+@option{-fno-verbose-asm}, the default, causes the
+extra information to be omitted and is useful when comparing two assembler
+files.
+
+@item -frecord-gcc-switches
+@opindex frecord-gcc-switches
+This switch causes the command line that was used to invoke the
+compiler to be recorded into the object file that is being created.
+This switch is only implemented on some targets and the exact format
+of the recording is target and binary file format dependent, but it
+usually takes the form of a section containing ASCII text.  This
+switch is related to the @option{-fverbose-asm} switch, but that
+switch only records information in the assembler output file as
+comments, so it never reaches the object file.
+
+@item -fpic
+@opindex fpic
+@cindex global offset table
+@cindex PIC
+Generate position-independent code (PIC) suitable for use in a shared
+library, if supported for the target machine.  Such code accesses all
+constant addresses through a global offset table (GOT)@.  The dynamic
+loader resolves the GOT entries when the program starts (the dynamic
+loader is not part of GCC; it is part of the operating system).  If
+the GOT size for the linked executable exceeds a machine-specific
+maximum size, you get an error message from the linker indicating that
+@option{-fpic} does not work; in that case, recompile with @option{-fPIC}
+instead.  (These maximums are 8k on the SPARC and 32k
+on the m68k and RS/6000.  The 386 has no such limit.)
+
+Position-independent code requires special support, and therefore works
+only on certain machines.  For the 386, GCC supports PIC for System V
+but not for the Sun 386i.  Code generated for the IBM RS/6000 is always
+position-independent.
+
+When this flag is set, the macros @code{__pic__} and @code{__PIC__}
+are defined to 1.
+
+@item -fPIC
+@opindex fPIC
+If supported for the target machine, emit position-independent code,
+suitable for dynamic linking and avoiding any limit on the size of the
+global offset table.  This option makes a difference on the m68k,
+PowerPC and SPARC@.
+
+Position-independent code requires special support, and therefore works
+only on certain machines.
+
+When this flag is set, the macros @code{__pic__} and @code{__PIC__}
+are defined to 2.
+
+@item -fpie
+@itemx -fPIE
+@opindex fpie
+@opindex fPIE
+These options are similar to @option{-fpic} and @option{-fPIC}, but
+generated position independent code can be only linked into executables.
+Usually these options are used when @option{-pie} GCC option will be
+used during linking.
+
+@option{-fpie} and @option{-fPIE} both define the macros
+@code{__pie__} and @code{__PIE__}.  The macros have the value 1
+for @option{-fpie} and 2 for @option{-fPIE}.
+
+@item -fno-jump-tables
+@opindex fno-jump-tables
+Do not use jump tables for switch statements even where it would be
+more efficient than other code generation strategies.  This option is
+of use in conjunction with @option{-fpic} or @option{-fPIC} for
+building code which forms part of a dynamic linker and cannot
+reference the address of a jump table.  On some targets, jump tables
+do not require a GOT and this option is not needed.
+
+@item -ffixed-@var{reg}
+@opindex ffixed
+Treat the register named @var{reg} as a fixed register; generated code
+should never refer to it (except perhaps as a stack pointer, frame
+pointer or in some other fixed role).
+
+@var{reg} must be the name of a register.  The register names accepted
+are machine-specific and are defined in the @code{REGISTER_NAMES}
+macro in the machine description macro file.
+
+This flag does not have a negative form, because it specifies a
+three-way choice.
+
+@item -fcall-used-@var{reg}
+@opindex fcall-used
+Treat the register named @var{reg} as an allocable register that is
+clobbered by function calls.  It may be allocated for temporaries or
+variables that do not live across a call.  Functions compiled this way
+will not save and restore the register @var{reg}.
+
+It is an error to used this flag with the frame pointer or stack pointer.
+Use of this flag for other registers that have fixed pervasive roles in
+the machine's execution model will produce disastrous results.
+
+This flag does not have a negative form, because it specifies a
+three-way choice.
+
+@item -fcall-saved-@var{reg}
+@opindex fcall-saved
+Treat the register named @var{reg} as an allocable register saved by
+functions.  It may be allocated even for temporaries or variables that
+live across a call.  Functions compiled this way will save and restore
+the register @var{reg} if they use it.
+
+It is an error to used this flag with the frame pointer or stack pointer.
+Use of this flag for other registers that have fixed pervasive roles in
+the machine's execution model will produce disastrous results.
+
+A different sort of disaster will result from the use of this flag for
+a register in which function values may be returned.
+
+This flag does not have a negative form, because it specifies a
+three-way choice.
+
+@item -fpack-struct[=@var{n}]
+@opindex fpack-struct
+Without a value specified, pack all structure members together without
+holes.  When a value is specified (which must be a small power of two), pack
+structure members according to this value, representing the maximum
+alignment (that is, objects with default alignment requirements larger than
+this will be output potentially unaligned at the next fitting location.
+
+@strong{Warning:} the @option{-fpack-struct} switch causes GCC to generate
+code that is not binary compatible with code generated without that switch.
+Additionally, it makes the code suboptimal.
+Use it to conform to a non-default application binary interface.
+
+@item -finstrument-functions
+@opindex finstrument-functions
+Generate instrumentation calls for entry and exit to functions.  Just
+after function entry and just before function exit, the following
+profiling functions will be called with the address of the current
+function and its call site.  (On some platforms,
+@code{__builtin_return_address} does not work beyond the current
+function, so the call site information may not be available to the
+profiling functions otherwise.)
+
+@smallexample
+void __cyg_profile_func_enter (void *this_fn,
+                               void *call_site);
+void __cyg_profile_func_exit  (void *this_fn,
+                               void *call_site);
+@end smallexample
+
+The first argument is the address of the start of the current function,
+which may be looked up exactly in the symbol table.
+
+This instrumentation is also done for functions expanded inline in other
+functions.  The profiling calls will indicate where, conceptually, the
+inline function is entered and exited.  This means that addressable
+versions of such functions must be available.  If all your uses of a
+function are expanded inline, this may mean an additional expansion of
+code size.  If you use @samp{extern inline} in your C code, an
+addressable version of such functions must be provided.  (This is
+normally the case anyways, but if you get lucky and the optimizer always
+expands the functions inline, you might have gotten away without
+providing static copies.)
+
+A function may be given the attribute @code{no_instrument_function}, in
+which case this instrumentation will not be done.  This can be used, for
+example, for the profiling functions listed above, high-priority
+interrupt routines, and any functions from which the profiling functions
+cannot safely be called (perhaps signal handlers, if the profiling
+routines generate output or allocate memory).
+
+@item -finstrument-functions-exclude-file-list=@var{file},@var{file},@dots{}
+@opindex finstrument-functions-exclude-file-list
+
+Set the list of functions that are excluded from instrumentation (see
+the description of @code{-finstrument-functions}).  If the file that
+contains a function definition matches with one of @var{file}, then
+that function is not instrumented.  The match is done on substrings:
+if the @var{file} parameter is a substring of the file name, it is
+considered to be a match.
+
+For example,
+@code{-finstrument-functions-exclude-file-list=/bits/stl,include/sys}
+will exclude any inline function defined in files whose pathnames
+contain @code{/bits/stl} or @code{include/sys}.
+
+If, for some reason, you want to include letter @code{','} in one of
+@var{sym}, write @code{'\,'}. For example,
+@code{-finstrument-functions-exclude-file-list='\,\,tmp'}
+(note the single quote surrounding the option).
+
+@item -finstrument-functions-exclude-function-list=@var{sym},@var{sym},@dots{}
+@opindex finstrument-functions-exclude-function-list
+
+This is similar to @code{-finstrument-functions-exclude-file-list},
+but this option sets the list of function names to be excluded from
+instrumentation.  The function name to be matched is its user-visible
+name, such as @code{vector<int> blah(const vector<int> &)}, not the
+internal mangled name (e.g., @code{_Z4blahRSt6vectorIiSaIiEE}).  The
+match is done on substrings: if the @var{sym} parameter is a substring
+of the function name, it is considered to be a match.
+
+@item -fstack-check
+@opindex fstack-check
+Generate code to verify that you do not go beyond the boundary of the
+stack.  You should specify this flag if you are running in an
+environment with multiple threads, but only rarely need to specify it in
+a single-threaded environment since stack overflow is automatically
+detected on nearly all systems if there is only one stack.
+
+Note that this switch does not actually cause checking to be done; the
+operating system or the language runtime must do that.  The switch causes
+generation of code to ensure that they see the stack being extended.
+
+You can additionally specify a string parameter: @code{no} means no
+checking, @code{generic} means force the use of old-style checking,
+@code{specific} means use the best checking method and is equivalent
+to bare @option{-fstack-check}.
+
+Old-style checking is a generic mechanism that requires no specific
+target support in the compiler but comes with the following drawbacks:
+
+@enumerate
+@item
+Modified allocation strategy for large objects: they will always be
+allocated dynamically if their size exceeds a fixed threshold.
+
+@item
+Fixed limit on the size of the static frame of functions: when it is
+topped by a particular function, stack checking is not reliable and
+a warning is issued by the compiler.
+
+@item
+Inefficiency: because of both the modified allocation strategy and the
+generic implementation, the performances of the code are hampered.
+@end enumerate
+
+Note that old-style stack checking is also the fallback method for
+@code{specific} if no target support has been added in the compiler.
+
+@item -fstack-limit-register=@var{reg}
+@itemx -fstack-limit-symbol=@var{sym}
+@itemx -fno-stack-limit
+@opindex fstack-limit-register
+@opindex fstack-limit-symbol
+@opindex fno-stack-limit
+Generate code to ensure that the stack does not grow beyond a certain value,
+either the value of a register or the address of a symbol.  If the stack
+would grow beyond the value, a signal is raised.  For most targets,
+the signal is raised before the stack overruns the boundary, so
+it is possible to catch the signal without taking special precautions.
+
+For instance, if the stack starts at absolute address @samp{0x80000000}
+and grows downwards, you can use the flags
+@option{-fstack-limit-symbol=__stack_limit} and
+@option{-Wl,--defsym,__stack_limit=0x7ffe0000} to enforce a stack limit
+of 128KB@.  Note that this may only work with the GNU linker.
+
+@cindex aliasing of parameters
+@cindex parameters, aliased
+@item -fargument-alias
+@itemx -fargument-noalias
+@itemx -fargument-noalias-global
+@itemx -fargument-noalias-anything
+@opindex fargument-alias
+@opindex fargument-noalias
+@opindex fargument-noalias-global
+@opindex fargument-noalias-anything
+Specify the possible relationships among parameters and between
+parameters and global data.
+
+@option{-fargument-alias} specifies that arguments (parameters) may
+alias each other and may alias global storage.@*
+@option{-fargument-noalias} specifies that arguments do not alias
+each other, but may alias global storage.@*
+@option{-fargument-noalias-global} specifies that arguments do not
+alias each other and do not alias global storage.
+@option{-fargument-noalias-anything} specifies that arguments do not
+alias any other storage.
+
+Each language will automatically use whatever option is required by
+the language standard.  You should not need to use these options yourself.
+
+@item -fleading-underscore
+@opindex fleading-underscore
+This option and its counterpart, @option{-fno-leading-underscore}, forcibly
+change the way C symbols are represented in the object file.  One use
+is to help link with legacy assembly code.
+
+@strong{Warning:} the @option{-fleading-underscore} switch causes GCC to
+generate code that is not binary compatible with code generated without that
+switch.  Use it to conform to a non-default application binary interface.
+Not all targets provide complete support for this switch.
+
+@item -ftls-model=@var{model}
+@opindex ftls-model
+Alter the thread-local storage model to be used (@pxref{Thread-Local}).
+The @var{model} argument should be one of @code{global-dynamic},
+@code{local-dynamic}, @code{initial-exec} or @code{local-exec}.
+
+The default without @option{-fpic} is @code{initial-exec}; with
+@option{-fpic} the default is @code{global-dynamic}.
+
+@item -fvisibility=@var{default|internal|hidden|protected}
+@opindex fvisibility
+Set the default ELF image symbol visibility to the specified option---all
+symbols will be marked with this unless overridden within the code.
+Using this feature can very substantially improve linking and
+load times of shared object libraries, produce more optimized
+code, provide near-perfect API export and prevent symbol clashes.
+It is @strong{strongly} recommended that you use this in any shared objects
+you distribute.
+
+Despite the nomenclature, @code{default} always means public ie;
+available to be linked against from outside the shared object.
+@code{protected} and @code{internal} are pretty useless in real-world
+usage so the only other commonly used option will be @code{hidden}.
+The default if @option{-fvisibility} isn't specified is
+@code{default}, i.e., make every
+symbol public---this causes the same behavior as previous versions of
+GCC@.
+
+A good explanation of the benefits offered by ensuring ELF
+symbols have the correct visibility is given by ``How To Write
+Shared Libraries'' by Ulrich Drepper (which can be found at
+@w{@uref{http://people.redhat.com/~drepper/}})---however a superior
+solution made possible by this option to marking things hidden when
+the default is public is to make the default hidden and mark things
+public.  This is the norm with DLL's on Windows and with @option{-fvisibility=hidden}
+and @code{__attribute__ ((visibility("default")))} instead of
+@code{__declspec(dllexport)} you get almost identical semantics with
+identical syntax.  This is a great boon to those working with
+cross-platform projects.
+
+For those adding visibility support to existing code, you may find
+@samp{#pragma GCC visibility} of use.  This works by you enclosing
+the declarations you wish to set visibility for with (for example)
+@samp{#pragma GCC visibility push(hidden)} and
+@samp{#pragma GCC visibility pop}.
+Bear in mind that symbol visibility should be viewed @strong{as
+part of the API interface contract} and thus all new code should
+always specify visibility when it is not the default ie; declarations
+only for use within the local DSO should @strong{always} be marked explicitly
+as hidden as so to avoid PLT indirection overheads---making this
+abundantly clear also aids readability and self-documentation of the code.
+Note that due to ISO C++ specification requirements, operator new and
+operator delete must always be of default visibility.
+
+Be aware that headers from outside your project, in particular system
+headers and headers from any other library you use, may not be
+expecting to be compiled with visibility other than the default.  You
+may need to explicitly say @samp{#pragma GCC visibility push(default)}
+before including any such headers.
+
+@samp{extern} declarations are not affected by @samp{-fvisibility}, so
+a lot of code can be recompiled with @samp{-fvisibility=hidden} with
+no modifications.  However, this means that calls to @samp{extern}
+functions with no explicit visibility will use the PLT, so it is more
+effective to use @samp{__attribute ((visibility))} and/or
+@samp{#pragma GCC visibility} to tell the compiler which @samp{extern}
+declarations should be treated as hidden.
+
+Note that @samp{-fvisibility} does affect C++ vague linkage
+entities. This means that, for instance, an exception class that will
+be thrown between DSOs must be explicitly marked with default
+visibility so that the @samp{type_info} nodes will be unified between
+the DSOs.
+
+An overview of these techniques, their benefits and how to use them
+is at @w{@uref{http://gcc.gnu.org/wiki/Visibility}}.
+
+@end table
+
+@c man end
+
+@node Environment Variables
+@section Environment Variables Affecting GCC
+@cindex environment variables
+
+@c man begin ENVIRONMENT
+This section describes several environment variables that affect how GCC
+operates.  Some of them work by specifying directories or prefixes to use
+when searching for various kinds of files.  Some are used to specify other
+aspects of the compilation environment.
+
+Note that you can also specify places to search using options such as
+@option{-B}, @option{-I} and @option{-L} (@pxref{Directory Options}).  These
+take precedence over places specified using environment variables, which
+in turn take precedence over those specified by the configuration of GCC@.
+@xref{Driver,, Controlling the Compilation Driver @file{gcc}, gccint,
+GNU Compiler Collection (GCC) Internals}.
+
+@table @env
+@item LANG
+@itemx LC_CTYPE
+@c @itemx LC_COLLATE
+@itemx LC_MESSAGES
+@c @itemx LC_MONETARY
+@c @itemx LC_NUMERIC
+@c @itemx LC_TIME
+@itemx LC_ALL
+@findex LANG
+@findex LC_CTYPE
+@c @findex LC_COLLATE
+@findex LC_MESSAGES
+@c @findex LC_MONETARY
+@c @findex LC_NUMERIC
+@c @findex LC_TIME
+@findex LC_ALL
+@cindex locale
+These environment variables control the way that GCC uses
+localization information that allow GCC to work with different
+national conventions.  GCC inspects the locale categories
+@env{LC_CTYPE} and @env{LC_MESSAGES} if it has been configured to do
+so.  These locale categories can be set to any value supported by your
+installation.  A typical value is @samp{en_GB.UTF-8} for English in the United
+Kingdom encoded in UTF-8.
+
+The @env{LC_CTYPE} environment variable specifies character
+classification.  GCC uses it to determine the character boundaries in
+a string; this is needed for some multibyte encodings that contain quote
+and escape characters that would otherwise be interpreted as a string
+end or escape.
+
+The @env{LC_MESSAGES} environment variable specifies the language to
+use in diagnostic messages.
+
+If the @env{LC_ALL} environment variable is set, it overrides the value
+of @env{LC_CTYPE} and @env{LC_MESSAGES}; otherwise, @env{LC_CTYPE}
+and @env{LC_MESSAGES} default to the value of the @env{LANG}
+environment variable.  If none of these variables are set, GCC
+defaults to traditional C English behavior.
+
+@item TMPDIR
+@findex TMPDIR
+If @env{TMPDIR} is set, it specifies the directory to use for temporary
+files.  GCC uses temporary files to hold the output of one stage of
+compilation which is to be used as input to the next stage: for example,
+the output of the preprocessor, which is the input to the compiler
+proper.
+
+@item GCC_EXEC_PREFIX
+@findex GCC_EXEC_PREFIX
+If @env{GCC_EXEC_PREFIX} is set, it specifies a prefix to use in the
+names of the subprograms executed by the compiler.  No slash is added
+when this prefix is combined with the name of a subprogram, but you can
+specify a prefix that ends with a slash if you wish.
+
+If @env{GCC_EXEC_PREFIX} is not set, GCC will attempt to figure out
+an appropriate prefix to use based on the pathname it was invoked with.
+
+If GCC cannot find the subprogram using the specified prefix, it
+tries looking in the usual places for the subprogram.
+
+The default value of @env{GCC_EXEC_PREFIX} is
+@file{@var{prefix}/lib/gcc/} where @var{prefix} is the prefix to
+the installed compiler. In many cases @var{prefix} is the value
+of @code{prefix} when you ran the @file{configure} script.
+
+Other prefixes specified with @option{-B} take precedence over this prefix.
+
+This prefix is also used for finding files such as @file{crt0.o} that are
+used for linking.
+
+In addition, the prefix is used in an unusual way in finding the
+directories to search for header files.  For each of the standard
+directories whose name normally begins with @samp{/usr/local/lib/gcc}
+(more precisely, with the value of @env{GCC_INCLUDE_DIR}), GCC tries
+replacing that beginning with the specified prefix to produce an
+alternate directory name.  Thus, with @option{-Bfoo/}, GCC will search
+@file{foo/bar} where it would normally search @file{/usr/local/lib/bar}.
+These alternate directories are searched first; the standard directories
+come next. If a standard directory begins with the configured
+@var{prefix} then the value of @var{prefix} is replaced by
+@env{GCC_EXEC_PREFIX} when looking for header files.
+
+@item COMPILER_PATH
+@findex COMPILER_PATH
+The value of @env{COMPILER_PATH} is a colon-separated list of
+directories, much like @env{PATH}.  GCC tries the directories thus
+specified when searching for subprograms, if it can't find the
+subprograms using @env{GCC_EXEC_PREFIX}.
+
+@item LIBRARY_PATH
+@findex LIBRARY_PATH
+The value of @env{LIBRARY_PATH} is a colon-separated list of
+directories, much like @env{PATH}.  When configured as a native compiler,
+GCC tries the directories thus specified when searching for special
+linker files, if it can't find them using @env{GCC_EXEC_PREFIX}.  Linking
+using GCC also uses these directories when searching for ordinary
+libraries for the @option{-l} option (but directories specified with
+@option{-L} come first).
+
+@item LANG
+@findex LANG
+@cindex locale definition
+This variable is used to pass locale information to the compiler.  One way in
+which this information is used is to determine the character set to be used
+when character literals, string literals and comments are parsed in C and C++.
+When the compiler is configured to allow multibyte characters,
+the following values for @env{LANG} are recognized:
+
+@table @samp
+@item C-JIS
+Recognize JIS characters.
+@item C-SJIS
+Recognize SJIS characters.
+@item C-EUCJP
+Recognize EUCJP characters.
+@end table
+
+If @env{LANG} is not defined, or if it has some other value, then the
+compiler will use mblen and mbtowc as defined by the default locale to
+recognize and translate multibyte characters.
+@end table
+
+@noindent
+Some additional environments variables affect the behavior of the
+preprocessor.
+
+@include cppenv.texi
+
+@c man end
+
+@node Precompiled Headers
+@section Using Precompiled Headers
+@cindex precompiled headers
+@cindex speed of compilation
+
+Often large projects have many header files that are included in every
+source file.  The time the compiler takes to process these header files
+over and over again can account for nearly all of the time required to
+build the project.  To make builds faster, GCC allows users to
+`precompile' a header file; then, if builds can use the precompiled
+header file they will be much faster.
+
+To create a precompiled header file, simply compile it as you would any
+other file, if necessary using the @option{-x} option to make the driver
+treat it as a C or C++ header file.  You will probably want to use a
+tool like @command{make} to keep the precompiled header up-to-date when
+the headers it contains change.
+
+A precompiled header file will be searched for when @code{#include} is
+seen in the compilation.  As it searches for the included file
+(@pxref{Search Path,,Search Path,cpp,The C Preprocessor}) the
+compiler looks for a precompiled header in each directory just before it
+looks for the include file in that directory.  The name searched for is
+the name specified in the @code{#include} with @samp{.gch} appended.  If
+the precompiled header file can't be used, it is ignored.
+
+For instance, if you have @code{#include "all.h"}, and you have
+@file{all.h.gch} in the same directory as @file{all.h}, then the
+precompiled header file will be used if possible, and the original
+header will be used otherwise.
+
+Alternatively, you might decide to put the precompiled header file in a
+directory and use @option{-I} to ensure that directory is searched
+before (or instead of) the directory containing the original header.
+Then, if you want to check that the precompiled header file is always
+used, you can put a file of the same name as the original header in this
+directory containing an @code{#error} command.
+
+This also works with @option{-include}.  So yet another way to use
+precompiled headers, good for projects not designed with precompiled
+header files in mind, is to simply take most of the header files used by
+a project, include them from another header file, precompile that header
+file, and @option{-include} the precompiled header.  If the header files
+have guards against multiple inclusion, they will be skipped because
+they've already been included (in the precompiled header).
+
+If you need to precompile the same header file for different
+languages, targets, or compiler options, you can instead make a
+@emph{directory} named like @file{all.h.gch}, and put each precompiled
+header in the directory, perhaps using @option{-o}.  It doesn't matter
+what you call the files in the directory, every precompiled header in
+the directory will be considered.  The first precompiled header
+encountered in the directory that is valid for this compilation will
+be used; they're searched in no particular order.
+
+There are many other possibilities, limited only by your imagination,
+good sense, and the constraints of your build system.
+
+A precompiled header file can be used only when these conditions apply:
+
+@itemize
+@item
+Only one precompiled header can be used in a particular compilation.
+
+@item
+A precompiled header can't be used once the first C token is seen.  You
+can have preprocessor directives before a precompiled header; you can
+even include a precompiled header from inside another header, so long as
+there are no C tokens before the @code{#include}.
+
+@item
+The precompiled header file must be produced for the same language as
+the current compilation.  You can't use a C precompiled header for a C++
+compilation.
+
+@item
+The precompiled header file must have been produced by the same compiler
+binary as the current compilation is using.
+
+@item
+Any macros defined before the precompiled header is included must
+either be defined in the same way as when the precompiled header was
+generated, or must not affect the precompiled header, which usually
+means that they don't appear in the precompiled header at all.
+
+The @option{-D} option is one way to define a macro before a
+precompiled header is included; using a @code{#define} can also do it.
+There are also some options that define macros implicitly, like
+@option{-O} and @option{-Wdeprecated}; the same rule applies to macros
+defined this way.
+
+@item If debugging information is output when using the precompiled
+header, using @option{-g} or similar, the same kind of debugging information
+must have been output when building the precompiled header.  However,
+a precompiled header built using @option{-g} can be used in a compilation
+when no debugging information is being output.
+
+@item The same @option{-m} options must generally be used when building
+and using the precompiled header.  @xref{Submodel Options},
+for any cases where this rule is relaxed.
+
+@item Each of the following options must be the same when building and using
+the precompiled header:
+
+@gccoptlist{-fexceptions}
+
+@item
+Some other command-line options starting with @option{-f},
+@option{-p}, or @option{-O} must be defined in the same way as when
+the precompiled header was generated.  At present, it's not clear
+which options are safe to change and which are not; the safest choice
+is to use exactly the same options when generating and using the
+precompiled header.  The following are known to be safe:
+
+@gccoptlist{-fmessage-length=  -fpreprocessed  -fsched-interblock @gol
+-fsched-spec  -fsched-spec-load  -fsched-spec-load-dangerous @gol
+-fsched-verbose=<number>  -fschedule-insns  -fvisibility= @gol
+-pedantic-errors}
+
+@end itemize
+
+For all of these except the last, the compiler will automatically
+ignore the precompiled header if the conditions aren't met.  If you
+find an option combination that doesn't work and doesn't cause the
+precompiled header to be ignored, please consider filing a bug report,
+see @ref{Bugs}.
+
+If you do use differing options when generating and using the
+precompiled header, the actual behavior will be a mixture of the
+behavior for the options.  For instance, if you use @option{-g} to
+generate the precompiled header but not when using it, you may or may
+not get debugging information for routines in the precompiled header.
+
+@node Running Protoize
+@section Running Protoize
+
+The program @code{protoize} is an optional part of GCC@.  You can use
+it to add prototypes to a program, thus converting the program to ISO
+C in one respect.  The companion program @code{unprotoize} does the
+reverse: it removes argument types from any prototypes that are found.
+
+When you run these programs, you must specify a set of source files as
+command line arguments.  The conversion programs start out by compiling
+these files to see what functions they define.  The information gathered
+about a file @var{foo} is saved in a file named @file{@var{foo}.X}.
+
+After scanning comes actual conversion.  The specified files are all
+eligible to be converted; any files they include (whether sources or
+just headers) are eligible as well.
+
+But not all the eligible files are converted.  By default,
+@code{protoize} and @code{unprotoize} convert only source and header
+files in the current directory.  You can specify additional directories
+whose files should be converted with the @option{-d @var{directory}}
+option.  You can also specify particular files to exclude with the
+@option{-x @var{file}} option.  A file is converted if it is eligible, its
+directory name matches one of the specified directory names, and its
+name within the directory has not been excluded.
+
+Basic conversion with @code{protoize} consists of rewriting most
+function definitions and function declarations to specify the types of
+the arguments.  The only ones not rewritten are those for varargs
+functions.
+
+@code{protoize} optionally inserts prototype declarations at the
+beginning of the source file, to make them available for any calls that
+precede the function's definition.  Or it can insert prototype
+declarations with block scope in the blocks where undeclared functions
+are called.
+
+Basic conversion with @code{unprotoize} consists of rewriting most
+function declarations to remove any argument types, and rewriting
+function definitions to the old-style pre-ISO form.
+
+Both conversion programs print a warning for any function declaration or
+definition that they can't convert.  You can suppress these warnings
+with @option{-q}.
+
+The output from @code{protoize} or @code{unprotoize} replaces the
+original source file.  The original file is renamed to a name ending
+with @samp{.save} (for DOS, the saved filename ends in @samp{.sav}
+without the original @samp{.c} suffix).  If the @samp{.save} (@samp{.sav}
+for DOS) file already exists, then the source file is simply discarded.
+
+@code{protoize} and @code{unprotoize} both depend on GCC itself to
+scan the program and collect information about the functions it uses.
+So neither of these programs will work until GCC is installed.
+
+Here is a table of the options you can use with @code{protoize} and
+@code{unprotoize}.  Each option works with both programs unless
+otherwise stated.
+
+@table @code
+@item -B @var{directory}
+Look for the file @file{SYSCALLS.c.X} in @var{directory}, instead of the
+usual directory (normally @file{/usr/local/lib}).  This file contains
+prototype information about standard system functions.  This option
+applies only to @code{protoize}.
+
+@item -c @var{compilation-options}
+Use @var{compilation-options} as the options when running @command{gcc} to
+produce the @samp{.X} files.  The special option @option{-aux-info} is
+always passed in addition, to tell @command{gcc} to write a @samp{.X} file.
+
+Note that the compilation options must be given as a single argument to
+@code{protoize} or @code{unprotoize}.  If you want to specify several
+@command{gcc} options, you must quote the entire set of compilation options
+to make them a single word in the shell.
+
+There are certain @command{gcc} arguments that you cannot use, because they
+would produce the wrong kind of output.  These include @option{-g},
+@option{-O}, @option{-c}, @option{-S}, and @option{-o} If you include these in
+the @var{compilation-options}, they are ignored.
+
+@item -C
+Rename files to end in @samp{.C} (@samp{.cc} for DOS-based file
+systems) instead of @samp{.c}.  This is convenient if you are converting
+a C program to C++.  This option applies only to @code{protoize}.
+
+@item -g
+Add explicit global declarations.  This means inserting explicit
+declarations at the beginning of each source file for each function
+that is called in the file and was not declared.  These declarations
+precede the first function definition that contains a call to an
+undeclared function.  This option applies only to @code{protoize}.
+
+@item -i @var{string}
+Indent old-style parameter declarations with the string @var{string}.
+This option applies only to @code{protoize}.
+
+@code{unprotoize} converts prototyped function definitions to old-style
+function definitions, where the arguments are declared between the
+argument list and the initial @samp{@{}.  By default, @code{unprotoize}
+uses five spaces as the indentation.  If you want to indent with just
+one space instead, use @option{-i " "}.
+
+@item -k
+Keep the @samp{.X} files.  Normally, they are deleted after conversion
+is finished.
+
+@item -l
+Add explicit local declarations.  @code{protoize} with @option{-l} inserts
+a prototype declaration for each function in each block which calls the
+function without any declaration.  This option applies only to
+@code{protoize}.
+
+@item -n
+Make no real changes.  This mode just prints information about the conversions
+that would have been done without @option{-n}.
+
+@item -N
+Make no @samp{.save} files.  The original files are simply deleted.
+Use this option with caution.
+
+@item -p @var{program}
+Use the program @var{program} as the compiler.  Normally, the name
+@file{gcc} is used.
+
+@item -q
+Work quietly.  Most warnings are suppressed.
+
+@item -v
+Print the version number, just like @option{-v} for @command{gcc}.
+@end table
+
+If you need special compiler options to compile one of your program's
+source files, then you should generate that file's @samp{.X} file
+specially, by running @command{gcc} on that source file with the
+appropriate options and the option @option{-aux-info}.  Then run
+@code{protoize} on the entire set of files.  @code{protoize} will use
+the existing @samp{.X} file because it is newer than the source file.
+For example:
+
+@smallexample
+gcc -Dfoo=bar file1.c -aux-info file1.X
+protoize *.c
+@end smallexample
+
+@noindent
+You need to include the special files along with the rest in the
+@code{protoize} command, even though their @samp{.X} files already
+exist, because otherwise they won't get converted.
+
+@xref{Protoize Caveats}, for more information on how to use
+@code{protoize} successfully.
diff -Nur gcc-4.4.6.orig/gcc/doc/md.texi gcc-4.4.6/gcc/doc/md.texi
--- gcc-4.4.6.orig/gcc/doc/md.texi	2009-05-07 10:14:55.000000000 +0200
+++ gcc-4.4.6/gcc/doc/md.texi	2011-08-27 19:45:43.849240766 +0200
@@ -4,6 +4,7 @@
 @c This is part of the GCC manual.
 @c For copying conditions, see the file gcc.texi.
 
+
 @ifset INTERNALS
 @node Machine Desc
 @chapter Machine Descriptions
@@ -1685,6 +1686,58 @@
 A memory reference suitable for the ARMv4 ldrsb instruction.
 @end table
 
+@item AVR32 family---@file{avr32.h}
+@table @code
+@item f
+Floating-point registers (f0 to f15)
+
+@item Ku@var{bits}
+Unsigned constant representable with @var{bits} number of bits (Must be
+two digits). I.e: An unsigned 8-bit constant is written as @samp{Ku08}  
+ 
+@item Ks@var{bits}
+Signed constant representable with @var{bits} number of bits (Must be
+two digits). I.e: A signed 12-bit constant is written as @samp{Ks12}  
+
+@item Is@var{bits}
+The negated range of a signed constant representable with  @var{bits} 
+number of bits. The same as @samp{Ks@var{bits}} with a negated range. 
+This means that the constant must be in the range @math{-2^{bits-1}-1} to @math{2^{bits-1}}
+
+@item G
+A single/double precision floating-point immediate or 64-bit integer 
+immediate where the least and most significant words both can be
+loaded with a move instruction. That is the the integer form of the 
+values in the least and most significant words both are in the range 
+@math{-2^{20}} to @math{2^{20}-1}.
+         
+@item RKs@var{bits}
+A memory reference where the address consists of a base register
+plus a signed immediate displacement with range given by @samp{Ks@var{bits}}
+which has the same format as for the signed immediate integer constraint
+given above.  
+
+@item RKu@var{bits}
+A memory reference where the address consists of a base register
+plus an unsigned immediate displacement with range given by @samp{Ku@var{bits}}
+which has the same format as for the unsigned immediate integer constraint
+given above.  
+
+@item S
+A memory reference with an immediate or register offset
+
+@item T
+A memory reference to a constant pool entry
+
+@item W
+A valid operand for use in the @samp{lda.w} instruction macro when
+relaxing is enabled
+
+@item Z
+A memory reference valid for coprocessor memory instructions
+
+@end table
+
 @item AVR family---@file{config/avr/constraints.md}
 @table @code
 @item l
diff -Nur gcc-4.4.6.orig/gcc/expmed.c gcc-4.4.6/gcc/expmed.c
--- gcc-4.4.6.orig/gcc/expmed.c	2010-08-06 09:52:04.000000000 +0200
+++ gcc-4.4.6/gcc/expmed.c	2011-08-27 19:45:43.869240328 +0200
@@ -472,9 +472,9 @@
 	  ? ((GET_MODE_SIZE (fieldmode) >= UNITS_PER_WORD
 	     || GET_MODE_SIZE (GET_MODE (op0)) == GET_MODE_SIZE (fieldmode))
 	     && byte_offset % GET_MODE_SIZE (fieldmode) == 0)
-	  : (! SLOW_UNALIGNED_ACCESS (fieldmode, MEM_ALIGN (op0))
+          : ( (! SLOW_UNALIGNED_ACCESS (fieldmode, MEM_ALIGN (op0))
 	     || (offset * BITS_PER_UNIT % bitsize == 0
-		 && MEM_ALIGN (op0) % GET_MODE_BITSIZE (fieldmode) == 0))))
+                     && MEM_ALIGN (op0) % GET_MODE_BITSIZE (fieldmode) == 0)))))
     {
       if (MEM_P (op0))
 	op0 = adjust_address (op0, fieldmode, offset);
diff -Nur gcc-4.4.6.orig/gcc/expr.c gcc-4.4.6/gcc/expr.c
--- gcc-4.4.6.orig/gcc/expr.c	2011-01-16 23:56:10.000000000 +0100
+++ gcc-4.4.6/gcc/expr.c	2011-08-27 19:45:43.937982102 +0200
@@ -52,6 +52,7 @@
 #include "tree-flow.h"
 #include "target.h"
 #include "timevar.h"
+#include "c-common.h"
 #include "df.h"
 #include "diagnostic.h"
 
@@ -3647,16 +3648,17 @@
     }
   else
     {
+      emit_move_insn (stack_pointer_rtx,
+		      expand_binop (Pmode,
 #ifdef STACK_GROWS_DOWNWARD
-      /* ??? This seems wrong if STACK_PUSH_CODE == POST_DEC.  */
-      dest_addr = gen_rtx_PLUS (Pmode, stack_pointer_rtx,
-				GEN_INT (-(HOST_WIDE_INT) rounded_size));
+				    sub_optab,
 #else
-      /* ??? This seems wrong if STACK_PUSH_CODE == POST_INC.  */
-      dest_addr = gen_rtx_PLUS (Pmode, stack_pointer_rtx,
-				GEN_INT (rounded_size));
+				    add_optab,
 #endif
-      dest_addr = gen_rtx_PRE_MODIFY (Pmode, stack_pointer_rtx, dest_addr);
+				    stack_pointer_rtx,
+				    GEN_INT (rounded_size),
+				    NULL_RTX, 0, OPTAB_LIB_WIDEN));
+      dest_addr = stack_pointer_rtx;
     }
 
   dest = gen_rtx_MEM (mode, dest_addr);
@@ -5775,7 +5777,8 @@
      is a bit field, we cannot use addressing to access it.
      Use bit-field techniques or SUBREG to store in it.  */
 
-  if (mode == VOIDmode
+  if (
+      mode == VOIDmode
       || (mode != BLKmode && ! direct_store[(int) mode]
 	  && GET_MODE_CLASS (mode) != MODE_COMPLEX_INT
 	  && GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)
@@ -5932,7 +5935,18 @@
     {
       tree field = TREE_OPERAND (exp, 1);
       size_tree = DECL_SIZE (field);
-      if (!DECL_BIT_FIELD (field))
+      if (!DECL_BIT_FIELD (field)
+          /* Added for AVR32:
+             Bitfields with a size equal to a target storage
+             type might not cause DECL_BIT_FIELD to return
+             true since it can be optimized into a normal array
+             access operation. But for volatile bitfields we do
+             not allow this when targetm.narrow_volatile_bitfield ()
+             is false. We can use DECL_C_BIT_FIELD to check if this
+             really is a c-bitfield. */ 
+          && !(TREE_THIS_VOLATILE (exp)
+               && !targetm.narrow_volatile_bitfield ()
+               && DECL_C_BIT_FIELD (field)) )
 	mode = DECL_MODE (field);
       else if (DECL_MODE (field) == BLKmode)
 	blkmode_bitfield = true;
@@ -7915,7 +7929,8 @@
 	   by doing the extract into an object as wide as the field
 	   (which we know to be the width of a basic mode), then
 	   storing into memory, and changing the mode to BLKmode.  */
-	if (mode1 == VOIDmode
+       if (      
+            mode1 == VOIDmode
 	    || REG_P (op0) || GET_CODE (op0) == SUBREG
 	    || (mode1 != BLKmode && ! direct_load[(int) mode1]
 		&& GET_MODE_CLASS (mode) != MODE_COMPLEX_INT
diff -Nur gcc-4.4.6.orig/gcc/function.c gcc-4.4.6/gcc/function.c
--- gcc-4.4.6.orig/gcc/function.c	2010-08-16 22:24:54.000000000 +0200
+++ gcc-4.4.6/gcc/function.c	2011-08-27 19:45:43.947990930 +0200
@@ -2810,7 +2810,11 @@
   assign_parm_remove_parallels (data);
 
   /* Copy the value into the register.  */
-  if (data->nominal_mode != data->passed_mode
+  if ( (data->nominal_mode != data->passed_mode
+        /* Added for AVR32: If passed_mode is equal
+           to promoted nominal mode why should be convert?
+           The conversion should make no difference. */
+        && data->passed_mode != promoted_nominal_mode)
       || promoted_nominal_mode != data->promoted_mode)
     {
       int save_tree_used;
diff -Nur gcc-4.4.6.orig/gcc/genemit.c gcc-4.4.6/gcc/genemit.c
--- gcc-4.4.6.orig/gcc/genemit.c	2009-02-20 16:20:38.000000000 +0100
+++ gcc-4.4.6/gcc/genemit.c	2011-08-27 19:45:44.027983016 +0200
@@ -121,6 +121,24 @@
 }
 
 static void
+gen_vararg_prologue(int operands)
+{
+  int i;
+
+  if (operands > 1)
+    {
+      for (i = 1; i < operands; i++)
+	printf("  rtx operand%d ATTRIBUTE_UNUSED;\n", i);
+
+      printf("  va_list args;\n\n");
+      printf("  va_start(args, operand0);\n");
+      for (i = 1; i < operands; i++)
+	printf("  operand%d = va_arg(args, rtx);\n", i);
+      printf("  va_end(args);\n\n");
+    }
+}
+
+static void
 print_code (RTX_CODE code)
 {
   const char *p1;
@@ -406,18 +424,16 @@
     fatal ("match_dup operand number has no match_operand");
 
   /* Output the function name and argument declarations.  */
-  printf ("rtx\ngen_%s (", XSTR (insn, 0));
+  printf ("rtx\ngen_%s ", XSTR (insn, 0));
+
   if (operands)
-    for (i = 0; i < operands; i++)
-      if (i)
-	printf (",\n\trtx operand%d ATTRIBUTE_UNUSED", i);
+    printf("(rtx operand0 ATTRIBUTE_UNUSED, ...)\n");
       else
-	printf ("rtx operand%d ATTRIBUTE_UNUSED", i);
-  else
-    printf ("void");
-  printf (")\n");
+    printf("(void)\n");
   printf ("{\n");
 
+  gen_vararg_prologue(operands);
+
   /* Output code to construct and return the rtl for the instruction body.  */
 
   if (XVECLEN (insn, 1) == 1)
@@ -461,16 +477,12 @@
   operands = max_operand_vec (expand, 1);
 
   /* Output the function name and argument declarations.  */
-  printf ("rtx\ngen_%s (", XSTR (expand, 0));
+  printf ("rtx\ngen_%s ", XSTR (expand, 0));
   if (operands)
-    for (i = 0; i < operands; i++)
-      if (i)
-	printf (",\n\trtx operand%d", i);
-      else
-	printf ("rtx operand%d", i);
+    printf("(rtx operand0 ATTRIBUTE_UNUSED, ...)\n");
   else
-    printf ("void");
-  printf (")\n");
+    printf("(void)\n");
+
   printf ("{\n");
 
   /* If we don't have any C code to write, only one insn is being written,
@@ -480,6 +492,8 @@
       && operands > max_dup_opno
       && XVECLEN (expand, 1) == 1)
     {
+      gen_vararg_prologue(operands);
+
       printf ("  return ");
       gen_exp (XVECEXP (expand, 1, 0), DEFINE_EXPAND, NULL);
       printf (";\n}\n\n");
@@ -493,6 +507,7 @@
   for (; i <= max_scratch_opno; i++)
     printf ("  rtx operand%d ATTRIBUTE_UNUSED;\n", i);
   printf ("  rtx _val = 0;\n");
+  gen_vararg_prologue(operands);
   printf ("  start_sequence ();\n");
 
   /* The fourth operand of DEFINE_EXPAND is some code to be executed
diff -Nur gcc-4.4.6.orig/gcc/genflags.c gcc-4.4.6/gcc/genflags.c
--- gcc-4.4.6.orig/gcc/genflags.c	2007-07-26 10:37:01.000000000 +0200
+++ gcc-4.4.6/gcc/genflags.c	2011-08-27 19:45:44.067990456 +0200
@@ -127,7 +127,6 @@
 gen_proto (rtx insn)
 {
   int num = num_operands (insn);
-  int i;
   const char *name = XSTR (insn, 0);
   int truth = maybe_eval_c_test (XSTR (insn, 2));
 
@@ -158,12 +157,7 @@
   if (num == 0)
     fputs ("void", stdout);
   else
-    {
-      for (i = 1; i < num; i++)
-	fputs ("rtx, ", stdout);
-
-      fputs ("rtx", stdout);
-    }
+    fputs("rtx, ...", stdout);
 
   puts (");");
 
@@ -173,12 +167,7 @@
     {
       printf ("static inline rtx\ngen_%s", name);
       if (num > 0)
-	{
-	  putchar ('(');
-	  for (i = 0; i < num-1; i++)
-	    printf ("rtx ARG_UNUSED (%c), ", 'a' + i);
-	  printf ("rtx ARG_UNUSED (%c))\n", 'a' + i);
-	}
+	puts("(rtx ARG_UNUSED(a), ...)");
       else
 	puts ("(void)");
       puts ("{\n  return 0;\n}");
diff -Nur gcc-4.4.6.orig/gcc/genoutput.c gcc-4.4.6/gcc/genoutput.c
--- gcc-4.4.6.orig/gcc/genoutput.c	2009-02-20 16:20:38.000000000 +0100
+++ gcc-4.4.6/gcc/genoutput.c	2011-08-27 19:45:44.107989452 +0200
@@ -386,7 +386,7 @@
 	}
 
       if (d->name && d->name[0] != '*')
-	printf ("    (insn_gen_fn) gen_%s,\n", d->name);
+	printf ("    gen_%s,\n", d->name);
       else
 	printf ("    0,\n");
 
diff -Nur gcc-4.4.6.orig/gcc/ifcvt.c gcc-4.4.6/gcc/ifcvt.c
--- gcc-4.4.6.orig/gcc/ifcvt.c	2010-01-07 15:59:59.000000000 +0100
+++ gcc-4.4.6/gcc/ifcvt.c	2011-08-27 19:45:44.167989467 +0200
@@ -84,7 +84,7 @@
 static int num_updated_if_blocks;
 
 /* # of changes made.  */
-static int num_true_changes;
+int num_true_changes;
 
 /* Whether conditional execution changes were made.  */
 static int cond_exec_changed_p;
@@ -290,6 +290,9 @@
       if (must_be_last)
 	return FALSE;
 
+#ifdef IFCVT_ALLOW_MODIFY_TEST_IN_INSN       
+      if ( !IFCVT_ALLOW_MODIFY_TEST_IN_INSN )
+#endif
       if (modified_in_p (test, insn))
 	{
 	  if (!mod_ok)
@@ -570,15 +573,18 @@
   IFCVT_MODIFY_FINAL (ce_info);
 #endif
 
+  /* Merge the blocks!  */
+  if ( reload_completed ){
   /* Conversion succeeded.  */
   if (dump_file)
     fprintf (dump_file, "%d insn%s converted to conditional execution.\n",
 	     n_insns, (n_insns == 1) ? " was" : "s were");
 
-  /* Merge the blocks!  */
   merge_if_block (ce_info);
   cond_exec_changed_p = TRUE;
   return TRUE;
+  }
+  return FALSE;
 
  fail:
 #ifdef IFCVT_MODIFY_CANCEL
@@ -1087,7 +1093,11 @@
 	  != UNKNOWN))
     {
       rtx cond = if_info->cond;
-      enum rtx_code code = reversed_comparison_code (cond, if_info->jump);
+      /* This generates wrong code for AVR32. The cond code need not be reversed
+         since the addmodecc patterns add if the condition is NOT met. */
+      /*   enum rtx_code code = reversed_comparison_code (cond, if_info->jump);*/
+      enum rtx_code code = GET_CODE(cond);
+
 
       /* First try to use addcc pattern.  */
       if (general_operand (XEXP (cond, 0), VOIDmode)
@@ -3039,7 +3049,12 @@
       && noce_find_if_block (test_bb, then_edge, else_edge, pass))
     goto success;
 
-  if (HAVE_conditional_execution && reload_completed
+  if (HAVE_conditional_execution && 
+#ifdef IFCVT_COND_EXEC_BEFORE_RELOAD
+      (reload_completed || IFCVT_COND_EXEC_BEFORE_RELOAD)
+#else
+      reload_completed
+#endif
       && cond_exec_find_if_block (&ce_info))
     goto success;
 
@@ -3154,7 +3169,11 @@
 
   /* We only ever should get here after reload,
      and only if we have conditional execution.  */
+#ifdef IFCVT_COND_EXEC_BEFORE_RELOAD
+  gcc_assert (HAVE_conditional_execution && (reload_completed||IFCVT_COND_EXEC_BEFORE_RELOAD));
+#else
   gcc_assert (HAVE_conditional_execution && reload_completed);
+#endif
 
   /* Discover if any fall through predecessors of the current test basic block
      were && tests (which jump to the else block) or || tests (which jump to
@@ -4259,6 +4278,14 @@
 static unsigned int
 rest_of_handle_if_after_reload (void)
 {
+  /* Hack for the AVR32 experimental ifcvt processing before reload.
+     The AVR32 specific ifcvt code needs to know when ifcvt after reload 
+     has begun. */
+#ifdef IFCVT_COND_EXEC_BEFORE_RELOAD
+  if ( IFCVT_COND_EXEC_BEFORE_RELOAD )
+    cfun->machine->ifcvt_after_reload = 1;
+#endif
+  
   if_convert ();
   return 0;
 }
diff -Nur gcc-4.4.6.orig/gcc/longlong.h gcc-4.4.6/gcc/longlong.h
--- gcc-4.4.6.orig/gcc/longlong.h	2009-08-12 00:36:56.000000000 +0200
+++ gcc-4.4.6/gcc/longlong.h	2011-08-27 19:45:44.227991100 +0200
@@ -250,6 +250,41 @@
 #define COUNT_LEADING_ZEROS_0 32
 #endif
 
+#if defined (__avr32__) && W_TYPE_SIZE == 32
+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
+  __asm__ ("add\t%1, %4, %5\n\tadc\t%0, %2, %3"		\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "r" ((USItype) (ah)),					\
+	     "r" ((USItype) (bh)),					\
+	     "r" ((USItype) (al)),					\
+	     "r" ((USItype) (bl)) __CLOBBER_CC)
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("sub\t%1, %4, %5\n\tsbc\t%0, %2, %3"		\
+	   : "=r" ((USItype) (sh)),					\
+	     "=&r" ((USItype) (sl))					\
+	   : "r" ((USItype) (ah)),					\
+	     "r" ((USItype) (bh)),					\
+	     "r" ((USItype) (al)),					\
+	     "r" ((USItype) (bl)) __CLOBBER_CC)
+
+#if !defined (__AVR32_NO_MUL__)
+#define __umulsidi3(a,b) ((UDItype)(a) * (UDItype)(b))
+
+#define umul_ppmm(w1, w0, u, v) \
+{									\
+  DWunion __w;								\
+  __w.ll = __umulsidi3 (u, v);						\
+  w1 = __w.s.high;							\
+  w0 = __w.s.low;							\
+}
+#endif
+
+#define count_leading_zeros(COUNT,X)	((COUNT) = __builtin_clz (X))
+#define count_trailing_zeros(COUNT,X)	((COUNT) = __builtin_ctz (X))
+#define COUNT_LEADING_ZEROS_0 32
+#endif
+
 #if defined (__CRIS__) && __CRIS_arch_version >= 3
 #define count_leading_zeros(COUNT, X) ((COUNT) = __builtin_clz (X))
 #if __CRIS_arch_version >= 8
diff -Nur gcc-4.4.6.orig/gcc/optabs.h gcc-4.4.6/gcc/optabs.h
--- gcc-4.4.6.orig/gcc/optabs.h	2008-08-07 09:35:51.000000000 +0200
+++ gcc-4.4.6/gcc/optabs.h	2011-08-27 19:45:44.277990875 +0200
@@ -603,7 +603,7 @@
 extern optab code_to_optab[NUM_RTX_CODE + 1];
 
 
-typedef rtx (*rtxfun) (rtx);
+typedef rtx (*rtxfun) (rtx, ...);
 
 /* Indexed by the rtx-code for a conditional (e.g. EQ, LT,...)
    gives the gen_function to make a branch to test that condition.  */
diff -Nur gcc-4.4.6.orig/gcc/regrename.c gcc-4.4.6/gcc/regrename.c
--- gcc-4.4.6.orig/gcc/regrename.c	2009-02-20 16:20:38.000000000 +0100
+++ gcc-4.4.6/gcc/regrename.c	2011-08-27 19:45:44.309657742 +0200
@@ -1582,6 +1582,9 @@
   bool changed = false;
   rtx insn;
 
+  rtx prev_pred_test;
+  int prev_pred_insn_skipped = 0;
+
   for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))
     {
       int n_ops, i, alt, predicated;
@@ -1621,6 +1624,58 @@
 	    recog_data.operand_type[i] = OP_INOUT;
 	}
 
+
+      /* Added for targets (AVR32) which supports test operands to be modified
+         in cond_exec instruction. For these targets we cannot make a change to
+         the test operands if one of the test operands is an output operand This beacuse
+         changing the test operands might cause the need for inserting a new test
+         insns in the middle of a sequence of cond_exec insns and if the test operands
+         are modified these tests will fail.
+      */
+      if ( IFCVT_ALLOW_MODIFY_TEST_IN_INSN
+           && predicated )
+        { 
+          int insn_skipped = 0;
+          rtx test = COND_EXEC_TEST (PATTERN (insn));
+
+          /* Check if the previous insn was a skipped predicated insn with the same
+             test as this predicated insns. If so we cannot do any modification to
+             this insn either since we cannot emit the test insn because the operands
+             are clobbered. */
+          if ( prev_pred_insn_skipped 
+               && (rtx_equal_p (test, prev_pred_test) 
+                   || rtx_equal_p (test, reversed_condition (prev_pred_test))) )
+            { 
+              insn_skipped = 1;
+            }
+          else
+            {
+              /* Check if the output operand is used in the test expression. */
+              for (i = 0; i < n_ops; ++i)
+                if ( recog_data.operand_type[i] == OP_INOUT 
+                     && reg_mentioned_p (recog_data.operand[i], test) )
+                  {
+                    insn_skipped = 1;
+                    break;
+                  }
+              
+            }
+          
+          prev_pred_test = test;
+          prev_pred_insn_skipped = insn_skipped;
+          if ( insn_skipped )
+            {
+              if (insn == BB_END (bb))
+                break;
+              else
+                continue;
+            }
+        } 
+      else 
+        {
+          prev_pred_insn_skipped = 0;
+        }
+      
       /* For each earlyclobber operand, zap the value data.  */
       for (i = 0; i < n_ops; i++)
 	if (recog_op_alt[i][alt].earlyclobber)
diff -Nur gcc-4.4.6.orig/gcc/sched-deps.c gcc-4.4.6/gcc/sched-deps.c
--- gcc-4.4.6.orig/gcc/sched-deps.c	2010-08-24 10:53:11.000000000 +0200
+++ gcc-4.4.6/gcc/sched-deps.c	2011-08-27 19:45:44.380490459 +0200
@@ -1473,7 +1473,14 @@
 
   prev_nonnote = prev_nonnote_insn (insn);
   if (BLOCK_FOR_INSN (insn) == BLOCK_FOR_INSN (prev_nonnote)
-      && ! sched_insns_conditions_mutex_p (insn, prev_nonnote))
+      /* Modification for AVR32 by RP: Why is this here, this will
+         cause instruction to be without any dependencies which might
+         cause it to be moved anywhere. For the AVR32 we try to keep
+         a group of conditionals together even if they are mutual exclusive.
+      */
+      && (! sched_insns_conditions_mutex_p (insn, prev_nonnote)
+          || GET_CODE (PATTERN (insn)) == COND_EXEC )
+      )
     add_dependence (insn, prev_nonnote, REG_DEP_ANTI);
 }
 
@@ -2230,8 +2237,29 @@
 
   if (code == COND_EXEC)
     {
+#ifdef IFCVT_ALLOW_MODIFY_TEST_IN_INSN
+      if (IFCVT_ALLOW_MODIFY_TEST_IN_INSN)
+        {
+          /* Check if we have a group og conditional instructions with the same test. 
+             If so we must make sure that they are not scheduled apart in order to
+             avoid unnecesarry tests and if one of the registers in the test is modified
+             in the instruction this is needed to ensure correct code. */
+          if ( prev_nonnote_insn (insn)
+               && INSN_P (prev_nonnote_insn (insn))
+               && GET_CODE (PATTERN (prev_nonnote_insn (insn))) == COND_EXEC 
+               && rtx_equal_p (XEXP(COND_EXEC_TEST (PATTERN (prev_nonnote_insn (insn))), 0), XEXP (COND_EXEC_TEST (x), 0))
+               && rtx_equal_p (XEXP(COND_EXEC_TEST (PATTERN (prev_nonnote_insn (insn))), 1), XEXP (COND_EXEC_TEST (x), 1))
+               && ( GET_CODE (COND_EXEC_TEST (PATTERN (prev_nonnote_insn (insn)))) == GET_CODE (COND_EXEC_TEST (x))
+                    || GET_CODE (COND_EXEC_TEST (PATTERN (prev_nonnote_insn (insn)))) == reversed_comparison_code (COND_EXEC_TEST (x), insn)))
+            {
+              SCHED_GROUP_P (insn) = 1;
+              //CANT_MOVE (prev_nonnote_insn (insn)) = 1;
+            }
+        }
+#endif      
       sched_analyze_2 (deps, COND_EXEC_TEST (x), insn);
 
+
       /* ??? Should be recording conditions so we reduce the number of
 	 false dependencies.  */
       x = COND_EXEC_CODE (x);
diff -Nur gcc-4.4.6.orig/gcc/testsuite/gcc.dg/sibcall-3.c gcc-4.4.6/gcc/testsuite/gcc.dg/sibcall-3.c
--- gcc-4.4.6.orig/gcc/testsuite/gcc.dg/sibcall-3.c	2009-01-08 18:56:52.000000000 +0100
+++ gcc-4.4.6/gcc/testsuite/gcc.dg/sibcall-3.c	2011-08-27 19:45:44.447989503 +0200
@@ -5,7 +5,7 @@
    Copyright (C) 2002 Free Software Foundation Inc.
    Contributed by Hans-Peter Nilsson  <hp@bitrange.com>  */
 
-/* { dg-do run { xfail { { arc-*-* avr-*-* cris-*-* crisv32-*-* h8300-*-* hppa*64*-*-* m32r-*-* m68hc1?-*-* mcore-*-* mn10300-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa*-*-* } || { arm*-*-* && { ! arm32 } } } } } */
+/* { dg-do run { xfail { { arc-*-* avr-*-* avr32-*-* cris-*-* crisv32-*-* h8300-*-* hppa*64*-*-* m32r-*-* m68hc1?-*-* mcore-*-* mn10300-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa*-*-* } || { arm*-*-* && { ! arm32 } } } } } */
 /* -mlongcall disables sibcall patterns.  */
 /* { dg-skip-if "" { powerpc*-*-* } { "-mlongcall" } { "" } } */
 /* { dg-options "-O2 -foptimize-sibling-calls" } */
diff -Nur gcc-4.4.6.orig/gcc/testsuite/gcc.dg/sibcall-4.c gcc-4.4.6/gcc/testsuite/gcc.dg/sibcall-4.c
--- gcc-4.4.6.orig/gcc/testsuite/gcc.dg/sibcall-4.c	2009-01-08 18:56:52.000000000 +0100
+++ gcc-4.4.6/gcc/testsuite/gcc.dg/sibcall-4.c	2011-08-27 19:45:44.499241252 +0200
@@ -5,7 +5,7 @@
    Copyright (C) 2002 Free Software Foundation Inc.
    Contributed by Hans-Peter Nilsson  <hp@bitrange.com>  */
 
-/* { dg-do run { xfail { { arc-*-* avr-*-* cris-*-* crisv32-*-* h8300-*-* hppa*64*-*-* m32r-*-* m68hc1?-*-* mcore-*-* mn10300-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa*-*-* } || { arm*-*-* && { ! arm32 } } } } } */
+/* { dg-do run { xfail { { arc-*-* avr-*-* avr32-*-* cris-*-* crisv32-*-* h8300-*-* hppa*64*-*-* m32r-*-* m68hc1?-*-* mcore-*-* mn10300-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa*-*-* } || { arm*-*-* && { ! arm32 } } } } } */
 /* -mlongcall disables sibcall patterns.  */
 /* { dg-skip-if "" { powerpc*-*-* } { "-mlongcall" } { "" } } */
 /* { dg-options "-O2 -foptimize-sibling-calls" } */
diff -Nur gcc-4.4.6.orig/gcc/testsuite/gcc.dg/trampoline-1.c gcc-4.4.6/gcc/testsuite/gcc.dg/trampoline-1.c
--- gcc-4.4.6.orig/gcc/testsuite/gcc.dg/trampoline-1.c	2008-05-12 23:52:38.000000000 +0200
+++ gcc-4.4.6/gcc/testsuite/gcc.dg/trampoline-1.c	2011-08-27 19:45:44.567990409 +0200
@@ -47,6 +47,8 @@
 
 int main (void)
 {
+#ifndef NO_TRAMPOLINES
   foo ();
+#endif
   return 0;
 }
diff -Nur gcc-4.4.6.orig/libgcc/config.host gcc-4.4.6/libgcc/config.host
--- gcc-4.4.6.orig/libgcc/config.host	2009-04-17 13:58:41.000000000 +0200
+++ gcc-4.4.6/libgcc/config.host	2011-08-27 19:45:44.617991228 +0200
@@ -218,6 +218,13 @@
 	;;
 arm-*-pe*)
 	;;
+avr32-*-linux*)
+	# No need to build crtbeginT.o on uClibc systems. Should probably be
+	# moved to the OS specific section above.
+	extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
+	;;
+avr32-*-*)
+	;;
 avr-*-rtems*)
 	;;
 avr-*-*)
diff -Nur gcc-4.4.6.orig/libstdc++-v3/config/os/gnu-linux/ctype_base.h gcc-4.4.6/libstdc++-v3/config/os/gnu-linux/ctype_base.h
--- gcc-4.4.6.orig/libstdc++-v3/config/os/gnu-linux/ctype_base.h	2009-04-10 01:23:07.000000000 +0200
+++ gcc-4.4.6/libstdc++-v3/config/os/gnu-linux/ctype_base.h	2011-08-27 19:45:44.687989554 +0200
@@ -26,6 +26,8 @@
 //
 // ISO C++ 14882: 22.1  Locales
 //
+#include <features.h>
+#include <ctype.h>
   
 /** @file ctype_base.h
  *  This is an internal header file, included by other library headers.
@@ -40,7 +42,11 @@
   struct ctype_base
   {
     // Non-standard typedefs.
+#ifdef __UCLIBC__
+    typedef const __ctype_touplow_t*   __to_type;
+#else
     typedef const int* 		__to_type;
+#endif
 
     // NB: Offsets into ctype<char>::_M_table force a particular size
     // on the mask type. Because of this, we don't use an enum.
diff -Nur gcc-4.4.6.orig/libstdc++-v3/include/Makefile.in gcc-4.4.6/libstdc++-v3/include/Makefile.in
--- gcc-4.4.6.orig/libstdc++-v3/include/Makefile.in	2009-05-13 02:24:16.000000000 +0200
+++ gcc-4.4.6/libstdc++-v3/include/Makefile.in	2011-08-27 19:45:44.737991067 +0200
@@ -36,6 +36,7 @@
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
+LIBOBJDIR =
 DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
 	$(top_srcdir)/fragment.am
 subdir = include
diff -Nur gcc-4.4.6.orig/libstdc++-v3/libsupc++/Makefile.in gcc-4.4.6/libstdc++-v3/libsupc++/Makefile.in
--- gcc-4.4.6.orig/libstdc++-v3/libsupc++/Makefile.in	2009-01-15 21:02:11.000000000 +0100
+++ gcc-4.4.6/libstdc++-v3/libsupc++/Makefile.in	2011-08-27 19:45:44.777991092 +0200
@@ -38,6 +38,7 @@
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
+LIBOBJDIR =
 DIST_COMMON = $(glibcxxinstall_HEADERS) $(srcdir)/Makefile.am \
 	$(srcdir)/Makefile.in $(top_srcdir)/fragment.am
 subdir = libsupc++
diff -Nur gcc-4.4.6.orig/libstdc++-v3/Makefile.in gcc-4.4.6/libstdc++-v3/Makefile.in
--- gcc-4.4.6.orig/libstdc++-v3/Makefile.in	2010-04-29 17:03:38.000000000 +0200
+++ gcc-4.4.6/libstdc++-v3/Makefile.in	2011-08-27 19:45:44.850357194 +0200
@@ -36,6 +36,7 @@
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
+LIBOBJDIR =
 DIST_COMMON = $(top_srcdir)/fragment.am $(srcdir)/../config.guess \
 	$(srcdir)/../config.sub README ChangeLog $(srcdir)/Makefile.in \
 	$(srcdir)/Makefile.am $(top_srcdir)/configure \
diff -Nur gcc-4.4.6.orig/libstdc++-v3/po/Makefile.in gcc-4.4.6/libstdc++-v3/po/Makefile.in
--- gcc-4.4.6.orig/libstdc++-v3/po/Makefile.in	2009-01-15 21:02:11.000000000 +0100
+++ gcc-4.4.6/libstdc++-v3/po/Makefile.in	2011-08-27 19:45:44.900490527 +0200
@@ -36,6 +36,7 @@
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
+LIBOBJDIR =
 DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
 	$(top_srcdir)/fragment.am
 subdir = po
diff -Nur gcc-4.4.6.orig/libstdc++-v3/src/Makefile.in gcc-4.4.6/libstdc++-v3/src/Makefile.in
--- gcc-4.4.6.orig/libstdc++-v3/src/Makefile.in	2009-08-26 21:04:11.000000000 +0200
+++ gcc-4.4.6/libstdc++-v3/src/Makefile.in	2011-08-27 19:45:44.958377128 +0200
@@ -37,6 +37,7 @@
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
+LIBOBJDIR =
 DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
 	$(top_srcdir)/fragment.am
 subdir = src
