From 642cf06b4c07658b78fb6029648edc14fcd0075a Mon Sep 17 00:00:00 2001
From: Waldemar Brodkorb <wbx@openadk.org>
Date: Wed, 20 Aug 2014 20:29:08 +0200
Subject: [PATCH 5/9] sync WRITE_BUFFER_SIZE with glibc test

Test on Linux 3.16.1 in Qemu ARM fails with:
 TEST_EXEC nptl/ tst-cancel4
ret == 1 ; expected_ret == 0
make[1]: *** [tst-cancel4.exe] Error 1
The output of failed test is:
minimum write buffer size too large
../Test.mak:89: recipe for target 'tst-cancel4.exe' failed

Signed-off-by: Waldemar Brodkorb <wbx@uclibc-ng.org>
---
 test/nptl/tst-cancel4.c | 26 ++++++++++++++++++++++++--
 1 file changed, 24 insertions(+), 2 deletions(-)

diff --git a/test/nptl/tst-cancel4.c b/test/nptl/tst-cancel4.c
index e711958..53abf83 100644
--- a/test/nptl/tst-cancel4.c
+++ b/test/nptl/tst-cancel4.c
@@ -83,7 +83,30 @@ static pthread_barrier_t b2;
 # define IPC_ADDVAL 0
 #endif
 
-#define WRITE_BUFFER_SIZE 4096
+/* The WRITE_BUFFER_SIZE value needs to be chosen such that if we set
+   the socket send buffer size to '1', a write of this size on that
+   socket will block.
+
+   The Linux kernel imposes a minimum send socket buffer size which
+   has changed over the years.  As of Linux 3.10 the value is:
+
+     2 * (2048 + SKB_DATA_ALIGN(sizeof(struct sk_buff)))
+
+   which is attempting to make sure that with standard MTUs,
+   TCP can always queue up at least 2 full sized packets.
+
+   Furthermore, there is logic in the socket send paths that
+   will allow one more packet (of any size) to be queued up as
+   long as some socket buffer space remains.   Blocking only
+   occurs when we try to queue up a new packet and the send
+   buffer space has already been fully consumed.
+
+   Therefore we must set this value to the largest possible value of
+   the formula above (and since it depends upon the size of "struct
+   sk_buff", it is dependent upon machine word size etc.) plus some
+   slack space.  */
+
+#define WRITE_BUFFER_SIZE 16384
 
 /* Cleanup handling test.  */
 static int cl_called;
@@ -758,7 +781,6 @@ tf_sigpause (void *arg)
 
   pthread_cleanup_push (cl, NULL);
 
-  /* Just for fun block the cancellation signal.  */
   sigpause (SIGCANCEL);
 
   pthread_cleanup_pop (0);
-- 
1.8.5.2 (Apple Git-48)

