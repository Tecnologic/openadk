--- libqb-0.16.0.orig/docs/man3/qbutil.h.3	2013-07-25 20:16:18.000000000 +0200
+++ libqb-0.16.0/docs/man3/qbutil.h.3	2013-09-09 05:26:31.891805285 +0200
@@ -1,4 +1,4 @@
-.TH "qbutil.h" 3 "Thu Jul 25 2013" "Version 0.16.0" "libqb" \" -*- nroff -*-
+.TH "qbutil.h" 3 "Mon Sep 9 2013" "Version 0.16.0" "libqb" \" -*- nroff -*-
 .ad l
 .nh
 .SH NAME
@@ -15,7 +15,7 @@ qbutil.h \-
 \fC#include <qb/qbdefs\&.h>\fP
 .br
 
-.SS "Macros"
+.SS "Defines"
 
 .in +1c
 .ti -1c
@@ -138,7 +138,7 @@ qbutil.h \-
 .PP 
 \fBAuthor:\fP
 .RS 4
-Angus Salkeld asalkeld@redhat.com
+Angus Salkeld <asalkeld@redhat.com>
 .RE
 .PP
 These are some convience functions used throughout libqb\&.
@@ -180,21 +180,21 @@ These are some convience functions used
 
 .PP
 .nf
-uint64_t elapsed1;
-uint64_t elapsed2;
-qb_util_stopwatch_t *sw = qb_util_stopwatch_create();
+ uint64_t elapsed1;
+ uint64_t elapsed2;
+ qb_util_stopwatch_t *sw = qb_util_stopwatch_create();
 
-qb_util_stopwatch_start(sw);
+ qb_util_stopwatch_start(sw);
 
-usleep(sometime);
-qb_util_stopwatch_stop(sw);
-elapsed1 = qb_util_stopwatch_us_elapsed_get(sw);
+ usleep(sometime);
+ qb_util_stopwatch_stop(sw);
+ elapsed1 = qb_util_stopwatch_us_elapsed_get(sw);
 
-usleep(somemoretime);
-qb_util_stopwatch_stop(sw);
-elapsed2 = qb_util_stopwatch_us_elapsed_get(sw);
+ usleep(somemoretime);
+ qb_util_stopwatch_stop(sw);
+ elapsed2 = qb_util_stopwatch_us_elapsed_get(sw);
 
-qb_util_stopwatch_free(sw);
+ qb_util_stopwatch_free(sw);
 
 .fi
 .PP
@@ -207,72 +207,65 @@ Setup a stopwatch with space for 3 split
 .PP
 .PP
 .nf
-uint64_t split;
-qb_util_stopwatch_t *sw = qb_util_stopwatch_create();
+ uint64_t split;
+ qb_util_stopwatch_t *sw = qb_util_stopwatch_create();
 
-qb_util_stopwatch_split_ctl(sw, 3, 0);
-qb_util_stopwatch_start(sw);
+ qb_util_stopwatch_split_ctl(sw, 3, 0);
+ qb_util_stopwatch_start(sw);
 
-usleep(sometime);
-qb_util_stopwatch_split(sw);
+ usleep(sometime);
+ qb_util_stopwatch_split(sw);
 
-usleep(somemoretime);
-qb_util_stopwatch_split(sw);
+ usleep(somemoretime);
+ qb_util_stopwatch_split(sw);
 
-usleep(somemoretime);
-qb_util_stopwatch_split(sw);
+ usleep(somemoretime);
+ qb_util_stopwatch_split(sw);
 
-idx = qb_util_stopwatch_split_last(sw);
-do {
-     split = qb_util_stopwatch_time_split_get(sw, idx, idx);
-     qb_log(LOG_INFO, 'split %d is %'PRIu64'', last, split);
-     idx--;
-} while (split > 0);
+ idx = qb_util_stopwatch_split_last(sw);
+ do {
+      split = qb_util_stopwatch_time_split_get(sw, idx, idx);
+      qb_log(LOG_INFO, 'split %d is %'PRIu64'', last, split);
+      idx--;
+ } while (split > 0);
 
-split = qb_util_stopwatch_time_split_get(sw, 2, 1);
-qb_log(LOG_INFO, 'time between second and third split is %'PRIu64'', split);
+ split = qb_util_stopwatch_time_split_get(sw, 2, 1);
+ qb_log(LOG_INFO, 'time between second and third split is %'PRIu64'', split);
 
-qb_util_stopwatch_free(sw);
+ qb_util_stopwatch_free(sw);
 .fi
 .PP
  
-.SH "Macro Definition Documentation"
+.SH "Define Documentation"
 .PP 
-.SS "#define QB_UTIL_SW_OVERWRITE   0x01"
-
+.SS "#define \fBQB_UTIL_SW_OVERWRITE\fP   0x01"
 .SH "Typedef Documentation"
 .PP 
 .SS "typedef struct qb_thread_lock_s \fBqb_thread_lock_t\fP"
-
-.SS "typedef void(* qb_util_log_fn_t)(const char *file_name, int32_t file_line, int32_t severity, const char *msg)"
-
+.SS "typedef void(* \fBqb_util_log_fn_t\fP)(const char *file_name, int32_t file_line, int32_t severity, const char *msg)"
 .SS "typedef struct qb_util_stopwatch \fBqb_util_stopwatch_t\fP"
-
 .SH "Enumeration Type Documentation"
 .PP 
 .SS "enum \fBqb_thread_lock_type_t\fP"
-
 .PP
 QB_THREAD_LOCK_SHORT is a short term lock (spinlock if available on your system) QB_THREAD_LOCK_LONG is a mutex\&. 
 .PP
-\fBEnumerator\fP
+\fBEnumerator: \fP
 .in +1c
 .TP
 \fB\fIQB_THREAD_LOCK_SHORT \fP\fP
 .TP
 \fB\fIQB_THREAD_LOCK_LONG \fP\fP
+
 .SH "Function Documentation"
 .PP 
-.SS "char* qb_strerror_r (interrnum, char *buf, size_tbuflen)"
-
+.SS "char* \fBqb_strerror_r\fP (interrnum, char *buf, size_tbuflen)"
 .PP
 strerror_r replacement\&. 
-.SS "int32_t qb_thread_lock (\fBqb_thread_lock_t\fP *tl)"
-
+.SS "int32_t \fBqb_thread_lock\fP (\fBqb_thread_lock_t\fP *tl)"
 .PP
 Calls either pthread_mutex_lock() or pthread_spin_lock()\&. 
-.SS "\fBqb_thread_lock_t\fP* qb_thread_lock_create (\fBqb_thread_lock_type_t\fPtype)"
-
+.SS "\fBqb_thread_lock_t\fP* \fBqb_thread_lock_create\fP (\fBqb_thread_lock_type_t\fPtype)"
 .PP
 Create a new lock of the given type\&. \fBParameters:\fP
 .RS 4
@@ -285,20 +278,16 @@ pointer to qb_thread_lock_type_t or NULL
 .RE
 .PP
 
-.SS "int32_t qb_thread_lock_destroy (\fBqb_thread_lock_t\fP *tl)"
-
+.SS "int32_t \fBqb_thread_lock_destroy\fP (\fBqb_thread_lock_t\fP *tl)"
 .PP
 Calls either pthread_mutex_destro() or pthread_spin_destroy()\&. 
-.SS "int32_t qb_thread_trylock (\fBqb_thread_lock_t\fP *tl)"
-
+.SS "int32_t \fBqb_thread_trylock\fP (\fBqb_thread_lock_t\fP *tl)"
 .PP
 Calls either pthread_mutex_trylock() or pthread_spin_trylock()\&. 
-.SS "int32_t qb_thread_unlock (\fBqb_thread_lock_t\fP *tl)"
-
+.SS "int32_t \fBqb_thread_unlock\fP (\fBqb_thread_lock_t\fP *tl)"
 .PP
 Calls either pthread_mutex_unlock() or pthread_spin_unlock\&. 
-.SS "void qb_timespec_add_ms (struct timespec *ts, int32_tms)"
-
+.SS "void \fBqb_timespec_add_ms\fP (struct timespec *ts, int32_tms)"
 .PP
 Add milliseconds onto the timespec\&. \fBParameters:\fP
 .RS 4
@@ -308,36 +297,28 @@ Add milliseconds onto the timespec\&. \f
 .RE
 .PP
 
-.SS "uint64_t qb_util_nano_current_get (void)"
-
+.SS "uint64_t \fBqb_util_nano_current_get\fP (void)"
 .PP
 Get the current number of nano secounds produced by the systems incrementing clock (CLOCK_MONOTOMIC if available)\&. 
-.SS "uint64_t qb_util_nano_from_epoch_get (void)"
-
+.SS "uint64_t \fBqb_util_nano_from_epoch_get\fP (void)"
 .PP
 Get the time in nano seconds since epoch\&. 
-.SS "uint64_t qb_util_nano_monotonic_hz (void)"
-
+.SS "uint64_t \fBqb_util_nano_monotonic_hz\fP (void)"
 .PP
 Get the frequence of the clock used in \fBqb_util_nano_current_get()\fP\&. 
-.SS "void qb_util_set_log_function (\fBqb_util_log_fn_t\fPfn)"
-
+.SS "void \fBqb_util_set_log_function\fP (\fBqb_util_log_fn_t\fPfn)"
 .PP
 Use this function to output libqb internal log message as you wish\&. 
-.SS "\fBqb_util_stopwatch_t\fP* qb_util_stopwatch_create (void)"
-
+.SS "\fBqb_util_stopwatch_t\fP* \fBqb_util_stopwatch_create\fP (void)"
 .PP
 Create a Stopwatch (to time operations) 
-.SS "void qb_util_stopwatch_free (\fBqb_util_stopwatch_t\fP *sw)"
-
+.SS "void \fBqb_util_stopwatch_free\fP (\fBqb_util_stopwatch_t\fP *sw)"
 .PP
 Free the stopwatch\&. 
-.SS "float qb_util_stopwatch_sec_elapsed_get (\fBqb_util_stopwatch_t\fP *sw)"
-
+.SS "float \fBqb_util_stopwatch_sec_elapsed_get\fP (\fBqb_util_stopwatch_t\fP *sw)"
 .PP
 Get the elapsed time in seconds\&. (it must have been started and stopped)\&. 
-.SS "uint64_t qb_util_stopwatch_split (\fBqb_util_stopwatch_t\fP *sw)"
-
+.SS "uint64_t \fBqb_util_stopwatch_split\fP (\fBqb_util_stopwatch_t\fP *sw)"
 .PP
 Create a new time split (or lap time) \fBParameters:\fP
 .RS 4
@@ -352,8 +333,7 @@ Create a new time split (or lap time) \f
 .RE
 .PP
 
-.SS "int32_t qb_util_stopwatch_split_ctl (\fBqb_util_stopwatch_t\fP *sw, uint32_tmax_splits, uint32_toptions)"
-\fBParameters:\fP
+.SS "int32_t \fBqb_util_stopwatch_split_ctl\fP (\fBqb_util_stopwatch_t\fP *sw, uint32_tmax_splits, uint32_toptions)"\fBParameters:\fP
 .RS 4
 \fIsw\fP the stopwatch 
 .br
@@ -370,8 +350,7 @@ Create a new time split (or lap time) \f
 .RE
 .PP
 
-.SS "uint32_t qb_util_stopwatch_split_last (\fBqb_util_stopwatch_t\fP *sw)"
-
+.SS "uint32_t \fBqb_util_stopwatch_split_last\fP (\fBqb_util_stopwatch_t\fP *sw)"
 .PP
 Get the last split index to be used by \fBqb_util_stopwatch_time_split_get()\fP \fBNote:\fP
 .RS 4
@@ -389,16 +368,13 @@ the last entry index
 .RE
 .PP
 
-.SS "void qb_util_stopwatch_start (\fBqb_util_stopwatch_t\fP *sw)"
-
+.SS "void \fBqb_util_stopwatch_start\fP (\fBqb_util_stopwatch_t\fP *sw)"
 .PP
 Start the stopwatch\&. This also acts as a reset\&. Essentially it sets the starting time and clears the splits\&. 
-.SS "void qb_util_stopwatch_stop (\fBqb_util_stopwatch_t\fP *sw)"
-
+.SS "void \fBqb_util_stopwatch_stop\fP (\fBqb_util_stopwatch_t\fP *sw)"
 .PP
 Stop the stopwatch\&. This just allows you to get the elapsed time\&. So you can call this multiple times\&. Do not call \fBqb_util_stopwatch_start()\fP unless you want to reset the stopwatch\&. 
-.SS "uint64_t qb_util_stopwatch_time_split_get (\fBqb_util_stopwatch_t\fP *sw, uint32_treceint, uint32_tolder)"
-
+.SS "uint64_t \fBqb_util_stopwatch_time_split_get\fP (\fBqb_util_stopwatch_t\fP *sw, uint32_treceint, uint32_tolder)"
 .PP
 Read the time split (in us) from 'receint' to 'older'\&. If older == receint then the cumulated split will be returned (from the stopwatch start)\&.
 .PP
@@ -419,12 +395,10 @@ Read the time split (in us) from 'recein
 .RE
 .PP
 
-.SS "uint64_t qb_util_stopwatch_us_elapsed_get (\fBqb_util_stopwatch_t\fP *sw)"
-
+.SS "uint64_t \fBqb_util_stopwatch_us_elapsed_get\fP (\fBqb_util_stopwatch_t\fP *sw)"
 .PP
 Get the elapsed time in micro seconds\&. (it must have been started and stopped)\&. 
-.SS "void qb_util_timespec_from_epoch_get (struct timespec *ts)"
-
+.SS "void \fBqb_util_timespec_from_epoch_get\fP (struct timespec *ts)"
 .PP
 Get the time in timespec since epoch\&. \fBParameters:\fP
 .RS 4
