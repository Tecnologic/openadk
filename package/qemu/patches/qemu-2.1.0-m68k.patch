--- qemu-2.1.0/hw/m68k/mcf_intc.c	2014-08-01 16:12:17.000000000 +0200
+++ qemu-2.1.0.m68k/hw/m68k/mcf_intc.c	2014-08-12 11:41:52.416975339 +0200
@@ -65,6 +65,10 @@
         return (uint32_t)(s->ifr >> 32);
     case 0x14:
         return (uint32_t)s->ifr;
+    /* Reading from SIMR and CIMR return 0 */
+    case 0x1c:
+    case 0x1d:
+	return 0;
     case 0xe0: /* SWIACK.  */
         return s->active_vector;
     case 0xe1: case 0xe2: case 0xe3: case 0xe4:
@@ -102,6 +106,20 @@
     case 0x0c:
         s->imr = (s->imr & 0xffffffff00000000ull) | (uint32_t)val;
         break;
+    /* SIMR allows to easily mask interrupts */
+    case 0x1c:
+	if (val & 0x40)
+		s->imr = ~0ull;
+	else
+		s->imr |= (1 << (val & 0x3f));
+	break;
+    /* CIMR allows to easily unmask interrupts */
+    case 0x1d:
+	if (val & 0x40)
+		s->imr = 0ull;
+	else
+		s->imr &= ~(1 << (val & 0x3f));
+	break;
     default:
         hw_error("mcf_intc_write: Bad write offset %d\n", offset);
         break;

