--- sangam-atm-1.0.orig/tn7dsl.c	2007-01-04 09:04:14.000000000 +0100
+++ sangam-atm-1.0/tn7dsl.c	2010-03-06 12:40:16.000000000 +0100
@@ -94,7 +94,6 @@
 *  1/02/07  JZ     CQ11054: Data Precision and Range Changes for TR-069 Conformance
 *  UR8_MERGE_END   CQ11054*
  *********************************************************************************************/
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -102,8 +101,6 @@
 #include <linux/delay.h>
 #include <linux/spinlock.h>
 #include <linux/smp_lock.h>
-#include <asm/io.h>
-#include <asm/mips-boards/prom.h>
 #include <linux/proc_fs.h>
 #include <linux/string.h>
 #include <linux/ctype.h>
@@ -111,6 +108,18 @@
 #include <linux/timer.h>
 #include <linux/vmalloc.h>
 #include <linux/file.h>
+#include <linux/firmware.h>
+#include <linux/version.h>
+
+#include <asm/io.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
+#include <asm/ar7/ar7.h>
+#include <asm/ar7/prom.h>
+#else
+#include <asm/mach-ar7/ar7.h>
+#include <asm/mach-ar7/prom.h>
+#endif
+
 /* Modules specific header files */
 #include "tn7atm.h"
 #include "tn7api.h"
@@ -133,6 +142,27 @@
 #define NEW_TRAINING_VAL_T1413  128
 #define NEW_TRAINING_VAL_MMODE  255
 
+extern char *mp_modulation;
+extern int mp_fine_gain_control;
+extern int mp_fine_gain_value;
+extern int mp_enable_margin_retrain;
+extern int mp_margin_threshold;
+extern int mp_enable_rate_adapt;
+extern int mp_powercutback;
+extern int mp_trellis;
+extern int mp_bitswap;
+extern int mp_maximum_bits_per_carrier;
+extern int mp_maximum_interleave_depth;
+extern int mp_pair_selection;
+extern int mp_dgas_polarity;
+extern int mp_los_alarm;
+extern char *mp_eoc_vendor_id;
+extern int mp_eoc_vendor_revision;
+extern char *mp_eoc_vendor_serialnum;
+extern char *mp_invntry_vernum;
+extern int mp_dsl_bit_tmode;
+extern int mp_high_precision;
+
 int testflag1 = 0;
 extern int  __guDbgLevel;
 extern sar_stat_t sarStat;
@@ -173,7 +203,6 @@ led_reg_t ledreg[2];
 static struct led_funcs ledreg[2];
 #endif
 
-#define DEV_DSLMOD       1
 #define MAX_STR_SIZE     256
 #define DSL_MOD_SIZE     256
 
@@ -299,7 +328,7 @@ static PITIDSLHW_T    pIhw;
 static volatile int bshutdown;
 static char info[MAX_STR_SIZE];
 /* Used for DSL Polling enable */
-static DECLARE_MUTEX_LOCKED (adsl_sem_overlay);
+static struct semaphore adsl_sem_overlay;
 
 //kthread_t overlay_thread;
 /* end of module wide declars */
@@ -309,8 +338,7 @@ static void tn7dsl_chng_modulation(void*
 static unsigned int tn7dsl_set_modulation(void* data, int flag);
 static void tn7dsl_ctrl_fineGain(int value);
 static void tn7dsl_set_fineGainValue(int value);
-static int dslmod_sysctl (ctl_table * ctl, int write, struct file *filp,
-                          void *buffer, size_t * lenp);
+static int dslmod_sysctl (ctl_table * ctl, int write, void *buffer, size_t * lenp, loff_t *ppos);
 static void tn7dsl_register_dslss_led(void);
 void tn7dsl_dslmod_sysctl_register(void);
 void tn7dsl_dslmod_sysctl_unregister(void);
@@ -323,6 +351,14 @@ static int tn7dsl_proc_snr_print (char *
 #define gDot1(a) ((a>0)?(a%10):((-a)%10))
 //  UR8_MERGE_END   CQ11054*
 
+int avalanche_request_intr_pacing(int irq_nr, unsigned int blk_num,
+                            unsigned int pace_value)
+{
+	printk("avalanche_request_pacing(%d, %u, %u); // not implemented\n", irq_nr, blk_num, pace_value);
+	return 0;
+}
+
+
 int os_atoi(const char *pStr)
 {
   int MulNeg = (*pStr == '-' ? -1 : 1);
@@ -359,39 +395,6 @@ void dprintf (int uDbgLevel, char *szFmt
 #endif
 }
 
-int strcmp(const char *s1, const char *s2)
-{
-
-  int size = strlen(s1);
-
-  return(strncmp(s1, s2, size));
-}
-
-int strncmp(const char *s1, const char *s2, size_t size)
-{
-  int i = 0;
-  int max_size = (int)size;
-
-  while((s1[i] != 0) && i < max_size)
-  {
-    if(s2[i] == 0)
-    {
-      return -1;
-    }
-    if(s1[i] != s2[i])
-    {
-       return 1;
-    }
-    i++;
-  }
-  if(s2[i] != 0)
-  {
-    return 1;
-  }
-
-  return 0;
-}
-
 // * UR8_MERGE_START CQ10640   Jack Zhang
 int tn7dsl_dump_dsp_memory(char *input_str) //cph99
   {
@@ -441,101 +444,79 @@ unsigned int shim_osGetCpuFrequency(void
   return CpuFrequency;
 }
 
-int shim_osLoadFWImage(unsigned char *ptr)
+static void avsar_release(struct device *dev)
 {
-  unsigned int bytesRead;
-  mm_segment_t  oldfs;
-  static struct file *filp;
-  unsigned int imageLength=0x5ffff;
-
-
-  dgprintf(4, "tn7dsl_read_dsp()\n");
-
-  dgprintf(4,"open file %s\n", DSP_FIRMWARE_PATH);
-
-  filp=filp_open(DSP_FIRMWARE_PATH,00,O_RDONLY);
-  if(filp ==NULL)
-  {
-    printk("Failed: Could not open DSP binary file\n");
-          return -1;
-  }
-
-  if (filp->f_dentry != NULL)
-  {
-    if (filp->f_dentry->d_inode != NULL)
-    {
-      printk ("DSP binary filesize = %d bytes\n",
-              (int) filp->f_dentry->d_inode->i_size);
-      imageLength = (unsigned int)filp->f_dentry->d_inode->i_size + 0x200;
-    }
-  }
-
-  if (filp->f_op->read==NULL)
-          return -1;  /* File(system) doesn't allow reads */
-
-  /*
-   * Disable parameter checking
-   */
-  oldfs = get_fs();
-  set_fs(KERNEL_DS);
-
-  /*
-   * Now read bytes from postion "StartPos"
-   */
-  filp->f_pos = 0;
-
-  bytesRead = filp->f_op->read(filp,ptr,imageLength,&filp->f_pos);
-
-  dgprintf(4,"file length = %d\n", bytesRead);
-
-  set_fs(oldfs);
-
-  /*
-   * Close the file
-   */
-  fput(filp);
-
-  return bytesRead;
+	printk(KERN_DEBUG "avsar firmware released\n");
 }
 
+static struct device avsar = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
+	.bus_id    = "vlynq",
+#endif
+	.release   = avsar_release,
+};
 
-unsigned int shim_read_overlay_page (void *ptr, unsigned int secOffset,
-                                     unsigned int secLength)
+int shim_osLoadFWImage(unsigned char *ptr)
 {
-  unsigned int bytesRead;
-  mm_segment_t  oldfs;
-  struct file *filp;
-
-  dgprintf(4,"shim_read_overlay_page\n");
-  //dgprintf(4,"sec offset=%d, sec length =%d\n", secOffset, secLength);
+	const struct firmware *fw_entry;
+	size_t size;
 
-  filp=filp_open(DSP_FIRMWARE_PATH,00,O_RDONLY);
-  if(filp ==NULL)
-  {
-    printk("Failed: Could not open DSP binary file\n");
-          return -1;
-  }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30)
+	dev_set_name(&avsar, "avsar");
+#endif
+	printk("requesting firmware image \"ar0700xx.bin\"\n");
+	if(device_register(&avsar) < 0) {
+		printk(KERN_ERR
+			"avsar: device_register fails\n");
+		return -1;
+	}
 
-  if (filp->f_op->read==NULL)
-          return -1;  /* File(system) doesn't allow reads */
+	if(request_firmware(&fw_entry, "ar0700xx.bin", &avsar)) {
+		printk(KERN_ERR
+			"avsar: Firmware not available\n");
+		device_unregister(&avsar);
+		return -1;
+	}
+	size = fw_entry->size;
+	device_unregister(&avsar);
+	if(size > 0x5ffff) {
+			printk(KERN_ERR
+			"avsar: Firmware too big (%d bytes)\n", size);
+			release_firmware(fw_entry);
+			return -1;
+		}
+	memcpy(ptr, fw_entry->data, size);
+	release_firmware(fw_entry);
+	return size;
+}
 
-  /*
-   * Now read bytes from postion "StartPos"
-   */
+unsigned int shim_read_overlay_page(void *ptr, unsigned int secOffset, unsigned int secLength)
+{
+	const struct firmware *fw_entry;
 
-  if(filp->f_op->llseek)
-    filp->f_op->llseek(filp,secOffset, 0);
-  oldfs = get_fs();
-  set_fs(KERNEL_DS);
-  filp->f_pos = secOffset;
-  bytesRead = filp->f_op->read(filp,ptr,secLength,&filp->f_pos);
+	printk("requesting firmware image \"ar0700xx.bin\"\n");
+	if(device_register(&avsar) < 0) {
+		printk(KERN_ERR
+			"avsar: device_register fails\n");
+		return -1;
+	}
 
-  set_fs(oldfs);
-  /*
-   * Close the file
-   */
-  fput(filp);
-  return bytesRead;
+	if(request_firmware(&fw_entry, "ar0700xx.bin", &avsar)) {
+		printk(KERN_ERR
+			"avsar: Firmware not available\n");
+		device_unregister(&avsar);
+		return -1;
+	}
+	device_unregister(&avsar);
+	if(fw_entry->size > secLength) {
+		printk(KERN_ERR
+			"avsar: Firmware too big (%d bytes)\n", fw_entry->size);
+		release_firmware(fw_entry);
+		return -1;
+	}
+	memcpy(ptr + secOffset, fw_entry->data, secLength);
+	release_firmware(fw_entry);
+	return secLength;
 }
 
 int shim_osLoadDebugFWImage(unsigned char *ptr)
@@ -2834,7 +2815,6 @@ static int tn7dsl_set_dsl(void)
   int value;
   int i, offset[2]={4,11},oamFeature=0;
   char tmp[4];
-  char dspVer[10];
 
   // OAM Feature Configuration
   dslhal_api_dspInterfaceRead (pIhw, (unsigned int) pIhw->pmainAddr, 2,
@@ -2845,98 +2825,82 @@ static int tn7dsl_set_dsl(void)
                                 (unsigned int *) &offset,
                                 (unsigned char *) &oamFeature, 4);
 
-  /* Do only if we are in the new Base PSP 7.4.*/
-  #if ((PSP_VERSION_MAJOR == 7) && (PSP_VERSION_MINOR == 4))
-  /* Check to see if we are operating in the new bit mode. */
-  ptr = prom_getenv("DSL_BIT_TMODE");
-  if (ptr)
-  {
-    /* If we are see if this is the first time the user has upgraded. */
-    ptr = prom_getenv("DSL_UPG_DONE");
-    if(!ptr)
-      {
-         /* If it is the first time the user is upgrading, then make sure that
-             we clear the modulation environment variable, as this could potentially
-             not have the same meaning in the new mode.
-          */
-         prom_unsetenv("modulation");
-         prom_setenv("DSL_UPG_DONE", "1");
-      }
-  }
-  #endif
-
   // modulation
   ptr = prom_getenv("modulation");
-  if (ptr)
+  if (ptr || mp_modulation != NULL)
   {
-    tn7dsl_set_modulation(ptr, FALSE);
+    tn7dsl_set_modulation(mp_modulation == NULL ? ptr : mp_modulation, FALSE);
   }
 
   // Fine Gains
   ptr = prom_getenv("fine_gain_control");
-  if (ptr)
+  if (ptr || mp_fine_gain_control != -1)
   {
-    value = os_atoi(ptr);
+    value = mp_fine_gain_control == -1 ? os_atoi(ptr) : mp_fine_gain_control;
     tn7dsl_ctrl_fineGain(value);
   }
   ptr = NULL;
   ptr = prom_getenv("fine_gain_value");
-  if(ptr)
-    tn7dsl_set_fineGainValue(os_atoh(ptr));
+  if(ptr || mp_fine_gain_value != -1)
+    tn7dsl_set_fineGainValue(mp_fine_gain_value == -1 ? os_atoh(ptr) : mp_fine_gain_value);
 
   // margin retrain
   ptr = NULL;
   ptr = prom_getenv("enable_margin_retrain");
-  if(ptr)
+  value = mp_enable_margin_retrain == -1 ? (ptr ? os_atoi(ptr) : 0) : mp_enable_margin_retrain;
+
+  if (value == 1)
   {
-    value = os_atoi(ptr);
-    if(value == 1)
+    dslhal_api_setMarginMonitorFlags(pIhw, 0, 1);
+    bMarginRetrainEnable = 1;
+    //printk("enable showtime margin monitor.\n");
+
+    ptr = NULL;
+    ptr = prom_getenv("margin_threshold");
+    value = mp_margin_threshold == -1 ? (ptr ? os_atoi(ptr) : 0) : mp_margin_threshold;
+
+    if(value >= 0)
     {
-      dslhal_api_setMarginMonitorFlags(pIhw, 0, 1);
-      bMarginRetrainEnable = 1;
-      //printk("enable showtime margin monitor.\n");
-      ptr = NULL;
-      ptr = prom_getenv("margin_threshold");
-      if(ptr)
-      {
-        value = os_atoi(ptr);
-        //printk("Set margin threshold to %d x 0.5 db\n",value);
-        if(value >= 0)
-        {
-          dslhal_api_setMarginThreshold(pIhw, value);
-          bMarginThConfig=1;
-        }
-      }
+      dslhal_api_setMarginThreshold(pIhw, value);
+      bMarginThConfig=1;
     }
   }
 
   // rate adapt
   ptr = NULL;
   ptr = prom_getenv("enable_rate_adapt");
-  if(ptr)
+  if(ptr || mp_enable_rate_adapt != -1)
   {
-    dslhal_api_setRateAdaptFlag(pIhw, os_atoi(ptr));
+    dslhal_api_setRateAdaptFlag(pIhw, mp_enable_rate_adapt == -1 ? os_atoi(ptr) : mp_enable_rate_adapt);
+  }
+
+  // set powercutback
+  ptr = NULL;
+  ptr = prom_getenv("powercutback");
+  if(ptr || mp_powercutback != -1)
+  {
+    dslhal_advcfg_onOffPcb(pIhw, mp_powercutback == -1 ? os_atoi(ptr) : mp_powercutback);
   }
 
   // trellis
   ptr = NULL;
   ptr = prom_getenv("trellis");
-  if(ptr)
+  if(ptr || mp_trellis != -1)
   {
-    dslhal_api_setTrellisFlag(pIhw, os_atoi(ptr));
-    trellis = os_atoi(ptr);
+    trellis = mp_trellis == -1 ? os_atoi(ptr) : mp_trellis;
+    dslhal_api_setTrellisFlag(pIhw, trellis);
     //printk("trellis=%d\n");
   }
 
   // bitswap
   ptr = NULL;
   ptr = prom_getenv("bitswap");
-  if(ptr)
+  if(ptr || mp_bitswap != -1)
   {
     int offset[2] = {33, 0};
     unsigned int bitswap;
 
-    bitswap = os_atoi(ptr);
+    bitswap = mp_bitswap == -1 ? os_atoi(ptr) : mp_bitswap;
 
     tn7dsl_generic_read(2, offset);
     dslReg &= dslhal_support_byteSwap32(0xFFFFFF00);
@@ -2954,46 +2918,47 @@ static int tn7dsl_set_dsl(void)
   // maximum bits per carrier
   ptr = NULL;
   ptr = prom_getenv("maximum_bits_per_carrier");
-  if(ptr)
+  if(ptr || mp_maximum_bits_per_carrier != -1)
   {
-    dslhal_api_setMaxBitsPerCarrierUpstream(pIhw, os_atoi(ptr));
+    dslhal_api_setMaxBitsPerCarrierUpstream(pIhw, mp_maximum_bits_per_carrier == -1 ? os_atoi(ptr) : mp_maximum_bits_per_carrier);
   }
 
   // maximum interleave depth
   ptr = NULL;
   ptr = prom_getenv("maximum_interleave_depth");
-  if(ptr)
+  if(ptr || mp_maximum_interleave_depth != -1)
   {
-    dslhal_api_setMaxInterleaverDepth(pIhw, os_atoi(ptr));
+    dslhal_api_setMaxInterleaverDepth(pIhw, mp_maximum_interleave_depth == -1 ? os_atoi(ptr) : mp_maximum_interleave_depth);
   }
 
   // inner and outer pairs
   ptr = NULL;
   ptr = prom_getenv("pair_selection");
-  if(ptr)
+  if(ptr || mp_pair_selection != -1)
   {
-    dslhal_api_selectInnerOuterPair(pIhw, os_atoi(ptr));
+    dslhal_api_selectInnerOuterPair(pIhw, mp_pair_selection == -1 ? os_atoi(ptr) : mp_pair_selection);
   }
 
   ptr = NULL;
   ptr = prom_getenv("dgas_polarity");
-  if(ptr)
+  if(ptr || mp_dgas_polarity != -1)
   {
     dslhal_api_configureDgaspLpr(pIhw, 1, 1);
-    dslhal_api_configureDgaspLpr(pIhw, 0, os_atoi(ptr));
+    dslhal_api_configureDgaspLpr(pIhw, 0, mp_dgas_polarity == -1 ? os_atoi(ptr) : mp_dgas_polarity);
   }
 
   ptr = NULL;
   ptr = prom_getenv("los_alarm");
-  if(ptr)
+  if(ptr || mp_los_alarm != -1)
   {
-    dslhal_api_disableLosAlarm(pIhw, os_atoi(ptr));
+    dslhal_api_disableLosAlarm(pIhw, mp_los_alarm == -1 ? os_atoi(ptr) : mp_los_alarm);
   }
 
   ptr = NULL;
   ptr = prom_getenv("eoc_vendor_id");
-  if(ptr)
+  if(ptr || mp_eoc_vendor_id != NULL)
   {
+    ptr = mp_eoc_vendor_id == NULL ? ptr : mp_eoc_vendor_id;
     for(i=0;i<8;i++)
     {
       tmp[0]=ptr[i*2];
@@ -3018,26 +2983,26 @@ static int tn7dsl_set_dsl(void)
   }
   ptr = NULL;
   ptr = prom_getenv("eoc_vendor_revision");
-  if(ptr)
+  if(ptr || mp_eoc_vendor_revision != -1)
   {
-    value = os_atoi(ptr);
+    value = mp_eoc_vendor_revision == -1 ? os_atoi(ptr) : mp_eoc_vendor_revision;
     //printk("eoc rev=%d\n", os_atoi(ptr));
     dslhal_api_setEocRevisionNumber(pIhw, (char *)&value);
 
   }
   ptr = NULL;
   ptr = prom_getenv("eoc_vendor_serialnum");
-  if(ptr)
+  if(ptr || mp_eoc_vendor_serialnum != NULL)
   {
-    dslhal_api_setEocSerialNumber(pIhw, ptr);
+    dslhal_api_setEocSerialNumber(pIhw, mp_eoc_vendor_serialnum == NULL ? ptr : mp_eoc_vendor_serialnum);
   }  
   
   // CQ10037 Added invntry_vernum environment variable to be able to set version number in ADSL2, ADSL2+ modes.  
   ptr = NULL;
   ptr = prom_getenv("invntry_vernum");
-  if(ptr)
+  if(ptr || mp_invntry_vernum != NULL)
   {
-    dslhal_api_setEocRevisionNumber(pIhw, ptr);
+    dslhal_api_setEocRevisionNumber(pIhw, mp_invntry_vernum == NULL ? ptr : mp_invntry_vernum);
   }
 
   return 0;
@@ -3064,6 +3029,7 @@ int tn7dsl_init(void *priv)
   int high_precision_selected = 0;  
 //  UR8_MERGE_END   CQ11054*
 
+  sema_init(&adsl_sem_overlay, 0);
   /*
    * start dsl
    */
@@ -3081,7 +3047,7 @@ int tn7dsl_init(void *priv)
    * backward compatibility.
    */
   cp = prom_getenv("DSL_BIT_TMODE");
-  if (cp)
+  if (cp || mp_dsl_bit_tmode != -1)
   {
     printk("%s : env var DSL_BIT_TMODE is set\n", __FUNCTION__);
     /*
@@ -3110,9 +3076,9 @@ int tn7dsl_init(void *priv)
 
 //  UR8_MERGE_START CQ11054   Jack Zhang
   cp = prom_getenv("high_precision");
-  if (cp)
+  if (cp || mp_high_precision != -1)
   {
-    high_precision_selected = os_atoi(cp);
+    high_precision_selected = mp_high_precision == -1 ? os_atoi(cp) : mp_high_precision;
   }
   if ( high_precision_selected)
   {
@@ -3419,8 +3385,7 @@ unsigned int tn7dsl_get_memory(unsigned 
 
 
 
-static int dslmod_sysctl(ctl_table *ctl, int write, struct file * filp,
-      void *buffer, size_t *lenp)
+static int dslmod_sysctl(ctl_table *ctl, int write, void *buffer, size_t *lenp, loff_t *ppos)
 {
   char *ptr;
   int ret, len = 0;
@@ -3432,7 +3397,7 @@ static int dslmod_sysctl(ctl_table *ctl,
   char mod_req[16] = { '\t' };
   char fst_byt;
 
-  if (!*lenp || (filp->f_pos && !write))
+  if (!*lenp || (!*ppos && !write))
   {
     *lenp = 0;
     return 0;
@@ -3442,11 +3407,10 @@ static int dslmod_sysctl(ctl_table *ctl,
    */
   if(write)
     {
-    ret = proc_dostring(ctl, write, filp, buffer, lenp);
+    ret = proc_dostring(ctl, write, buffer, lenp, ppos);
 
-    switch (ctl->ctl_name)
+    if (strcmp(ctl->procname, "dslmod") == 0) 
       {
-      case DEV_DSLMOD:
       ptr = strpbrk(info, " \t");
       strcpy(mod_req, info);
 
@@ -3456,7 +3420,7 @@ static int dslmod_sysctl(ctl_table *ctl,
       if (!strcmp (info, "dspfreq"))
       {
         printk("dsp_freq = %d\n", SAR_FREQUNCY * 4);
-        break;
+	return 0;
       }
       else if (!strncmp(info,"nohost", 6))
       {
@@ -3481,14 +3445,14 @@ static int dslmod_sysctl(ctl_table *ctl,
             i, curr_setting.phyEnableDisableWord,
             i, curr_setting.phyControlWord);
         }
-        break;
+	return 0;
       }
 // * UR8_MERGE_START CQ10880   Jack Zhang
       else if (!strcmp(info,"dsp_l3msg"))
       {
         //printk("dsp_l3msg sent to DSP\n");
         dslhal_api_sendL3Command(pIhw);
-        break;
+	return 0;
       }
 // * UR8_MERGE_END   CQ10880*
 
@@ -3503,51 +3467,57 @@ static int dslmod_sysctl(ctl_table *ctl,
                 if( fst_byt == 'S') type = type | (1 << 1);
                 ret = tn7sar_oam_generation (pIhw->pOsContext, chan, type, vpi, vci, timeout);
                 break;
-
-       case 'F':
+      case 'F':
                 chan = tn7dsl_process_txflush_string (&queue, mod_req);
                 if (chan < 16)
                     tn7sar_tx_flush (pIhw->pOsContext, chan, queue, 0);
                 break;
       case 'D':
-// * UR8_MERGE_START CQ10640   Jack Zhang
-                if (mod_req[0]=='d') //cph99
+                if (mod_req[0]=='d')
                   tn7dsl_dump_dsp_memory (&mod_req[1]);
                 else 
                   tn7dsl_dump_memory (&mod_req[1]);
-// * UR8_MERGE_END   CQ10640*
-      break;
+      		break;
       case 'W':
                 tn7dsl_write_memory(&mod_req[1]);
                 break;
       default:
                tn7dsl_chng_modulation (info);
       }
-      }
+     }
     }
   else
     {
     len += sprintf(info+len, mod_req);
-    ret = proc_dostring(ctl, write, filp, buffer, lenp);
+    ret = proc_dostring(ctl, write, buffer, lenp, ppos);
     }
   return ret;
 }
 
 
 ctl_table dslmod_table[] = {
-  {DEV_DSLMOD, "dslmod", info, DSL_MOD_SIZE, 0644, NULL, &dslmod_sysctl}
-  ,
-  {0}
-  };
+  	{
+		.procname	= "dslmod", 
+		.data		= info, 
+		.maxlen		= DSL_MOD_SIZE, 
+		.mode		= 0644, 
+		.proc_handler	= &dslmod_sysctl
+	},
+ 	{ }
+};
 
 /* Make sure that /proc/sys/dev is there */
 ctl_table dslmod_root_table[] = {
 #ifdef CONFIG_PROC_FS
-  {CTL_DEV, "dev", NULL, 0, 0555, dslmod_table}
-  ,
+  {
+		.procname	= "dev", 
+		.maxlen		= 0, 
+		.mode		= 0555, 
+		.child		= dslmod_table,
+  },
 #endif /* CONFIG_PROC_FS */
-  {0}
-  };
+  { }
+};
 
 static struct ctl_table_header *dslmod_sysctl_header;
 
@@ -3558,8 +3528,7 @@ void tn7dsl_dslmod_sysctl_register(void)
   if (initialized == 1)
     return;
 
-  dslmod_sysctl_header = register_sysctl_table(dslmod_root_table, 1);
-  dslmod_root_table->child->de->owner = THIS_MODULE;
+  dslmod_sysctl_header = register_sysctl_table(dslmod_root_table);
 
   /*
    * set the defaults
@@ -4821,4 +4790,4 @@ int tn7dsl_proc_PMDus(char* buf, char **
 }
 #endif //NO_ADV_STATS
 #endif //TR69_PMD_IN
-// *    UR8_MERGE_END   CQ11057 *
\ No newline at end of file
+// *    UR8_MERGE_END   CQ11057 *
