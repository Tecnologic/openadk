From eb65132adca3fe1e7c39fc6032266a8d04150561 Mon Sep 17 00:00:00 2001
From: Nico Erfurth <ne@erfurth.eu>
Date: Sun, 27 Feb 2011 17:57:30 +0100
Subject: [PATCH 2/2] nameif: Added matching for PhyAddresses

Very useful when trying to distinguish platform-devices served by the
same driver, which is actually quite common in embedded-devices.

Signed-off-by: Nico Erfurth <ne@erfurth.eu>
Signed-off-by: Phil Sutter <phil.sutter@viprinet.com>
---
 networking/nameif.c |   33 +++++++++++++++++++++++++++++++++
 1 files changed, 33 insertions(+), 0 deletions(-)

diff --git a/networking/nameif.c b/networking/nameif.c
index 8e325e7..8d64b37 100644
--- a/networking/nameif.c
+++ b/networking/nameif.c
@@ -38,6 +38,7 @@ typedef struct ethtable_s {
 #if ENABLE_FEATURE_NAMEIF_EXTENDED
 	char *bus_info;
 	char *driver;
+	int32_t phy_address;
 #endif
 } ethtable_t;
 
@@ -59,6 +60,25 @@ struct ethtool_drvinfo {
 	uint32_t eedump_len; /* Size of data from ETHTOOL_GEEPROM (bytes) */
 	uint32_t regdump_len;  /* Size of data from ETHTOOL_GREGS (bytes) */
 };
+
+struct ethtool_cmd {
+	__u32   cmd;
+	__u32   supported;      /* Features this interface supports */
+	__u32   advertising;    /* Features this interface advertises */
+	__u16   speed;          /* The forced speed, 10Mb, 100Mb, gigabit */
+	__u8    duplex;         /* Duplex, half or full */
+	__u8    port;           /* Which connector port */
+	__u8    phy_address;
+	__u8    transceiver;    /* Which transceiver to use */
+	__u8    autoneg;        /* Enable or disable autonegotiation */
+	__u32   maxtxpkt;       /* Tx pkts before generating tx int */
+	__u32   maxrxpkt;       /* Rx pkts before generating rx int */
+	__u16   speed_hi;
+	__u16   reserved2;
+	__u32   reserved[3];
+};
+
+#define ETHTOOL_GSET      0x00000001 /* Get settings. */
 #define ETHTOOL_GDRVINFO  0x00000003 /* Get driver info. */
 #endif
 
@@ -74,6 +94,7 @@ static void nameif_parse_selector(ethtable_t *ch, char *selector)
 #endif
 		selector = skip_whitespace(selector);
 #if ENABLE_FEATURE_NAMEIF_EXTENDED
+		ch->phy_address = -1;
 		if (*selector == '\0')
 			break;
 		/* Search for the end .... */
@@ -87,6 +108,9 @@ static void nameif_parse_selector(ethtable_t *ch, char *selector)
 		} else if (strncmp(selector, "driver=", 7) == 0) {
 			ch->driver = xstrdup(selector + 7);
 			found_selector++;
+		} else if (strncmp(selector, "phyaddr=", 8) == 0) {
+			ch->phy_address = atoi(selector + 8);
+			found_selector++;
 		} else {
 #endif
 			lmac = xmalloc(ETH_ALEN);
@@ -173,6 +197,7 @@ int nameif_main(int argc, char **argv)
 		struct ifreq ifr;
 #if  ENABLE_FEATURE_NAMEIF_EXTENDED
 		struct ethtool_drvinfo drvinfo;
+		struct ethtool_cmd eth_settings;
 #endif
 		if (parser->lineno < 3)
 			continue; /* Skip the first two lines */
@@ -182,6 +207,12 @@ int nameif_main(int argc, char **argv)
 		strncpy_IFNAMSIZ(ifr.ifr_name, token[0]);
 
 #if ENABLE_FEATURE_NAMEIF_EXTENDED
+		/* Check for phy address */
+		memset(&eth_settings, 0, sizeof(struct ethtool_cmd));
+		eth_settings.cmd = ETHTOOL_GSET;
+		ifr.ifr_data = (caddr_t) &eth_settings;
+		ioctl(ctl_sk, SIOCETHTOOL, &ifr);
+
 		/* Check for driver etc. */
 		memset(&drvinfo, 0, sizeof(struct ethtool_drvinfo));
 		drvinfo.cmd = ETHTOOL_GDRVINFO;
@@ -198,6 +229,8 @@ int nameif_main(int argc, char **argv)
 				continue;
 			if (ch->driver && strcmp(ch->driver, drvinfo.driver) != 0)
 				continue;
+			if (ch->phy_address != -1 && ch->phy_address != eth_settings.phy_address)
+				continue;
 #endif
 			if (ch->mac && memcmp(ch->mac, ifr.ifr_hwaddr.sa_data, ETH_ALEN) != 0)
 				continue;
-- 
1.7.3.4

