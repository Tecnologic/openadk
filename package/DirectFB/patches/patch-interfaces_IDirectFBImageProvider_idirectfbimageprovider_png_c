--- DirectFB-1.4.11.orig/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c	2010-10-31 09:49:49.000000000 +0100
+++ DirectFB-1.4.11/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c	2011-03-29 10:57:18.433069010 +0200
@@ -207,7 +207,7 @@ Construct( IDirectFBImageProvider *thiz,
      if (!data->png_ptr)
           goto error;
 
-     if (setjmp( data->png_ptr->jmpbuf )) {
+     if (png_jmpbuf( data->png_ptr )) {
           D_ERROR( "ImageProvider/PNG: Error reading header!\n" );
           goto error;
      }
@@ -292,7 +292,7 @@ IDirectFBImageProvider_PNG_RenderTo( IDi
           rect = dst_data->area.wanted;
      }
 
-     if (setjmp( data->png_ptr->jmpbuf )) {
+     if (png_jmpbuf( data->png_ptr )) {
           D_ERROR( "ImageProvider/PNG: Error during decoding!\n" );
 
           if (data->stage < STAGE_IMAGE)
@@ -327,6 +327,7 @@ IDirectFBImageProvider_PNG_RenderTo( IDi
      }
      else {
           CoreSurfaceBufferLock lock;
+          png_byte bit_depth = png_get_bit_depth( data->png_ptr, data->info_ptr );
 
           ret = dfb_surface_lock_buffer( dst_surface, CSBR_BACK, CSAID_CPU, CSAF_WRITE, &lock );
           if (ret)
@@ -334,7 +335,7 @@ IDirectFBImageProvider_PNG_RenderTo( IDi
 
           switch (data->color_type) {
                case PNG_COLOR_TYPE_PALETTE:
-                    if (dst_surface->config.format == DSPF_LUT8 && data->info_ptr->bit_depth == 8) {
+                    if (dst_surface->config.format == DSPF_LUT8 && bit_depth == 8) {
                          /*
                           * Special indexed PNG to LUT8 loading.
                           */
@@ -377,7 +378,7 @@ IDirectFBImageProvider_PNG_RenderTo( IDi
                     }
                     else {
                          if (data->color_type == PNG_COLOR_TYPE_GRAY) {
-                              int num = 1 << data->info_ptr->bit_depth;
+                              int num = 1 << bit_depth;
 
                               for (x=0; x<num; x++) {
                                    int value = x * 255 / (num - 1);
@@ -386,7 +387,7 @@ IDirectFBImageProvider_PNG_RenderTo( IDi
                               }
                          }
 
-                         switch (data->info_ptr->bit_depth) {
+                         switch (bit_depth) {
                               case 8:
                                    for (y=0; y<data->height; y++) {
                                         u8  *S = data->image + data->pitch * y;
@@ -441,7 +442,7 @@ IDirectFBImageProvider_PNG_RenderTo( IDi
 
                               default:
                                    D_ERROR( "ImageProvider/PNG: Unsupported indexed bit depth %d!\n",
-                                            data->info_ptr->bit_depth );
+                                            bit_depth );
                          }
 
                          dfb_scale_linear_32( image_argb, data->width, data->height,
@@ -594,16 +595,26 @@ png_info_callback( png_structp png_read_
                    NULL, NULL, NULL );
 
      if (png_get_valid( data->png_ptr, data->info_ptr, PNG_INFO_tRNS )) {
+          png_bytep     trans;
+          png_color_16p trans_color;
+          int           num_trans;
+
+          png_get_tRNS( data->png_ptr, data->info_ptr, &trans, &num_trans, &trans_color );
+
           data->color_keyed = true;
 
           /* generate color key based on palette... */
           if (data->color_type == PNG_COLOR_TYPE_PALETTE) {
                u32        key;
-               png_colorp palette    = data->info_ptr->palette;
-               png_bytep  trans      = data->info_ptr->trans_alpha;
-               int        num_colors = MIN( MAXCOLORMAPSIZE,
-                                            data->info_ptr->num_palette );
-               u8         cmap[3][num_colors];
+               png_colorp palette;
+               int        num_colors;
+               u8        *cmap[3];
+
+               png_get_PLTE( data->png_ptr, data->info_ptr, &palette, &num_colors );
+               num_colors = MIN( MAXCOLORMAPSIZE, num_colors );
+               cmap[0] = alloca (num_colors);
+               cmap[1] = alloca (num_colors);
+               cmap[2] = alloca (num_colors);
 
                for (i=0; i<num_colors; i++) {
                     cmap[0][i] = palette[i].red;
@@ -613,7 +624,7 @@ png_info_callback( png_structp png_read_
 
                key = FindColorKey( num_colors, &cmap[0][0] );
 
-               for (i=0; i<data->info_ptr->num_trans; i++) {
+               for (i=0; i<num_trans; i++) {
                     if (!trans[i]) {
                          palette[i].red   = (key & 0xff0000) >> 16;
                          palette[i].green = (key & 0x00ff00) >>  8;
@@ -625,20 +636,23 @@ png_info_callback( png_structp png_read_
           }
           else {
                /* ...or based on trans rgb value */
-               png_color_16p trans = &data->info_ptr->trans_color;
-
-               data->color_key = (((trans->red & 0xff00) << 8) |
-                                  ((trans->green & 0xff00)) |
-                                  ((trans->blue & 0xff00) >> 8));
+               data->color_key = (((trans_color->red & 0xff00) << 8) |
+                                  ((trans_color->green & 0xff00)) |
+                                  ((trans_color->blue & 0xff00) >> 8));
           }
      }
 
      switch (data->color_type) {
           case PNG_COLOR_TYPE_PALETTE: {
-               png_colorp palette    = data->info_ptr->palette;
-               png_bytep  trans      = data->info_ptr->trans_alpha;
-               int        num_trans  = data->info_ptr->num_trans;
-               int        num_colors = MIN( MAXCOLORMAPSIZE, data->info_ptr->num_palette );
+               png_colorp    palette;
+               png_bytep     trans;
+               png_color_16p trans_color;
+               int           num_trans;
+               int           num_colors;
+
+               png_get_PLTE( data->png_ptr, data->info_ptr, &palette, &num_colors );
+               num_colors = MIN( MAXCOLORMAPSIZE, num_colors );
+               png_get_tRNS( data->png_ptr, data->info_ptr, &trans, &num_trans, &trans_color );
 
                for (i=0; i<num_colors; i++) {
                     data->colors[i].a = (i < num_trans) ? trans[i] : 0xff;
