--- rpm-4.7.0.orig/rpmio/rpmsq.c	2009-03-03 07:51:52.000000000 +0100
+++ rpm-4.7.0/rpmio/rpmsq.c	2009-06-25 20:15:31.954966249 +0200
@@ -83,6 +83,7 @@ static rpmsq rpmsqQueue = &rpmsqRock;
  */
 static int rpmsqInsert(void * elem, void * prev)
 {
+    sigset_t new_set, old_set;
     rpmsq sq = (rpmsq) elem;
     int ret = -1;
 
@@ -91,7 +92,9 @@ static int rpmsqInsert(void * elem, void
 if (_rpmsq_debug)
 fprintf(stderr, "    Insert(%p): %p\n", ME(), sq);
 #endif
-	ret = sighold(SIGCHLD);
+	sigemptyset(&new_set);
+	sigaddset(&new_set, SIGCHLD);
+	ret = sigprocmask(SIG_BLOCK, &new_set, &old_set);
 	if (ret == 0) {
 	    sq->child = 0;
 	    sq->reaped = 0;
@@ -102,7 +105,7 @@ fprintf(stderr, "    Insert(%p): %p\n", 
 	    sq->id = ME();
 	    ret = pthread_mutex_init(&sq->mutex, NULL);
 	    insque(elem, (prev != NULL ? prev : rpmsqQueue));
-	    ret = sigrelse(SIGCHLD);
+	    ret = sigprocmask(SIG_SETMASK, &old_set, NULL);
 	}
     }
     return ret;
@@ -115,6 +118,7 @@ fprintf(stderr, "    Insert(%p): %p\n", 
  */
 static int rpmsqRemove(void * elem)
 {
+    sigset_t new_set, old_set;
     rpmsq sq = (rpmsq) elem;
     int ret = -1;
 
@@ -124,7 +128,9 @@ static int rpmsqRemove(void * elem)
 if (_rpmsq_debug)
 fprintf(stderr, "    Remove(%p): %p\n", ME(), sq);
 #endif
-	ret = sighold (SIGCHLD);
+	sigemptyset(&new_set);
+	sigaddset(&new_set, SIGCHLD);
+	ret = sigprocmask(SIG_BLOCK, &new_set, &old_set);
 	if (ret == 0) {
 	    remque(elem);
 	   
@@ -142,7 +148,7 @@ fprintf(stderr, "    Remove(%p): %p\n", 
 	    sq->reaped = 0;
 	    sq->child = 0;
 #endif
-	    ret = sigrelse(SIGCHLD);
+	    ret = sigprocmask(SIG_SETMASK, &old_set, NULL);
 	}
     }
     return ret;
@@ -289,6 +295,7 @@ int rpmsqEnable(int signum, rpmsqAction_
 
 pid_t rpmsqFork(rpmsq sq)
 {
+    sigset_t new_set, old_set;
     pid_t pid;
     int xx;
     int nothreads = 0;   /* XXX: Shouldn't this be a global? */
@@ -304,7 +311,9 @@ fprintf(stderr, "    Enable(%p): %p\n", 
 
     xx = pipe(sq->pipes);
 
-    xx = sighold(SIGCHLD);
+    sigemptyset(&new_set);
+    sigaddset(&new_set, SIGCHLD);
+    xx = sigprocmask(SIG_BLOCK, &new_set, &old_set);
 
     /* 
      * Initialize the cond var mutex.   We have to aquire the lock we 
@@ -355,7 +364,7 @@ fprintf(stderr, "    Parent(%p): %p chil
     }
 
 out:
-    xx = sigrelse(SIGCHLD);
+    xx = sigprocmask(SIG_SETMASK, &old_set, NULL);
     return sq->child;
 }
 
@@ -367,12 +376,15 @@ out:
  */
 static int rpmsqWaitUnregister(rpmsq sq)
 {
+    sigset_t new_set, old_set;
     int nothreads = 0;
     int ret = 0;
     int xx;
 
     /* Protect sq->reaped from handler changes. */
-    ret = sighold(SIGCHLD);
+    sigemptyset(&new_set);
+    sigaddset(&new_set, SIGCHLD);
+    ret = sigprocmask(SIG_BLOCK, &new_set, &old_set);
 
     /* Start the child, linux often runs child before parent. */
     if (sq->pipes[0] >= 0)
@@ -388,9 +400,9 @@ static int rpmsqWaitUnregister(rpmsq sq)
     while (ret == 0 && sq->reaped != sq->child) {
 	if (nothreads)
 	    /* Note that sigpause re-enables SIGCHLD. */
-	    ret = sigpause(SIGCHLD);
+	    ret = sigsuspend(&new_set);
 	else {
-	    xx = sigrelse(SIGCHLD);
+    	    xx = sigprocmask(SIG_SETMASK, &old_set, NULL);
 	    
 	    /* 
 	     * We start before the fork with this mutex locked;
@@ -398,14 +410,14 @@ static int rpmsqWaitUnregister(rpmsq sq)
 	     * So if we get the lock the child has been reaped.
 	     */
 	    ret = pthread_mutex_lock(&sq->mutex);
-	    xx = sighold(SIGCHLD);
+	    xx = sigprocmask(SIG_BLOCK, &new_set, &old_set);
 	}
     }
 
     /* Accumulate stopwatch time spent waiting, potential performance gain. */
     sq->ms_scriptlets += rpmswExit(&sq->op, -1)/1000;
 
-    xx = sigrelse(SIGCHLD);
+    xx = sigprocmask(SIG_SETMASK, &old_set, NULL);
 
 #ifdef _RPMSQ_DEBUG
 if (_rpmsq_debug)
