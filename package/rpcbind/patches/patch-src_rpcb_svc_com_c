--- rpcbind-0.2.3.orig/src/rpcb_svc_com.c	2015-04-27 16:07:43.000000000 +0200
+++ rpcbind-0.2.3/src/rpcb_svc_com.c	2016-10-08 18:20:08.000000000 +0200
@@ -42,8 +42,6 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/param.h>
-#include <sys/poll.h>
-#include <bits/poll.h>
 #include <sys/socket.h>
 #include <rpc/rpc.h>
 #include <rpc/rpcb_prot.h>
@@ -54,6 +52,7 @@
 #include <unistd.h>
 #include <stdio.h>
 #include <time.h>
+#include <poll.h>
 #ifdef PORTMAP
 #include <netinet/in.h>
 #include <rpc/pmap_prot.h>
@@ -100,29 +99,29 @@ struct finfo {
 static struct finfo     FINFO[NFORWARD];
 
 
-static bool_t xdr_encap_parms __P((XDR *, struct encap_parms *));
-static bool_t xdr_rmtcall_args __P((XDR *, struct r_rmtcall_args *));
-static bool_t xdr_rmtcall_result __P((XDR *, struct r_rmtcall_args *));
-static bool_t xdr_opaque_parms __P((XDR *, struct r_rmtcall_args *));
-static int find_rmtcallfd_by_netid __P((char *));
-static SVCXPRT *find_rmtcallxprt_by_fd __P((int));
-static int forward_register __P((u_int32_t, struct netbuf *, int, char *,
-    rpcproc_t, rpcvers_t, u_int32_t *));
-static struct finfo *forward_find __P((u_int32_t));
-static int free_slot_by_xid __P((u_int32_t));
-static int free_slot_by_index __P((int));
-static int netbufcmp __P((struct netbuf *, struct netbuf *));
-static struct netbuf *netbufdup __P((struct netbuf *));
-static void netbuffree __P((struct netbuf *));
-static int check_rmtcalls __P((struct pollfd *, int));
-static void xprt_set_caller __P((SVCXPRT *, struct finfo *));
-static void send_svcsyserr __P((SVCXPRT *, struct finfo *));
-static void handle_reply __P((int, SVCXPRT *));
-static void find_versions __P((rpcprog_t, char *, rpcvers_t *, rpcvers_t *));
-static rpcblist_ptr find_service __P((rpcprog_t, rpcvers_t, char *));
-static char *getowner __P((SVCXPRT *, char *, size_t));
-static int add_pmaplist __P((RPCB *));
-static int del_pmaplist __P((RPCB *));
+static bool_t xdr_encap_parms (XDR *, struct encap_parms *);
+static bool_t xdr_rmtcall_args (XDR *, struct r_rmtcall_args *);
+static bool_t xdr_rmtcall_result (XDR *, struct r_rmtcall_args *);
+static bool_t xdr_opaque_parms (XDR *, struct r_rmtcall_args *);
+static int find_rmtcallfd_by_netid (char *);
+static SVCXPRT *find_rmtcallxprt_by_fd (int);
+static int forward_register (u_int32_t, struct netbuf *, int, char *,
+    rpcproc_t, rpcvers_t, u_int32_t *);
+static struct finfo *forward_find (u_int32_t);
+static int free_slot_by_xid (u_int32_t);
+static int free_slot_by_index (int);
+static int netbufcmp (struct netbuf *, struct netbuf *);
+static struct netbuf *netbufdup (struct netbuf *);
+static void netbuffree (struct netbuf *);
+static int check_rmtcalls (struct pollfd *, int);
+static void xprt_set_caller (SVCXPRT *, struct finfo *);
+static void send_svcsyserr (SVCXPRT *, struct finfo *);
+static void handle_reply (int, SVCXPRT *);
+static void find_versions (rpcprog_t, char *, rpcvers_t *, rpcvers_t *);
+static rpcblist_ptr find_service (rpcprog_t, rpcvers_t, char *);
+static char *getowner (SVCXPRT *, char *, size_t);
+static int add_pmaplist (RPCB *);
+static int del_pmaplist (RPCB *);
 
 /*
  * Set a mapping of program, version, netid
@@ -1183,12 +1182,33 @@ check_rmtcalls(struct pollfd *pfds, int 
 	return (ncallbacks_found);
 }
 
+/*
+ * This is really a helper function defined in libtirpc, but unfortunately, it hasn't
+ * been exported yet.
+ */
+static struct netbuf *
+__rpc_set_netbuf(struct netbuf *nb, const void *ptr, size_t len)
+{
+	if (nb->len != len) {
+		if (nb->len)
+			mem_free(nb->buf, nb->len);
+		nb->buf = mem_alloc(len);
+		if (nb->buf == NULL)
+			return NULL;
+
+		nb->maxlen = nb->len = len;
+	}
+	memcpy(nb->buf, ptr, len);
+	return nb;
+}
+
 static void
 xprt_set_caller(SVCXPRT *xprt, struct finfo *fi)
 {
+	const struct netbuf *caller = fi->caller_addr;
 	u_int32_t *xidp;
 
-	*(svc_getrpccaller(xprt)) = *(fi->caller_addr);
+	__rpc_set_netbuf(svc_getrpccaller(xprt), caller->buf, caller->len);
 	xidp = __rpcb_get_dg_xidp(xprt);
 	*xidp = fi->caller_xid;
 }
@@ -1274,10 +1294,17 @@ handle_reply(int fd, SVCXPRT *xprt)
 	a.rmt_localvers = fi->versnum;
 
 	xprt_set_caller(xprt, fi);
+#if defined(SVC_XP_AUTH)
+	SVC_XP_AUTH(xprt) = svc_auth_none;
+#else 
 	xprt->xp_auth = &svc_auth_none;
+#endif
 	svc_sendreply(xprt, (xdrproc_t) xdr_rmtcall_result, (char *) &a);
+#if !defined(SVC_XP_AUTH)
 	SVCAUTH_DESTROY(xprt->xp_auth);
 	xprt->xp_auth = NULL;
+#endif
+
 done:
 	if (buffer)
 		free(buffer);
